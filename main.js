import './index.css';var Xv = Object.defineProperty;
var Zv = (t, e, n) => e in t ? Xv(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n;
var _s = (t, e, n) => Zv(t, typeof e != "symbol" ? e + "" : e, n);
import * as React from "react";
import React__default, { useContext, useMemo, useState, useRef, useEffect, forwardRef, createContext, memo as memo$1, useCallback, isValidElement, Children, PureComponent, useImperativeHandle, cloneElement, createElement, Component as Component$1, useLayoutEffect, createRef } from "react";
import { useNavigate, useParams, useLocation, useSearchParams, Routes, Route } from "react-router-dom";
import * as ReactDOM from "react-dom";
import ReactDOM__default, { findDOMNode } from "react-dom";
var commonjsGlobal$1 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function getAugmentedNamespace(t) {
  if (t.__esModule) return t;
  var e = t.default;
  if (typeof e == "function") {
    var n = function o() {
      return this instanceof o ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    n.prototype = e.prototype;
  } else n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(t).forEach(function(o) {
    var l = Object.getOwnPropertyDescriptor(t, o);
    Object.defineProperty(n, o, l.get ? l : {
      enumerable: !0,
      get: function() {
        return t[o];
      }
    });
  }), n;
}
var jsxRuntime$1 = { exports: {} }, reactJsxRuntime_production_min$1 = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min$1;
function requireReactJsxRuntime_production_min$1() {
  if (hasRequiredReactJsxRuntime_production_min$1) return reactJsxRuntime_production_min$1;
  hasRequiredReactJsxRuntime_production_min$1 = 1;
  var t = React__default, e = Symbol.for("react.element"), n = Symbol.for("react.fragment"), o = Object.prototype.hasOwnProperty, l = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, u = { key: !0, ref: !0, __self: !0, __source: !0 };
  function f(h, p, v) {
    var g, w = {}, E = null, T = null;
    v !== void 0 && (E = "" + v), p.key !== void 0 && (E = "" + p.key), p.ref !== void 0 && (T = p.ref);
    for (g in p) o.call(p, g) && !u.hasOwnProperty(g) && (w[g] = p[g]);
    if (h && h.defaultProps) for (g in p = h.defaultProps, p) w[g] === void 0 && (w[g] = p[g]);
    return { $$typeof: e, type: h, key: E, ref: T, props: w, _owner: l.current };
  }
  return reactJsxRuntime_production_min$1.Fragment = n, reactJsxRuntime_production_min$1.jsx = f, reactJsxRuntime_production_min$1.jsxs = f, reactJsxRuntime_production_min$1;
}
var reactJsxRuntime_development$1 = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_development$1;
function requireReactJsxRuntime_development$1() {
  return hasRequiredReactJsxRuntime_development$1 || (hasRequiredReactJsxRuntime_development$1 = 1, process.env.NODE_ENV !== "production" && function() {
    var t = React__default, e = Symbol.for("react.element"), n = Symbol.for("react.portal"), o = Symbol.for("react.fragment"), l = Symbol.for("react.strict_mode"), u = Symbol.for("react.profiler"), f = Symbol.for("react.provider"), h = Symbol.for("react.context"), p = Symbol.for("react.forward_ref"), v = Symbol.for("react.suspense"), g = Symbol.for("react.suspense_list"), w = Symbol.for("react.memo"), E = Symbol.for("react.lazy"), T = Symbol.for("react.offscreen"), R = Symbol.iterator, _ = "@@iterator";
    function b(Se) {
      if (Se === null || typeof Se != "object")
        return null;
      var pr = R && Se[R] || Se[_];
      return typeof pr == "function" ? pr : null;
    }
    var M = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function A(Se) {
      {
        for (var pr = arguments.length, mn = new Array(pr > 1 ? pr - 1 : 0), Si = 1; Si < pr; Si++)
          mn[Si - 1] = arguments[Si];
        $("error", Se, mn);
      }
    }
    function $(Se, pr, mn) {
      {
        var Si = M.ReactDebugCurrentFrame, Io = Si.getStackAddendum();
        Io !== "" && (pr += "%s", mn = mn.concat([Io]));
        var ve = mn.map(function(He) {
          return String(He);
        });
        ve.unshift("Warning: " + pr), Function.prototype.apply.call(console[Se], console, ve);
      }
    }
    var S = !1, C = !1, D = !1, O = !1, N = !1, j;
    j = Symbol.for("react.module.reference");
    function L(Se) {
      return !!(typeof Se == "string" || typeof Se == "function" || Se === o || Se === u || N || Se === l || Se === v || Se === g || O || Se === T || S || C || D || typeof Se == "object" && Se !== null && (Se.$$typeof === E || Se.$$typeof === w || Se.$$typeof === f || Se.$$typeof === h || Se.$$typeof === p || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      Se.$$typeof === j || Se.getModuleId !== void 0));
    }
    function z(Se, pr, mn) {
      var Si = Se.displayName;
      if (Si)
        return Si;
      var Io = pr.displayName || pr.name || "";
      return Io !== "" ? mn + "(" + Io + ")" : mn;
    }
    function G(Se) {
      return Se.displayName || "Context";
    }
    function B(Se) {
      if (Se == null)
        return null;
      if (typeof Se.tag == "number" && A("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof Se == "function")
        return Se.displayName || Se.name || null;
      if (typeof Se == "string")
        return Se;
      switch (Se) {
        case o:
          return "Fragment";
        case n:
          return "Portal";
        case u:
          return "Profiler";
        case l:
          return "StrictMode";
        case v:
          return "Suspense";
        case g:
          return "SuspenseList";
      }
      if (typeof Se == "object")
        switch (Se.$$typeof) {
          case h:
            var pr = Se;
            return G(pr) + ".Consumer";
          case f:
            var mn = Se;
            return G(mn._context) + ".Provider";
          case p:
            return z(Se, Se.render, "ForwardRef");
          case w:
            var Si = Se.displayName || null;
            return Si !== null ? Si : B(Se.type) || "Memo";
          case E: {
            var Io = Se, ve = Io._payload, He = Io._init;
            try {
              return B(He(ve));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var F = Object.assign, H = 0, W, V, X, Z, Q, q, J;
    function ie() {
    }
    ie.__reactDisabledLog = !0;
    function ne() {
      {
        if (H === 0) {
          W = console.log, V = console.info, X = console.warn, Z = console.error, Q = console.group, q = console.groupCollapsed, J = console.groupEnd;
          var Se = {
            configurable: !0,
            enumerable: !0,
            value: ie,
            writable: !0
          };
          Object.defineProperties(console, {
            info: Se,
            log: Se,
            warn: Se,
            error: Se,
            group: Se,
            groupCollapsed: Se,
            groupEnd: Se
          });
        }
        H++;
      }
    }
    function ge() {
      {
        if (H--, H === 0) {
          var Se = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: F({}, Se, {
              value: W
            }),
            info: F({}, Se, {
              value: V
            }),
            warn: F({}, Se, {
              value: X
            }),
            error: F({}, Se, {
              value: Z
            }),
            group: F({}, Se, {
              value: Q
            }),
            groupCollapsed: F({}, Se, {
              value: q
            }),
            groupEnd: F({}, Se, {
              value: J
            })
          });
        }
        H < 0 && A("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var ye = M.ReactCurrentDispatcher, xe;
    function we(Se, pr, mn) {
      {
        if (xe === void 0)
          try {
            throw Error();
          } catch (Io) {
            var Si = Io.stack.trim().match(/\n( *(at )?)/);
            xe = Si && Si[1] || "";
          }
        return `
` + xe + Se;
      }
    }
    var de = !1, Te;
    {
      var Ce = typeof WeakMap == "function" ? WeakMap : Map;
      Te = new Ce();
    }
    function ee(Se, pr) {
      if (!Se || de)
        return "";
      {
        var mn = Te.get(Se);
        if (mn !== void 0)
          return mn;
      }
      var Si;
      de = !0;
      var Io = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ve;
      ve = ye.current, ye.current = null, ne();
      try {
        if (pr) {
          var He = function() {
            throw Error();
          };
          if (Object.defineProperty(He.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(He, []);
            } catch (bp) {
              Si = bp;
            }
            Reflect.construct(Se, [], He);
          } else {
            try {
              He.call();
            } catch (bp) {
              Si = bp;
            }
            Se.call(He.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (bp) {
            Si = bp;
          }
          Se();
        }
      } catch (bp) {
        if (bp && Si && typeof bp.stack == "string") {
          for (var nt = bp.stack.split(`
`), dr = Si.stack.split(`
`), dt = nt.length - 1, ci = dr.length - 1; dt >= 1 && ci >= 0 && nt[dt] !== dr[ci]; )
            ci--;
          for (; dt >= 1 && ci >= 0; dt--, ci--)
            if (nt[dt] !== dr[ci]) {
              if (dt !== 1 || ci !== 1)
                do
                  if (dt--, ci--, ci < 0 || nt[dt] !== dr[ci]) {
                    var Uo = `
` + nt[dt].replace(" at new ", " at ");
                    return Se.displayName && Uo.includes("<anonymous>") && (Uo = Uo.replace("<anonymous>", Se.displayName)), typeof Se == "function" && Te.set(Se, Uo), Uo;
                  }
                while (dt >= 1 && ci >= 0);
              break;
            }
        }
      } finally {
        de = !1, ye.current = ve, ge(), Error.prepareStackTrace = Io;
      }
      var xs = Se ? Se.displayName || Se.name : "", vs = xs ? we(xs) : "";
      return typeof Se == "function" && Te.set(Se, vs), vs;
    }
    function Ae(Se, pr, mn) {
      return ee(Se, !1);
    }
    function be(Se) {
      var pr = Se.prototype;
      return !!(pr && pr.isReactComponent);
    }
    function Fe(Se, pr, mn) {
      if (Se == null)
        return "";
      if (typeof Se == "function")
        return ee(Se, be(Se));
      if (typeof Se == "string")
        return we(Se);
      switch (Se) {
        case v:
          return we("Suspense");
        case g:
          return we("SuspenseList");
      }
      if (typeof Se == "object")
        switch (Se.$$typeof) {
          case p:
            return Ae(Se.render);
          case w:
            return Fe(Se.type, pr, mn);
          case E: {
            var Si = Se, Io = Si._payload, ve = Si._init;
            try {
              return Fe(ve(Io), pr, mn);
            } catch {
            }
          }
        }
      return "";
    }
    var et = Object.prototype.hasOwnProperty, Ye = {}, De = M.ReactDebugCurrentFrame;
    function Ue(Se) {
      if (Se) {
        var pr = Se._owner, mn = Fe(Se.type, Se._source, pr ? pr.type : null);
        De.setExtraStackFrame(mn);
      } else
        De.setExtraStackFrame(null);
    }
    function Qe(Se, pr, mn, Si, Io) {
      {
        var ve = Function.call.bind(et);
        for (var He in Se)
          if (ve(Se, He)) {
            var nt = void 0;
            try {
              if (typeof Se[He] != "function") {
                var dr = Error((Si || "React class") + ": " + mn + " type `" + He + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof Se[He] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw dr.name = "Invariant Violation", dr;
              }
              nt = Se[He](pr, He, Si, mn, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (dt) {
              nt = dt;
            }
            nt && !(nt instanceof Error) && (Ue(Io), A("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Si || "React class", mn, He, typeof nt), Ue(null)), nt instanceof Error && !(nt.message in Ye) && (Ye[nt.message] = !0, Ue(Io), A("Failed %s type: %s", mn, nt.message), Ue(null));
          }
      }
    }
    var ue = Array.isArray;
    function te(Se) {
      return ue(Se);
    }
    function Be(Se) {
      {
        var pr = typeof Symbol == "function" && Symbol.toStringTag, mn = pr && Se[Symbol.toStringTag] || Se.constructor.name || "Object";
        return mn;
      }
    }
    function Je(Se) {
      try {
        return ft(Se), !1;
      } catch {
        return !0;
      }
    }
    function ft(Se) {
      return "" + Se;
    }
    function lt(Se) {
      if (Je(Se))
        return A("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Be(Se)), ft(Se);
    }
    var he = M.ReactCurrentOwner, ae = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, se, Re, Oe;
    Oe = {};
    function We(Se) {
      if (et.call(Se, "ref")) {
        var pr = Object.getOwnPropertyDescriptor(Se, "ref").get;
        if (pr && pr.isReactWarning)
          return !1;
      }
      return Se.ref !== void 0;
    }
    function Ct(Se) {
      if (et.call(Se, "key")) {
        var pr = Object.getOwnPropertyDescriptor(Se, "key").get;
        if (pr && pr.isReactWarning)
          return !1;
      }
      return Se.key !== void 0;
    }
    function le(Se, pr) {
      if (typeof Se.ref == "string" && he.current && pr && he.current.stateNode !== pr) {
        var mn = B(he.current.type);
        Oe[mn] || (A('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', B(he.current.type), Se.ref), Oe[mn] = !0);
      }
    }
    function ke(Se, pr) {
      {
        var mn = function() {
          se || (se = !0, A("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", pr));
        };
        mn.isReactWarning = !0, Object.defineProperty(Se, "key", {
          get: mn,
          configurable: !0
        });
      }
    }
    function Ke(Se, pr) {
      {
        var mn = function() {
          Re || (Re = !0, A("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", pr));
        };
        mn.isReactWarning = !0, Object.defineProperty(Se, "ref", {
          get: mn,
          configurable: !0
        });
      }
    }
    var me = function(Se, pr, mn, Si, Io, ve, He) {
      var nt = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: Se,
        key: pr,
        ref: mn,
        props: He,
        // Record the component responsible for creating this element.
        _owner: ve
      };
      return nt._store = {}, Object.defineProperty(nt._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(nt, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Si
      }), Object.defineProperty(nt, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Io
      }), Object.freeze && (Object.freeze(nt.props), Object.freeze(nt)), nt;
    };
    function Ee(Se, pr, mn, Si, Io) {
      {
        var ve, He = {}, nt = null, dr = null;
        mn !== void 0 && (lt(mn), nt = "" + mn), Ct(pr) && (lt(pr.key), nt = "" + pr.key), We(pr) && (dr = pr.ref, le(pr, Io));
        for (ve in pr)
          et.call(pr, ve) && !ae.hasOwnProperty(ve) && (He[ve] = pr[ve]);
        if (Se && Se.defaultProps) {
          var dt = Se.defaultProps;
          for (ve in dt)
            He[ve] === void 0 && (He[ve] = dt[ve]);
        }
        if (nt || dr) {
          var ci = typeof Se == "function" ? Se.displayName || Se.name || "Unknown" : Se;
          nt && ke(He, ci), dr && Ke(He, ci);
        }
        return me(Se, nt, dr, Io, Si, he.current, He);
      }
    }
    var tt = M.ReactCurrentOwner, ce = M.ReactDebugCurrentFrame;
    function _e(Se) {
      if (Se) {
        var pr = Se._owner, mn = Fe(Se.type, Se._source, pr ? pr.type : null);
        ce.setExtraStackFrame(mn);
      } else
        ce.setExtraStackFrame(null);
    }
    var Ht;
    Ht = !1;
    function K(Se) {
      return typeof Se == "object" && Se !== null && Se.$$typeof === e;
    }
    function Ve() {
      {
        if (tt.current) {
          var Se = B(tt.current.type);
          if (Se)
            return `

Check the render method of \`` + Se + "`.";
        }
        return "";
      }
    }
    function Ne(Se) {
      return "";
    }
    var pe = {};
    function Le(Se) {
      {
        var pr = Ve();
        if (!pr) {
          var mn = typeof Se == "string" ? Se : Se.displayName || Se.name;
          mn && (pr = `

Check the top-level render call using <` + mn + ">.");
        }
        return pr;
      }
    }
    function bt(Se, pr) {
      {
        if (!Se._store || Se._store.validated || Se.key != null)
          return;
        Se._store.validated = !0;
        var mn = Le(pr);
        if (pe[mn])
          return;
        pe[mn] = !0;
        var Si = "";
        Se && Se._owner && Se._owner !== tt.current && (Si = " It was passed a child from " + B(Se._owner.type) + "."), _e(Se), A('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', mn, Si), _e(null);
      }
    }
    function yi(Se, pr) {
      {
        if (typeof Se != "object")
          return;
        if (te(Se))
          for (var mn = 0; mn < Se.length; mn++) {
            var Si = Se[mn];
            K(Si) && bt(Si, pr);
          }
        else if (K(Se))
          Se._store && (Se._store.validated = !0);
        else if (Se) {
          var Io = b(Se);
          if (typeof Io == "function" && Io !== Se.entries)
            for (var ve = Io.call(Se), He; !(He = ve.next()).done; )
              K(He.value) && bt(He.value, pr);
        }
      }
    }
    function _n(Se) {
      {
        var pr = Se.type;
        if (pr == null || typeof pr == "string")
          return;
        var mn;
        if (typeof pr == "function")
          mn = pr.propTypes;
        else if (typeof pr == "object" && (pr.$$typeof === p || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        pr.$$typeof === w))
          mn = pr.propTypes;
        else
          return;
        if (mn) {
          var Si = B(pr);
          Qe(mn, Se.props, "prop", Si, Se);
        } else if (pr.PropTypes !== void 0 && !Ht) {
          Ht = !0;
          var Io = B(pr);
          A("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Io || "Unknown");
        }
        typeof pr.getDefaultProps == "function" && !pr.getDefaultProps.isReactClassApproved && A("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Do(Se) {
      {
        for (var pr = Object.keys(Se.props), mn = 0; mn < pr.length; mn++) {
          var Si = pr[mn];
          if (Si !== "children" && Si !== "key") {
            _e(Se), A("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Si), _e(null);
            break;
          }
        }
        Se.ref !== null && (_e(Se), A("Invalid attribute `ref` supplied to `React.Fragment`."), _e(null));
      }
    }
    var ms = {};
    function Bp(Se, pr, mn, Si, Io, ve) {
      {
        var He = L(Se);
        if (!He) {
          var nt = "";
          (Se === void 0 || typeof Se == "object" && Se !== null && Object.keys(Se).length === 0) && (nt += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var dr = Ne();
          dr ? nt += dr : nt += Ve();
          var dt;
          Se === null ? dt = "null" : te(Se) ? dt = "array" : Se !== void 0 && Se.$$typeof === e ? (dt = "<" + (B(Se.type) || "Unknown") + " />", nt = " Did you accidentally export a JSX literal instead of a component?") : dt = typeof Se, A("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", dt, nt);
        }
        var ci = Ee(Se, pr, mn, Io, ve);
        if (ci == null)
          return ci;
        if (He) {
          var Uo = pr.children;
          if (Uo !== void 0)
            if (Si)
              if (te(Uo)) {
                for (var xs = 0; xs < Uo.length; xs++)
                  yi(Uo[xs], Se);
                Object.freeze && Object.freeze(Uo);
              } else
                A("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              yi(Uo, Se);
        }
        if (et.call(pr, "key")) {
          var vs = B(Se), bp = Object.keys(pr).filter(function(wp) {
            return wp !== "key";
          }), Ep = bp.length > 0 ? "{key: someKey, " + bp.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!ms[vs + Ep]) {
            var Ap = bp.length > 0 ? "{" + bp.join(": ..., ") + ": ...}" : "{}";
            A(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Ep, vs, Ap, vs), ms[vs + Ep] = !0;
          }
        }
        return Se === o ? Do(ci) : _n(ci), ci;
      }
    }
    function Sp(Se, pr, mn) {
      return Bp(Se, pr, mn, !0);
    }
    function Tp(Se, pr, mn) {
      return Bp(Se, pr, mn, !1);
    }
    var Pp = Tp, Xe = Sp;
    reactJsxRuntime_development$1.Fragment = o, reactJsxRuntime_development$1.jsx = Pp, reactJsxRuntime_development$1.jsxs = Xe;
  }()), reactJsxRuntime_development$1;
}
process.env.NODE_ENV === "production" ? jsxRuntime$1.exports = requireReactJsxRuntime_production_min$1() : jsxRuntime$1.exports = requireReactJsxRuntime_development$1();
var jsxRuntimeExports$1 = jsxRuntime$1.exports, classnames = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(t) {
  (function() {
    var e = {}.hasOwnProperty;
    function n() {
      for (var u = "", f = 0; f < arguments.length; f++) {
        var h = arguments[f];
        h && (u = l(u, o(h)));
      }
      return u;
    }
    function o(u) {
      if (typeof u == "string" || typeof u == "number")
        return u;
      if (typeof u != "object")
        return "";
      if (Array.isArray(u))
        return n.apply(null, u);
      if (u.toString !== Object.prototype.toString && !u.toString.toString().includes("[native code]"))
        return u.toString();
      var f = "";
      for (var h in u)
        e.call(u, h) && u[h] && (f = l(f, h));
      return f;
    }
    function l(u, f) {
      return f ? u ? u + " " + f : u + f : u;
    }
    t.exports ? (n.default = n, t.exports = n) : window.classNames = n;
  })();
})(classnames);
var classnamesExports = classnames.exports;
const classNames = /* @__PURE__ */ getDefaultExportFromCjs(classnamesExports);
function _extends$x() {
  return _extends$x = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var o in n) ({}).hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }
    return t;
  }, _extends$x.apply(null, arguments);
}
const _extends$y = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get default() {
    return _extends$x;
  }
}, Symbol.toStringTag, { value: "Module" }));
function _objectWithoutPropertiesLoose$n(t, e) {
  if (t == null) return {};
  var n = {};
  for (var o in t) if ({}.hasOwnProperty.call(t, o)) {
    if (e.includes(o)) continue;
    n[o] = t[o];
  }
  return n;
}
const DEFAULT_BREAKPOINTS = ["xxl", "xl", "lg", "md", "sm", "xs"], DEFAULT_MIN_BREAKPOINT = "xs", ThemeContext$2 = /* @__PURE__ */ React.createContext({
  prefixes: {},
  breakpoints: DEFAULT_BREAKPOINTS,
  minBreakpoint: DEFAULT_MIN_BREAKPOINT
});
function useBootstrapPrefix(t, e) {
  const {
    prefixes: n
  } = useContext(ThemeContext$2);
  return t || n[e] || e;
}
function useBootstrapBreakpoints() {
  const {
    breakpoints: t
  } = useContext(ThemeContext$2);
  return t;
}
function useBootstrapMinBreakpoint() {
  const {
    minBreakpoint: t
  } = useContext(ThemeContext$2);
  return t;
}
var propTypes$2 = { exports: {} }, reactIs$4 = { exports: {} }, reactIs_production_min$3 = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_production_min$3;
function requireReactIs_production_min$3() {
  if (hasRequiredReactIs_production_min$3) return reactIs_production_min$3;
  hasRequiredReactIs_production_min$3 = 1;
  var t = typeof Symbol == "function" && Symbol.for, e = t ? Symbol.for("react.element") : 60103, n = t ? Symbol.for("react.portal") : 60106, o = t ? Symbol.for("react.fragment") : 60107, l = t ? Symbol.for("react.strict_mode") : 60108, u = t ? Symbol.for("react.profiler") : 60114, f = t ? Symbol.for("react.provider") : 60109, h = t ? Symbol.for("react.context") : 60110, p = t ? Symbol.for("react.async_mode") : 60111, v = t ? Symbol.for("react.concurrent_mode") : 60111, g = t ? Symbol.for("react.forward_ref") : 60112, w = t ? Symbol.for("react.suspense") : 60113, E = t ? Symbol.for("react.suspense_list") : 60120, T = t ? Symbol.for("react.memo") : 60115, R = t ? Symbol.for("react.lazy") : 60116, _ = t ? Symbol.for("react.block") : 60121, b = t ? Symbol.for("react.fundamental") : 60117, M = t ? Symbol.for("react.responder") : 60118, A = t ? Symbol.for("react.scope") : 60119;
  function $(C) {
    if (typeof C == "object" && C !== null) {
      var D = C.$$typeof;
      switch (D) {
        case e:
          switch (C = C.type, C) {
            case p:
            case v:
            case o:
            case u:
            case l:
            case w:
              return C;
            default:
              switch (C = C && C.$$typeof, C) {
                case h:
                case g:
                case R:
                case T:
                case f:
                  return C;
                default:
                  return D;
              }
          }
        case n:
          return D;
      }
    }
  }
  function S(C) {
    return $(C) === v;
  }
  return reactIs_production_min$3.AsyncMode = p, reactIs_production_min$3.ConcurrentMode = v, reactIs_production_min$3.ContextConsumer = h, reactIs_production_min$3.ContextProvider = f, reactIs_production_min$3.Element = e, reactIs_production_min$3.ForwardRef = g, reactIs_production_min$3.Fragment = o, reactIs_production_min$3.Lazy = R, reactIs_production_min$3.Memo = T, reactIs_production_min$3.Portal = n, reactIs_production_min$3.Profiler = u, reactIs_production_min$3.StrictMode = l, reactIs_production_min$3.Suspense = w, reactIs_production_min$3.isAsyncMode = function(C) {
    return S(C) || $(C) === p;
  }, reactIs_production_min$3.isConcurrentMode = S, reactIs_production_min$3.isContextConsumer = function(C) {
    return $(C) === h;
  }, reactIs_production_min$3.isContextProvider = function(C) {
    return $(C) === f;
  }, reactIs_production_min$3.isElement = function(C) {
    return typeof C == "object" && C !== null && C.$$typeof === e;
  }, reactIs_production_min$3.isForwardRef = function(C) {
    return $(C) === g;
  }, reactIs_production_min$3.isFragment = function(C) {
    return $(C) === o;
  }, reactIs_production_min$3.isLazy = function(C) {
    return $(C) === R;
  }, reactIs_production_min$3.isMemo = function(C) {
    return $(C) === T;
  }, reactIs_production_min$3.isPortal = function(C) {
    return $(C) === n;
  }, reactIs_production_min$3.isProfiler = function(C) {
    return $(C) === u;
  }, reactIs_production_min$3.isStrictMode = function(C) {
    return $(C) === l;
  }, reactIs_production_min$3.isSuspense = function(C) {
    return $(C) === w;
  }, reactIs_production_min$3.isValidElementType = function(C) {
    return typeof C == "string" || typeof C == "function" || C === o || C === v || C === u || C === l || C === w || C === E || typeof C == "object" && C !== null && (C.$$typeof === R || C.$$typeof === T || C.$$typeof === f || C.$$typeof === h || C.$$typeof === g || C.$$typeof === b || C.$$typeof === M || C.$$typeof === A || C.$$typeof === _);
  }, reactIs_production_min$3.typeOf = $, reactIs_production_min$3;
}
var reactIs_development$3 = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_development$3;
function requireReactIs_development$3() {
  return hasRequiredReactIs_development$3 || (hasRequiredReactIs_development$3 = 1, process.env.NODE_ENV !== "production" && function() {
    var t = typeof Symbol == "function" && Symbol.for, e = t ? Symbol.for("react.element") : 60103, n = t ? Symbol.for("react.portal") : 60106, o = t ? Symbol.for("react.fragment") : 60107, l = t ? Symbol.for("react.strict_mode") : 60108, u = t ? Symbol.for("react.profiler") : 60114, f = t ? Symbol.for("react.provider") : 60109, h = t ? Symbol.for("react.context") : 60110, p = t ? Symbol.for("react.async_mode") : 60111, v = t ? Symbol.for("react.concurrent_mode") : 60111, g = t ? Symbol.for("react.forward_ref") : 60112, w = t ? Symbol.for("react.suspense") : 60113, E = t ? Symbol.for("react.suspense_list") : 60120, T = t ? Symbol.for("react.memo") : 60115, R = t ? Symbol.for("react.lazy") : 60116, _ = t ? Symbol.for("react.block") : 60121, b = t ? Symbol.for("react.fundamental") : 60117, M = t ? Symbol.for("react.responder") : 60118, A = t ? Symbol.for("react.scope") : 60119;
    function $(ee) {
      return typeof ee == "string" || typeof ee == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      ee === o || ee === v || ee === u || ee === l || ee === w || ee === E || typeof ee == "object" && ee !== null && (ee.$$typeof === R || ee.$$typeof === T || ee.$$typeof === f || ee.$$typeof === h || ee.$$typeof === g || ee.$$typeof === b || ee.$$typeof === M || ee.$$typeof === A || ee.$$typeof === _);
    }
    function S(ee) {
      if (typeof ee == "object" && ee !== null) {
        var Ae = ee.$$typeof;
        switch (Ae) {
          case e:
            var be = ee.type;
            switch (be) {
              case p:
              case v:
              case o:
              case u:
              case l:
              case w:
                return be;
              default:
                var Fe = be && be.$$typeof;
                switch (Fe) {
                  case h:
                  case g:
                  case R:
                  case T:
                  case f:
                    return Fe;
                  default:
                    return Ae;
                }
            }
          case n:
            return Ae;
        }
      }
    }
    var C = p, D = v, O = h, N = f, j = e, L = g, z = o, G = R, B = T, F = n, H = u, W = l, V = w, X = !1;
    function Z(ee) {
      return X || (X = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), Q(ee) || S(ee) === p;
    }
    function Q(ee) {
      return S(ee) === v;
    }
    function q(ee) {
      return S(ee) === h;
    }
    function J(ee) {
      return S(ee) === f;
    }
    function ie(ee) {
      return typeof ee == "object" && ee !== null && ee.$$typeof === e;
    }
    function ne(ee) {
      return S(ee) === g;
    }
    function ge(ee) {
      return S(ee) === o;
    }
    function ye(ee) {
      return S(ee) === R;
    }
    function xe(ee) {
      return S(ee) === T;
    }
    function we(ee) {
      return S(ee) === n;
    }
    function de(ee) {
      return S(ee) === u;
    }
    function Te(ee) {
      return S(ee) === l;
    }
    function Ce(ee) {
      return S(ee) === w;
    }
    reactIs_development$3.AsyncMode = C, reactIs_development$3.ConcurrentMode = D, reactIs_development$3.ContextConsumer = O, reactIs_development$3.ContextProvider = N, reactIs_development$3.Element = j, reactIs_development$3.ForwardRef = L, reactIs_development$3.Fragment = z, reactIs_development$3.Lazy = G, reactIs_development$3.Memo = B, reactIs_development$3.Portal = F, reactIs_development$3.Profiler = H, reactIs_development$3.StrictMode = W, reactIs_development$3.Suspense = V, reactIs_development$3.isAsyncMode = Z, reactIs_development$3.isConcurrentMode = Q, reactIs_development$3.isContextConsumer = q, reactIs_development$3.isContextProvider = J, reactIs_development$3.isElement = ie, reactIs_development$3.isForwardRef = ne, reactIs_development$3.isFragment = ge, reactIs_development$3.isLazy = ye, reactIs_development$3.isMemo = xe, reactIs_development$3.isPortal = we, reactIs_development$3.isProfiler = de, reactIs_development$3.isStrictMode = Te, reactIs_development$3.isSuspense = Ce, reactIs_development$3.isValidElementType = $, reactIs_development$3.typeOf = S;
  }()), reactIs_development$3;
}
var hasRequiredReactIs;
function requireReactIs() {
  return hasRequiredReactIs || (hasRequiredReactIs = 1, process.env.NODE_ENV === "production" ? reactIs$4.exports = requireReactIs_production_min$3() : reactIs$4.exports = requireReactIs_development$3()), reactIs$4.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var objectAssign, hasRequiredObjectAssign;
function requireObjectAssign() {
  if (hasRequiredObjectAssign) return objectAssign;
  hasRequiredObjectAssign = 1;
  var t = Object.getOwnPropertySymbols, e = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function o(u) {
    if (u == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(u);
  }
  function l() {
    try {
      if (!Object.assign)
        return !1;
      var u = new String("abc");
      if (u[5] = "de", Object.getOwnPropertyNames(u)[0] === "5")
        return !1;
      for (var f = {}, h = 0; h < 10; h++)
        f["_" + String.fromCharCode(h)] = h;
      var p = Object.getOwnPropertyNames(f).map(function(g) {
        return f[g];
      });
      if (p.join("") !== "0123456789")
        return !1;
      var v = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(g) {
        v[g] = g;
      }), Object.keys(Object.assign({}, v)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return objectAssign = l() ? Object.assign : function(u, f) {
    for (var h, p = o(u), v, g = 1; g < arguments.length; g++) {
      h = Object(arguments[g]);
      for (var w in h)
        e.call(h, w) && (p[w] = h[w]);
      if (t) {
        v = t(h);
        for (var E = 0; E < v.length; E++)
          n.call(h, v[E]) && (p[v[E]] = h[v[E]]);
      }
    }
    return p;
  }, objectAssign;
}
var ReactPropTypesSecret_1, hasRequiredReactPropTypesSecret;
function requireReactPropTypesSecret() {
  if (hasRequiredReactPropTypesSecret) return ReactPropTypesSecret_1;
  hasRequiredReactPropTypesSecret = 1;
  var t = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return ReactPropTypesSecret_1 = t, ReactPropTypesSecret_1;
}
var has, hasRequiredHas;
function requireHas() {
  return hasRequiredHas || (hasRequiredHas = 1, has = Function.call.bind(Object.prototype.hasOwnProperty)), has;
}
var checkPropTypes_1, hasRequiredCheckPropTypes;
function requireCheckPropTypes() {
  if (hasRequiredCheckPropTypes) return checkPropTypes_1;
  hasRequiredCheckPropTypes = 1;
  var t = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var e = requireReactPropTypesSecret(), n = {}, o = requireHas();
    t = function(u) {
      var f = "Warning: " + u;
      typeof console < "u" && console.error(f);
      try {
        throw new Error(f);
      } catch {
      }
    };
  }
  function l(u, f, h, p, v) {
    if (process.env.NODE_ENV !== "production") {
      for (var g in u)
        if (o(u, g)) {
          var w;
          try {
            if (typeof u[g] != "function") {
              var E = Error(
                (p || "React class") + ": " + h + " type `" + g + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof u[g] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw E.name = "Invariant Violation", E;
            }
            w = u[g](f, g, p, h, null, e);
          } catch (R) {
            w = R;
          }
          if (w && !(w instanceof Error) && t(
            (p || "React class") + ": type specification of " + h + " `" + g + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof w + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), w instanceof Error && !(w.message in n)) {
            n[w.message] = !0;
            var T = v ? v() : "";
            t(
              "Failed " + h + " type: " + w.message + (T ?? "")
            );
          }
        }
    }
  }
  return l.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, checkPropTypes_1 = l, checkPropTypes_1;
}
var factoryWithTypeCheckers, hasRequiredFactoryWithTypeCheckers;
function requireFactoryWithTypeCheckers() {
  if (hasRequiredFactoryWithTypeCheckers) return factoryWithTypeCheckers;
  hasRequiredFactoryWithTypeCheckers = 1;
  var t = requireReactIs(), e = requireObjectAssign(), n = requireReactPropTypesSecret(), o = requireHas(), l = requireCheckPropTypes(), u = function() {
  };
  process.env.NODE_ENV !== "production" && (u = function(h) {
    var p = "Warning: " + h;
    typeof console < "u" && console.error(p);
    try {
      throw new Error(p);
    } catch {
    }
  });
  function f() {
    return null;
  }
  return factoryWithTypeCheckers = function(h, p) {
    var v = typeof Symbol == "function" && Symbol.iterator, g = "@@iterator";
    function w(Q) {
      var q = Q && (v && Q[v] || Q[g]);
      if (typeof q == "function")
        return q;
    }
    var E = "<<anonymous>>", T = {
      array: M("array"),
      bigint: M("bigint"),
      bool: M("boolean"),
      func: M("function"),
      number: M("number"),
      object: M("object"),
      string: M("string"),
      symbol: M("symbol"),
      any: A(),
      arrayOf: $,
      element: S(),
      elementType: C(),
      instanceOf: D,
      node: L(),
      objectOf: N,
      oneOf: O,
      oneOfType: j,
      shape: G,
      exact: B
    };
    function R(Q, q) {
      return Q === q ? Q !== 0 || 1 / Q === 1 / q : Q !== Q && q !== q;
    }
    function _(Q, q) {
      this.message = Q, this.data = q && typeof q == "object" ? q : {}, this.stack = "";
    }
    _.prototype = Error.prototype;
    function b(Q) {
      if (process.env.NODE_ENV !== "production")
        var q = {}, J = 0;
      function ie(ge, ye, xe, we, de, Te, Ce) {
        if (we = we || E, Te = Te || xe, Ce !== n) {
          if (p) {
            var ee = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw ee.name = "Invariant Violation", ee;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var Ae = we + ":" + xe;
            !q[Ae] && // Avoid spamming the console because they are often not actionable except for lib authors
            J < 3 && (u(
              "You are manually calling a React.PropTypes validation function for the `" + Te + "` prop on `" + we + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), q[Ae] = !0, J++);
          }
        }
        return ye[xe] == null ? ge ? ye[xe] === null ? new _("The " + de + " `" + Te + "` is marked as required " + ("in `" + we + "`, but its value is `null`.")) : new _("The " + de + " `" + Te + "` is marked as required in " + ("`" + we + "`, but its value is `undefined`.")) : null : Q(ye, xe, we, de, Te);
      }
      var ne = ie.bind(null, !1);
      return ne.isRequired = ie.bind(null, !0), ne;
    }
    function M(Q) {
      function q(J, ie, ne, ge, ye, xe) {
        var we = J[ie], de = W(we);
        if (de !== Q) {
          var Te = V(we);
          return new _(
            "Invalid " + ge + " `" + ye + "` of type " + ("`" + Te + "` supplied to `" + ne + "`, expected ") + ("`" + Q + "`."),
            { expectedType: Q }
          );
        }
        return null;
      }
      return b(q);
    }
    function A() {
      return b(f);
    }
    function $(Q) {
      function q(J, ie, ne, ge, ye) {
        if (typeof Q != "function")
          return new _("Property `" + ye + "` of component `" + ne + "` has invalid PropType notation inside arrayOf.");
        var xe = J[ie];
        if (!Array.isArray(xe)) {
          var we = W(xe);
          return new _("Invalid " + ge + " `" + ye + "` of type " + ("`" + we + "` supplied to `" + ne + "`, expected an array."));
        }
        for (var de = 0; de < xe.length; de++) {
          var Te = Q(xe, de, ne, ge, ye + "[" + de + "]", n);
          if (Te instanceof Error)
            return Te;
        }
        return null;
      }
      return b(q);
    }
    function S() {
      function Q(q, J, ie, ne, ge) {
        var ye = q[J];
        if (!h(ye)) {
          var xe = W(ye);
          return new _("Invalid " + ne + " `" + ge + "` of type " + ("`" + xe + "` supplied to `" + ie + "`, expected a single ReactElement."));
        }
        return null;
      }
      return b(Q);
    }
    function C() {
      function Q(q, J, ie, ne, ge) {
        var ye = q[J];
        if (!t.isValidElementType(ye)) {
          var xe = W(ye);
          return new _("Invalid " + ne + " `" + ge + "` of type " + ("`" + xe + "` supplied to `" + ie + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return b(Q);
    }
    function D(Q) {
      function q(J, ie, ne, ge, ye) {
        if (!(J[ie] instanceof Q)) {
          var xe = Q.name || E, we = Z(J[ie]);
          return new _("Invalid " + ge + " `" + ye + "` of type " + ("`" + we + "` supplied to `" + ne + "`, expected ") + ("instance of `" + xe + "`."));
        }
        return null;
      }
      return b(q);
    }
    function O(Q) {
      if (!Array.isArray(Q))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? u(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : u("Invalid argument supplied to oneOf, expected an array.")), f;
      function q(J, ie, ne, ge, ye) {
        for (var xe = J[ie], we = 0; we < Q.length; we++)
          if (R(xe, Q[we]))
            return null;
        var de = JSON.stringify(Q, function(Ce, ee) {
          var Ae = V(ee);
          return Ae === "symbol" ? String(ee) : ee;
        });
        return new _("Invalid " + ge + " `" + ye + "` of value `" + String(xe) + "` " + ("supplied to `" + ne + "`, expected one of " + de + "."));
      }
      return b(q);
    }
    function N(Q) {
      function q(J, ie, ne, ge, ye) {
        if (typeof Q != "function")
          return new _("Property `" + ye + "` of component `" + ne + "` has invalid PropType notation inside objectOf.");
        var xe = J[ie], we = W(xe);
        if (we !== "object")
          return new _("Invalid " + ge + " `" + ye + "` of type " + ("`" + we + "` supplied to `" + ne + "`, expected an object."));
        for (var de in xe)
          if (o(xe, de)) {
            var Te = Q(xe, de, ne, ge, ye + "." + de, n);
            if (Te instanceof Error)
              return Te;
          }
        return null;
      }
      return b(q);
    }
    function j(Q) {
      if (!Array.isArray(Q))
        return process.env.NODE_ENV !== "production" && u("Invalid argument supplied to oneOfType, expected an instance of array."), f;
      for (var q = 0; q < Q.length; q++) {
        var J = Q[q];
        if (typeof J != "function")
          return u(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + X(J) + " at index " + q + "."
          ), f;
      }
      function ie(ne, ge, ye, xe, we) {
        for (var de = [], Te = 0; Te < Q.length; Te++) {
          var Ce = Q[Te], ee = Ce(ne, ge, ye, xe, we, n);
          if (ee == null)
            return null;
          ee.data && o(ee.data, "expectedType") && de.push(ee.data.expectedType);
        }
        var Ae = de.length > 0 ? ", expected one of type [" + de.join(", ") + "]" : "";
        return new _("Invalid " + xe + " `" + we + "` supplied to " + ("`" + ye + "`" + Ae + "."));
      }
      return b(ie);
    }
    function L() {
      function Q(q, J, ie, ne, ge) {
        return F(q[J]) ? null : new _("Invalid " + ne + " `" + ge + "` supplied to " + ("`" + ie + "`, expected a ReactNode."));
      }
      return b(Q);
    }
    function z(Q, q, J, ie, ne) {
      return new _(
        (Q || "React class") + ": " + q + " type `" + J + "." + ie + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + ne + "`."
      );
    }
    function G(Q) {
      function q(J, ie, ne, ge, ye) {
        var xe = J[ie], we = W(xe);
        if (we !== "object")
          return new _("Invalid " + ge + " `" + ye + "` of type `" + we + "` " + ("supplied to `" + ne + "`, expected `object`."));
        for (var de in Q) {
          var Te = Q[de];
          if (typeof Te != "function")
            return z(ne, ge, ye, de, V(Te));
          var Ce = Te(xe, de, ne, ge, ye + "." + de, n);
          if (Ce)
            return Ce;
        }
        return null;
      }
      return b(q);
    }
    function B(Q) {
      function q(J, ie, ne, ge, ye) {
        var xe = J[ie], we = W(xe);
        if (we !== "object")
          return new _("Invalid " + ge + " `" + ye + "` of type `" + we + "` " + ("supplied to `" + ne + "`, expected `object`."));
        var de = e({}, J[ie], Q);
        for (var Te in de) {
          var Ce = Q[Te];
          if (o(Q, Te) && typeof Ce != "function")
            return z(ne, ge, ye, Te, V(Ce));
          if (!Ce)
            return new _(
              "Invalid " + ge + " `" + ye + "` key `" + Te + "` supplied to `" + ne + "`.\nBad object: " + JSON.stringify(J[ie], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(Q), null, "  ")
            );
          var ee = Ce(xe, Te, ne, ge, ye + "." + Te, n);
          if (ee)
            return ee;
        }
        return null;
      }
      return b(q);
    }
    function F(Q) {
      switch (typeof Q) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !Q;
        case "object":
          if (Array.isArray(Q))
            return Q.every(F);
          if (Q === null || h(Q))
            return !0;
          var q = w(Q);
          if (q) {
            var J = q.call(Q), ie;
            if (q !== Q.entries) {
              for (; !(ie = J.next()).done; )
                if (!F(ie.value))
                  return !1;
            } else
              for (; !(ie = J.next()).done; ) {
                var ne = ie.value;
                if (ne && !F(ne[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function H(Q, q) {
      return Q === "symbol" ? !0 : q ? q["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && q instanceof Symbol : !1;
    }
    function W(Q) {
      var q = typeof Q;
      return Array.isArray(Q) ? "array" : Q instanceof RegExp ? "object" : H(q, Q) ? "symbol" : q;
    }
    function V(Q) {
      if (typeof Q > "u" || Q === null)
        return "" + Q;
      var q = W(Q);
      if (q === "object") {
        if (Q instanceof Date)
          return "date";
        if (Q instanceof RegExp)
          return "regexp";
      }
      return q;
    }
    function X(Q) {
      var q = V(Q);
      switch (q) {
        case "array":
        case "object":
          return "an " + q;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + q;
        default:
          return q;
      }
    }
    function Z(Q) {
      return !Q.constructor || !Q.constructor.name ? E : Q.constructor.name;
    }
    return T.checkPropTypes = l, T.resetWarningCache = l.resetWarningCache, T.PropTypes = T, T;
  }, factoryWithTypeCheckers;
}
var factoryWithThrowingShims, hasRequiredFactoryWithThrowingShims;
function requireFactoryWithThrowingShims() {
  if (hasRequiredFactoryWithThrowingShims) return factoryWithThrowingShims;
  hasRequiredFactoryWithThrowingShims = 1;
  var t = requireReactPropTypesSecret();
  function e() {
  }
  function n() {
  }
  return n.resetWarningCache = e, factoryWithThrowingShims = function() {
    function o(f, h, p, v, g, w) {
      if (w !== t) {
        var E = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw E.name = "Invariant Violation", E;
      }
    }
    o.isRequired = o;
    function l() {
      return o;
    }
    var u = {
      array: o,
      bigint: o,
      bool: o,
      func: o,
      number: o,
      object: o,
      string: o,
      symbol: o,
      any: o,
      arrayOf: l,
      element: o,
      elementType: o,
      instanceOf: l,
      node: o,
      objectOf: l,
      oneOf: l,
      oneOfType: l,
      shape: l,
      exact: l,
      checkPropTypes: n,
      resetWarningCache: e
    };
    return u.PropTypes = u, u;
  }, factoryWithThrowingShims;
}
if (process.env.NODE_ENV !== "production") {
  var ReactIs = requireReactIs(), throwOnDirectAccess = !0;
  propTypes$2.exports = requireFactoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
} else
  propTypes$2.exports = requireFactoryWithThrowingShims()();
var propTypesExports = propTypes$2.exports;
const PropTypes = /* @__PURE__ */ getDefaultExportFromCjs(propTypesExports), _excluded$A = ["as", "disabled"];
function _objectWithoutPropertiesLoose$m(t, e) {
  if (t == null) return {};
  var n = {};
  for (var o in t) if ({}.hasOwnProperty.call(t, o)) {
    if (e.indexOf(o) >= 0) continue;
    n[o] = t[o];
  }
  return n;
}
function isTrivialHref(t) {
  return !t || t.trim() === "#";
}
function useButtonProps({
  tagName: t,
  disabled: e,
  href: n,
  target: o,
  rel: l,
  role: u,
  onClick: f,
  tabIndex: h = 0,
  type: p
}) {
  t || (n != null || o != null || l != null ? t = "a" : t = "button");
  const v = {
    tagName: t
  };
  if (t === "button")
    return [{
      type: p || "button",
      disabled: e
    }, v];
  const g = (E) => {
    if ((e || t === "a" && isTrivialHref(n)) && E.preventDefault(), e) {
      E.stopPropagation();
      return;
    }
    f == null || f(E);
  }, w = (E) => {
    E.key === " " && (E.preventDefault(), g(E));
  };
  return t === "a" && (n || (n = "#"), e && (n = void 0)), [{
    role: u ?? "button",
    // explicitly undefined so that it overrides the props disabled in a spread
    // e.g. <Tag {...props} {...hookProps} />
    disabled: void 0,
    tabIndex: e ? void 0 : h,
    href: n,
    target: t === "a" ? o : void 0,
    "aria-disabled": e || void 0,
    rel: t === "a" ? l : void 0,
    onClick: g,
    onKeyDown: w
  }, v];
}
const Button$1 = /* @__PURE__ */ React.forwardRef((t, e) => {
  let {
    as: n,
    disabled: o
  } = t, l = _objectWithoutPropertiesLoose$m(t, _excluded$A);
  const [u, {
    tagName: f
  }] = useButtonProps(Object.assign({
    tagName: n,
    disabled: o
  }, l));
  return /* @__PURE__ */ jsxRuntimeExports$1.jsx(f, Object.assign({}, l, u, {
    ref: e
  }));
});
Button$1.displayName = "Button";
const Button = /* @__PURE__ */ React.forwardRef(({
  as: t,
  bsPrefix: e,
  variant: n = "primary",
  size: o,
  active: l = !1,
  disabled: u = !1,
  className: f,
  ...h
}, p) => {
  const v = useBootstrapPrefix(e, "btn"), [g, {
    tagName: w
  }] = useButtonProps({
    tagName: t,
    disabled: u,
    ...h
  }), E = w;
  return /* @__PURE__ */ jsxRuntimeExports$1.jsx(E, {
    ...g,
    ...h,
    ref: p,
    disabled: u,
    className: classNames(f, v, l && "active", n && `${v}-${n}`, o && `${v}-${o}`, h.href && u && "disabled")
  });
});
Button.displayName = "Button";
function hasChildOfType(t, e) {
  return React.Children.toArray(t).some((n) => /* @__PURE__ */ React.isValidElement(n) && n.type === e);
}
function useCol({
  as: t,
  bsPrefix: e,
  className: n,
  ...o
}) {
  e = useBootstrapPrefix(e, "col");
  const l = useBootstrapBreakpoints(), u = useBootstrapMinBreakpoint(), f = [], h = [];
  return l.forEach((p) => {
    const v = o[p];
    delete o[p];
    let g, w, E;
    typeof v == "object" && v != null ? {
      span: g,
      offset: w,
      order: E
    } = v : g = v;
    const T = p !== u ? `-${p}` : "";
    g && f.push(g === !0 ? `${e}${T}` : `${e}${T}-${g}`), E != null && h.push(`order${T}-${E}`), w != null && h.push(`offset${T}-${w}`);
  }), [{
    ...o,
    className: classNames(n, ...f, ...h)
  }, {
    as: t,
    bsPrefix: e,
    spans: f
  }];
}
const Col = /* @__PURE__ */ React.forwardRef(
  // Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
  (t, e) => {
    const [{
      className: n,
      ...o
    }, {
      as: l = "div",
      bsPrefix: u,
      spans: f
    }] = useCol(t);
    return /* @__PURE__ */ jsxRuntimeExports$1.jsx(l, {
      ...o,
      ref: e,
      className: classNames(n, !f.length && u)
    });
  }
);
Col.displayName = "Col";
var __DEV__ = process.env.NODE_ENV !== "production", warning = function() {
};
if (__DEV__) {
  var printWarning = function(e, n) {
    var o = arguments.length;
    n = new Array(o > 1 ? o - 1 : 0);
    for (var l = 1; l < o; l++)
      n[l - 1] = arguments[l];
    var u = 0, f = "Warning: " + e.replace(/%s/g, function() {
      return n[u++];
    });
    typeof console < "u" && console.error(f);
    try {
      throw new Error(f);
    } catch {
    }
  };
  warning = function(t, e, n) {
    var o = arguments.length;
    n = new Array(o > 2 ? o - 2 : 0);
    for (var l = 2; l < o; l++)
      n[l - 2] = arguments[l];
    if (e === void 0)
      throw new Error(
        "`warning(condition, format, ...args)` requires a warning message argument"
      );
    t || printWarning.apply(null, [e].concat(n));
  };
}
var warning_1 = warning;
const warning$1 = /* @__PURE__ */ getDefaultExportFromCjs(warning_1), propTypes$1 = {
  /**
   * Specify whether the feedback is for valid or invalid fields
   *
   * @type {('valid'|'invalid')}
   */
  type: PropTypes.string,
  /** Display feedback as a tooltip. */
  tooltip: PropTypes.bool,
  as: PropTypes.elementType
}, Feedback = /* @__PURE__ */ React.forwardRef(
  // Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
  ({
    as: t = "div",
    className: e,
    type: n = "valid",
    tooltip: o = !1,
    ...l
  }, u) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(t, {
    ...l,
    ref: u,
    className: classNames(e, `${n}-${o ? "tooltip" : "feedback"}`)
  })
);
Feedback.displayName = "Feedback";
Feedback.propTypes = propTypes$1;
const FormContext = /* @__PURE__ */ React.createContext({}), FormCheckInput = /* @__PURE__ */ React.forwardRef(({
  id: t,
  bsPrefix: e,
  className: n,
  type: o = "checkbox",
  isValid: l = !1,
  isInvalid: u = !1,
  // Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
  as: f = "input",
  ...h
}, p) => {
  const {
    controlId: v
  } = useContext(FormContext);
  return e = useBootstrapPrefix(e, "form-check-input"), /* @__PURE__ */ jsxRuntimeExports$1.jsx(f, {
    ...h,
    ref: p,
    type: o,
    id: t || v,
    className: classNames(n, e, l && "is-valid", u && "is-invalid")
  });
});
FormCheckInput.displayName = "FormCheckInput";
const FormCheckLabel = /* @__PURE__ */ React.forwardRef(({
  bsPrefix: t,
  className: e,
  htmlFor: n,
  ...o
}, l) => {
  const {
    controlId: u
  } = useContext(FormContext);
  return t = useBootstrapPrefix(t, "form-check-label"), /* @__PURE__ */ jsxRuntimeExports$1.jsx("label", {
    ...o,
    ref: l,
    htmlFor: n || u,
    className: classNames(e, t)
  });
});
FormCheckLabel.displayName = "FormCheckLabel";
const FormCheck = /* @__PURE__ */ React.forwardRef(({
  id: t,
  bsPrefix: e,
  bsSwitchPrefix: n,
  inline: o = !1,
  reverse: l = !1,
  disabled: u = !1,
  isValid: f = !1,
  isInvalid: h = !1,
  feedbackTooltip: p = !1,
  feedback: v,
  feedbackType: g,
  className: w,
  style: E,
  title: T = "",
  type: R = "checkbox",
  label: _,
  children: b,
  // Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
  as: M = "input",
  ...A
}, $) => {
  e = useBootstrapPrefix(e, "form-check"), n = useBootstrapPrefix(n, "form-switch");
  const {
    controlId: S
  } = useContext(FormContext), C = useMemo(() => ({
    controlId: t || S
  }), [S, t]), D = !b && _ != null && _ !== !1 || hasChildOfType(b, FormCheckLabel), O = /* @__PURE__ */ jsxRuntimeExports$1.jsx(FormCheckInput, {
    ...A,
    type: R === "switch" ? "checkbox" : R,
    ref: $,
    isValid: f,
    isInvalid: h,
    disabled: u,
    as: M
  });
  return /* @__PURE__ */ jsxRuntimeExports$1.jsx(FormContext.Provider, {
    value: C,
    children: /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", {
      style: E,
      className: classNames(w, D && e, o && `${e}-inline`, l && `${e}-reverse`, R === "switch" && n),
      children: b || /* @__PURE__ */ jsxRuntimeExports$1.jsxs(jsxRuntimeExports$1.Fragment, {
        children: [O, D && /* @__PURE__ */ jsxRuntimeExports$1.jsx(FormCheckLabel, {
          title: T,
          children: _
        }), v && /* @__PURE__ */ jsxRuntimeExports$1.jsx(Feedback, {
          type: g,
          tooltip: p,
          children: v
        })]
      })
    })
  });
});
FormCheck.displayName = "FormCheck";
const FormCheck$1 = Object.assign(FormCheck, {
  Input: FormCheckInput,
  Label: FormCheckLabel
}), FormControl = /* @__PURE__ */ React.forwardRef(({
  bsPrefix: t,
  type: e,
  size: n,
  htmlSize: o,
  id: l,
  className: u,
  isValid: f = !1,
  isInvalid: h = !1,
  plaintext: p,
  readOnly: v,
  // Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
  as: g = "input",
  ...w
}, E) => {
  const {
    controlId: T
  } = useContext(FormContext);
  return t = useBootstrapPrefix(t, "form-control"), process.env.NODE_ENV !== "production" && warning$1(T == null || !l, "`controlId` is ignored on `<FormControl>` when `id` is specified."), /* @__PURE__ */ jsxRuntimeExports$1.jsx(g, {
    ...w,
    type: e,
    size: o,
    ref: E,
    readOnly: v,
    id: l || T,
    className: classNames(u, p ? `${t}-plaintext` : t, n && `${t}-${n}`, e === "color" && `${t}-color`, f && "is-valid", h && "is-invalid")
  });
});
FormControl.displayName = "FormControl";
const FormControl$1 = Object.assign(FormControl, {
  Feedback
}), FormFloating = /* @__PURE__ */ React.forwardRef(({
  className: t,
  bsPrefix: e,
  as: n = "div",
  ...o
}, l) => (e = useBootstrapPrefix(e, "form-floating"), /* @__PURE__ */ jsxRuntimeExports$1.jsx(n, {
  ref: l,
  className: classNames(t, e),
  ...o
})));
FormFloating.displayName = "FormFloating";
const FormGroup = /* @__PURE__ */ React.forwardRef(({
  controlId: t,
  // Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
  as: e = "div",
  ...n
}, o) => {
  const l = useMemo(() => ({
    controlId: t
  }), [t]);
  return /* @__PURE__ */ jsxRuntimeExports$1.jsx(FormContext.Provider, {
    value: l,
    children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(e, {
      ...n,
      ref: o
    })
  });
});
FormGroup.displayName = "FormGroup";
const FormLabel = /* @__PURE__ */ React.forwardRef(({
  // Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
  as: t = "label",
  bsPrefix: e,
  column: n = !1,
  visuallyHidden: o = !1,
  className: l,
  htmlFor: u,
  ...f
}, h) => {
  const {
    controlId: p
  } = useContext(FormContext);
  e = useBootstrapPrefix(e, "form-label");
  let v = "col-form-label";
  typeof n == "string" && (v = `${v} ${v}-${n}`);
  const g = classNames(l, e, o && "visually-hidden", n && v);
  return process.env.NODE_ENV !== "production" && warning$1(p == null || !u, "`controlId` is ignored on `<FormLabel>` when `htmlFor` is specified."), u = u || p, n ? /* @__PURE__ */ jsxRuntimeExports$1.jsx(Col, {
    ref: h,
    as: "label",
    className: g,
    htmlFor: u,
    ...f
  }) : (
    // eslint-disable-next-line jsx-a11y/label-has-for, jsx-a11y/label-has-associated-control
    /* @__PURE__ */ jsxRuntimeExports$1.jsx(t, {
      ref: h,
      className: g,
      htmlFor: u,
      ...f
    })
  );
});
FormLabel.displayName = "FormLabel";
const FormRange = /* @__PURE__ */ React.forwardRef(({
  bsPrefix: t,
  className: e,
  id: n,
  ...o
}, l) => {
  const {
    controlId: u
  } = useContext(FormContext);
  return t = useBootstrapPrefix(t, "form-range"), /* @__PURE__ */ jsxRuntimeExports$1.jsx("input", {
    ...o,
    type: "range",
    ref: l,
    className: classNames(e, t),
    id: n || u
  });
});
FormRange.displayName = "FormRange";
const FormSelect = /* @__PURE__ */ React.forwardRef(({
  bsPrefix: t,
  size: e,
  htmlSize: n,
  className: o,
  isValid: l = !1,
  isInvalid: u = !1,
  id: f,
  ...h
}, p) => {
  const {
    controlId: v
  } = useContext(FormContext);
  return t = useBootstrapPrefix(t, "form-select"), /* @__PURE__ */ jsxRuntimeExports$1.jsx("select", {
    ...h,
    size: n,
    ref: p,
    className: classNames(o, t, e && `${t}-${e}`, l && "is-valid", u && "is-invalid"),
    id: f || v
  });
});
FormSelect.displayName = "FormSelect";
const FormText = /* @__PURE__ */ React.forwardRef(
  // Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
  ({
    bsPrefix: t,
    className: e,
    as: n = "small",
    muted: o,
    ...l
  }, u) => (t = useBootstrapPrefix(t, "form-text"), /* @__PURE__ */ jsxRuntimeExports$1.jsx(n, {
    ...l,
    ref: u,
    className: classNames(e, t, o && "text-muted")
  }))
);
FormText.displayName = "FormText";
const Switch = /* @__PURE__ */ React.forwardRef((t, e) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(FormCheck$1, {
  ...t,
  ref: e,
  type: "switch"
}));
Switch.displayName = "Switch";
const Switch$1 = Object.assign(Switch, {
  Input: FormCheck$1.Input,
  Label: FormCheck$1.Label
}), FloatingLabel = /* @__PURE__ */ React.forwardRef(({
  bsPrefix: t,
  className: e,
  children: n,
  controlId: o,
  label: l,
  ...u
}, f) => (t = useBootstrapPrefix(t, "form-floating"), /* @__PURE__ */ jsxRuntimeExports$1.jsxs(FormGroup, {
  ref: f,
  className: classNames(e, t),
  controlId: o,
  ...u,
  children: [n, /* @__PURE__ */ jsxRuntimeExports$1.jsx("label", {
    htmlFor: o,
    children: l
  })]
})));
FloatingLabel.displayName = "FloatingLabel";
const propTypes = {
  /**
   * The Form `ref` will be forwarded to the underlying element,
   * which means, unless it's rendered `as` a composite component,
   * it will be a DOM node, when resolved.
   *
   * @type {ReactRef}
   * @alias ref
   */
  _ref: PropTypes.any,
  /**
   * Mark a form as having been validated. Setting it to `true` will
   * toggle any validation styles on the forms elements.
   */
  validated: PropTypes.bool,
  as: PropTypes.elementType
}, Form = /* @__PURE__ */ React.forwardRef(({
  className: t,
  validated: e,
  // Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
  as: n = "form",
  ...o
}, l) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(n, {
  ...o,
  ref: l,
  className: classNames(t, e && "was-validated")
}));
Form.displayName = "Form";
Form.propTypes = propTypes;
const Form$1 = Object.assign(Form, {
  Group: FormGroup,
  Control: FormControl$1,
  Floating: FormFloating,
  Check: FormCheck$1,
  Switch: Switch$1,
  Label: FormLabel,
  Text: FormText,
  Range: FormRange,
  Select: FormSelect,
  FloatingLabel
});
var Zs$1 = Object.defineProperty, Ys$1 = (t, e, n) => e in t ? Zs$1(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, Ci$1 = (t, e, n) => (Ys$1(t, typeof e != "symbol" ? e + "" : e, n), n), commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, jsxRuntime = { exports: {} }, reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min)
    return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var t = React__default, e = Symbol.for("react.element"), n = Symbol.for("react.fragment"), o = Object.prototype.hasOwnProperty, l = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, u = { key: !0, ref: !0, __self: !0, __source: !0 };
  function f(h, p, v) {
    var g, w = {}, E = null, T = null;
    v !== void 0 && (E = "" + v), p.key !== void 0 && (E = "" + p.key), p.ref !== void 0 && (T = p.ref);
    for (g in p)
      o.call(p, g) && !u.hasOwnProperty(g) && (w[g] = p[g]);
    if (h && h.defaultProps)
      for (g in p = h.defaultProps, p)
        w[g] === void 0 && (w[g] = p[g]);
    return { $$typeof: e, type: h, key: E, ref: T, props: w, _owner: l.current };
  }
  return reactJsxRuntime_production_min.Fragment = n, reactJsxRuntime_production_min.jsx = f, reactJsxRuntime_production_min.jsxs = f, reactJsxRuntime_production_min;
}
var reactJsxRuntime_development = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_development;
function requireReactJsxRuntime_development() {
  return hasRequiredReactJsxRuntime_development || (hasRequiredReactJsxRuntime_development = 1, process.env.NODE_ENV !== "production" && function() {
    var t = React__default, e = Symbol.for("react.element"), n = Symbol.for("react.portal"), o = Symbol.for("react.fragment"), l = Symbol.for("react.strict_mode"), u = Symbol.for("react.profiler"), f = Symbol.for("react.provider"), h = Symbol.for("react.context"), p = Symbol.for("react.forward_ref"), v = Symbol.for("react.suspense"), g = Symbol.for("react.suspense_list"), w = Symbol.for("react.memo"), E = Symbol.for("react.lazy"), T = Symbol.for("react.offscreen"), R = Symbol.iterator, _ = "@@iterator";
    function b(Xe) {
      if (Xe === null || typeof Xe != "object")
        return null;
      var Se = R && Xe[R] || Xe[_];
      return typeof Se == "function" ? Se : null;
    }
    var M = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function A(Xe) {
      {
        for (var Se = arguments.length, pr = new Array(Se > 1 ? Se - 1 : 0), mn = 1; mn < Se; mn++)
          pr[mn - 1] = arguments[mn];
        $("error", Xe, pr);
      }
    }
    function $(Xe, Se, pr) {
      {
        var mn = M.ReactDebugCurrentFrame, Si = mn.getStackAddendum();
        Si !== "" && (Se += "%s", pr = pr.concat([Si]));
        var Io = pr.map(function(ve) {
          return String(ve);
        });
        Io.unshift("Warning: " + Se), Function.prototype.apply.call(console[Xe], console, Io);
      }
    }
    var S = !1, C = !1, D = !1, O = !1, N = !1, j;
    j = Symbol.for("react.module.reference");
    function L(Xe) {
      return !!(typeof Xe == "string" || typeof Xe == "function" || Xe === o || Xe === u || N || Xe === l || Xe === v || Xe === g || O || Xe === T || S || C || D || typeof Xe == "object" && Xe !== null && (Xe.$$typeof === E || Xe.$$typeof === w || Xe.$$typeof === f || Xe.$$typeof === h || Xe.$$typeof === p || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      Xe.$$typeof === j || Xe.getModuleId !== void 0));
    }
    function z(Xe, Se, pr) {
      var mn = Xe.displayName;
      if (mn)
        return mn;
      var Si = Se.displayName || Se.name || "";
      return Si !== "" ? pr + "(" + Si + ")" : pr;
    }
    function G(Xe) {
      return Xe.displayName || "Context";
    }
    function B(Xe) {
      if (Xe == null)
        return null;
      if (typeof Xe.tag == "number" && A("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof Xe == "function")
        return Xe.displayName || Xe.name || null;
      if (typeof Xe == "string")
        return Xe;
      switch (Xe) {
        case o:
          return "Fragment";
        case n:
          return "Portal";
        case u:
          return "Profiler";
        case l:
          return "StrictMode";
        case v:
          return "Suspense";
        case g:
          return "SuspenseList";
      }
      if (typeof Xe == "object")
        switch (Xe.$$typeof) {
          case h:
            var Se = Xe;
            return G(Se) + ".Consumer";
          case f:
            var pr = Xe;
            return G(pr._context) + ".Provider";
          case p:
            return z(Xe, Xe.render, "ForwardRef");
          case w:
            var mn = Xe.displayName || null;
            return mn !== null ? mn : B(Xe.type) || "Memo";
          case E: {
            var Si = Xe, Io = Si._payload, ve = Si._init;
            try {
              return B(ve(Io));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var F = Object.assign, H = 0, W, V, X, Z, Q, q, J;
    function ie() {
    }
    ie.__reactDisabledLog = !0;
    function ne() {
      {
        if (H === 0) {
          W = console.log, V = console.info, X = console.warn, Z = console.error, Q = console.group, q = console.groupCollapsed, J = console.groupEnd;
          var Xe = {
            configurable: !0,
            enumerable: !0,
            value: ie,
            writable: !0
          };
          Object.defineProperties(console, {
            info: Xe,
            log: Xe,
            warn: Xe,
            error: Xe,
            group: Xe,
            groupCollapsed: Xe,
            groupEnd: Xe
          });
        }
        H++;
      }
    }
    function ge() {
      {
        if (H--, H === 0) {
          var Xe = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: F({}, Xe, {
              value: W
            }),
            info: F({}, Xe, {
              value: V
            }),
            warn: F({}, Xe, {
              value: X
            }),
            error: F({}, Xe, {
              value: Z
            }),
            group: F({}, Xe, {
              value: Q
            }),
            groupCollapsed: F({}, Xe, {
              value: q
            }),
            groupEnd: F({}, Xe, {
              value: J
            })
          });
        }
        H < 0 && A("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var ye = M.ReactCurrentDispatcher, xe;
    function we(Xe, Se, pr) {
      {
        if (xe === void 0)
          try {
            throw Error();
          } catch (Si) {
            var mn = Si.stack.trim().match(/\n( *(at )?)/);
            xe = mn && mn[1] || "";
          }
        return `
` + xe + Xe;
      }
    }
    var de = !1, Te;
    {
      var Ce = typeof WeakMap == "function" ? WeakMap : Map;
      Te = new Ce();
    }
    function ee(Xe, Se) {
      if (!Xe || de)
        return "";
      {
        var pr = Te.get(Xe);
        if (pr !== void 0)
          return pr;
      }
      var mn;
      de = !0;
      var Si = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Io;
      Io = ye.current, ye.current = null, ne();
      try {
        if (Se) {
          var ve = function() {
            throw Error();
          };
          if (Object.defineProperty(ve.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(ve, []);
            } catch (vs) {
              mn = vs;
            }
            Reflect.construct(Xe, [], ve);
          } else {
            try {
              ve.call();
            } catch (vs) {
              mn = vs;
            }
            Xe.call(ve.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (vs) {
            mn = vs;
          }
          Xe();
        }
      } catch (vs) {
        if (vs && mn && typeof vs.stack == "string") {
          for (var He = vs.stack.split(`
`), nt = mn.stack.split(`
`), dr = He.length - 1, dt = nt.length - 1; dr >= 1 && dt >= 0 && He[dr] !== nt[dt]; )
            dt--;
          for (; dr >= 1 && dt >= 0; dr--, dt--)
            if (He[dr] !== nt[dt]) {
              if (dr !== 1 || dt !== 1)
                do
                  if (dr--, dt--, dt < 0 || He[dr] !== nt[dt]) {
                    var ci = `
` + He[dr].replace(" at new ", " at ");
                    return Xe.displayName && ci.includes("<anonymous>") && (ci = ci.replace("<anonymous>", Xe.displayName)), typeof Xe == "function" && Te.set(Xe, ci), ci;
                  }
                while (dr >= 1 && dt >= 0);
              break;
            }
        }
      } finally {
        de = !1, ye.current = Io, ge(), Error.prepareStackTrace = Si;
      }
      var Uo = Xe ? Xe.displayName || Xe.name : "", xs = Uo ? we(Uo) : "";
      return typeof Xe == "function" && Te.set(Xe, xs), xs;
    }
    function Ae(Xe, Se, pr) {
      return ee(Xe, !1);
    }
    function be(Xe) {
      var Se = Xe.prototype;
      return !!(Se && Se.isReactComponent);
    }
    function Fe(Xe, Se, pr) {
      if (Xe == null)
        return "";
      if (typeof Xe == "function")
        return ee(Xe, be(Xe));
      if (typeof Xe == "string")
        return we(Xe);
      switch (Xe) {
        case v:
          return we("Suspense");
        case g:
          return we("SuspenseList");
      }
      if (typeof Xe == "object")
        switch (Xe.$$typeof) {
          case p:
            return Ae(Xe.render);
          case w:
            return Fe(Xe.type, Se, pr);
          case E: {
            var mn = Xe, Si = mn._payload, Io = mn._init;
            try {
              return Fe(Io(Si), Se, pr);
            } catch {
            }
          }
        }
      return "";
    }
    var et = Object.prototype.hasOwnProperty, Ye = {}, De = M.ReactDebugCurrentFrame;
    function Ue(Xe) {
      if (Xe) {
        var Se = Xe._owner, pr = Fe(Xe.type, Xe._source, Se ? Se.type : null);
        De.setExtraStackFrame(pr);
      } else
        De.setExtraStackFrame(null);
    }
    function Qe(Xe, Se, pr, mn, Si) {
      {
        var Io = Function.call.bind(et);
        for (var ve in Xe)
          if (Io(Xe, ve)) {
            var He = void 0;
            try {
              if (typeof Xe[ve] != "function") {
                var nt = Error((mn || "React class") + ": " + pr + " type `" + ve + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof Xe[ve] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw nt.name = "Invariant Violation", nt;
              }
              He = Xe[ve](Se, ve, mn, pr, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (dr) {
              He = dr;
            }
            He && !(He instanceof Error) && (Ue(Si), A("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", mn || "React class", pr, ve, typeof He), Ue(null)), He instanceof Error && !(He.message in Ye) && (Ye[He.message] = !0, Ue(Si), A("Failed %s type: %s", pr, He.message), Ue(null));
          }
      }
    }
    var ue = Array.isArray;
    function te(Xe) {
      return ue(Xe);
    }
    function Be(Xe) {
      {
        var Se = typeof Symbol == "function" && Symbol.toStringTag, pr = Se && Xe[Symbol.toStringTag] || Xe.constructor.name || "Object";
        return pr;
      }
    }
    function Je(Xe) {
      try {
        return ft(Xe), !1;
      } catch {
        return !0;
      }
    }
    function ft(Xe) {
      return "" + Xe;
    }
    function lt(Xe) {
      if (Je(Xe))
        return A("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Be(Xe)), ft(Xe);
    }
    var he = M.ReactCurrentOwner, ae = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, se, Re, Oe;
    Oe = {};
    function We(Xe) {
      if (et.call(Xe, "ref")) {
        var Se = Object.getOwnPropertyDescriptor(Xe, "ref").get;
        if (Se && Se.isReactWarning)
          return !1;
      }
      return Xe.ref !== void 0;
    }
    function Ct(Xe) {
      if (et.call(Xe, "key")) {
        var Se = Object.getOwnPropertyDescriptor(Xe, "key").get;
        if (Se && Se.isReactWarning)
          return !1;
      }
      return Xe.key !== void 0;
    }
    function le(Xe, Se) {
      if (typeof Xe.ref == "string" && he.current && Se && he.current.stateNode !== Se) {
        var pr = B(he.current.type);
        Oe[pr] || (A('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', B(he.current.type), Xe.ref), Oe[pr] = !0);
      }
    }
    function ke(Xe, Se) {
      {
        var pr = function() {
          se || (se = !0, A("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Se));
        };
        pr.isReactWarning = !0, Object.defineProperty(Xe, "key", {
          get: pr,
          configurable: !0
        });
      }
    }
    function Ke(Xe, Se) {
      {
        var pr = function() {
          Re || (Re = !0, A("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Se));
        };
        pr.isReactWarning = !0, Object.defineProperty(Xe, "ref", {
          get: pr,
          configurable: !0
        });
      }
    }
    var me = function(Xe, Se, pr, mn, Si, Io, ve) {
      var He = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: Xe,
        key: Se,
        ref: pr,
        props: ve,
        // Record the component responsible for creating this element.
        _owner: Io
      };
      return He._store = {}, Object.defineProperty(He._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(He, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: mn
      }), Object.defineProperty(He, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Si
      }), Object.freeze && (Object.freeze(He.props), Object.freeze(He)), He;
    };
    function Ee(Xe, Se, pr, mn, Si) {
      {
        var Io, ve = {}, He = null, nt = null;
        pr !== void 0 && (lt(pr), He = "" + pr), Ct(Se) && (lt(Se.key), He = "" + Se.key), We(Se) && (nt = Se.ref, le(Se, Si));
        for (Io in Se)
          et.call(Se, Io) && !ae.hasOwnProperty(Io) && (ve[Io] = Se[Io]);
        if (Xe && Xe.defaultProps) {
          var dr = Xe.defaultProps;
          for (Io in dr)
            ve[Io] === void 0 && (ve[Io] = dr[Io]);
        }
        if (He || nt) {
          var dt = typeof Xe == "function" ? Xe.displayName || Xe.name || "Unknown" : Xe;
          He && ke(ve, dt), nt && Ke(ve, dt);
        }
        return me(Xe, He, nt, Si, mn, he.current, ve);
      }
    }
    var tt = M.ReactCurrentOwner, ce = M.ReactDebugCurrentFrame;
    function _e(Xe) {
      if (Xe) {
        var Se = Xe._owner, pr = Fe(Xe.type, Xe._source, Se ? Se.type : null);
        ce.setExtraStackFrame(pr);
      } else
        ce.setExtraStackFrame(null);
    }
    var Ht;
    Ht = !1;
    function K(Xe) {
      return typeof Xe == "object" && Xe !== null && Xe.$$typeof === e;
    }
    function Ve() {
      {
        if (tt.current) {
          var Xe = B(tt.current.type);
          if (Xe)
            return `

Check the render method of \`` + Xe + "`.";
        }
        return "";
      }
    }
    function Ne(Xe) {
      return "";
    }
    var pe = {};
    function Le(Xe) {
      {
        var Se = Ve();
        if (!Se) {
          var pr = typeof Xe == "string" ? Xe : Xe.displayName || Xe.name;
          pr && (Se = `

Check the top-level render call using <` + pr + ">.");
        }
        return Se;
      }
    }
    function bt(Xe, Se) {
      {
        if (!Xe._store || Xe._store.validated || Xe.key != null)
          return;
        Xe._store.validated = !0;
        var pr = Le(Se);
        if (pe[pr])
          return;
        pe[pr] = !0;
        var mn = "";
        Xe && Xe._owner && Xe._owner !== tt.current && (mn = " It was passed a child from " + B(Xe._owner.type) + "."), _e(Xe), A('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', pr, mn), _e(null);
      }
    }
    function yi(Xe, Se) {
      {
        if (typeof Xe != "object")
          return;
        if (te(Xe))
          for (var pr = 0; pr < Xe.length; pr++) {
            var mn = Xe[pr];
            K(mn) && bt(mn, Se);
          }
        else if (K(Xe))
          Xe._store && (Xe._store.validated = !0);
        else if (Xe) {
          var Si = b(Xe);
          if (typeof Si == "function" && Si !== Xe.entries)
            for (var Io = Si.call(Xe), ve; !(ve = Io.next()).done; )
              K(ve.value) && bt(ve.value, Se);
        }
      }
    }
    function _n(Xe) {
      {
        var Se = Xe.type;
        if (Se == null || typeof Se == "string")
          return;
        var pr;
        if (typeof Se == "function")
          pr = Se.propTypes;
        else if (typeof Se == "object" && (Se.$$typeof === p || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        Se.$$typeof === w))
          pr = Se.propTypes;
        else
          return;
        if (pr) {
          var mn = B(Se);
          Qe(pr, Xe.props, "prop", mn, Xe);
        } else if (Se.PropTypes !== void 0 && !Ht) {
          Ht = !0;
          var Si = B(Se);
          A("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Si || "Unknown");
        }
        typeof Se.getDefaultProps == "function" && !Se.getDefaultProps.isReactClassApproved && A("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Do(Xe) {
      {
        for (var Se = Object.keys(Xe.props), pr = 0; pr < Se.length; pr++) {
          var mn = Se[pr];
          if (mn !== "children" && mn !== "key") {
            _e(Xe), A("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", mn), _e(null);
            break;
          }
        }
        Xe.ref !== null && (_e(Xe), A("Invalid attribute `ref` supplied to `React.Fragment`."), _e(null));
      }
    }
    function ms(Xe, Se, pr, mn, Si, Io) {
      {
        var ve = L(Xe);
        if (!ve) {
          var He = "";
          (Xe === void 0 || typeof Xe == "object" && Xe !== null && Object.keys(Xe).length === 0) && (He += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var nt = Ne();
          nt ? He += nt : He += Ve();
          var dr;
          Xe === null ? dr = "null" : te(Xe) ? dr = "array" : Xe !== void 0 && Xe.$$typeof === e ? (dr = "<" + (B(Xe.type) || "Unknown") + " />", He = " Did you accidentally export a JSX literal instead of a component?") : dr = typeof Xe, A("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", dr, He);
        }
        var dt = Ee(Xe, Se, pr, Si, Io);
        if (dt == null)
          return dt;
        if (ve) {
          var ci = Se.children;
          if (ci !== void 0)
            if (mn)
              if (te(ci)) {
                for (var Uo = 0; Uo < ci.length; Uo++)
                  yi(ci[Uo], Xe);
                Object.freeze && Object.freeze(ci);
              } else
                A("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              yi(ci, Xe);
        }
        return Xe === o ? Do(dt) : _n(dt), dt;
      }
    }
    function Bp(Xe, Se, pr) {
      return ms(Xe, Se, pr, !0);
    }
    function Sp(Xe, Se, pr) {
      return ms(Xe, Se, pr, !1);
    }
    var Tp = Sp, Pp = Bp;
    reactJsxRuntime_development.Fragment = o, reactJsxRuntime_development.jsx = Tp, reactJsxRuntime_development.jsxs = Pp;
  }()), reactJsxRuntime_development;
}
process.env.NODE_ENV === "production" ? jsxRuntime.exports = requireReactJsxRuntime_production_min() : jsxRuntime.exports = requireReactJsxRuntime_development();
var jsxRuntimeExports = jsxRuntime.exports;
class ControlBox extends React__default.Component {
  constructor() {
    super(...arguments), Ci$1(this, "handleSupercellChange", (e, n) => {
      let o = this.props.viewerParams.supercell;
      o[e] = parseInt(n), this.props.onViewerParamChange("supercell", o);
    }), Ci$1(this, "handleOptionChange", (e) => {
      this.props.onViewerParamChange(e, !this.props.viewerParams[e]);
    }), Ci$1(this, "handleCameraEvent", (e) => {
      this.props.onViewerEvent("camera", e);
    });
  }
  render() {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "control-box", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "control-box-row", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "supercell-container", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Form$1.Label, { children: "Supercell: " }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "flex" }, children: [0, 1, 2].map((e) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            Form$1.Control,
            {
              className: "supercell-input",
              type: "number",
              min: "1",
              max: "99",
              value: this.props.viewerParams.supercell[e],
              onChange: (n) => this.handleSupercellChange(e, n.target.value)
            },
            e
          )) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "camera-controls", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Form$1.Label, { children: "Camera: " }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              className: "camera-button",
              onClick: () => this.handleCameraEvent("x"),
              children: "x"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              className: "camera-button",
              onClick: () => this.handleCameraEvent("y"),
              children: "y"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              className: "camera-button",
              onClick: () => this.handleCameraEvent("z"),
              children: "z"
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "control-box-row", style: { display: "flex" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Form$1.Check,
          {
            className: "option-checkbox",
            type: "checkbox",
            checked: this.props.viewerParams.bonds,
            onChange: () => this.handleOptionChange("bonds"),
            label: "Bonds"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Form$1.Check,
          {
            className: "option-checkbox",
            type: "checkbox",
            checked: this.props.viewerParams.packedCell,
            onChange: () => this.handleOptionChange("packedCell"),
            label: "Packed cell"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Form$1.Check,
          {
            className: "option-checkbox",
            type: "checkbox",
            checked: this.props.viewerParams.atomLabels,
            onChange: () => this.handleOptionChange("atomLabels"),
            label: "Atom labels"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Form$1.Check,
          {
            className: "option-checkbox",
            type: "checkbox",
            checked: this.props.viewerParams.spaceFilling,
            onChange: () => this.handleOptionChange("vdwRadius"),
            label: "vdW radius"
          }
        )
      ] })
    ] });
  }
}
var _3Dmol = { exports: {} };
/*!
 * 3dmol v2.1.0
 * JavaScript/TypeScript molecular visualization library
 * Author: David Koes and contributors
 */
(function(module, exports) {
  (function(t, e) {
    module.exports = e();
  })(commonjsGlobal, () => (
    /******/
    (() => {
      var __webpack_modules__ = {
        /***/
        "./node_modules/iobuffer/lib-esm/IOBuffer.js": (
          /*!***************************************************!*\
            !*** ./node_modules/iobuffer/lib-esm/IOBuffer.js ***!
            \***************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              IOBuffer: () => (
                /* binding */
                h
              )
              /* harmony export */
            });
            var o = n(
              /*! ./text */
              "./node_modules/iobuffer/lib-esm/text.browser.js"
            );
            const l = 1024 * 8, u = (() => {
              const p = new Uint8Array(4), v = new Uint32Array(p.buffer);
              return !((v[0] = 1) & p[0]);
            })(), f = {
              int8: globalThis.Int8Array,
              uint8: globalThis.Uint8Array,
              int16: globalThis.Int16Array,
              uint16: globalThis.Uint16Array,
              int32: globalThis.Int32Array,
              uint32: globalThis.Uint32Array,
              uint64: globalThis.BigUint64Array,
              int64: globalThis.BigInt64Array,
              float32: globalThis.Float32Array,
              float64: globalThis.Float64Array
            };
            class h {
              /**
               * @param data - The data to construct the IOBuffer with.
               * If data is a number, it will be the new buffer's length<br>
               * If data is `undefined`, the buffer will be initialized with a default length of 8Kb<br>
               * If data is an ArrayBuffer, SharedArrayBuffer, an ArrayBufferView (Typed Array), an IOBuffer instance,
               * or a Node.js Buffer, a view will be created over the underlying ArrayBuffer.
               * @param options
               */
              constructor(v = l, g = {}) {
                let w = !1;
                typeof v == "number" ? v = new ArrayBuffer(v) : (w = !0, this.lastWrittenByte = v.byteLength);
                const E = g.offset ? g.offset >>> 0 : 0, T = v.byteLength - E;
                let R = E;
                (ArrayBuffer.isView(v) || v instanceof h) && (v.byteLength !== v.buffer.byteLength && (R = v.byteOffset + E), v = v.buffer), w ? this.lastWrittenByte = T : this.lastWrittenByte = 0, this.buffer = v, this.length = T, this.byteLength = T, this.byteOffset = R, this.offset = 0, this.littleEndian = !0, this._data = new DataView(this.buffer, R, T), this._mark = 0, this._marks = [];
              }
              /**
               * Checks if the memory allocated to the buffer is sufficient to store more
               * bytes after the offset.
               * @param byteLength - The needed memory in bytes.
               * @returns `true` if there is sufficient space and `false` otherwise.
               */
              available(v = 1) {
                return this.offset + v <= this.length;
              }
              /**
               * Check if little-endian mode is used for reading and writing multi-byte
               * values.
               * @returns `true` if little-endian mode is used, `false` otherwise.
               */
              isLittleEndian() {
                return this.littleEndian;
              }
              /**
               * Set little-endian mode for reading and writing multi-byte values.
               */
              setLittleEndian() {
                return this.littleEndian = !0, this;
              }
              /**
               * Check if big-endian mode is used for reading and writing multi-byte values.
               * @returns `true` if big-endian mode is used, `false` otherwise.
               */
              isBigEndian() {
                return !this.littleEndian;
              }
              /**
               * Switches to big-endian mode for reading and writing multi-byte values.
               */
              setBigEndian() {
                return this.littleEndian = !1, this;
              }
              /**
               * Move the pointer n bytes forward.
               * @param n - Number of bytes to skip.
               */
              skip(v = 1) {
                return this.offset += v, this;
              }
              /**
               * Move the pointer n bytes backward.
               * @param n - Number of bytes to move back.
               */
              back(v = 1) {
                return this.offset -= v, this;
              }
              /**
               * Move the pointer to the given offset.
               * @param offset
               */
              seek(v) {
                return this.offset = v, this;
              }
              /**
               * Store the current pointer offset.
               * @see {@link IOBuffer#reset}
               */
              mark() {
                return this._mark = this.offset, this;
              }
              /**
               * Move the pointer back to the last pointer offset set by mark.
               * @see {@link IOBuffer#mark}
               */
              reset() {
                return this.offset = this._mark, this;
              }
              /**
               * Push the current pointer offset to the mark stack.
               * @see {@link IOBuffer#popMark}
               */
              pushMark() {
                return this._marks.push(this.offset), this;
              }
              /**
               * Pop the last pointer offset from the mark stack, and set the current
               * pointer offset to the popped value.
               * @see {@link IOBuffer#pushMark}
               */
              popMark() {
                const v = this._marks.pop();
                if (v === void 0)
                  throw new Error("Mark stack empty");
                return this.seek(v), this;
              }
              /**
               * Move the pointer offset back to 0.
               */
              rewind() {
                return this.offset = 0, this;
              }
              /**
               * Make sure the buffer has sufficient memory to write a given byteLength at
               * the current pointer offset.
               * If the buffer's memory is insufficient, this method will create a new
               * buffer (a copy) with a length that is twice (byteLength + current offset).
               * @param byteLength
               */
              ensureAvailable(v = 1) {
                if (!this.available(v)) {
                  const g = (this.offset + v) * 2, w = new Uint8Array(g);
                  w.set(new Uint8Array(this.buffer)), this.buffer = w.buffer, this.length = this.byteLength = g, this._data = new DataView(this.buffer);
                }
                return this;
              }
              /**
               * Read a byte and return false if the byte's value is 0, or true otherwise.
               * Moves pointer forward by one byte.
               */
              readBoolean() {
                return this.readUint8() !== 0;
              }
              /**
               * Read a signed 8-bit integer and move pointer forward by 1 byte.
               */
              readInt8() {
                return this._data.getInt8(this.offset++);
              }
              /**
               * Read an unsigned 8-bit integer and move pointer forward by 1 byte.
               */
              readUint8() {
                return this._data.getUint8(this.offset++);
              }
              /**
               * Alias for {@link IOBuffer#readUint8}.
               */
              readByte() {
                return this.readUint8();
              }
              /**
               * Read `n` bytes and move pointer forward by `n` bytes.
               */
              readBytes(v = 1) {
                return this.readArray(v, "uint8");
              }
              /**
               * Creates an array of corresponding to the type `type` and size `size`.
               * For example type `uint8` will create a `Uint8Array`.
               * @param size - size of the resulting array
               * @param type - number type of elements to read
               */
              readArray(v, g) {
                const w = f[g].BYTES_PER_ELEMENT * v, E = this.byteOffset + this.offset, T = this.buffer.slice(E, E + w);
                if (this.littleEndian === u && g !== "uint8" && g !== "int8") {
                  const _ = new Uint8Array(this.buffer.slice(E, E + w));
                  _.reverse();
                  const b = new f[g](_.buffer);
                  return this.offset += w, b.reverse(), b;
                }
                const R = new f[g](T);
                return this.offset += w, R;
              }
              /**
               * Read a 16-bit signed integer and move pointer forward by 2 bytes.
               */
              readInt16() {
                const v = this._data.getInt16(this.offset, this.littleEndian);
                return this.offset += 2, v;
              }
              /**
               * Read a 16-bit unsigned integer and move pointer forward by 2 bytes.
               */
              readUint16() {
                const v = this._data.getUint16(this.offset, this.littleEndian);
                return this.offset += 2, v;
              }
              /**
               * Read a 32-bit signed integer and move pointer forward by 4 bytes.
               */
              readInt32() {
                const v = this._data.getInt32(this.offset, this.littleEndian);
                return this.offset += 4, v;
              }
              /**
               * Read a 32-bit unsigned integer and move pointer forward by 4 bytes.
               */
              readUint32() {
                const v = this._data.getUint32(this.offset, this.littleEndian);
                return this.offset += 4, v;
              }
              /**
               * Read a 32-bit floating number and move pointer forward by 4 bytes.
               */
              readFloat32() {
                const v = this._data.getFloat32(this.offset, this.littleEndian);
                return this.offset += 4, v;
              }
              /**
               * Read a 64-bit floating number and move pointer forward by 8 bytes.
               */
              readFloat64() {
                const v = this._data.getFloat64(this.offset, this.littleEndian);
                return this.offset += 8, v;
              }
              /**
               * Read a 64-bit signed integer number and move pointer forward by 8 bytes.
               */
              readBigInt64() {
                const v = this._data.getBigInt64(this.offset, this.littleEndian);
                return this.offset += 8, v;
              }
              /**
               * Read a 64-bit unsigned integer number and move pointer forward by 8 bytes.
               */
              readBigUint64() {
                const v = this._data.getBigUint64(this.offset, this.littleEndian);
                return this.offset += 8, v;
              }
              /**
               * Read a 1-byte ASCII character and move pointer forward by 1 byte.
               */
              readChar() {
                return String.fromCharCode(this.readInt8());
              }
              /**
               * Read `n` 1-byte ASCII characters and move pointer forward by `n` bytes.
               */
              readChars(v = 1) {
                let g = "";
                for (let w = 0; w < v; w++)
                  g += this.readChar();
                return g;
              }
              /**
               * Read the next `n` bytes, return a UTF-8 decoded string and move pointer
               * forward by `n` bytes.
               */
              readUtf8(v = 1) {
                return (0, o.decode)(this.readBytes(v));
              }
              /**
               * Read the next `n` bytes, return a string decoded with `encoding` and move pointer
               * forward by `n` bytes.
               * If no encoding is passed, the function is equivalent to @see {@link IOBuffer#readUtf8}
               */
              decodeText(v = 1, g = "utf-8") {
                return (0, o.decode)(this.readBytes(v), g);
              }
              /**
               * Write 0xff if the passed value is truthy, 0x00 otherwise and move pointer
               * forward by 1 byte.
               */
              writeBoolean(v) {
                return this.writeUint8(v ? 255 : 0), this;
              }
              /**
               * Write `value` as an 8-bit signed integer and move pointer forward by 1 byte.
               */
              writeInt8(v) {
                return this.ensureAvailable(1), this._data.setInt8(this.offset++, v), this._updateLastWrittenByte(), this;
              }
              /**
               * Write `value` as an 8-bit unsigned integer and move pointer forward by 1
               * byte.
               */
              writeUint8(v) {
                return this.ensureAvailable(1), this._data.setUint8(this.offset++, v), this._updateLastWrittenByte(), this;
              }
              /**
               * An alias for {@link IOBuffer#writeUint8}.
               */
              writeByte(v) {
                return this.writeUint8(v);
              }
              /**
               * Write all elements of `bytes` as uint8 values and move pointer forward by
               * `bytes.length` bytes.
               */
              writeBytes(v) {
                this.ensureAvailable(v.length);
                for (let g = 0; g < v.length; g++)
                  this._data.setUint8(this.offset++, v[g]);
                return this._updateLastWrittenByte(), this;
              }
              /**
               * Write `value` as a 16-bit signed integer and move pointer forward by 2
               * bytes.
               */
              writeInt16(v) {
                return this.ensureAvailable(2), this._data.setInt16(this.offset, v, this.littleEndian), this.offset += 2, this._updateLastWrittenByte(), this;
              }
              /**
               * Write `value` as a 16-bit unsigned integer and move pointer forward by 2
               * bytes.
               */
              writeUint16(v) {
                return this.ensureAvailable(2), this._data.setUint16(this.offset, v, this.littleEndian), this.offset += 2, this._updateLastWrittenByte(), this;
              }
              /**
               * Write `value` as a 32-bit signed integer and move pointer forward by 4
               * bytes.
               */
              writeInt32(v) {
                return this.ensureAvailable(4), this._data.setInt32(this.offset, v, this.littleEndian), this.offset += 4, this._updateLastWrittenByte(), this;
              }
              /**
               * Write `value` as a 32-bit unsigned integer and move pointer forward by 4
               * bytes.
               */
              writeUint32(v) {
                return this.ensureAvailable(4), this._data.setUint32(this.offset, v, this.littleEndian), this.offset += 4, this._updateLastWrittenByte(), this;
              }
              /**
               * Write `value` as a 32-bit floating number and move pointer forward by 4
               * bytes.
               */
              writeFloat32(v) {
                return this.ensureAvailable(4), this._data.setFloat32(this.offset, v, this.littleEndian), this.offset += 4, this._updateLastWrittenByte(), this;
              }
              /**
               * Write `value` as a 64-bit floating number and move pointer forward by 8
               * bytes.
               */
              writeFloat64(v) {
                return this.ensureAvailable(8), this._data.setFloat64(this.offset, v, this.littleEndian), this.offset += 8, this._updateLastWrittenByte(), this;
              }
              /**
               * Write `value` as a 64-bit signed bigint and move pointer forward by 8
               * bytes.
               */
              writeBigInt64(v) {
                return this.ensureAvailable(8), this._data.setBigInt64(this.offset, v, this.littleEndian), this.offset += 8, this._updateLastWrittenByte(), this;
              }
              /**
               * Write `value` as a 64-bit unsigned bigint and move pointer forward by 8
               * bytes.
               */
              writeBigUint64(v) {
                return this.ensureAvailable(8), this._data.setBigUint64(this.offset, v, this.littleEndian), this.offset += 8, this._updateLastWrittenByte(), this;
              }
              /**
               * Write the charCode of `str`'s first character as an 8-bit unsigned integer
               * and move pointer forward by 1 byte.
               */
              writeChar(v) {
                return this.writeUint8(v.charCodeAt(0));
              }
              /**
               * Write the charCodes of all `str`'s characters as 8-bit unsigned integers
               * and move pointer forward by `str.length` bytes.
               */
              writeChars(v) {
                for (let g = 0; g < v.length; g++)
                  this.writeUint8(v.charCodeAt(g));
                return this;
              }
              /**
               * UTF-8 encode and write `str` to the current pointer offset and move pointer
               * forward according to the encoded length.
               */
              writeUtf8(v) {
                return this.writeBytes((0, o.encode)(v));
              }
              /**
               * Export a Uint8Array view of the internal buffer.
               * The view starts at the byte offset and its length
               * is calculated to stop at the last written byte or the original length.
               */
              toArray() {
                return new Uint8Array(this.buffer, this.byteOffset, this.lastWrittenByte);
              }
              /**
               * Update the last written byte offset
               * @private
               */
              _updateLastWrittenByte() {
                this.offset > this.lastWrittenByte && (this.lastWrittenByte = this.offset);
              }
            }
          }
        ),
        /***/
        "./node_modules/iobuffer/lib-esm/text-encoding-polyfill.js": (
          /*!*****************************************************************!*\
            !*** ./node_modules/iobuffer/lib-esm/text-encoding-polyfill.js ***!
            \*****************************************************************/
          /***/
          function() {
            (function(t) {
              if (t.TextEncoder && t.TextDecoder)
                return !1;
              function e(o = "utf-8") {
                if (o !== "utf-8")
                  throw new RangeError(`Failed to construct 'TextEncoder': The encoding label provided ('${o}') is invalid.`);
              }
              Object.defineProperty(e.prototype, "encoding", {
                value: "utf-8"
              }), e.prototype.encode = function(o, l = { stream: !1 }) {
                if (l.stream)
                  throw new Error("Failed to encode: the 'stream' option is unsupported.");
                let u = 0;
                const f = o.length;
                let h = 0, p = Math.max(32, f + (f >> 1) + 7), v = new Uint8Array(p >> 3 << 3);
                for (; u < f; ) {
                  let g = o.charCodeAt(u++);
                  if (g >= 55296 && g <= 56319) {
                    if (u < f) {
                      const w = o.charCodeAt(u);
                      (w & 64512) === 56320 && (++u, g = ((g & 1023) << 10) + (w & 1023) + 65536);
                    }
                    if (g >= 55296 && g <= 56319)
                      continue;
                  }
                  if (h + 4 > v.length) {
                    p += 8, p *= 1 + u / o.length * 2, p = p >> 3 << 3;
                    const w = new Uint8Array(p);
                    w.set(v), v = w;
                  }
                  if (g & 4294967168)
                    if (!(g & 4294965248))
                      v[h++] = g >> 6 & 31 | 192;
                    else if (!(g & 4294901760))
                      v[h++] = g >> 12 & 15 | 224, v[h++] = g >> 6 & 63 | 128;
                    else if (!(g & 4292870144))
                      v[h++] = g >> 18 & 7 | 240, v[h++] = g >> 12 & 63 | 128, v[h++] = g >> 6 & 63 | 128;
                    else
                      continue;
                  else {
                    v[h++] = g;
                    continue;
                  }
                  v[h++] = g & 63 | 128;
                }
                return v.slice(0, h);
              };
              function n(o = "utf-8", l = { fatal: !1 }) {
                if (o !== "utf-8")
                  throw new RangeError(`Failed to construct 'TextDecoder': The encoding label provided ('${o}') is invalid.`);
                if (l.fatal)
                  throw new Error("Failed to construct 'TextDecoder': the 'fatal' option is unsupported.");
              }
              Object.defineProperty(n.prototype, "encoding", {
                value: "utf-8"
              }), Object.defineProperty(n.prototype, "fatal", { value: !1 }), Object.defineProperty(n.prototype, "ignoreBOM", {
                value: !1
              }), n.prototype.decode = function(o, l = { stream: !1 }) {
                if (l.stream)
                  throw new Error("Failed to decode: the 'stream' option is unsupported.");
                const u = new Uint8Array(o);
                let f = 0;
                const h = u.length, p = [];
                for (; f < h; ) {
                  const v = u[f++];
                  if (v === 0)
                    break;
                  if (!(v & 128))
                    p.push(v);
                  else if ((v & 224) === 192) {
                    const g = u[f++] & 63;
                    p.push((v & 31) << 6 | g);
                  } else if ((v & 240) === 224) {
                    const g = u[f++] & 63, w = u[f++] & 63;
                    p.push((v & 31) << 12 | g << 6 | w);
                  } else if ((v & 248) === 240) {
                    const g = u[f++] & 63, w = u[f++] & 63, E = u[f++] & 63;
                    let T = (v & 7) << 18 | g << 12 | w << 6 | E;
                    T > 65535 && (T -= 65536, p.push(T >>> 10 & 1023 | 55296), T = 56320 | T & 1023), p.push(T);
                  }
                }
                return String.fromCharCode.apply(null, p);
              }, t.TextEncoder = e, t.TextDecoder = n;
            })(typeof window < "u" ? window : typeof self < "u" ? self : this);
          }
        ),
        /***/
        "./node_modules/iobuffer/lib-esm/text.browser.js": (
          /*!*******************************************************!*\
            !*** ./node_modules/iobuffer/lib-esm/text.browser.js ***!
            \*******************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              decode: () => (
                /* binding */
                o
              ),
              /* harmony export */
              encode: () => (
                /* binding */
                u
              )
              /* harmony export */
            }), n(
              /*! ./text-encoding-polyfill */
              "./node_modules/iobuffer/lib-esm/text-encoding-polyfill.js"
            );
            function o(f, h = "utf8") {
              return new TextDecoder(h).decode(f);
            }
            const l = new TextEncoder();
            function u(f) {
              return l.encode(f);
            }
          }
        ),
        /***/
        "./node_modules/netcdfjs/lib-esm/data.js": (
          /*!***********************************************!*\
            !*** ./node_modules/netcdfjs/lib-esm/data.js ***!
            \***********************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              nonRecord: () => (
                /* binding */
                l
              ),
              /* harmony export */
              record: () => (
                /* binding */
                u
              )
              /* harmony export */
            });
            var o = n(
              /*! ./types */
              "./node_modules/netcdfjs/lib-esm/types.js"
            );
            function l(f, h) {
              const p = (0, o.str2num)(h.type), v = h.size / (0, o.num2bytes)(p), g = new Array(v);
              for (let w = 0; w < v; w++)
                g[w] = (0, o.readType)(f, p, 1);
              return g;
            }
            function u(f, h, p) {
              const v = (0, o.str2num)(h.type), g = h.size ? h.size / (0, o.num2bytes)(v) : 1, w = p.length, E = new Array(w), T = p.recordStep;
              if (T)
                for (let R = 0; R < w; R++) {
                  const _ = f.offset;
                  E[R] = (0, o.readType)(f, v, g), f.seek(_ + T);
                }
              else
                throw new Error("recordDimension.recordStep is undefined");
              return E;
            }
          }
        ),
        /***/
        "./node_modules/netcdfjs/lib-esm/header.js": (
          /*!*************************************************!*\
            !*** ./node_modules/netcdfjs/lib-esm/header.js ***!
            \*************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              header: () => (
                /* binding */
                g
              )
              /* harmony export */
            });
            var o = n(
              /*! ./types */
              "./node_modules/netcdfjs/lib-esm/types.js"
            ), l = n(
              /*! ./utils */
              "./node_modules/netcdfjs/lib-esm/utils.js"
            );
            const u = 0, f = 10, h = 11, p = 12, v = 0;
            function g(R, _) {
              const b = { version: _ }, M = {
                length: R.readUint32()
              }, A = w(R);
              Array.isArray(A) || (M.id = A.recordId, M.name = A.recordName, b.dimensions = A.dimensions), b.globalAttributes = E(R);
              const $ = T(R, M == null ? void 0 : M.id, _);
              return Array.isArray($) || (b.variables = $.variables, M.recordStep = $.recordStep), b.recordDimension = M, b;
            }
            function w(R) {
              const _ = {};
              let b, M;
              const A = R.readUint32();
              let $;
              if (A === u)
                return (0, l.notNetcdf)(R.readUint32() !== u, "wrong empty tag for list of dimensions"), [];
              {
                (0, l.notNetcdf)(A !== f, "wrong tag for list of dimensions");
                const S = R.readUint32();
                $ = new Array(S);
                for (let C = 0; C < S; C++) {
                  const D = (0, l.readName)(R), O = R.readUint32();
                  O === v && (b = C, M = D), $[C] = {
                    name: D,
                    size: O
                  };
                }
              }
              return b !== void 0 && (_.recordId = b), M !== void 0 && (_.recordName = M), _.dimensions = $, _;
            }
            function E(R) {
              const _ = R.readUint32();
              let b;
              if (_ === u)
                return (0, l.notNetcdf)(R.readUint32() !== u, "wrong empty tag for list of attributes"), [];
              {
                (0, l.notNetcdf)(_ !== p, "wrong tag for list of attributes");
                const M = R.readUint32();
                b = new Array(M);
                for (let A = 0; A < M; A++) {
                  const $ = (0, l.readName)(R), S = R.readUint32();
                  (0, l.notNetcdf)(S < 1 || S > 6, `non valid type ${S}`);
                  const C = R.readUint32(), D = (0, o.readType)(R, S, C);
                  (0, l.padding)(R), b[A] = {
                    name: $,
                    type: (0, o.num2str)(S),
                    value: D
                  };
                }
              }
              return b;
            }
            function T(R, _, b) {
              const M = R.readUint32();
              let A = 0, $;
              if (M === u)
                return (0, l.notNetcdf)(R.readUint32() !== u, "wrong empty tag for list of variables"), [];
              {
                (0, l.notNetcdf)(M !== h, "wrong tag for list of variables");
                const S = R.readUint32();
                $ = new Array(S);
                for (let C = 0; C < S; C++) {
                  const D = (0, l.readName)(R), O = R.readUint32(), N = new Array(O);
                  for (let F = 0; F < O; F++)
                    N[F] = R.readUint32();
                  const j = E(R), L = R.readUint32();
                  (0, l.notNetcdf)(L < 1 && L > 6, `non valid type ${L}`);
                  const z = R.readUint32();
                  let G = R.readUint32();
                  b === 2 && ((0, l.notNetcdf)(G > 0, "offsets larger than 4GB not supported"), G = R.readUint32());
                  let B = !1;
                  typeof _ < "u" && N[0] === _ && (A += z, B = !0), $[C] = {
                    name: D,
                    dimensions: N,
                    attributes: j,
                    type: (0, o.num2str)(L),
                    size: z,
                    offset: G,
                    record: B
                  };
                }
              }
              return {
                variables: $,
                recordStep: A
              };
            }
          }
        ),
        /***/
        "./node_modules/netcdfjs/lib-esm/index.js": (
          /*!************************************************!*\
            !*** ./node_modules/netcdfjs/lib-esm/index.js ***!
            \************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              NetCDFReader: () => (
                /* reexport safe */
                o.NetCDFReader
              )
              /* harmony export */
            });
            var o = n(
              /*! ./parser */
              "./node_modules/netcdfjs/lib-esm/parser.js"
            );
          }
        ),
        /***/
        "./node_modules/netcdfjs/lib-esm/parser.js": (
          /*!*************************************************!*\
            !*** ./node_modules/netcdfjs/lib-esm/parser.js ***!
            \*************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              NetCDFReader: () => (
                /* binding */
                p
              )
              /* harmony export */
            });
            var o = n(
              /*! iobuffer */
              "./node_modules/iobuffer/lib-esm/IOBuffer.js"
            ), l = n(
              /*! ./data */
              "./node_modules/netcdfjs/lib-esm/data.js"
            ), u = n(
              /*! ./header */
              "./node_modules/netcdfjs/lib-esm/header.js"
            ), f = n(
              /*! ./toString */
              "./node_modules/netcdfjs/lib-esm/toString.js"
            ), h = n(
              /*! ./utils */
              "./node_modules/netcdfjs/lib-esm/utils.js"
            );
            class p {
              constructor(g) {
                this.toString = f.toString;
                const w = new o.IOBuffer(g);
                w.setBigEndian(), (0, h.notNetcdf)(w.readChars(3) !== "CDF", "should start with CDF");
                const E = w.readByte();
                (0, h.notNetcdf)(E > 2, "unknown version"), this.header = (0, u.header)(w, E), this.buffer = w;
              }
              /**
               * @return - Version for the NetCDF format
               */
              get version() {
                return this.header.version === 1 ? "classic format" : "64-bit offset format";
              }
              /**
               * @return {object} - Metadata for the record dimension
               *  * `length`: Number of elements in the record dimension
               *  * `id`: Id number in the list of dimensions for the record dimension
               *  * `name`: String with the name of the record dimension
               *  * `recordStep`: Number with the record variables step size
               */
              get recordDimension() {
                return this.header.recordDimension;
              }
              /**
               * @return - Array - List of dimensions with:
               *  * `name`: String with the name of the dimension
               *  * `size`: Number with the size of the dimension
               */
              get dimensions() {
                return this.header.dimensions;
              }
              /**
               * @return - Array - List of global attributes with:
               *  * `name`: String with the name of the attribute
               *  * `type`: String with the type of the attribute
               *  * `value`: A number or string with the value of the attribute
               */
              get globalAttributes() {
                return this.header.globalAttributes;
              }
              /**
               * Returns the value of an attribute
               * @param - AttributeName
               * @return - Value of the attributeName or null
               */
              getAttribute(g) {
                const w = this.globalAttributes.find((E) => E.name === g);
                return w ? w.value : null;
              }
              /**
               * Returns the value of a variable as a string
               * @param - variableName
               * @return - Value of the variable as a string or null
               */
              getDataVariableAsString(g) {
                const w = this.getDataVariable(g);
                return w ? w.join("") : null;
              }
              get variables() {
                return this.header.variables;
              }
              /**
               * Retrieves the data for a given variable
               * @param variableName - Name of the variable to search or variable object
               * @return The variable values
               */
              getDataVariable(g) {
                let w;
                if (typeof g == "string" ? w = this.header.variables.find((E) => E.name === g) : w = g, w === void 0)
                  throw new Error("Not a valid NetCDF v3.x file: variable not found");
                return this.buffer.seek(w.offset), w.record ? (0, l.record)(this.buffer, w, this.header.recordDimension) : (0, l.nonRecord)(this.buffer, w);
              }
              /**
               * Check if a dataVariable exists
               * @param variableName - Name of the variable to find
               * @return boolean
               */
              dataVariableExists(g) {
                return this.header.variables.find((w) => w.name === g) !== void 0;
              }
              /**
               * Check if an attribute exists
               * @param attributeName - Name of the attribute to find
               * @return boolean
               */
              attributeExists(g) {
                return this.globalAttributes.find((w) => w.name === g) !== void 0;
              }
            }
          }
        ),
        /***/
        "./node_modules/netcdfjs/lib-esm/toString.js": (
          /*!***************************************************!*\
            !*** ./node_modules/netcdfjs/lib-esm/toString.js ***!
            \***************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              toString: () => (
                /* binding */
                o
              )
              /* harmony export */
            });
            function o() {
              const l = [];
              l.push("DIMENSIONS");
              for (const f of this.dimensions)
                l.push(`  ${f.name.padEnd(30)} = size: ${f.size}`);
              l.push(""), l.push("GLOBAL ATTRIBUTES");
              for (const f of this.globalAttributes)
                l.push(`  ${f.name.padEnd(30)} = ${f.value}`);
              const u = JSON.parse(JSON.stringify(this.variables));
              l.push(""), l.push("VARIABLES:");
              for (const f of u) {
                f.value = this.getDataVariable(f);
                let h = JSON.stringify(f.value);
                h.length > 50 && (h = h.substring(0, 50)), isNaN(f.value.length) || (h += ` (length: ${f.value.length})`), l.push(`  ${f.name.padEnd(30)} = ${h}`);
              }
              return l.join(`
`);
            }
          }
        ),
        /***/
        "./node_modules/netcdfjs/lib-esm/types.js": (
          /*!************************************************!*\
            !*** ./node_modules/netcdfjs/lib-esm/types.js ***!
            \************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              num2bytes: () => (
                /* binding */
                u
              ),
              /* harmony export */
              num2str: () => (
                /* binding */
                l
              ),
              /* harmony export */
              readType: () => (
                /* binding */
                p
              ),
              /* harmony export */
              str2num: () => (
                /* binding */
                f
              )
              /* harmony export */
            });
            const o = {
              BYTE: 1,
              CHAR: 2,
              SHORT: 3,
              INT: 4,
              FLOAT: 5,
              DOUBLE: 6
            };
            function l(g) {
              switch (Number(g)) {
                case o.BYTE:
                  return "byte";
                case o.CHAR:
                  return "char";
                case o.SHORT:
                  return "short";
                case o.INT:
                  return "int";
                case o.FLOAT:
                  return "float";
                case o.DOUBLE:
                  return "double";
                default:
                  return "undefined";
              }
            }
            function u(g) {
              switch (Number(g)) {
                case o.BYTE:
                  return 1;
                case o.CHAR:
                  return 1;
                case o.SHORT:
                  return 2;
                case o.INT:
                  return 4;
                case o.FLOAT:
                  return 4;
                case o.DOUBLE:
                  return 8;
                default:
                  return -1;
              }
            }
            function f(g) {
              switch (String(g)) {
                case "byte":
                  return o.BYTE;
                case "char":
                  return o.CHAR;
                case "short":
                  return o.SHORT;
                case "int":
                  return o.INT;
                case "float":
                  return o.FLOAT;
                case "double":
                  return o.DOUBLE;
                default:
                  return -1;
              }
            }
            function h(g, w) {
              if (g !== 1) {
                const E = new Array(g);
                for (let T = 0; T < g; T++)
                  E[T] = w();
                return E;
              } else
                return w();
            }
            function p(g, w, E) {
              switch (w) {
                case o.BYTE:
                  return Array.from(g.readBytes(E));
                case o.CHAR:
                  return v(g.readChars(E));
                case o.SHORT:
                  return h(E, g.readInt16.bind(g));
                case o.INT:
                  return h(E, g.readInt32.bind(g));
                case o.FLOAT:
                  return h(E, g.readFloat32.bind(g));
                case o.DOUBLE:
                  return h(E, g.readFloat64.bind(g));
                default:
                  throw new Error(`non valid type ${w}`);
              }
            }
            function v(g) {
              return g.charCodeAt(g.length - 1) === 0 ? g.substring(0, g.length - 1) : g;
            }
          }
        ),
        /***/
        "./node_modules/netcdfjs/lib-esm/utils.js": (
          /*!************************************************!*\
            !*** ./node_modules/netcdfjs/lib-esm/utils.js ***!
            \************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              notNetcdf: () => (
                /* binding */
                o
              ),
              /* harmony export */
              padding: () => (
                /* binding */
                l
              ),
              /* harmony export */
              readName: () => (
                /* binding */
                u
              )
              /* harmony export */
            });
            function o(f, h) {
              if (f)
                throw new TypeError(`Not a valid NetCDF v3.x file: ${h}`);
            }
            function l(f) {
              f.offset % 4 !== 0 && f.skip(4 - f.offset % 4);
            }
            function u(f) {
              const h = f.readUint32(), p = f.readChars(h);
              return l(f), p;
            }
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/basic/basic.frag": (
          /*!************************************************!*\
            !*** ./src/WebGL/shaders/lib/basic/basic.frag ***!
            \************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              default: () => o
              /* harmony export */
            });
            const o = `uniform mat4 viewMatrix;
uniform float opacity;
uniform vec3 fogColor;
uniform float fogNear;
uniform float fogFar;
varying vec3 vColor;
//DEFINEFRAGCOLOR
void main() {
    gl_FragColor = vec4( vColor, opacity );
    float depth = gl_FragCoord.z / gl_FragCoord.w;
    float fogFactor = smoothstep( fogNear, fogFar, depth );
    gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );
}`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/basic/basic.vert": (
          /*!************************************************!*\
            !*** ./src/WebGL/shaders/lib/basic/basic.vert ***!
            \************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              default: () => o
              /* harmony export */
            });
            const o = `uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;

attribute vec3 position;
attribute vec3 color;

varying vec3 vColor;

void main() {

    vColor = color;
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
    gl_Position = projectionMatrix * mvPosition;

}`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/instanced/instanced.frag": (
          /*!********************************************************!*\
            !*** ./src/WebGL/shaders/lib/instanced/instanced.frag ***!
            \********************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              default: () => o
              /* harmony export */
            });
            const o = `uniform mat4 viewMatrix;
uniform float opacity;

uniform vec3 fogColor;
uniform float fogNear;
uniform float fogFar;

varying vec3 vLightFront;
varying vec3 vColor;
//DEFINEFRAGCOLOR

void main() {

    gl_FragColor = vec4( vec3 ( 1.0 ), opacity );

    #ifndef WIREFRAME
    gl_FragColor.xyz *= vLightFront;
    #endif

    gl_FragColor = gl_FragColor * vec4( vColor, opacity );
    float depth = gl_FragCoord.z / gl_FragCoord.w;

    float fogFactor = smoothstep( fogNear, fogFar, depth );

    gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );

}


`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/instanced/instanced.vert": (
          /*!********************************************************!*\
            !*** ./src/WebGL/shaders/lib/instanced/instanced.vert ***!
            \********************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              default: () => o
              /* harmony export */
            });
            const o = `

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 directionalLightColor[ 1 ];
uniform vec3 directionalLightDirection[ 1 ];

attribute vec3 offset;
attribute vec3 position;
attribute vec3 normal;
attribute vec3 color;
attribute float radius;

varying vec3 vColor;
varying vec3 vLightFront;

void main() {

    vColor = color;

    vec3 objectNormal = normal;
    vec3 transformedNormal = normalMatrix * objectNormal;
    vec4 mvPosition = modelViewMatrix * vec4( position * radius + offset, 1.0 );

    vLightFront = vec3( 0.0 );

    transformedNormal = normalize( transformedNormal );

    vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ 0 ], 0.0 );
    vec3 dirVector = normalize( lDirection.xyz );
    float dotProduct = dot( transformedNormal, dirVector );
    vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );

    vLightFront += directionalLightColor[ 0 ] * directionalLightWeighting;

    gl_Position = projectionMatrix * mvPosition;
}

`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/lambert/lambert.frag": (
          /*!****************************************************!*\
            !*** ./src/WebGL/shaders/lib/lambert/lambert.frag ***!
            \****************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              default: () => o
              /* harmony export */
            });
            const o = `uniform mat4 viewMatrix;
uniform float opacity;

uniform vec3 fogColor;
uniform float fogNear;
uniform float fogFar;

varying vec3 vLightFront;
varying vec3 vColor;
//DEFINEFRAGCOLOR

void main() {

    gl_FragColor = vec4( vec3 ( 1.0 ), opacity );

    #ifndef WIREFRAME
    gl_FragColor.xyz *= vLightFront;
    #endif

    gl_FragColor = gl_FragColor * vec4( vColor, opacity );
    float depth = gl_FragCoord.z / gl_FragCoord.w;

    float fogFactor = smoothstep( fogNear, fogFar, depth );

    gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );

}`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/lambert/lambert.vert": (
          /*!****************************************************!*\
            !*** ./src/WebGL/shaders/lib/lambert/lambert.vert ***!
            \****************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              default: () => o
              /* harmony export */
            });
            const o = `
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 directionalLightColor[ 1 ];
uniform vec3 directionalLightDirection[ 1 ];

attribute vec3 position;
attribute vec3 normal;
attribute vec3 color;

varying vec3 vColor;
varying vec3 vLightFront;

void main() {

    vColor = color;

    vec3 objectNormal = normal;
    vec3 transformedNormal = normalMatrix * objectNormal;
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

    vLightFront = vec3( 0.0 );

    transformedNormal = normalize( transformedNormal );

    vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ 0 ], 0.0 );
    vec3 dirVector = normalize( lDirection.xyz );
    float dotProduct = dot( transformedNormal, dirVector );
    vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );

    vLightFront += directionalLightColor[ 0 ] * directionalLightWeighting;

    gl_Position = projectionMatrix * mvPosition;
}`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/lambertdouble/lambertdouble.frag": (
          /*!****************************************************************!*\
            !*** ./src/WebGL/shaders/lib/lambertdouble/lambertdouble.frag ***!
            \****************************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              default: () => o
              /* harmony export */
            });
            const o = `

uniform mat4 viewMatrix;
uniform float opacity;

uniform vec3 fogColor;
uniform float fogNear;
uniform float fogFar;

varying vec3 vLightFront;
varying vec3 vLightBack;

varying vec3 vColor;
//DEFINEFRAGCOLOR

void main() {

    gl_FragColor = vec4( vec3 ( 1.0 ), opacity );

    #ifndef WIREFRAME
    if ( gl_FrontFacing )
       gl_FragColor.xyz *= vLightFront;
    else
       gl_FragColor.xyz *= vLightBack;
    #endif

    gl_FragColor = gl_FragColor * vec4( vColor, opacity );
    float depth = gl_FragCoord.z / gl_FragCoord.w;

    float fogFactor = smoothstep( fogNear, fogFar, depth );

    gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );

}


`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/lambertdouble/lambertdouble.vert": (
          /*!****************************************************************!*\
            !*** ./src/WebGL/shaders/lib/lambertdouble/lambertdouble.vert ***!
            \****************************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              default: () => o
              /* harmony export */
            });
            const o = `

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 directionalLightColor[ 1 ];
uniform vec3 directionalLightDirection[ 1 ];

attribute vec3 position;
attribute vec3 normal;
attribute vec3 color;

varying vec3 vColor;
varying vec3 vLightFront;
varying vec3 vLightBack;

void main() {

    vColor = color;

    vec3 objectNormal = normal;
    vec3 transformedNormal = normalMatrix * objectNormal;
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

    vLightFront = vec3( 0.0 );
    vLightBack = vec3( 0.0 );

    transformedNormal = normalize( transformedNormal );

    vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ 0 ], 0.0 );
    vec3 dirVector = normalize( lDirection.xyz );
    float dotProduct = dot( transformedNormal, dirVector );
    vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );
    vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );

    vLightFront += directionalLightColor[ 0 ] * directionalLightWeighting;
    vLightBack += directionalLightColor[ 0 ] * directionalLightWeightingBack;

    gl_Position = projectionMatrix * mvPosition;
}

`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/outline/outline.frag": (
          /*!****************************************************!*\
            !*** ./src/WebGL/shaders/lib/outline/outline.frag ***!
            \****************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              default: () => o
              /* harmony export */
            });
            const o = `

uniform float opacity;
uniform vec3 outlineColor;
uniform vec3 fogColor;
uniform float fogNear;
uniform float fogFar;
//DEFINEFRAGCOLOR

void main() {
    gl_FragColor = vec4( outlineColor, 1 );
}


`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/outline/outline.vert": (
          /*!****************************************************!*\
            !*** ./src/WebGL/shaders/lib/outline/outline.vert ***!
            \****************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              default: () => o
              /* harmony export */
            });
            const o = `

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform float outlineWidth;
uniform float outlinePushback;

attribute vec3 position;
attribute vec3 normal;
attribute vec3 color;

void main() {

    vec4 norm = modelViewMatrix*vec4(normalize(normal),0.0);
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
    mvPosition.xy += norm.xy*outlineWidth;
    gl_Position = projectionMatrix * mvPosition;
    mvPosition.z -= outlinePushback; //go backwards in model space
    vec4 pushpos = projectionMatrix*mvPosition; //project to get z in projection space, I'm probably missing some simple math to do the same thing..
    gl_Position.z = gl_Position.w*pushpos.z/pushpos.w;
}

`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/screen/screen.frag": (
          /*!**************************************************!*\
            !*** ./src/WebGL/shaders/lib/screen/screen.frag ***!
            \**************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              default: () => o
              /* harmony export */
            });
            const o = `uniform sampler2D colormap;
varying highp vec2 vTexCoords;
uniform vec2 dimensions;
//DEFINEFRAGCOLOR
void main (void) {
   gl_FragColor = texture2D(colormap, vTexCoords);
}
        `;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/screen/screen.vert": (
          /*!**************************************************!*\
            !*** ./src/WebGL/shaders/lib/screen/screen.vert ***!
            \**************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              default: () => o
              /* harmony export */
            });
            const o = `attribute vec2 vertexPosition;
varying highp vec2 vTexCoords;
const vec2 scale = vec2(0.5, 0.5);

void main() {
   vTexCoords  = vertexPosition * scale + scale; // scale vertex attribute to [0,1] range
   gl_Position = vec4(vertexPosition, 0.0, 1.0);
}
        `;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/screenaa/screenaa.frag": (
          /*!******************************************************!*\
            !*** ./src/WebGL/shaders/lib/screenaa/screenaa.frag ***!
            \******************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              default: () => o
              /* harmony export */
            });
            const o = `uniform sampler2D colormap;
varying highp vec2 vTexCoords;
uniform vec2 dimensions;

// Basic FXAA implementation based on the code on geeks3d.com 
#define FXAA_REDUCE_MIN (1.0/ 128.0)
#define FXAA_REDUCE_MUL (1.0 / 8.0)
#define FXAA_SPAN_MAX 8.0

vec4 applyFXAA(vec2 fragCoord, sampler2D tex)
{
    vec4 color;
    vec2 inverseVP = vec2(1.0 / dimensions.x, 1.0 / dimensions.y);
    vec3 rgbNW = texture2D(tex, fragCoord + vec2(-1.0, -1.0) * inverseVP).xyz;
    vec3 rgbNE = texture2D(tex, fragCoord + vec2(1.0, -1.0) * inverseVP).xyz;
    vec3 rgbSW = texture2D(tex, fragCoord + vec2(-1.0, 1.0) * inverseVP).xyz;
    vec3 rgbSE = texture2D(tex, fragCoord + vec2(1.0, 1.0) * inverseVP).xyz;
    vec3 rgbM  = texture2D(tex, fragCoord  * inverseVP).xyz;
    vec3 luma = vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM,  luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

    vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *
                        (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);

    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),
            max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
            dir * rcpDirMin)) * inverseVP;

    vec3 rgbA = 0.5 * (
        texture2D(tex, fragCoord + dir * (1.0 / 3.0 - 0.5)).xyz +
        texture2D(tex, fragCoord  + dir * (2.0 / 3.0 - 0.5)).xyz);
    vec3 rgbB = rgbA * 0.5 + 0.25 * (
        texture2D(tex, fragCoord  + dir * -0.5).xyz +
        texture2D(tex, fragCoord  + dir * 0.5).xyz);

    float lumaB = dot(rgbB, luma);
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
        color = vec4(rgbA, 1.0);
    else
        color = vec4(rgbB, 1.0);
    return color;
}
//DEFINEFRAGCOLOR
void main (void) {
   gl_FragColor = applyFXAA(vTexCoords, colormap);
}
        `;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/screenaa/screenaa.vert": (
          /*!******************************************************!*\
            !*** ./src/WebGL/shaders/lib/screenaa/screenaa.vert ***!
            \******************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              default: () => o
              /* harmony export */
            });
            const o = `attribute vec2 vertexPosition;
varying highp vec2 vTexCoords;
const vec2 scale = vec2(0.5, 0.5);

void main() {
   vTexCoords  = vertexPosition * scale + scale; // scale vertex attribute to [0,1] range
   gl_Position = vec4(vertexPosition, 0.0, 1.0);
}
        `;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/sphereimposter/sphereimposter.frag": (
          /*!******************************************************************!*\
            !*** ./src/WebGL/shaders/lib/sphereimposter/sphereimposter.frag ***!
            \******************************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              default: () => o
              /* harmony export */
            });
            const o = `
uniform mat4 viewMatrix;
uniform float opacity;
uniform mat4 projectionMatrix;

uniform vec3 fogColor;
uniform float fogNear;
uniform float fogFar;
uniform float uDepth;
uniform vec3 directionalLightColor[ 1 ];

varying vec3 vColor;
varying vec2 mapping;
varying float rval;
varying vec3 vLight;
varying vec3 center;

//DEFINEFRAGCOLOR

void main() {
    float lensqr = dot(mapping,mapping);
    float rsqr = rval*rval;
    if(lensqr > rsqr)
       discard;
    float z = sqrt(rsqr-lensqr);
    vec3 cameraPos = center+ vec3(mapping.x,mapping.y,z);
    vec4 clipPos = projectionMatrix * vec4(cameraPos, 1.0);
    float ndcDepth = clipPos.z / clipPos.w;
    gl_FragDepthEXT = ((gl_DepthRange.diff * ndcDepth) + gl_DepthRange.near + gl_DepthRange.far) / 2.0;
    vec3 norm = normalize(vec3(mapping.x,mapping.y,z));
    float dotProduct = dot( norm, vLight );
    vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );
    vec3 vLight = directionalLightColor[ 0 ] * directionalLightWeighting;
    gl_FragColor = vec4(vLight*vColor, opacity*opacity );
    float fogFactor = smoothstep( fogNear, fogFar, gl_FragDepthEXT/gl_FragCoord.w );
    gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );


}

`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/sphereimposter/sphereimposter.vert": (
          /*!******************************************************************!*\
            !*** ./src/WebGL/shaders/lib/sphereimposter/sphereimposter.vert ***!
            \******************************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              default: () => o
              /* harmony export */
            });
            const o = `uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 directionalLightColor[ 1 ];
uniform vec3 directionalLightDirection[ 1 ];

attribute vec3 position;
attribute vec3 normal;
attribute vec3 color;

varying vec2 mapping;
varying vec3 vColor;
varying float rval;
varying vec3 vLight;
varying vec3 center;

void main() {

    vColor = color;
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
    center = mvPosition.xyz;
    vec4 projPosition = projectionMatrix * mvPosition;
    vec4 adjust = projectionMatrix* vec4(normal,0.0); adjust.z = 0.0; adjust.w = 0.0;
    vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ 0 ], 0.0 );
    vLight = normalize( lDirection.xyz );
    mapping = normal.xy;
    rval = abs(normal.x);
    gl_Position = projPosition+adjust;

}
`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/sphereimposteroutline/sphereimposteroutline.frag": (
          /*!********************************************************************************!*\
            !*** ./src/WebGL/shaders/lib/sphereimposteroutline/sphereimposteroutline.frag ***!
            \********************************************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              default: () => o
              /* harmony export */
            });
            const o = `

uniform float opacity;
uniform vec3 outlineColor;
uniform vec3 fogColor;
uniform float fogNear;
uniform float fogFar;
uniform mat4 projectionMatrix;
varying vec2 mapping;
varying float rval;
varying vec3 center;

uniform float outlinePushback;

//DEFINEFRAGCOLOR

void main() {
    float lensqr = dot(mapping,mapping);
    float rsqr = rval*rval;
    if(lensqr > rsqr)
       discard;
    float z = sqrt(rsqr-lensqr);
    vec3 cameraPos = center+ vec3(mapping.x,mapping.y,z-outlinePushback);
    vec4 clipPos = projectionMatrix * vec4(cameraPos, 1.0);
    float ndcDepth = clipPos.z / clipPos.w;
    gl_FragDepthEXT = ((gl_DepthRange.diff * ndcDepth) + gl_DepthRange.near + gl_DepthRange.far) / 2.0;
    gl_FragColor = vec4(outlineColor, 1 );
}


`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/sphereimposteroutline/sphereimposteroutline.vert": (
          /*!********************************************************************************!*\
            !*** ./src/WebGL/shaders/lib/sphereimposteroutline/sphereimposteroutline.vert ***!
            \********************************************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              default: () => o
              /* harmony export */
            });
            const o = `

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform float outlineWidth;
uniform float outlinePushback;

attribute vec3 position;
attribute vec3 normal;
attribute vec3 color;

varying vec2 mapping;
varying float rval;
varying vec3 center;

void main() {

    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
    center = mvPosition.xyz;
    vec4 projPosition = projectionMatrix * mvPosition;
    vec2 norm = normal.xy + vec2(sign(normal.x)*outlineWidth,sign(normal.y)*outlineWidth);
    vec4 adjust = projectionMatrix* vec4(norm,normal.z,0.0); adjust.z = 0.0; adjust.w = 0.0;
    mapping = norm.xy;
    rval = abs(norm.x);
    gl_Position = projPosition+adjust;
}

`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/sprite/sprite.frag": (
          /*!**************************************************!*\
            !*** ./src/WebGL/shaders/lib/sprite/sprite.frag ***!
            \**************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              default: () => o
              /* harmony export */
            });
            const o = `

uniform vec3 color;
uniform sampler2D map;
uniform float opacity;

uniform int fogType;
uniform vec3 fogColor;
uniform float fogDensity;
uniform float fogNear;
uniform float fogFar;
uniform float alphaTest;

varying vec2 vUV;
//DEFINEFRAGCOLOR

void main() {

    vec4 texture = texture2D(map, vUV);

    if (texture.a < alphaTest) discard;

    gl_FragColor = vec4(color * texture.xyz, texture.a * opacity);

    if (fogType > 0) {

        float depth = gl_FragCoord.z / gl_FragCoord.w;
        float fogFactor = 0.0;

        if (fogType == 1) {
            fogFactor = smoothstep(fogNear, fogFar, depth);
        }

        else {
            const float LOG2 = 1.442695;
            float fogFactor = exp2(- fogDensity * fogDensity * depth * depth * LOG2);
            fogFactor = 1.0 - clamp(fogFactor, 0.0, 1.0);
        }

        gl_FragColor = mix(gl_FragColor, vec4(fogColor, gl_FragColor.w), fogFactor);

    }
}

`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/sprite/sprite.vert": (
          /*!**************************************************!*\
            !*** ./src/WebGL/shaders/lib/sprite/sprite.vert ***!
            \**************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              default: () => o
              /* harmony export */
            });
            const o = `

uniform int useScreenCoordinates;
uniform vec3 screenPosition;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform float rotation;
uniform vec2 scale;
uniform vec2 alignment;
uniform vec2 uvOffset;
uniform vec2 uvScale;

attribute vec2 position;
attribute vec2 uv;

varying vec2 vUV;

void main() {

    vUV = uvOffset + uv * uvScale;

    vec2 alignedPosition = position + alignment;

    vec2 rotatedPosition;
    rotatedPosition.x = ( cos(rotation) * alignedPosition.x - sin(rotation) * alignedPosition.y ) * scale.x;
    rotatedPosition.y = ( sin(rotation) * alignedPosition.x + cos(rotation) * alignedPosition.y ) * scale.y;

    vec4 finalPosition;

    if(useScreenCoordinates != 0) {
        finalPosition = vec4(screenPosition.xy + rotatedPosition, screenPosition.z, 1.0);
    }

    else {
        finalPosition = projectionMatrix * modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0); finalPosition /= finalPosition.w;
        finalPosition.xy += rotatedPosition; 
    }

    gl_Position = finalPosition;

}

`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/stickimposter/stickimposter.partial.frag": (
          /*!************************************************************************!*\
            !*** ./src/WebGL/shaders/lib/stickimposter/stickimposter.partial.frag ***!
            \************************************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              default: () => o
              /* harmony export */
            });
            const o = `    float dotProduct = dot( norm, vLight );
    vec3 light = vec3( max( dotProduct, 0.0 ) );
    gl_FragColor = vec4(light*color, opacity*opacity );
    float fogFactor = smoothstep( fogNear, fogFar, depth );
    gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );
}`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/stickimposter/stickimposter.vert": (
          /*!****************************************************************!*\
            !*** ./src/WebGL/shaders/lib/stickimposter/stickimposter.vert ***!
            \****************************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              default: () => o
              /* harmony export */
            });
            const o = `

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 directionalLightColor[ 1 ];
uniform vec3 directionalLightDirection[ 1 ];

attribute vec3 position;
attribute vec3 normal;
attribute vec3 color;
attribute float radius;

varying vec3 vColor;
varying vec3 vLight;
varying vec3 cposition;
varying vec3 p1;
varying vec3 p2;
varying float r;

void main() {

    vColor = color; vColor.z = abs(vColor.z); //z indicates which vertex and so would vary
    r = abs(radius);
    vec4 to = modelViewMatrix*vec4(normal, 1.0); //normal is other point of cylinder
    vec4 pt = modelViewMatrix*vec4(position, 1.0);
    vec4 mvPosition = pt;
    p1 = pt.xyz; p2 = to.xyz;
    vec3 norm = to.xyz-pt.xyz;
    float mult = 1.1; //slop to account for perspective of sphere
    if(length(p1) > length(p2)) { //billboard at level of closest point
       mvPosition = to;
    }
    vec3 n = normalize(mvPosition.xyz);
//intersect with the plane defined by the camera looking at the billboard point
    if(color.z >= 0.0) { //p1
       if(projectionMatrix[3][3] == 0.0) { //perspective
         vec3 pnorm = normalize(p1);
         float t = dot(mvPosition.xyz-p1,n)/dot(pnorm,n);
         mvPosition.xyz = p1+t*pnorm; 
       } else { //orthographic
         mvPosition.xyz = p1;
       }
    } else {
      if(projectionMatrix[3][3] == 0.0) { //perspective
         vec3 pnorm = normalize(p2);
         float t = dot(mvPosition.xyz-p2,n)/dot(pnorm,n);
         mvPosition.xyz = p2+t*pnorm;
       } else { //orthographic
         mvPosition.xyz = p2;
       } 
       mult *= -1.0;
    }
    vec3 cr = normalize(cross(mvPosition.xyz,norm))*radius;
    vec3 doublecr = normalize(cross(mvPosition.xyz,cr))*radius;
    mvPosition.xyz +=  mult*(cr + doublecr).xyz;
    cposition = mvPosition.xyz;
    gl_Position = projectionMatrix * mvPosition;
    vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ 0 ], 0.0 );
    vLight = normalize( lDirection.xyz )*directionalLightColor[0]; //not really sure this is right, but color is always white so..
}

`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/stickimposteroutline/stickimposteroutline.vert": (
          /*!******************************************************************************!*\
            !*** ./src/WebGL/shaders/lib/stickimposteroutline/stickimposteroutline.vert ***!
            \******************************************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              default: () => o
              /* harmony export */
            });
            const o = `

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 directionalLightColor[ 1 ];
uniform vec3 directionalLightDirection[ 1 ];
uniform vec3 outlineColor;
uniform float outlineWidth;
uniform float outlinePushback;


attribute vec3 position;
attribute vec3 normal;
attribute vec3 color;
attribute float radius;

varying vec3 vColor;
varying vec3 vLight;
varying vec3 cposition;
varying vec3 p1;
varying vec3 p2;
varying float r;

void main() {

    vColor = outlineColor;
    float rad = radius+sign(radius)*outlineWidth;
    r = abs(rad);
    vec4 to = modelViewMatrix*vec4(normal, 1.0); //normal is other point of cylinder
    vec4 pt = modelViewMatrix*vec4(position, 1.0);
//pushback
    to.xyz += normalize(to.xyz)*outlinePushback;
    pt.xyz += normalize(pt.xyz)*outlinePushback;

    vec4 mvPosition = pt;
    p1 = pt.xyz; p2 = to.xyz;
    vec3 norm = to.xyz-pt.xyz;
    float mult = 1.1; //slop to account for perspective of sphere
    if(length(p1) > length(p2)) { //billboard at level of closest point
       mvPosition = to;
    }
    vec3 n = normalize(mvPosition.xyz);
//intersect with the plane defined by the camera looking at the billboard point
    if(color.z >= 0.0) { //p1
       vec3 pnorm = normalize(p1);
       float t = dot(mvPosition.xyz-p1,n)/dot(pnorm,n);
       mvPosition.xyz = p1+t*pnorm;
    } else {
       vec3 pnorm = normalize(p2);
       float t = dot(mvPosition.xyz-p2,n)/dot(pnorm,n);
       mvPosition.xyz = p2+t*pnorm;
       mult *= -1.0;
    }
    vec3 cr = normalize(cross(mvPosition.xyz,norm))*rad;
    vec3 doublecr = normalize(cross(mvPosition.xyz,cr))*rad;
    mvPosition.xy +=  mult*(cr + doublecr).xy;
    cposition = mvPosition.xyz;
    gl_Position = projectionMatrix * mvPosition;
    vLight = vec3(1.0,1.0,1.0);
}

`;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/volumetric/volumetric.frag": (
          /*!**********************************************************!*\
            !*** ./src/WebGL/shaders/lib/volumetric/volumetric.frag ***!
            \**********************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              default: () => o
              /* harmony export */
            });
            const o = `
uniform highp sampler3D data;
uniform highp sampler2D colormap;
uniform highp sampler2D depthmap;


uniform mat4 textmat;
uniform mat4 projinv;
uniform mat4 projectionMatrix;

uniform float step;
uniform float subsamples;
uniform float maxdepth;
uniform float transfermin;
uniform float transfermax;
in  vec4 mvPosition;
out vec4 color;
void main(void) {

   vec4 pos = mvPosition;
   bool seengood = false;
   float i = 0.0;
   color = vec4(1,1,1,0);
   float increment = 1.0/subsamples;
   float maxsteps = (maxdepth*subsamples/step);
//there's probably a better way to do this..
//calculate farthest possible point in model coordinates
   vec4 maxpos = vec4(pos.x,pos.y,pos.z-maxdepth,1.0);
// convert to projection
   maxpos = projectionMatrix*maxpos;
   vec4 startp = projectionMatrix*pos;
// homogonize
   maxpos /= maxpos.w;
   startp /= startp.w;
//take x,y from start and z from max
   maxpos = vec4(startp.x,startp.y,maxpos.z,1.0);
//convert back to model space
   maxpos = projinv*maxpos;
   maxpos /= maxpos.w;
   float incr = step/subsamples;
//get depth from depthmap
//startp is apparently [-1,1]
   vec2 tpos = startp.xy/2.0+0.5;
   float depth = texture(depthmap, tpos).r;
//compute vector between start and end
   vec4 direction = maxpos-pos;
   for( i = 0.0; i <= maxsteps; i++) {
      vec4 pt = (pos+(i/maxsteps)*direction);
      vec4 ppt = projectionMatrix*pt;
      float ptdepth = ppt.z/ppt.w;
      ptdepth = ((gl_DepthRange.diff * ptdepth) + gl_DepthRange.near + gl_DepthRange.far) / 2.0;
      if(ptdepth > depth) break;
      pt = textmat*pt;
//       pt /= pt.w;
      if(pt.x >= -0.01 && pt.y >= -0.01 && pt.z >= -0.01 && pt.x <= 1.01 && pt.y <= 1.01 && pt.z <= 1.01) {
         seengood = true;
      } else if(seengood) {
         break;
      }
      if( pt.x < -0.01 || pt.x > 1.01 || pt.y < -0.01 || pt.y > 1.01 || pt.z < -0.01 || pt.z > 1.01  ){
          color.a = 0.0;
          continue;
      }
      else {
         float val = texture(data, pt.zyx).r;
         if(isinf(val)) continue; //masked out
         float cval = (val-transfermin)/(transfermax-transfermin); //scale to texture 0-1 range
         vec4 val_color = texture(colormap, vec2(cval,0.5));
         color.rgb = color.rgb*color.a + (1.0-color.a)*val_color.a*val_color.rgb;
         color.a += (1.0 - color.a) * val_color.a; 
         if(color.a > 0.0) color.rgb /= color.a;
//          color = vec4(pt.x, pt.y, pt.z, 1.0);
      }
//       color = vec4(pt.x, pt.y, pt.z, 0.0)
    }
}

        `;
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/volumetric/volumetric.vert": (
          /*!**********************************************************!*\
            !*** ./src/WebGL/shaders/lib/volumetric/volumetric.vert ***!
            \**********************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              default: () => o
              /* harmony export */
            });
            const o = `uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;

in vec3 position;
out vec4 mvPosition;
void main() {

    mvPosition = modelViewMatrix * vec4( position, 1.0 );
    gl_Position = projectionMatrix*mvPosition;
}
`;
          }
        ),
        /***/
        "./src/WebGL/shaders/utils/stickimposterFragmentShader.partial.frag": (
          /*!**************************************************************************!*\
            !*** ./src/WebGL/shaders/utils/stickimposterFragmentShader.partial.frag ***!
            \**************************************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              default: () => o
              /* harmony export */
            });
            const o = `uniform float opacity;
uniform mat4 projectionMatrix;

uniform vec3 fogColor;
uniform float fogNear;
uniform float fogFar;

varying vec3 vLight;
varying vec3 vColor;
varying vec3 cposition;
varying vec3 p1;
varying vec3 p2;
varying float r;

//DEFINEFRAGCOLOR

//cylinder-ray intersection testing taken from http://mrl.nyu.edu/~dzorin/cg05/lecture12.pdf
//also useful: http://stackoverflow.com/questions/9595300/cylinder-impostor-in-glsl
//with a bit more care (caps) this could be a general cylinder imposter (see also outline)
void main() {
    vec3 color = abs(vColor);
    vec3 pos = cposition;
    vec3 p = pos; //ray point
    vec3 v = vec3(0.0,0.0,-1.0); //ray normal - orthographic
    if(projectionMatrix[3][3] == 0.0) v = normalize(pos); //ray normal - perspective
    vec3 pa = p1; //cyl start
    vec3 va = normalize(p2-p1); //cyl norm
    vec3 tmp1 = v-(dot(v,va)*va);
    vec3 deltap = p-pa;
    float A = dot(tmp1,tmp1);
    if(A == 0.0) discard;
    vec3 tmp2 = deltap-(dot(deltap,va)*va);
    float B = 2.0*dot(tmp1, tmp2);
    float C = dot(tmp2,tmp2)-r*r;
//quadratic equation!
    float det = (B*B) - (4.0*A*C);
    if(det < 0.0) discard;
    float sqrtDet = sqrt(det);
    float posT = (-B+sqrtDet)/(2.0*A);
    float negT = (-B-sqrtDet)/(2.0*A);
    float intersectionT = min(posT,negT);
    vec3 qi = p+v*intersectionT;
    float dotp1 = dot(va,qi-p1);
    float dotp2 = dot(va,qi-p2);
    vec3 norm;
    if( dotp1 < 0.0 || dotp2 > 0.0) { //(p-c)^2 + 2(p-c)vt +v^2+t^2 - r^2 = 0
       vec3 cp;
       if( dotp1 < 0.0) {  
//        if(vColor.x < 0.0 ) discard; //color sign bit indicates if we should cap or not
        cp = p1;
       } else {
//          if(vColor.y < 0.0 ) discard;
          cp = p2;
       }
       vec3 diff = p-cp;
       A = dot(v,v);
       B = dot(diff,v)*2.0;
       C = dot(diff,diff)-r*r;
       det = (B*B) - (4.0*C);
       if(det < 0.0) discard;
       sqrtDet = sqrt(det);
       posT = (-B+sqrtDet)/(2.0);
       negT = (-B-sqrtDet)/(2.0);
       float t = min(posT,negT);
       qi = p+v*t; 
       norm = normalize(qi-cp); 
    } else {
       norm = normalize(qi-(dotp1*va + p1));
    }
    vec4 clipPos = projectionMatrix * vec4(qi, 1.0);
    float ndcDepth = clipPos.z / clipPos.w;
    float depth = ((gl_DepthRange.diff * ndcDepth) + gl_DepthRange.near + gl_DepthRange.far) / 2.0;
    gl_FragDepthEXT = depth;`;
          }
        ),
        /***/
        "./src/GLDraw.ts": (
          /*!***********************!*\
            !*** ./src/GLDraw.ts ***!
            \***********************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              CAP: () => (
                /* binding */
                l
              ),
              /* harmony export */
              GLDraw: () => (
                /* binding */
                u
              )
              /* harmony export */
            });
            var o = n(
              /*! ./WebGL/math */
              "./src/WebGL/math/index.ts"
            ), l;
            (function(f) {
              f[f.NONE = 0] = "NONE", f[f.FLAT = 1] = "FLAT", f[f.ROUND = 2] = "ROUND";
            })(l || (l = {}));
            var u;
            (function(f) {
              function h(_, b, M) {
                var A = Math.hypot(_, b), $, S, C, D, O;
                A < 1e-4 ? (S = 0, C = 1) : (S = -_ / A, C = b / A), b = -S * _ + C * b, $ = Math.hypot(b, M), $ < 1e-4 ? (D = 0, O = 1) : (D = M / $, O = b / $);
                var N = new Float32Array(9);
                return N[0] = C, N[1] = S, N[2] = 0, N[3] = -S * O, N[4] = C * O, N[5] = D, N[6] = S * D, N[7] = -C * D, N[8] = O, N;
              }
              class p {
                constructor() {
                  this.cache = {};
                  let b = [], M = 4, A = Math.pow(2, M), $ = 2, S = Math.pow(2, $), C = A / S, D;
                  for (b[0] = new o.Vector3(-1, 0, 0), b[C] = new o.Vector3(0, 0, 1), b[C * 2] = new o.Vector3(1, 0, 0), b[C * 3] = new o.Vector3(0, 0, -1), $ = 3; $ <= M; $++) {
                    for (S = Math.pow(2, $ - 1), C = A / S, D = 0; D < S - 1; D++)
                      b[C / 2 + D * C] = b[D * C].clone().add(b[(D + 1) * C]).normalize();
                    D = S - 1, b[C / 2 + D * C] = b[D * C].clone().add(b[0]).normalize();
                  }
                  this.basisVectors = b;
                }
                getVerticesForRadius(b, M, A) {
                  if (typeof this.cache < "u" && this.cache[b] !== void 0 && this.cache[b][M + A] !== void 0)
                    return this.cache[b][M + A];
                  for (var $ = this.basisVectors.length, S = [], C = [], D, O = 0; O < $; O++)
                    S.push(this.basisVectors[O].clone().multiplyScalar(b)), S.push(this.basisVectors[O].clone().multiplyScalar(b)), D = this.basisVectors[O].clone().normalize(), C.push(D), C.push(D);
                  var N = [], j = 10, L = $, z = 0, G = Math.PI * 2, B = 0, F = Math.PI, H, W, V = !1, X = !1;
                  for (W = 0; W <= j; W++) {
                    V = W === 0 || W === j, X = W === j / 2;
                    var Z = [], Q = [];
                    for (H = 0; H <= L; H++) {
                      if (X) {
                        var q = H < L ? 2 * H : 0;
                        Q.push(q + 1), Z.push(q);
                        continue;
                      }
                      var J = H / L, ie = W / j;
                      if (!V || H === 0)
                        if (H < L) {
                          var ne = new o.Vector3();
                          ne.x = -b * Math.cos(z + J * G) * Math.sin(B + ie * F), M == 1 ? ne.y = 0 : ne.y = b * Math.cos(B + ie * F), ne.z = b * Math.sin(z + J * G) * Math.sin(B + ie * F), Math.abs(ne.x) < 1e-5 && (ne.x = 0), Math.abs(ne.y) < 1e-5 && (ne.y = 0), Math.abs(ne.z) < 1e-5 && (ne.z = 0), M == l.FLAT ? (D = new o.Vector3(0, Math.cos(B + ie * F), 0), D.normalize()) : (D = new o.Vector3(ne.x, ne.y, ne.z), D.normalize()), S.push(ne), C.push(D), Z.push(S.length - 1);
                        } else
                          Z.push(S.length - L);
                      else
                        V && Z.push(S.length - 1);
                    }
                    X && N.push(Q), N.push(Z);
                  }
                  var ge = {
                    vertices: S,
                    normals: C,
                    verticesRows: N,
                    w: L,
                    h: j
                  };
                  return b in this.cache || (this.cache[b] = {}), this.cache[b][M + A] = ge, ge;
                }
              }
              var v = new p();
              function g(_, b, M, A, $, S = 0, C = 0) {
                if (!b || !M)
                  return;
                let D = function(bt) {
                  if (typeof bt == "string") {
                    let yi = bt;
                    return yi.toLowerCase() == "flat" ? l.FLAT : yi.toLowerCase() == "round" ? l.ROUND : l.NONE;
                  } else
                    return bt;
                };
                S = D(S), C = D(C);
                var O = C || S;
                $ = $ || { r: 0, g: 0, b: 0 };
                var N = h(M.x - b.x, M.y - b.y, M.z - b.z), j = v.getVerticesForRadius(A, C, "to"), L = j.w, z = j.h, G = O ? z * L + 2 : 2 * L, B = _.updateGeoGroup(G), F = j.vertices, H = j.normals, W = j.verticesRows, V = W[z / 2], X = W[z / 2 + 1], Z = B.vertices, Q, q, J, ie, ne, ge, ye = B.vertexArray, xe = B.normalArray, we = B.colorArray, de = B.faceArray;
                for (J = 0; J < L; ++J) {
                  var Te = 2 * J;
                  ie = N[0] * F[Te].x + N[3] * F[Te].y + N[6] * F[Te].z, ne = N[1] * F[Te].x + N[4] * F[Te].y + N[7] * F[Te].z, ge = N[5] * F[Te].y + N[8] * F[Te].z, Q = 3 * (Z + Te), q = B.faceidx, ye[Q] = ie + b.x, ye[Q + 1] = ne + b.y, ye[Q + 2] = ge + b.z, ye[Q + 3] = ie + M.x, ye[Q + 4] = ne + M.y, ye[Q + 5] = ge + M.z, xe[Q] = ie, xe[Q + 3] = ie, xe[Q + 1] = ne, xe[Q + 4] = ne, xe[Q + 2] = ge, xe[Q + 5] = ge, we[Q] = $.r, we[Q + 3] = $.r, we[Q + 1] = $.g, we[Q + 4] = $.g, we[Q + 2] = $.b, we[Q + 5] = $.b, de[q] = X[J] + Z, de[q + 1] = X[J + 1] + Z, de[q + 2] = V[J] + Z, de[q + 3] = V[J] + Z, de[q + 4] = X[J + 1] + Z, de[q + 5] = V[J + 1] + Z, B.faceidx += 6;
                }
                if (O) {
                  var Ce = C ? 0 : z / 2, ee = S ? z + 1 : z / 2 + 1, Ae, be, Fe, et, Ye, De, Ue, Qe, ue, te, Be, Je, ft, lt, he, ae, se, Re, Oe, We, Ct, le, ke, Ke, me, Ee, tt, ce, _e, Ht, K, Ve;
                  for (ne = Ce; ne < ee; ne++)
                    if (ne !== z / 2) {
                      var Ne = ne <= z / 2 ? M : b, pe = v.getVerticesForRadius(A, C, "to"), Le = v.getVerticesForRadius(A, S, "from");
                      for (Ne === M ? (F = pe.vertices, H = pe.normals, W = pe.verticesRows) : Ne == b && (F = Le.vertices, H = Le.normals, W = Le.verticesRows), ie = 0; ie < L; ie++)
                        q = B.faceidx, Ae = W[ne][ie + 1], _e = (Ae + Z) * 3, be = W[ne][ie], Ht = (be + Z) * 3, Fe = W[ne + 1][ie], K = (Fe + Z) * 3, et = W[ne + 1][ie + 1], Ve = (et + Z) * 3, Ye = N[0] * F[Ae].x + N[3] * F[Ae].y + N[6] * F[Ae].z, De = N[0] * F[be].x + N[3] * F[be].y + N[6] * F[be].z, Ue = N[0] * F[Fe].x + N[3] * F[Fe].y + N[6] * F[Fe].z, Qe = N[0] * F[et].x + N[3] * F[et].y + N[6] * F[et].z, ue = N[1] * F[Ae].x + N[4] * F[Ae].y + N[7] * F[Ae].z, te = N[1] * F[be].x + N[4] * F[be].y + N[7] * F[be].z, Be = N[1] * F[Fe].x + N[4] * F[Fe].y + N[7] * F[Fe].z, Je = N[1] * F[et].x + N[4] * F[et].y + N[7] * F[et].z, ft = N[5] * F[Ae].y + N[8] * F[Ae].z, lt = N[5] * F[be].y + N[8] * F[be].z, he = N[5] * F[Fe].y + N[8] * F[Fe].z, ae = N[5] * F[et].y + N[8] * F[et].z, ye[_e] = Ye + Ne.x, ye[Ht] = De + Ne.x, ye[K] = Ue + Ne.x, ye[Ve] = Qe + Ne.x, ye[_e + 1] = ue + Ne.y, ye[Ht + 1] = te + Ne.y, ye[K + 1] = Be + Ne.y, ye[Ve + 1] = Je + Ne.y, ye[_e + 2] = ft + Ne.z, ye[Ht + 2] = lt + Ne.z, ye[K + 2] = he + Ne.z, ye[Ve + 2] = ae + Ne.z, we[_e] = $.r, we[Ht] = $.r, we[K] = $.r, we[Ve] = $.r, we[_e + 1] = $.g, we[Ht + 1] = $.g, we[K + 1] = $.g, we[Ve + 1] = $.g, we[_e + 2] = $.b, we[Ht + 2] = $.b, we[K + 2] = $.b, we[Ve + 2] = $.b, se = N[0] * H[Ae].x + N[3] * H[Ae].y + N[6] * H[Ae].z, Re = N[0] * H[be].x + N[3] * H[be].y + N[6] * H[be].z, Oe = N[0] * H[Fe].x + N[3] * H[Fe].y + N[6] * H[Fe].z, We = N[0] * H[et].x + N[3] * H[et].y + N[6] * H[et].z, Ct = N[1] * H[Ae].x + N[4] * H[Ae].y + N[7] * H[Ae].z, le = N[1] * H[be].x + N[4] * H[be].y + N[7] * H[be].z, ke = N[1] * H[Fe].x + N[4] * H[Fe].y + N[7] * H[Fe].z, Ke = N[1] * H[et].x + N[4] * H[et].y + N[7] * H[et].z, me = N[5] * H[Ae].y + N[8] * H[Ae].z, Ee = N[5] * H[be].y + N[8] * H[be].z, tt = N[5] * H[Fe].y + N[8] * H[Fe].z, ce = N[5] * H[et].y + N[8] * H[et].z, ne === 0 ? (xe[_e] = se, xe[K] = Oe, xe[Ve] = We, xe[_e + 1] = Ct, xe[K + 1] = ke, xe[Ve + 1] = Ke, xe[_e + 2] = me, xe[K + 2] = tt, xe[Ve + 2] = ce, de[q] = Ae + Z, de[q + 1] = Fe + Z, de[q + 2] = et + Z, B.faceidx += 3) : ne === ee - 1 ? (xe[_e] = se, xe[Ht] = Re, xe[K] = Oe, xe[_e + 1] = Ct, xe[Ht + 1] = le, xe[K + 1] = ke, xe[_e + 2] = me, xe[Ht + 2] = Ee, xe[K + 2] = tt, de[q] = Ae + Z, de[q + 1] = be + Z, de[q + 2] = Fe + Z, B.faceidx += 3) : (xe[_e] = se, xe[Ht] = Re, xe[Ve] = We, xe[_e + 1] = Ct, xe[Ht + 1] = le, xe[Ve + 1] = Ke, xe[_e + 2] = me, xe[Ht + 2] = Ee, xe[Ve + 2] = ce, xe[Ht] = Re, xe[K] = Oe, xe[Ve] = We, xe[Ht + 1] = le, xe[K + 1] = ke, xe[Ve + 1] = Ke, xe[Ht + 2] = Ee, xe[K + 2] = tt, xe[Ve + 2] = ce, de[q] = Ae + Z, de[q + 1] = be + Z, de[q + 2] = et + Z, de[q + 3] = be + Z, de[q + 4] = Fe + Z, de[q + 5] = et + Z, B.faceidx += 6);
                    }
                }
                B.vertices += G;
              }
              f.drawCylinder = g;
              function w(_, b, M, A, $) {
                if (!b || !M)
                  return;
                $ = $ || { r: 0, g: 0, b: 0 };
                let S = new o.Vector3(M.x - b.x, M.y - b.y, M.z - b.z);
                var C = h(S.x, S.y, S.z);
                S = S.normalize();
                var D = v.basisVectors.length, O = v.basisVectors, N = D + 2, j = _.updateGeoGroup(N), L = j.vertices, z, G, B, F, H, W, V = j.vertexArray, X = j.normalArray, Z = j.colorArray, Q = j.faceArray;
                for (z = L * 3, V[z] = b.x, V[z + 1] = b.y, V[z + 2] = b.z, X[z] = -S.x, X[z + 1] = -S.y, X[z + 2] = -S.z, Z[z] = $.r, Z[z + 1] = $.g, Z[z + 2] = $.b, V[z + 3] = M.x, V[z + 4] = M.y, V[z + 5] = M.z, X[z + 3] = S.x, X[z + 4] = S.y, X[z + 5] = S.z, Z[z + 3] = $.r, Z[z + 4] = $.g, Z[z + 5] = $.b, z += 6, B = 0; B < D; ++B) {
                  var q = O[B].clone();
                  q.multiplyScalar(A), F = C[0] * q.x + C[3] * q.y + C[6] * q.z, H = C[1] * q.x + C[4] * q.y + C[7] * q.z, W = C[5] * q.y + C[8] * q.z, V[z] = F + b.x, V[z + 1] = H + b.y, V[z + 2] = W + b.z, X[z] = F, X[z + 1] = H, X[z + 2] = W, Z[z] = $.r, Z[z + 1] = $.g, Z[z + 2] = $.b, z += 3;
                }
                for (j.vertices += D + 2, G = j.faceidx, B = 0; B < D; B++) {
                  var J = L + 2 + B, ie = L + 2 + (B + 1) % D;
                  Q[G] = J, Q[G + 1] = ie, Q[G + 2] = L, G += 3, Q[G] = J, Q[G + 1] = ie, Q[G + 2] = L + 1, G += 3;
                }
                j.faceidx += 6 * D;
              }
              f.drawCone = w;
              class E {
                constructor() {
                  this.cache = /* @__PURE__ */ new Map();
                }
                getVerticesForRadius(b, M) {
                  M = M || 2, this.cache.has(M) || this.cache.set(M, /* @__PURE__ */ new Map());
                  let A = this.cache.get(M);
                  if (A.has(b))
                    return A.get(b);
                  var $ = {
                    vertices: [],
                    verticesRows: [],
                    normals: []
                  }, S = 16 * M, C = 10 * M;
                  b < 1 && (S = 10 * M, C = 8 * M);
                  var D = 0, O = Math.PI * 2, N = 0, j = Math.PI, L, z;
                  for (z = 0; z <= C; z++) {
                    let B = [];
                    for (L = 0; L <= S; L++) {
                      let F = L / S, H = z / C, W = -b * Math.cos(D + F * O) * Math.sin(N + H * j), V = b * Math.cos(N + H * j), X = b * Math.sin(D + F * O) * Math.sin(N + H * j);
                      var G = new o.Vector3(W, V, X);
                      G.normalize(), $.vertices.push({ x: W, y: V, z: X }), $.normals.push(G), B.push($.vertices.length - 1);
                    }
                    $.verticesRows.push(B);
                  }
                  return A.set(b, $), $;
                }
              }
              var T = new E();
              function R(_, b, M, A, $) {
                var S = T.getVerticesForRadius(M, $), C = S.vertices, D = S.normals, O = _.updateGeoGroup(C.length), N = O.vertices, j = O.vertexArray, L = O.colorArray, z = O.faceArray, G = O.lineArray, B = O.normalArray;
                for (let W = 0, V = C.length; W < V; ++W) {
                  let X = 3 * (N + W), Z = C[W];
                  j[X] = Z.x + b.x, j[X + 1] = Z.y + b.y, j[X + 2] = Z.z + b.z, L[X] = A.r, L[X + 1] = A.g, L[X + 2] = A.b;
                }
                O.vertices += C.length;
                let F = S.verticesRows, H = F.length - 1;
                for (let W = 0; W < H; W++) {
                  let V = F[W].length - 1;
                  for (let X = 0; X < V; X++) {
                    let Z = O.faceidx, Q = O.lineidx, q = F[W][X + 1] + N, J = q * 3, ie = F[W][X] + N, ne = ie * 3, ge = F[W + 1][X] + N, ye = ge * 3, xe = F[W + 1][X + 1] + N, we = xe * 3, de = D[q - N], Te = D[ie - N], Ce = D[ge - N], ee = D[xe - N];
                    Math.abs(C[q - N].y) === M ? (B[J] = de.x, B[ye] = Ce.x, B[we] = ee.x, B[J + 1] = de.y, B[ye + 1] = Ce.y, B[we + 1] = ee.y, B[J + 2] = de.z, B[ye + 2] = Ce.z, B[we + 2] = ee.z, z[Z] = q, z[Z + 1] = ge, z[Z + 2] = xe, G[Q] = q, G[Q + 1] = ge, G[Q + 2] = q, G[Q + 3] = xe, G[Q + 4] = ge, G[Q + 5] = xe, O.faceidx += 3, O.lineidx += 6) : Math.abs(C[ge - N].y) === M ? (B[J] = de.x, B[ne] = Te.x, B[ye] = Ce.x, B[J + 1] = de.y, B[ne + 1] = Te.y, B[ye + 1] = Ce.y, B[J + 2] = de.z, B[ne + 2] = Te.z, B[ye + 2] = Ce.z, z[Z] = q, z[Z + 1] = ie, z[Z + 2] = ge, G[Q] = q, G[Q + 1] = ie, G[Q + 2] = q, G[Q + 3] = ge, G[Q + 4] = ie, G[Q + 5] = ge, O.faceidx += 3, O.lineidx += 6) : (B[J] = de.x, B[ne] = Te.x, B[we] = ee.x, B[J + 1] = de.y, B[ne + 1] = Te.y, B[we + 1] = ee.y, B[J + 2] = de.z, B[ne + 2] = Te.z, B[we + 2] = ee.z, B[ne] = Te.x, B[ye] = Ce.x, B[we] = ee.x, B[ne + 1] = Te.y, B[ye + 1] = Ce.y, B[we + 1] = ee.y, B[ne + 2] = Te.z, B[ye + 2] = Ce.z, B[we + 2] = ee.z, z[Z] = q, z[Z + 1] = ie, z[Z + 2] = xe, z[Z + 3] = ie, z[Z + 4] = ge, z[Z + 5] = xe, G[Q] = q, G[Q + 1] = ie, G[Q + 2] = q, G[Q + 3] = xe, G[Q + 4] = ie, G[Q + 5] = ge, G[Q + 6] = ge, G[Q + 7] = xe, O.faceidx += 6, O.lineidx += 8);
                  }
                }
              }
              f.drawSphere = R;
            })(u || (u = {}));
          }
        ),
        /***/
        "./src/GLModel.ts": (
          /*!************************!*\
            !*** ./src/GLModel.ts ***!
            \************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              GLModel: () => (
                /* binding */
                b
              )
              /* harmony export */
            });
            var o = n(
              /*! ./WebGL */
              "./src/WebGL/index.ts"
            ), l = n(
              /*! ./WebGL/shapes */
              "./src/WebGL/shapes/index.ts"
            ), u = n(
              /*! ./WebGL/math */
              "./src/WebGL/math/index.ts"
            ), f = n(
              /*! ./colors */
              "./src/colors.ts"
            ), h = n(
              /*! ./GLDraw */
              "./src/GLDraw.ts"
            ), p = n(
              /*! ./glcartoon */
              "./src/glcartoon.ts"
            ), v = n(
              /*! ./utilities */
              "./src/utilities.ts"
            ), g = n(
              /*! ./Gradient */
              "./src/Gradient.ts"
            ), w = n(
              /*! ./parsers */
              "./src/parsers/index.ts"
            ), E = n(
              /*! netcdfjs */
              "./node_modules/netcdfjs/lib-esm/index.js"
            ), T = n(
              /*! pako */
              "./node_modules/pako/dist/pako.esm.mjs"
            ), R = n(
              /*! ./parsers/utils/assignBonds */
              "./src/parsers/utils/assignBonds.ts"
            );
            function _(M) {
              let A;
              return typeof M == "string" ? A = new TextEncoder().encode(M) : A = new Uint8Array(M), (0, T.inflate)(A, {
                to: "string"
              });
            }
            class b {
              // class functions
              // return true if a and b represent the same style
              static sameObj(A, $) {
                return A && $ ? JSON.stringify(A) == JSON.stringify($) : A == $;
              }
              constructor(A, $) {
                this.atoms = [], this.frames = [], this.box = null, this.atomdfs = null, this.id = 0, this.hidden = !1, this.molObj = null, this.renderedMolObj = null, this.lastColors = null, this.modelData = {}, this.modelDatas = null, this.idMatrix = new u.Matrix4(), this.dontDuplicateAtoms = !0, this.defaultColor = f.elementColors.defaultColor, this.defaultStickRadius = 0.25, this.options = $ || {}, this.ElementColors = this.options.defaultcolors ? this.options.defaultcolors : f.elementColors.defaultColors, this.defaultSphereRadius = this.options.defaultSphereRadius ? this.options.defaultSphereRadius : 1.5, this.defaultCartoonQuality = this.options.cartoonQuality ? this.options.cartoonQuality : 10, this.id = A;
              }
              // return proper radius for atom given style
              /**
               *
               * @param {AtomSpec} atom
               * @param {atomstyle} style
               * @return {number}
               *
               */
              getRadiusFromStyle(A, $) {
                var S = this.defaultSphereRadius;
                if (typeof $.radius < "u")
                  S = $.radius;
                else if (b.vdwRadii[A.elem])
                  S = b.vdwRadii[A.elem];
                else if (A.elem.length > 1) {
                  let C = A.elem;
                  C = C[0].toUpperCase() + C[1].toLowerCase(), b.vdwRadii[C] && (S = b.vdwRadii[C]);
                }
                return typeof $.scale < "u" && (S *= $.scale), S;
              }
              // cross drawing
              /**
               *
               * @param {AtomSpec} atom
               * @param {Record<number, Geometry>} geos
               */
              drawAtomCross(A, $) {
                if (A.style.cross) {
                  var S = A.style.cross;
                  if (!S.hidden) {
                    var C = S.linewidth || b.defaultlineWidth;
                    $[C] || ($[C] = new o.Geometry());
                    var D = $[C].updateGeoGroup(6), O = this.getRadiusFromStyle(A, S), N = [
                      [O, 0, 0],
                      [-O, 0, 0],
                      [0, O, 0],
                      [0, -O, 0],
                      [0, 0, O],
                      [0, 0, -O]
                    ], j = A.clickable || A.hoverable;
                    j && A.intersectionShape === void 0 && (A.intersectionShape = { sphere: [], cylinder: [], line: [] });
                    for (var L = (0, v.getColorFromStyle)(A, S), z = D.vertexArray, G = D.colorArray, B = 0; B < 6; B++) {
                      var F = D.vertices * 3;
                      if (D.vertices++, z[F] = A.x + N[B][0], z[F + 1] = A.y + N[B][1], z[F + 2] = A.z + N[B][2], G[F] = L.r, G[F + 1] = L.g, G[F + 2] = L.b, j) {
                        var H = new u.Vector3(N[B][0], N[B][1], N[B][2]);
                        H.multiplyScalar(0.1), H.set(H.x + A.x, H.y + A.y, H.z + A.z), A.intersectionShape.line.push(H);
                      }
                    }
                  }
                }
              }
              getGoodCross(A, $, S, C) {
                for (var D = null, O = -1, N = 0, j = A.bonds.length; N < j; N++)
                  if (A.bonds[N] != $.index) {
                    let z = A.bonds[N], G = this.atoms[z], B = new u.Vector3(G.x, G.y, G.z).clone();
                    B.sub(S);
                    let F = B.clone();
                    F.cross(C);
                    var L = F.lengthSq();
                    if (L > O && (O = L, D = F, O > 0.1))
                      return D;
                  }
                return D;
              }
              //from atom, return a normalized vector v that is orthogonal and along which
              //it is appropraite to draw multiple bonds
              getSideBondV(A, $, S) {
                var C, D, O, N, j, L = new u.Vector3(A.x, A.y, A.z), z = new u.Vector3($.x, $.y, $.z), G = z.clone(), B = null;
                if (G.sub(L), A.bonds.length === 1)
                  $.bonds.length === 1 ? (B = G.clone(), Math.abs(B.x) > 1e-4 ? B.y += 1 : B.x += 1) : (C = (S + 1) % $.bonds.length, D = $.bonds[C], O = this.atoms[D], O.index == A.index && (C = (C + 1) % $.bonds.length, D = $.bonds[C], O = this.atoms[D]), N = new u.Vector3(O.x, O.y, O.z), j = N.clone(), j.sub(L), B = j.clone(), B.cross(G));
                else if (B = this.getGoodCross(A, $, L, G), B.lengthSq() < 0.01) {
                  var F = this.getGoodCross($, A, L, G);
                  F != null && (B = F);
                }
                return B.lengthSq() < 0.01 && (B = G.clone(), Math.abs(B.x) > 1e-4 ? B.y += 1 : B.x += 1), B.cross(G), B.normalize(), B;
              }
              addLine(A, $, S, C, D, O) {
                A[S] = C.x, A[S + 1] = C.y, A[S + 2] = C.z, $[S] = O.r, $[S + 1] = O.g, $[S + 2] = O.b, A[S + 3] = D.x, A[S + 4] = D.y, A[S + 5] = D.z, $[S + 3] = O.r, $[S + 4] = O.g, $[S + 5] = O.b;
              }
              // bonds - both atoms must match bond style
              // standardize on only drawing for lowest to highest
              /**
               *
               * @param {AtomSpec}
               *            atom
               * @param {AtomSpec[]} atoms
               * @param {Record<number,Geometry>} geos
               */
              drawBondLines(A, $, S) {
                if (A.style.line) {
                  var C = A.style.line;
                  if (!C.hidden) {
                    var D, O, N, j, L = C.linewidth || b.defaultlineWidth;
                    S[L] || (S[L] = new o.Geometry());
                    for (var z = S[L].updateGeoGroup(6 * A.bonds.length), G = z.vertexArray, B = z.colorArray, F = 0; F < A.bonds.length; F++) {
                      var H = A.bonds[F], W = $[H];
                      if (W.style.line && !(A.index >= W.index)) {
                        var V = new u.Vector3(A.x, A.y, A.z), X = new u.Vector3(W.x, W.y, W.z), Z = V.clone().add(X).multiplyScalar(0.5), Q = !1, q = A.clickable || A.hoverable, J = W.clickable || W.hoverable;
                        (q || J) && (q && (A.intersectionShape === void 0 && (A.intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] }), A.intersectionShape.line.push(V), A.intersectionShape.line.push(Z)), J && (W.intersectionShape === void 0 && (W.intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] }), W.intersectionShape.line.push(Z), W.intersectionShape.line.push(X)));
                        var ie = (0, v.getColorFromStyle)(A, A.style.line), ne = (0, v.getColorFromStyle)(W, W.style.line);
                        if (A.bondStyles && A.bondStyles[F]) {
                          var ge = A.bondStyles[F];
                          if (!ge.iswire)
                            continue;
                          ge.singleBond && (Q = !0), typeof ge.color1 < "u" && (ie = f.CC.color(ge.color1)), typeof ge.color2 < "u" && (ne = f.CC.color(ge.color2));
                        }
                        var ye = z.vertices * 3, xe, we;
                        if (A.bondOrder[F] > 1 && A.bondOrder[F] < 4 && !Q) {
                          var de = this.getSideBondV(A, W, F), Te = X.clone();
                          Te.sub(V), A.bondOrder[F] == 2 ? (de.multiplyScalar(0.1), D = V.clone(), D.add(de), O = V.clone(), O.sub(de), N = D.clone(), N.add(Te), j = O.clone(), j.add(Te), ie == ne ? (z.vertices += 4, this.addLine(G, B, ye, D, N, ie), this.addLine(G, B, ye + 6, O, j, ie)) : (z.vertices += 8, Te.multiplyScalar(0.5), xe = D.clone(), xe.add(Te), we = O.clone(), we.add(Te), this.addLine(G, B, ye, D, xe, ie), this.addLine(G, B, ye + 6, xe, N, ne), this.addLine(G, B, ye + 12, O, we, ie), this.addLine(G, B, ye + 18, we, j, ne))) : A.bondOrder[F] == 3 && (de.multiplyScalar(0.1), D = V.clone(), D.add(de), O = V.clone(), O.sub(de), N = D.clone(), N.add(Te), j = O.clone(), j.add(Te), ie == ne ? (z.vertices += 6, this.addLine(G, B, ye, V, X, ie), this.addLine(G, B, ye + 6, D, N, ie), this.addLine(G, B, ye + 12, O, j, ie)) : (z.vertices += 12, Te.multiplyScalar(0.5), xe = D.clone(), xe.add(Te), we = O.clone(), we.add(Te), this.addLine(G, B, ye, V, Z, ie), this.addLine(G, B, ye + 6, Z, X, ne), this.addLine(G, B, ye + 12, D, xe, ie), this.addLine(G, B, ye + 18, xe, N, ne), this.addLine(G, B, ye + 24, O, we, ie), this.addLine(G, B, ye + 30, we, j, ne)));
                        } else
                          ie == ne ? (z.vertices += 2, this.addLine(G, B, ye, V, X, ie)) : (z.vertices += 4, this.addLine(G, B, ye, V, Z, ie), this.addLine(G, B, ye + 6, Z, X, ne));
                      }
                    }
                  }
                }
              }
              //sphere drawing
              //See also: drawCylinder
              /**
               *
               * @param {AtomSpec} atom
               * @param {Geometry} geo
               */
              drawAtomSphere(A, $) {
                if (A.style.sphere) {
                  var S = A.style.sphere;
                  if (!S.hidden) {
                    var C = (0, v.getColorFromStyle)(A, S), D = this.getRadiusFromStyle(A, S);
                    if ((A.clickable === !0 || A.hoverable) && A.intersectionShape !== void 0) {
                      var O = new u.Vector3(A.x, A.y, A.z);
                      A.intersectionShape.sphere.push(new l.Sphere(O, D));
                    }
                    h.GLDraw.drawSphere($, A, D, C);
                  }
                }
              }
              /** Register atom shaped click handlers */
              drawAtomClickSphere(A) {
                if (A.style.clicksphere) {
                  var $ = A.style.clicksphere;
                  if (!$.hidden) {
                    var S = this.getRadiusFromStyle(A, $);
                    if ((A.clickable === !0 || A.hoverable) && A.intersectionShape !== void 0) {
                      var C = new u.Vector3(A.x, A.y, A.z);
                      A.intersectionShape.sphere.push(new l.Sphere(C, S));
                    }
                  }
                }
              }
              drawAtomInstanced(A, $) {
                if (A.style.sphere) {
                  var S = A.style.sphere;
                  if (!S.hidden) {
                    var C = this.getRadiusFromStyle(A, S), D = (0, v.getColorFromStyle)(A, S), O = $.updateGeoGroup(1), N = O.vertices, j = N * 3, L = O.vertexArray, z = O.colorArray, G = O.radiusArray;
                    if (L[j] = A.x, L[j + 1] = A.y, L[j + 2] = A.z, z[j] = D.r, z[j + 1] = D.g, z[j + 2] = D.b, G[N] = C, (A.clickable === !0 || A.hoverable) && A.intersectionShape !== void 0) {
                      var B = new u.Vector3(A.x, A.y, A.z);
                      A.intersectionShape.sphere.push(new l.Sphere(B, C));
                    }
                    O.vertices += 1;
                  }
                }
              }
              drawSphereImposter(A, $, S, C) {
                var D = A.updateGeoGroup(4), O, N = D.vertices, j = N * 3, L = D.vertexArray, z = D.colorArray;
                for (O = 0; O < 4; O++)
                  L[j + 3 * O] = $.x, L[j + 3 * O + 1] = $.y, L[j + 3 * O + 2] = $.z;
                var G = D.normalArray;
                for (O = 0; O < 4; O++)
                  z[j + 3 * O] = C.r, z[j + 3 * O + 1] = C.g, z[j + 3 * O + 2] = C.b;
                G[j + 0] = -S, G[j + 1] = S, G[j + 2] = 0, G[j + 3] = -S, G[j + 4] = -S, G[j + 5] = 0, G[j + 6] = S, G[j + 7] = -S, G[j + 8] = 0, G[j + 9] = S, G[j + 10] = S, G[j + 11] = 0, D.vertices += 4;
                var B = D.faceArray, F = D.faceidx;
                B[F + 0] = N, B[F + 1] = N + 1, B[F + 2] = N + 2, B[F + 3] = N + 2, B[F + 4] = N + 3, B[F + 5] = N, D.faceidx += 6;
              }
              //dkoes -  code for sphere imposters
              drawAtomImposter(A, $) {
                if (A.style.sphere) {
                  var S = A.style.sphere;
                  if (!S.hidden) {
                    var C = this.getRadiusFromStyle(A, S), D = (0, v.getColorFromStyle)(A, S);
                    if ((A.clickable === !0 || A.hoverable) && A.intersectionShape !== void 0) {
                      var O = new u.Vector3(A.x, A.y, A.z);
                      A.intersectionShape.sphere.push(new l.Sphere(O, C));
                    }
                    this.drawSphereImposter($, A, C, D);
                  }
                }
              }
              calculateDashes(A, $, S, C, D) {
                var O = Math.sqrt(Math.pow(A.x - $.x, 2) + Math.pow(A.y - $.y, 2) + Math.pow(A.z - $.z, 2));
                S = Math.max(S, 0), D = Math.max(D, 0) + 2 * S, C = Math.max(C, 1e-3), C + D > O && (C = O, D = 0);
                var N = Math.floor((O - C) / (C + D)) + 1, j = N * C;
                D = (O - j) / N;
                for (var L, z = new u.Vector3(A.x, A.y, A.z), G = new u.Vector3(($.x - A.x) / (O / D), ($.y - A.y) / (O / D), ($.z - A.z) / (O / D)), B = new u.Vector3(($.x - A.x) / (O / C), ($.y - A.y) / (O / C), ($.z - A.z) / (O / C)), F = [], H = 0; H < N; H++)
                  L = new u.Vector3(z.x + B.x, z.y + B.y, z.z + B.z), F.push({ from: z, to: L }), z = new u.Vector3(L.x + G.x, L.y + G.y, L.z + G.z);
                return F;
              }
              static drawStickImposter(A, $, S, C, D, O = 0, N = 0) {
                for (var j = A.updateGeoGroup(4), L = j.vertices, z = L * 3, G = j.vertexArray, B = j.colorArray, F = j.radiusArray, H = j.normalArray, W = D.r, V = D.g, X = D.b, Z = function(ne) {
                  var ge = -ne;
                  return ge == 0 && (ge = -1e-4), ge;
                }, Q = z, q = 0; q < 4; q++)
                  G[Q] = $.x, H[Q] = S.x, B[Q] = W, Q++, G[Q] = $.y, H[Q] = S.y, B[Q] = V, Q++, G[Q] = $.z, H[Q] = S.z, q < 2 ? B[Q] = X : B[Q] = Z(X), Q++;
                j.vertices += 4, F[L] = -C, F[L + 1] = C, F[L + 2] = -C, F[L + 3] = C;
                var J = j.faceArray, ie = j.faceidx;
                J[ie + 0] = L, J[ie + 1] = L + 1, J[ie + 2] = L + 2, J[ie + 3] = L + 2, J[ie + 4] = L + 3, J[ie + 5] = L, j.faceidx += 6;
              }
              // draws cylinders and small spheres (at bond radius)
              drawBondSticks(A, $, S) {
                var C, D;
                if (A.style.stick) {
                  var O = A.style.stick;
                  if (!O.hidden) {
                    var N = O.radius || this.defaultStickRadius, j = O.doubleBondScaling || 0.4, L = O.tripleBondScaling || 0.25, z = ((C = O.dashedBondConfig) === null || C === void 0 ? void 0 : C.dashLength) || 0.1, G = ((D = O.dashedBondConfig) === null || D === void 0 ? void 0 : D.gapLength) || 0.25, B = N, F = O.singleBonds || !1, H = O.dashedBonds || !1, W = 0, V = 0, X, Z, Q, q, J, ie, ne, ge, ye, xe, we, de = (0, v.getColorFromStyle)(A, O), Te, Ce, ee;
                    !A.capDrawn && A.bonds.length < 4 && (W = 2);
                    var Ae = (me) => {
                      var Ee = S.imposter ? b.drawStickImposter : h.GLDraw.drawCylinder;
                      return !H && me >= 1 ? Ee : (tt, ce, _e, Ht, K, Ve = 0, Ne = 0, pe = 0.1, Le = 0.25) => {
                        var bt = this.calculateDashes(ce, _e, Ht, pe, Le);
                        bt.forEach((yi) => {
                          Ee(tt, yi.from, yi.to, Ht, K, Ve, Ne);
                        });
                      };
                    };
                    for (Q = 0; Q < A.bonds.length; Q++) {
                      var be = Ae(A.bondOrder[Q]), Fe = A.bonds[Q], et = $[Fe];
                      if (Te = Ce = ee = null, A.index < et.index) {
                        var Ye = et.style;
                        if (!Ye.stick || Ye.stick.hidden)
                          continue;
                        var De = (0, v.getColorFromStyle)(et, Ye.stick);
                        if (B = N, q = F, A.bondStyles && A.bondStyles[Q]) {
                          if (J = A.bondStyles[Q], J.iswire)
                            continue;
                          J.radius && (B = J.radius), J.singleBond && (q = !0), typeof J.color1 < "u" && (de = f.CC.color(J.color1)), typeof J.color2 < "u" && (De = f.CC.color(J.color2));
                        }
                        var Ue = new u.Vector3(A.x, A.y, A.z), Qe = new u.Vector3(et.x, et.y, et.z);
                        if (A.bondOrder[Q] <= 1 || q || A.bondOrder[Q] > 3) {
                          if (A.bondOrder[Q] < 1 && (B *= A.bondOrder[Q]), !et.capDrawn && et.bonds.length < 4 && (V = 2), de != De ? (Te = new u.Vector3().addVectors(Ue, Qe).multiplyScalar(0.5), be(S, Ue, Te, B, de, W, 0, z, G), be(S, Te, Qe, B, De, 0, V, z, G)) : be(S, Ue, Qe, B, de, W, V, z, G), X = A.clickable || A.hoverable, Z = et.clickable || et.hoverable, X || Z) {
                            if (Te || (Te = new u.Vector3().addVectors(Ue, Qe).multiplyScalar(0.5)), X) {
                              var ue = new l.Cylinder(Ue, Te, B), te = new l.Sphere(Ue, B);
                              A.intersectionShape.cylinder.push(ue), A.intersectionShape.sphere.push(te);
                            }
                            if (Z) {
                              var Be = new l.Cylinder(Qe, Te, B), Je = new l.Sphere(Qe, B);
                              et.intersectionShape.cylinder.push(Be), et.intersectionShape.sphere.push(Je);
                            }
                          }
                        } else if (A.bondOrder[Q] > 1) {
                          var ft = 0, lt = 0;
                          B != N && (ft = 2, lt = 2);
                          var he = Qe.clone(), ae = null;
                          he.sub(Ue);
                          var se, Re, Oe, We, Ct;
                          ae = this.getSideBondV(A, et, Q), A.bondOrder[Q] == 2 ? (se = B * j, ae.multiplyScalar(se * 1.5), Re = Ue.clone(), Re.add(ae), Oe = Ue.clone(), Oe.sub(ae), We = Re.clone(), We.add(he), Ct = Oe.clone(), Ct.add(he), de != De ? (Te = new u.Vector3().addVectors(Re, We).multiplyScalar(0.5), Ce = new u.Vector3().addVectors(Oe, Ct).multiplyScalar(0.5), be(S, Re, Te, se, de, ft, 0), be(S, Te, We, se, De, 0, lt), be(S, Oe, Ce, se, de, ft, 0), be(S, Ce, Ct, se, De, 0, lt)) : (be(S, Re, We, se, de, ft, lt), be(S, Oe, Ct, se, de, ft, lt)), X = A.clickable || A.hoverable, Z = et.clickable || et.hoverable, (X || Z) && (Te || (Te = new u.Vector3().addVectors(Re, We).multiplyScalar(0.5)), Ce || (Ce = new u.Vector3().addVectors(Oe, Ct).multiplyScalar(0.5)), X && (ie = new l.Cylinder(Re, Te, se), ne = new l.Cylinder(Oe, Ce, se), A.intersectionShape.cylinder.push(ie), A.intersectionShape.cylinder.push(ne)), Z && (ye = new l.Cylinder(We, Te, se), xe = new l.Cylinder(Ct, Ce, se), et.intersectionShape.cylinder.push(ye), et.intersectionShape.cylinder.push(xe)))) : A.bondOrder[Q] == 3 && (se = B * L, ae.cross(he), ae.normalize(), ae.multiplyScalar(se * 3), Re = Ue.clone(), Re.add(ae), Oe = Ue.clone(), Oe.sub(ae), We = Re.clone(), We.add(he), Ct = Oe.clone(), Ct.add(he), de != De ? (Te = new u.Vector3().addVectors(Re, We).multiplyScalar(0.5), Ce = new u.Vector3().addVectors(Oe, Ct).multiplyScalar(0.5), ee = new u.Vector3().addVectors(Ue, Qe).multiplyScalar(0.5), be(S, Re, Te, se, de, ft, 0), be(S, Te, We, se, De, 0, lt), be(S, Ue, ee, se, de, W, 0), be(S, ee, Qe, se, De, 0, V), be(S, Oe, Ce, se, de, ft, 0), be(S, Ce, Ct, se, De, 0, lt)) : (be(S, Re, We, se, de, ft, lt), be(S, Ue, Qe, se, de, W, V), be(S, Oe, Ct, se, de, ft, lt)), X = A.clickable || A.hoverable, Z = et.clickable || et.hoverable, (X || Z) && (Te || (Te = new u.Vector3().addVectors(Re, We).multiplyScalar(0.5)), Ce || (Ce = new u.Vector3().addVectors(Oe, Ct).multiplyScalar(0.5)), ee || (ee = new u.Vector3().addVectors(Ue, Qe).multiplyScalar(0.5)), X && (ie = new l.Cylinder(Re.clone(), Te.clone(), se), ne = new l.Cylinder(Oe.clone(), Ce.clone(), se), ge = new l.Cylinder(Ue.clone(), ee.clone(), se), A.intersectionShape.cylinder.push(ie), A.intersectionShape.cylinder.push(ne), A.intersectionShape.cylinder.push(ge)), Z && (ye = new l.Cylinder(We.clone(), Te.clone(), se), xe = new l.Cylinder(Ct.clone(), Ce.clone(), se), we = new l.Cylinder(Qe.clone(), ee.clone(), se), et.intersectionShape.cylinder.push(ye), et.intersectionShape.cylinder.push(xe), et.intersectionShape.cylinder.push(we))));
                        }
                      }
                    }
                    var le = !1, ke = 0, Ke = !1;
                    for (Q = 0; Q < A.bonds.length; Q++)
                      q = F, A.bondStyles && A.bondStyles[Q] && (J = A.bondStyles[Q], J.singleBond && (q = !0), J.radius && J.radius != N && (Ke = !0)), (q || A.bondOrder[Q] == 1) && ke++;
                    Ke ? ke > 0 && (le = !0) : ke == 0 && (A.bonds.length > 0 || O.showNonBonded) && (le = !0), le && (B = N, S.imposter ? this.drawSphereImposter(S.sphereGeometry, A, B, de) : h.GLDraw.drawSphere(S, A, B, de));
                  }
                }
              }
              // go through all the atoms and regenerate their geometries
              // we try to have one geometry for each style since this is much much
              // faster
              // at some point we should optimize this to avoid unnecessary
              // recalculation
              /** param {AtomSpec[]} atoms */
              createMolObj(A, $) {
                $ = $ || {};
                var S = new o.Object3D(), C = [], D = {}, O = {}, N = this.drawAtomSphere, j = null, L = null;
                $.supportsImposters ? (N = this.drawAtomImposter, j = new o.Geometry(!0), j.imposter = !0, L = new o.Geometry(!0, !0), L.imposter = !0, L.sphereGeometry = new o.Geometry(!0), L.sphereGeometry.imposter = !0, L.drawnCaps = {}) : $.supportsAIA ? (N = this.drawAtomInstanced, j = new o.Geometry(!1, !0, !0), j.instanced = !0, L = new o.Geometry(!0)) : (j = new o.Geometry(!0), L = new o.Geometry(!0));
                var z, G, B, F, H = {}, W = [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY];
                for (z = 0, B = A.length; z < B; z++) {
                  var V = A[z];
                  if (V && V.style) {
                    (V.clickable || V.hoverable) && V.intersectionShape === void 0 && (V.intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] }), F = { line: void 0, cross: void 0, stick: void 0, sphere: void 0 };
                    for (G in F)
                      V.style[G] ? V.style[G].opacity ? F[G] = parseFloat(V.style[G].opacity) : F[G] = 1 : F[G] = void 0, H[G] ? F[G] != null && H[G] != F[G] && (console.log("Warning: " + G + " opacity is ambiguous"), H[G] = 1) : H[G] = F[G];
                    N.call(this, V, j), this.drawAtomClickSphere(V), this.drawAtomCross(V, O), this.drawBondLines(V, A, D), this.drawBondSticks(V, A, L), typeof V.style.cartoon < "u" && !V.style.cartoon.hidden && (V.style.cartoon.color === "spectrum" && typeof V.resi == "number" && !V.hetflag && (V.resi < W[0] && (W[0] = V.resi), V.resi > W[1] && (W[1] = V.resi)), C.push(V));
                  }
                }
                if (C.length > 0 && (0, p.drawCartoon)(S, C, W, this.defaultCartoonQuality), j && j.vertices > 0) {
                  j.initTypedArrays();
                  var X = null, Z = null;
                  j.imposter ? X = new o.SphereImposterMaterial({
                    ambient: 0,
                    vertexColors: !0,
                    reflectivity: 0
                  }) : j.instanced ? (Z = new o.Geometry(!0), h.GLDraw.drawSphere(Z, { x: 0, y: 0, z: 0 }, 1, new f.Color(0.5, 0.5, 0.5)), Z.initTypedArrays(), X = new o.InstancedMaterial({
                    sphereMaterial: new o.MeshLambertMaterial({
                      ambient: 0,
                      vertexColors: !0,
                      reflectivity: 0
                    }),
                    sphere: Z
                  })) : X = new o.MeshLambertMaterial({
                    ambient: 0,
                    vertexColors: !0,
                    reflectivity: 0
                  }), H.sphere < 1 && H.sphere >= 0 && (X.transparent = !0, X.opacity = H.sphere), Z = new o.Mesh(j, X), S.add(Z);
                }
                if (L.vertices > 0) {
                  var Q = null, q = null, J = L.sphereGeometry;
                  (!J || typeof J.vertices > "u" || J.vertices == 0) && (J = null), L.initTypedArrays(), J && J.initTypedArrays();
                  var ie = { ambient: 0, vertexColors: !0, reflectivity: 0 };
                  L.imposter ? (Q = new o.StickImposterMaterial(ie), q = new o.SphereImposterMaterial(ie)) : (Q = new o.MeshLambertMaterial(ie), q = new o.MeshLambertMaterial(ie), Q.wireframe && (L.setUpWireframe(), J && J.setUpWireframe())), H.stick < 1 && H.stick >= 0 && (Q.transparent = !0, Q.opacity = H.stick, q.transparent = !0, q.opacity = H.stick);
                  var ne = new o.Mesh(L, Q);
                  if (S.add(ne), J) {
                    var ge = new o.Mesh(J, q);
                    S.add(ge);
                  }
                }
                var ye;
                for (z in D)
                  if (D.hasOwnProperty(z)) {
                    ye = z;
                    var xe = new o.LineBasicMaterial({
                      linewidth: ye,
                      vertexColors: !0
                    });
                    H.line < 1 && H.line >= 0 && (xe.transparent = !0, xe.opacity = H.line), D[z].initTypedArrays();
                    var we = new o.Line(D[z], xe, o.LineStyle.LinePieces);
                    S.add(we);
                  }
                for (z in O)
                  if (O.hasOwnProperty(z)) {
                    ye = z;
                    var de = new o.LineBasicMaterial({
                      linewidth: ye,
                      vertexColors: !0
                    });
                    H.cross < 1 && H.cross >= 0 && (de.transparent = !0, de.opacity = H.cross), O[z].initTypedArrays();
                    var Te = new o.Line(O[z], de, o.LineStyle.LinePieces);
                    S.add(Te);
                  }
                if (this.dontDuplicateAtoms && this.modelData.symmetries && this.modelData.symmetries.length > 0) {
                  var Ce = new o.Object3D(), ee;
                  for (ee = 0; ee < this.modelData.symmetries.length; ee++) {
                    var Ae = new o.Object3D();
                    Ae = S.clone(), Ae.matrix.copy(this.modelData.symmetries[ee]), Ae.matrixAutoUpdate = !1, Ce.add(Ae);
                  }
                  return Ce;
                }
                return S;
              }
              /**
               * Return object representing internal state of
               * the model appropriate for passing to setInternalState
               *
              */
              getInternalState() {
                return {
                  atoms: this.atoms,
                  frames: this.frames
                };
              }
              /**
               * Overwrite the internal model state with the passed state.
               *
              */
              setInternalState(A) {
                this.atoms = A.atoms, this.frames = A.frames, this.molObj = null;
              }
              /**
               * Returns crystallographic information if present.
               *
               *
               */
              getCrystData() {
                if (this.modelData.cryst) {
                  if (!this.modelData.cryst.matrix) {
                    const A = this.modelData.cryst;
                    this.modelData.cryst.matrix = (0, u.conversionMatrix3)(A.a, A.b, A.c, A.alpha, A.beta, A.gamma);
                  }
                  return this.modelData.cryst;
                } else
                  return null;
              }
              /**
              	     * Set crystallographic information using three angles and three lengths
              	     *
              	     * @param {number} a - length of unit cell side
              	     * @param {number} b - length of unit cell side
              	     * @param {number} c - length of unit cell side
              	     * @param {number} alpha - unit cell angle in degrees (default 90)
              	     * @param {number} beta - unit cell angle in degrees (default 90)
              	     * @param {number} gamma - unit cell angle in degrees (default 90)
              
              	     */
              setCrystData(A, $, S, C, D, O) {
                A = A || 1, $ = $ || 1, S = S || 1, C = C || 90, D = D || 90, O = O || 90;
                const N = (0, u.conversionMatrix3)(A, $, S, C, D, O);
                this.modelData.cryst = {
                  a: A,
                  b: $,
                  c: S,
                  alpha: C,
                  beta: D,
                  gamma: O,
                  matrix: N
                };
              }
              /**
               * Set the crystallographic matrix to the given matrix.
               *
               * This function removes `a`, `b`, `c`, `alpha`, `beta`, `gamma` from
               * the crystal data.
               *
               * @param {Matrix3} matrix - unit cell matrix
               */
              setCrystMatrix(A) {
                A = A || new u.Matrix3(1, 0, 0, 0, 1, 0, 0, 0, 1), this.modelData.cryst = {
                  matrix: A
                };
              }
              /**
               * Returns list of rotational/translational matrices if there is BIOMT data
               * Otherwise returns a list of just the ID matrix
               *
               * @return {Array<Matrix4>}
               *
               */
              getSymmetries() {
                return typeof this.modelData.symmetries > "u" && (this.modelData.symmetries = [this.idMatrix]), this.modelData.symmetries;
              }
              /**
               * Sets symmetries based on specified matrices in list
               *
               * @param {Array<Matrix4>} list
               *
               */
              setSymmetries(A) {
                typeof A > "u" ? this.modelData.symmetries = [this.idMatrix] : this.modelData.symmetries = A;
              }
              /**
               * Returns model id number
               *
               * @return {number} Model ID
               */
              getID() {
                return this.id;
              }
              /**
               * Returns model's frames property, a list of atom lists
               *
               * @return {number}
               */
              getNumFrames() {
                return this.frames.numFrames != null ? this.frames.numFrames : this.frames.length;
              }
              adjustCoord(A, $, S, C) {
                var D = $ - A;
                return D < -S ? $ + C : D > S ? $ - C : $;
              }
              //go over current atoms in depth first order and ensure that connected
              //attoms aren't split across the box
              adjustCoordinatesToBox() {
                if (this.box && this.atomdfs)
                  for (var A = this.box[0], $ = this.box[1], S = this.box[2], C = A * 0.9, D = $ * 0.9, O = S * 0.9, N = 0; N < this.atomdfs.length; N++)
                    for (var j = this.atomdfs[N], L = 1; L < j.length; L++) {
                      var z = this.atoms[j[L][0]], G = this.atoms[j[L][1]];
                      z.x = this.adjustCoord(G.x, z.x, C, A), z.y = this.adjustCoord(G.y, z.y, D, $), z.z = this.adjustCoord(G.z, z.z, O, S);
                    }
              }
              /**
               * Sets model's atomlist to specified frame
               * Sets to last frame if framenum out of range
               *
               * @param {number} framenum - model's atoms are set to this index in frames list
               * @return {Promise}
               */
              setFrame(A, $) {
                var S = this.getNumFrames();
                let C = this;
                return new Promise(function(D, O) {
                  if (S == 0 && D(), (A < 0 || A >= S) && (A = S - 1), C.frames.url != null) {
                    var N = C.frames.url;
                    (0, v.getbin)(N + "/traj/frame/" + A + "/" + C.frames.path, void 0, "POST", void 0).then(function(j) {
                      for (var L = new Float32Array(j, 44), z = 0, G = 0; G < C.atoms.length; G++)
                        C.atoms[G].x = L[z++], C.atoms[G].y = L[z++], C.atoms[G].z = L[z++];
                      C.box && C.atomdfs && C.adjustCoordinatesToBox(), D();
                    }).catch(O);
                  } else
                    C.atoms = C.frames[A], D();
                  C.molObj = null, C.modelDatas && A < C.modelDatas.length && (C.modelData = C.modelDatas[A], C.unitCellObjects && $ && ($.removeUnitCell(C), $.addUnitCell(C)));
                });
              }
              /**
               * Add atoms as frames of model
               *
               * @param {AtomSpec[]} atoms - atoms to be added
               */
              addFrame(A) {
                this.frames.push(A);
              }
              /**
              	     * If model atoms have dx, dy, dz properties (in some xyz files), vibrate populates the model's frame property based on parameters.
              	     * Model can then be animated
              	     *
              	     * @param {number} numFrames - number of frames to be created, default to 10
              	     * @param {number} amplitude - amplitude of distortion, default to 1 (full)
              	     * @param {boolean} bothWays - if true, extend both in positive and negative directions by numFrames
              	     * @param {GLViewer} viewer - required if arrowSpec is provided
              	     * @param {ArrowSpec} arrowSpec - specification for drawing animated arrows. If color isn't specified, atom color (sphere, stick, line preference) is used.
              	     *@example
              
              	      $3Dmol.download("pdb:4UAA",viewer,{},function(){
              	        viewer.setStyle({},{stick:{}});
              	        viewer.vibrate(10, 1);
              	        viewer.animate({loop: "forward",reps: 1});
              
              	        viewer.zoomTo();
              	              viewer.render();
              	          });
              	     */
              vibrate(A = 10, $ = 1, S = !1, C, D) {
                var O = 0, N = A;
                S && (O = -A, N = A), this.frames !== void 0 && this.frames.origIndex !== void 0 ? this.setFrame(this.frames.origIndex) : this.setFrame(0), O < N && (this.frames = []), S && (this.frames.origIndex = A);
                for (var j = O; j < N; j++) {
                  var L = [], z = this.frames.length;
                  if (j == 0 && !D) {
                    this.frames.push(this.atoms);
                    continue;
                  }
                  for (var G = 0; G < this.atoms.length; G++) {
                    var B = (0, v.getAtomProperty)(this.atoms[G], "dx"), F = (0, v.getAtomProperty)(this.atoms[G], "dy"), H = (0, v.getAtomProperty)(this.atoms[G], "dz"), W = new u.Vector3(B, F, H), V = new u.Vector3(this.atoms[G].x, this.atoms[G].y, this.atoms[G].z), X = j * $ / A;
                    W.multiplyScalar(X), V.add(W);
                    var Z = {};
                    for (var Q in this.atoms[G])
                      Z[Q] = this.atoms[G][Q];
                    if (Z.x = V.x, Z.y = V.y, Z.z = V.z, L.push(Z), C && D) {
                      var q = (0, v.extend)({}, D), J = new u.Vector3(B, F, H);
                      if (J.multiplyScalar($), J.add(V), q.start = V, q.end = J, q.frame = z, !q.color) {
                        var ie = Z.style.sphere;
                        ie || (ie = Z.style.stick), ie || (ie = Z.style.line), q.color = (0, v.getColorFromStyle)(Z, ie);
                      }
                      C.addArrow(q);
                    }
                  }
                  this.frames.push(L);
                }
              }
              // set default style and colors for atoms
              setAtomDefaults(A) {
                for (let $ = 0; $ < A.length; $++) {
                  let S = A[$];
                  S && (S.style = S.style || (0, v.deepCopy)(b.defaultAtomStyle), S.color = S.color || this.ElementColors[S.elem] || this.defaultColor, S.model = this.id, (S.clickable || S.hoverable) && (S.intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] }));
                }
              }
              /** add atoms to this model from molecular data string
               *
               * @param {string|ArrayBuffer} data - atom structure file input data string, for gzipped input use ArrayBuffer
               * @param {string} format - input file string format (e.g 'pdb', 'sdf', 'sdf.gz', etc.)
               * @param {ParserOptionsSpec} options - format dependent options. Attributes depend on the input format
               */
              addMolData(A, $, S = {}) {
                var C = b.parseMolData(A, $, S);
                this.dontDuplicateAtoms = !S.duplicateAssemblyAtoms;
                var D = C.modelData;
                if (D && (Array.isArray(D) ? (this.modelData = D[0], S.frames && (this.modelDatas = D)) : this.modelData = D), C.box ? this.box = C.box : this.box = null, this.frames.length == 0) {
                  for (let N = 0; N < C.length; N++)
                    C[N].length != 0 && this.frames.push(C[N]);
                  this.frames[0] && (this.atoms = this.frames[0]);
                } else if (S.frames)
                  for (let N = 0; N < C.length; N++)
                    this.frames.push(C[N]);
                else
                  for (var O = 0; O < C.length; O++)
                    this.addAtoms(C[O]);
                for (let N = 0; N < this.frames.length; N++)
                  this.setAtomDefaults(this.frames[N]);
                S.vibrate && S.vibrate.frames && S.vibrate.amplitude && this.vibrate(S.vibrate.frames, S.vibrate.amplitude), S.style && this.setStyle({}, S.style);
              }
              setDontDuplicateAtoms(A) {
                this.dontDuplicateAtoms = A;
              }
              setModelData(A) {
                this.modelData = A;
              }
              //return true if atom value matches property val
              propertyMatches(A, $) {
                if (A == $)
                  return !0;
                if (typeof $ == "string" && typeof A == "number") {
                  var S = $.match(/(-?\d+)\s*-\s*(-?\d+)/);
                  if (S) {
                    var C = parseInt(S[1]), D = parseInt(S[2]);
                    if (S && A >= C && A <= D)
                      return !0;
                  }
                }
                return !1;
              }
              // make a deep copy of a selection object and create caches of expensive
              // selections.  We create a copy so caches are not attached to user
              // supplied objects where the user might change them invalidating the cache.
              // This does not support arbitrary
              // javascript objects, but support enough for eveything that is
              // used in selections: number, string, boolean, functions; as well
              // as arrays and nested objects with values of the aformentioned
              // types.
              static deepCopyAndCache(A, $) {
                if (typeof A != "object" || A == null || A.__cache_created)
                  return A;
                const S = {};
                for (const C in A) {
                  const D = A[C];
                  if (Array.isArray(D)) {
                    S[C] = [];
                    for (let O = 0; O < D.length; O++)
                      S[C].push(b.deepCopyAndCache(D[O], $));
                  } else
                    typeof D == "object" && C != "properties" && C != "model" ? S[C] = b.deepCopyAndCache(D, $) : S[C] = D;
                  if (C == "and" || C == "or") {
                    const O = [];
                    for (const N of S[C]) {
                      const j = /* @__PURE__ */ new Set();
                      for (const L of $.selectedAtoms(N))
                        j.add(L.index);
                      O.push(j);
                    }
                    if (C == "and") {
                      const N = function(L, z) {
                        const G = /* @__PURE__ */ new Set();
                        for (const B of z)
                          L.has(B) && G.add(B);
                        return G;
                      };
                      let j = new Set(O[0]);
                      for (const L of O.splice(1))
                        j = N(j, L);
                      S[C].__cached_results = j;
                    } else if (C == "or") {
                      const N = /* @__PURE__ */ new Set();
                      for (const j of O)
                        for (const L of j)
                          N.add(L);
                      S[C].__cached_results = N;
                    }
                  }
                }
                return S.__cache_created = !0, S;
              }
              /** given a selection specification, return true if atom is selected.
               * Does not support context-aware selectors like expand/within/byres.
               *
               * @param {AtomSpec} atom
               * @param {AtomSelectionSpec} sel
               * @return {boolean}
               */
              atomIsSelected(A, $) {
                if (typeof $ > "u")
                  return !0;
                var S = !!$.invert, C = !0;
                for (var D in $)
                  if (D == "and" || D == "or" || D == "not") {
                    if (D == "not") {
                      if (this.atomIsSelected(A, $[D])) {
                        C = !1;
                        break;
                      }
                    } else if ($[D].__cached_results === void 0 && ($ = b.deepCopyAndCache($, this)), C = $[D].__cached_results.has(A.index), !C)
                      break;
                  } else if (D === "predicate") {
                    if (!$.predicate(A)) {
                      C = !1;
                      break;
                    }
                  } else if (D == "properties" && A[D]) {
                    for (var O in $.properties)
                      if (!O.startsWith("__cache")) {
                        if (typeof A.properties[O] > "u") {
                          C = !1;
                          break;
                        }
                        if (A.properties[O] != $.properties[O]) {
                          C = !1;
                          break;
                        }
                      }
                  } else if ($.hasOwnProperty(D) && !b.ignoredKeys.has(D) && !D.startsWith("__cache")) {
                    if (typeof A[D] > "u") {
                      C = !1;
                      break;
                    }
                    var N = !1;
                    if (D === "bonds") {
                      var j = $[D];
                      if (j != A.bonds.length) {
                        C = !1;
                        break;
                      }
                    } else if (Array.isArray($[D])) {
                      var L = $[D], z = A[D];
                      for (let G = 0; G < L.length; G++)
                        if (this.propertyMatches(z, L[G])) {
                          N = !0;
                          break;
                        }
                      if (!N) {
                        C = !1;
                        break;
                      }
                    } else {
                      let G = $[D];
                      if (!this.propertyMatches(A[D], G)) {
                        C = !1;
                        break;
                      }
                    }
                  }
                return S ? !C : C;
              }
              static squaredDistance(A, $) {
                var S = $.x - A.x, C = $.y - A.y, D = $.z - A.z;
                return S * S + C * C + D * D;
              }
              /** returns a list of atoms in the expanded bounding box, but not in the current one
               *
               *  Bounding box:
               *
               *    [ [ xmin, ymin, zmin ],
               *      [ xmax, ymax, zmax ],
               *      [ xctr, yctr, zctr ] ]
               *
               **/
              expandAtomList(A, $) {
                if ($ <= 0)
                  return A;
                for (var S = (0, v.getExtent)(A, void 0), C = [[], [], []], D = 0; D < 3; D++)
                  C[0][D] = S[0][D] - $, C[1][D] = S[1][D] + $, C[2][D] = S[2][D];
                var O = [];
                for (let z = 0; z < this.atoms.length; z++) {
                  var N = this.atoms[z].x, j = this.atoms[z].y, L = this.atoms[z].z;
                  N >= C[0][0] && N <= C[1][0] && j >= C[0][1] && j <= C[1][1] && L >= C[0][2] && L <= C[1][2] && (N >= S[0][0] && N <= S[1][0] && j >= S[0][1] && j <= S[1][1] && L >= S[0][2] && L <= S[1][2] || O.push(this.atoms[z]));
                }
                return O;
              }
              static getFloat(A) {
                return typeof A == "number" ? A : parseFloat(A);
              }
              /** return list of atoms selected by sel, this is specific to glmodel
               *
               * @param {AtomSelectionSpec} sel
               * @return {Object[]}
               * @example
               $3Dmol.download("pdb:4wwy",viewer,{},function(){
                        var atoms = viewer.selectedAtoms({chain:'A'});
                        for(var i = 0, n = atoms.length; i < n; i++) {
                           atoms[i].b = 0.0;
                        }
                        viewer.setStyle({cartoon:{colorscheme:{prop:'b',gradient: 'roygb',min:0,max:30}}});
                        viewer.render();
                    });
               */
              selectedAtoms(A, $) {
                var S = [];
                A = b.deepCopyAndCache(A || {}, this), $ || ($ = this.atoms);
                for (var C = $.length, D = 0; D < C; D++) {
                  var O = $[D];
                  O && this.atomIsSelected(O, A) && S.push(O);
                }
                if (A.hasOwnProperty("expand")) {
                  const Z = b.getFloat(A.expand);
                  let Q = this.expandAtomList(S, Z), q = S.length;
                  const J = Z * Z;
                  for (let ie = 0; ie < Q.length; ie++)
                    for (let ne = 0; ne < q; ne++) {
                      var N = b.squaredDistance(Q[ie], S[ne]);
                      N < J && N > 0 && S.push(Q[ie]);
                    }
                }
                if (A.hasOwnProperty("within") && A.within.hasOwnProperty("sel") && A.within.hasOwnProperty("distance")) {
                  var j = this.selectedAtoms(A.within.sel, this.atoms), L = {};
                  const Z = b.getFloat(A.within.distance), Q = Z * Z;
                  for (let q = 0; q < j.length; q++)
                    for (let J = 0; J < S.length; J++) {
                      let ie = b.squaredDistance(j[q], S[J]);
                      ie < Q && ie > 0 && (L[J] = 1);
                    }
                  var z = [];
                  if (A.within.invert)
                    for (let q = 0; q < S.length; q++)
                      L[q] || z.push(S[q]);
                  else
                    for (let q in L)
                      z.push(S[q]);
                  S = z;
                }
                if (A.hasOwnProperty("byres")) {
                  var G = {}, B = [], F = [];
                  for (let Z = 0; Z < S.length; Z++) {
                    let Q = S[Z];
                    var H = Q.chain, W = Q.resi;
                    if (G[H] === void 0 && (G[H] = {}), Q.hasOwnProperty("resi") && G[H][W] === void 0) {
                      for (G[H][W] = !0, F.push(Q); F.length > 0; )
                        if (Q = F.pop(), H = Q.chain, W = Q.resi, B[Q.index] === void 0) {
                          B[Q.index] = !0;
                          for (var V = 0; V < Q.bonds.length; V++) {
                            var X = this.atoms[Q.bonds[V]];
                            B[X.index] === void 0 && X.hasOwnProperty("resi") && X.chain == H && X.resi == W && (F.push(X), S.push(X));
                          }
                        }
                    }
                  }
                }
                return S;
              }
              /** Add list of new atoms to model.  Adjusts bonds appropriately.
              	     *
              	     * @param {AtomSpec[]} newatoms
              	     * @example
              	     * var atoms = [{elem: 'C', x: 0, y: 0, z: 0, bonds: [1,2], bondOrder: [1,2]}, {elem: 'O', x: -1.5, y: 0, z: 0, bonds: [0]},{elem: 'O', x: 1.5, y: 0, z: 0, bonds: [0], bondOrder: [2]}];
              
              	        viewer.setBackgroundColor(0xffffffff);
              	        var m = viewer.addModel();
              	        m.addAtoms(atoms);
              	        m.setStyle({},{stick:{}});
              	        viewer.zoomTo();
              	        viewer.render();
              	     */
              addAtoms(A) {
                this.molObj = null;
                var $ = this.atoms.length, S = [], C;
                for (C = 0; C < A.length; C++)
                  typeof A[C].index > "u" && (A[C].index = C), typeof A[C].serial > "u" && (A[C].serial = C), S[A[C].index] = $ + C;
                for (C = 0; C < A.length; C++) {
                  var D = A[C], O = S[D.index], N = (0, v.extend)({}, D);
                  N.index = O, N.bonds = [], N.bondOrder = [], N.model = this.id, N.style = N.style || (0, v.deepCopy)(b.defaultAtomStyle), typeof N.color > "u" && (N.color = this.ElementColors[N.elem] || this.defaultColor);
                  for (var j = D.bonds ? D.bonds.length : 0, L = 0; L < j; L++) {
                    var z = S[D.bonds[L]];
                    typeof z < "u" && (N.bonds.push(z), N.bondOrder.push(D.bondOrder ? D.bondOrder[L] : 1));
                  }
                  this.atoms.push(N);
                }
              }
              /** Assign bonds based on atomic coordinates.
               *  This currently uses a primitive distance-based algorithm that does not
               * consider valence constraints and will only create single bonds.
               */
              assignBonds() {
                (0, R.assignBonds)(this.atoms, { assignBonds: !0 });
              }
              /** Remove specified atoms from model
               *
               * @param {AtomSpec[]} badatoms - list of atoms
               */
              removeAtoms(A) {
                this.molObj = null;
                var $ = [], S;
                for (S = 0; S < A.length; S++)
                  $[A[S].index] = !0;
                var C = [];
                for (S = 0; S < this.atoms.length; S++) {
                  var D = this.atoms[S];
                  $[D.index] || C.push(D);
                }
                this.atoms = [], this.addAtoms(C);
              }
              /** Set atom style of selected atoms
              	     *
              	     * @param {AtomSelectionSpec} sel
              	     * @param {AtomStyleSpec} style
              	     * @param {boolean} add - if true, add to current style, don't replace
              	     @example
              	    $3Dmol.download("pdb:4UB9",viewer,{},function(){
              	              viewer.setBackgroundColor(0xffffffff);
              
              	              viewer.setStyle({chain:'A'},{line:{hidden:true,colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.Sinebow($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});
              	              viewer.setStyle({chain:'B'},{line:{colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.Sinebow($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});
              	              viewer.setStyle({chain:'C'},{cross:{hidden:true,colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.Sinebow($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});
              	              viewer.setStyle({chain:'D'},{cross:{colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.RWB($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});
              	              viewer.setStyle({chain:'E'},{cross:{radius:2.0,colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.RWB($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});
              	              viewer.setStyle({chain:'F'},{stick:{hidden:true,colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.RWB($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});
              	              viewer.setStyle({chain:'G'},{stick:{radius:0.8,colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.ROYGB($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});
              	              viewer.setStyle({chain:'H'},{stick:{singleBonds:true,colorscheme:{prop:'b',gradient: new $3Dmol.Gradient.ROYGB($3Dmol.getPropertyRange(viewer.selectedAtoms(),'b'))}}});
              	              viewer.render();
              	          });
              	     */
              setStyle(A, $, S) {
                typeof $ > "u" && typeof S > "u" && ($ = A, A = {}), A = A, typeof $ == "string" && ($ = (0, v.specStringToObject)($));
                var C = !1, D = this, O = function(j) {
                  var L = D.selectedAtoms(A, j);
                  for (let z = 0; z < j.length; z++)
                    j[z] && (j[z].capDrawn = !1);
                  for (let z = 0; z < L.length; z++) {
                    C = !0, (L[z].clickable || L[z].hoverable) && (L[z].intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] }), S || (L[z].style = {});
                    for (let G in $)
                      $.hasOwnProperty(G) && (L[z].style[G] = L[z].style[G] || {}, Object.assign(L[z].style[G], $[G]));
                  }
                };
                if (A.frame !== void 0 && A.frame < this.frames.length) {
                  let j = A.frame;
                  j < 0 && (j = this.frames.length + j), O(this.frames[j]);
                } else {
                  O(this.atoms);
                  for (var N = 0; N < this.frames.length; N++)
                    this.frames[N] !== this.atoms && O(this.frames[N]);
                }
                C && (this.molObj = null);
              }
              /** Set clickable and callback of selected atoms
              	     *
              	     * @param {AtomSelectionSpec} sel - atom selection to apply clickable settings to
              	     * @param {boolean} clickable - whether click-handling is enabled for the selection
              	     * @param {function} callback - function called when an atom in the selection is clicked
              
              	     */
              setClickable(A, $, S) {
                if ($ = !!$, S = (0, v.makeFunction)(S), S === null) {
                  console.log("Callback is not a function");
                  return;
                }
                var C = this.selectedAtoms(A, this.atoms), D = C.length;
                for (let O = 0; O < D; O++)
                  C[O].intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] }, C[O].clickable = $, S && (C[O].callback = S);
                D > 0 && (this.molObj = null);
              }
              /** Set hoverable and callback of selected atoms
              *
              * @param {AtomSelectionSpec} sel - atom selection to apply hoverable settings to
              * @param {boolean} hoverable - whether hover-handling is enabled for the selection
              * @param {function} hover_callback - function called when an atom in the selection is hovered over
              * @param {function} unhover_callback - function called when the mouse moves out of the hover area
              */
              setHoverable(A, $, S, C) {
                if ($ = !!$, S = (0, v.makeFunction)(S), C = (0, v.makeFunction)(C), S === null) {
                  console.log("Hover_callback is not a function");
                  return;
                }
                if (C === null) {
                  console.log("Unhover_callback is not a function");
                  return;
                }
                var D = this.selectedAtoms(A, this.atoms), O = D.length;
                for (let N = 0; N < O; N++)
                  D[N].intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] }, D[N].hoverable = $, S && (D[N].hover_callback = S), C && (D[N].unhover_callback = C);
                O > 0 && (this.molObj = null);
              }
              /** enable context menu of selected atoms
               *
               * @param {AtomSelectionSpec} sel - atom selection to apply hoverable settings to
               * @param {boolean} contextMenuEnabled - whether contextMenu-handling is enabled for the selection
               */
              enableContextMenu(A, $) {
                $ = !!$;
                var S, C = this.selectedAtoms(A, this.atoms), D = C.length;
                for (S = 0; S < D; S++)
                  C[S].intersectionShape = { sphere: [], cylinder: [], line: [], triangle: [] }, C[S].contextMenuEnabled = $;
                D > 0 && (this.molObj = null);
              }
              /** given a mapping from element to color, set atom colors
               *
               * @param {AtomSelectionSpec} sel
               * @param {object} colors
               */
              setColorByElement(A, $) {
                if (!(this.molObj !== null && b.sameObj($, this.lastColors))) {
                  this.lastColors = $;
                  var S = this.selectedAtoms(A, S);
                  S.length > 0 && (this.molObj = null);
                  for (var C = 0; C < S.length; C++) {
                    var D = S[C];
                    typeof $[D.elem] < "u" && (D.color = $[D.elem]);
                  }
                }
              }
              /**
               * @param {AtomSelectionSpec} sel
               * @param {string} prop
               * @param {Gradient|string} scheme
               */
              setColorByProperty(A, $, S, C) {
                var D, O, N = this.selectedAtoms(A, N);
                for (this.lastColors = null, N.length > 0 && (this.molObj = null), typeof S == "string" && typeof g.Gradient.builtinGradients[S] < "u" && (S = new g.Gradient.builtinGradients[S]()), S = S, C || (C = S.range()), C || (C = (0, v.getPropertyRange)(N, $)), D = 0; D < N.length; D++) {
                  O = N[D];
                  var j = (0, v.getAtomProperty)(O, $);
                  j != null && (O.color = S.valueToHex(parseFloat(O.properties[$]), C));
                }
              }
              /**
              	     * @deprecated use setStyle and colorfunc attribute
              	     * @param {AtomSelectionSpec} sel - selection object
              	     * @param {function} func - function to be used to set the color
              	     @example
              	      $3Dmol.download("pdb:4UAA",viewer,{},function(){
              	              viewer.setBackgroundColor(0xffffffff);
              	              var colorAsSnake = function(atom) {
              	                return atom.resi % 2 ? 'white': 'green'
              	              };
              
              	              viewer.setStyle( {}, { cartoon: {colorfunc: colorAsSnake }});
              
              	              viewer.render();
              	          });
              
              	     */
              setColorByFunction(A, $) {
                var S = this.selectedAtoms(A, S);
                if (typeof $ == "function") {
                  this.lastColors = null, S.length > 0 && (this.molObj = null);
                  for (let C = 0; C < S.length; C++) {
                    let D = S[C];
                    D.color = $(D);
                  }
                }
              }
              /** Convert the model into an object in the format of a ChemDoodle JSON model.
               *
               * @param {boolean} whether or not to include style information. Defaults to false.
               * @return {Object}
               */
              toCDObject(A = !1) {
                var $ = { a: [], b: [] };
                A && ($.s = []);
                for (let C = 0; C < this.atoms.length; C++) {
                  let D = {}, O = this.atoms[C];
                  if (D.x = O.x, D.y = O.y, D.z = O.z, O.elem != "C" && (D.l = O.elem), A) {
                    for (var S = 0; S < $.s.length && JSON.stringify(O.style) !== JSON.stringify($.s[S]); )
                      S++;
                    S === $.s.length && $.s.push(O.style), S !== 0 && (D.s = S);
                  }
                  $.a.push(D);
                  for (let N = 0; N < O.bonds.length; N++) {
                    let j = C, L = O.bonds[N];
                    if (j >= L)
                      continue;
                    let z = {
                      b: j,
                      e: L
                    }, G = O.bondOrder[N];
                    G != 1 && (z.o = G), $.b.push(z);
                  }
                }
                return $;
              }
              /** manage the globj for this model in the possed modelGroup - if it has to be regenerated, remove and add
               *
               * @param {Object3D} group
               * @param Object options
               */
              globj(A, $) {
                (this.molObj === null || $.regen) && (this.molObj = this.createMolObj(this.atoms, $), this.renderedMolObj && (A.remove(this.renderedMolObj), this.renderedMolObj = null), this.renderedMolObj = this.molObj.clone(), this.hidden && (this.renderedMolObj.setVisible(!1), this.molObj.setVisible(!1)), A.add(this.renderedMolObj));
              }
              /** return a VRML string representation of the model.  Does not include VRML header information
               * @return VRML
               */
              exportVRML() {
                var A = this.createMolObj(this.atoms, { supportsImposters: !1, supportsAIA: !1 });
                return A.vrml();
              }
              /** Remove any renderable mol object from scene
               *
               * @param {Object3D} group
               */
              removegl(A) {
                this.renderedMolObj && (this.renderedMolObj.geometry !== void 0 && this.renderedMolObj.geometry.dispose(), this.renderedMolObj.material !== void 0 && this.renderedMolObj.material.dispose(), A.remove(this.renderedMolObj), this.renderedMolObj = null), this.molObj = null;
              }
              /**
              	     * Don't show this model in future renderings. Keep all styles and state
              	     * so it can be efficiencly shown again.
              	     *
              	     * * @see GLModel#show
              
              	     * @example
              	        $3Dmol.download("pdb:3ucr",viewer,{},function(){
              	        viewer.setStyle({},{stick:{}});
              	        viewer.getModel().hide();
              	        viewer.render();
              	        });
              	     */
              hide() {
                this.hidden = !0, this.renderedMolObj && this.renderedMolObj.setVisible(!1), this.molObj && this.molObj.setVisible(!1);
              }
              /**
               * Unhide a hidden model
               * @see GLModel#hide
               * @example
                  $3Dmol.download("pdb:3ucr",viewer,{},function(){
                  viewer.setStyle({},{stick:{}});
                  viewer.getModel().hide();
                  viewer.render(  )
                  viewer.getModel().show()
                  viewer.render();
                  });
               */
              show() {
                this.hidden = !1, this.renderedMolObj && this.renderedMolObj.setVisible(!0), this.molObj && this.molObj.setVisible(!0);
              }
              /** Create labels for atoms that show the value of the passed property.
               *
               * @param {String} prop - property name
               * @param {AtomSelectionSpec} sel
               * @param {GLViewer} viewer
               * @param {LabelSpec} options
               */
              addPropertyLabels(A, $, S, C) {
                for (var D = this.selectedAtoms($, D), O = (0, v.deepCopy)(C), N = 0; N < D.length; N++) {
                  var j = D[N], L = null;
                  typeof j[A] < "u" ? L = String(j[A]) : typeof j.properties[A] < "u" && (L = String(j.properties[A])), L != null && (O.position = j, S.addLabel(L, O));
                }
              }
              /** Create labels for residues of selected atoms.
               * Will create a single label at the center of mass of all atoms
               * with the same chain,resn, and resi.
               *
               * @param {AtomSelectionSpec} sel
               * @param {GLViewer} viewer
               * @param {LabelSpec} options
               * @param {boolean} byframe - if true, create labels for every individual frame, not just current; frames must be loaded already
               */
              addResLabels(A, $, S, C = !1) {
                var D = [], O = function(j, L) {
                  for (var z = j.selectedAtoms(A, z), G = {}, B = 0; B < z.length; B++) {
                    var F = z[B], H = F.chain, W = F.resn, V = F.resi, X = W + "" + V;
                    G[H] || (G[H] = {}), G[H][X] || (G[H][X] = []), G[H][X].push(F);
                  }
                  var Z = (0, v.deepCopy)(S);
                  for (let q in G)
                    if (G.hasOwnProperty(q)) {
                      var Q = G[q];
                      for (let J in Q)
                        if (Q.hasOwnProperty(J)) {
                          let ie = Q[J], ne = new u.Vector3(0, 0, 0);
                          for (let ye = 0; ye < ie.length; ye++) {
                            let xe = ie[ye];
                            ne.x += xe.x, ne.y += xe.y, ne.z += xe.z;
                          }
                          ne.divideScalar(ie.length), Z.position = ne, Z.frame = L;
                          let ge = $.addLabel(J, Z, void 0, !0);
                          D.push(ge);
                        }
                    }
                };
                if (C) {
                  var N = this.getNumFrames();
                  let j = this.atoms;
                  for (let L = 0; L < N; L++)
                    this.frames[L] && (this.atoms = this.frames[L], O(this, L));
                  this.atoms = j;
                } else
                  O(this);
                return D;
              }
              //recurse over the current atoms to establish a depth first order
              setupDFS() {
                this.atomdfs = [];
                var A = this, $ = new Int8Array(this.atoms.length);
                $.fill(0);
                for (var S = function(N, j, L) {
                  L.push([N, j]);
                  var z = A.atoms[N];
                  $[N] = 1;
                  for (var G = 0; G < z.bonds.length; G++) {
                    var B = z.bonds[G];
                    A.atoms[B] && !$[B] && S(B, N, L);
                  }
                }, C = 0; C < this.atoms.length; C++) {
                  var D = this.atoms[C];
                  if (D && !$[C]) {
                    var O = [];
                    S(C, -1, O), this.atomdfs.push(O);
                  }
                }
              }
              /**
              * Set coordinates from remote trajectory file.
              * @param {string} url - contains the url where mdsrv has been hosted
              * @param {string} path - contains the path of the file (<root>/filename)
              * @return {Promise}
              */
              setCoordinatesFromURL(A, $) {
                this.frames = [];
                var S = this;
                return this.box && this.setupDFS(), A.startsWith("http") || (A = "http://" + A), (0, v.get)(A + "/traj/numframes/" + $, function(C) {
                  if (!isNaN(parseInt(C)))
                    return S.frames.push(S.atoms), S.frames.numFrames = C, S.frames.url = A, S.frames.path = $, S.setFrame(0);
                });
              }
              /**
              * Set coordinates for the atoms from provided trajectory file.
              * @param {string|ArrayBuffer} str - contains the data of the file
              * @param {string} format - contains the format of the file (mdcrd, inpcrd, pdb, netcdf, or array).  Arrays should be TxNx3 where T is the number of timesteps and N the number of atoms.
                @example
                   let m = viewer.addModel()  //create an empty model
                   m.addAtoms([{x:0,y:0,z:0,elem:'C'},{x:2,y:0,z:0,elem:'C'}]) //provide a list of dictionaries representing the atoms
                   viewer.setStyle({'sphere':{}})
                   m.setCoordinates([[[0.0, 0.0, 0.0], [2.0, 0.0, 0.0]], [[0.0, 0.0, 0.0], [2.8888888359069824, 0.0, 0.0]], [[0.0, 0.0, 0.0], [3.777777671813965, 0.0, 0.0]], [[0.0, 0.0, 0.0], [4.666666507720947, 0.0, 0.0]], [[0.0, 0.0, 0.0], [5.55555534362793, 0.0, 0.0]], [[0.0, 0.0, 0.0], [6.44444465637207, 0.0, 0.0]], [[0.0, 0.0, 0.0], [7.333333492279053, 0.0, 0.0]], [[0.0, 0.0, 0.0], [8.222222328186035, 0.0, 0.0]], [[0.0, 0.0, 0.0], [9.11111068725586, 0.0, 0.0]], [[0.0, 0.0, 0.0], [10.0, 0.0, 0.0]]],'array');
                   viewer.animate({loop: "forward",reps: 1});
                   viewer.zoomTo();
                   viewer.zoom(0.5);
                   viewer.render();
              */
              setCoordinates(A, $) {
                if ($ = $ || "", !A)
                  return [];
                if (/\.gz$/.test($)) {
                  $ = $.replace(/\.gz$/, "");
                  try {
                    A = _(A);
                  } catch (G) {
                    console.log(G);
                  }
                }
                var S = { mdcrd: "", inpcrd: "", pdb: "", netcdf: "", array: "" };
                if (S.hasOwnProperty($)) {
                  this.frames = [];
                  for (var C = this.atoms.length, D = b.parseCrd(A, $), O = 0; O < D.length; ) {
                    for (var N = [], j = 0; j < C; j++) {
                      var L = {};
                      for (var z in this.atoms[j])
                        L[z] = this.atoms[j][z];
                      N[j] = L, N[j].x = D[O++], N[j].y = D[O++], N[j].z = D[O++];
                    }
                    this.frames.push(N);
                  }
                  return this.atoms = this.frames[0], this.frames;
                }
                return [];
              }
              /**
               * add atomSpecs to validAtomSelectionSpecs
               * @deprecated
               * @param {Array} customAtomSpecs - array of strings that can be used as atomSelectionSpecs
               * this is to prevent the 'Unknown Selector x' message on the console for the strings passed.
               * These messages are no longer generated as, in theory, typescript will catch problems at compile time.
               * In practice, there may still be issues at run-time but we don't check for them...
               *
               * What we should do is use something like https://github.com/woutervh-/typescript-is to do runtime
               * type checking, but it currently doesn't work with our types...
               */
              addAtomSpecs(A) {
              }
              static parseCrd(A, $) {
                var S = [], C = 0;
                if ($ == "pdb")
                  for (var D = A.indexOf(`
ATOM`); D != -1; ) {
                    for (; A.slice(D, D + 5) == `
ATOM` || A.slice(D, D + 7) == `
HETATM`; )
                      S[C++] = parseFloat(A.slice(D + 31, D + 39)), S[C++] = parseFloat(A.slice(D + 39, D + 47)), S[C++] = parseFloat(A.slice(D + 47, D + 55)), D = A.indexOf(`
`, D + 54), A.slice(D, D + 4) == `
TER` && (D = A.indexOf(`
`, D + 5));
                    D = A.indexOf(`
ATOM`, D);
                  }
                else if ($ == "netcdf") {
                  var O = new E.NetCDFReader(A);
                  S = [].concat.apply([], O.getDataVariable("coordinates"));
                } else {
                  if ($ == "array" || Array.isArray(A))
                    return A.flat(2);
                  {
                    let N = A.indexOf(`
`);
                    $ == "inpcrd" && (N = A.indexOf(`
`, N + 1)), A = A.slice(N + 1), S = A.match(/\S+/g).map(parseFloat);
                  }
                }
                return S;
              }
              static parseMolData(A, $ = "", S) {
                if (!A)
                  return [];
                if (/\.gz$/.test($)) {
                  $ = $.replace(/\.gz$/, "");
                  try {
                    A = _(A);
                  } catch (O) {
                    console.log(O);
                  }
                }
                typeof w.Parsers[$] > "u" && ($ = $.split(".").pop(), typeof w.Parsers[$] > "u" && (console.log("Unknown format: " + $), A instanceof Uint8Array ? $ = "mmtf" : A.match(/^@<TRIPOS>MOLECULE/gm) ? $ = "mol2" : A.match(/^data_/gm) && A.match(/^loop_/gm) ? $ = "cif" : A.match(/^HETATM/gm) || A.match(/^ATOM/gm) ? $ = "pdb" : A.match(/ITEM: TIMESTEP/gm) ? $ = "lammpstrj" : A.match(/^.*\n.*\n.\s*(\d+)\s+(\d+)/gm) ? $ = "sdf" : A.match(/^%VERSION\s+VERSION_STAMP/gm) ? $ = "prmtop" : $ = "xyz", console.log("Best guess: " + $)));
                var C = w.Parsers[$], D = C(A, S);
                return D;
              }
            }
            b.defaultAtomStyle = {
              line: {}
            }, b.defaultlineWidth = 1, b.vdwRadii = {
              H: 1.2,
              He: 1.4,
              Li: 1.82,
              Be: 1.53,
              B: 1.92,
              C: 1.7,
              N: 1.55,
              O: 1.52,
              F: 1.47,
              Ne: 1.54,
              Na: 2.27,
              Mg: 1.73,
              Al: 1.84,
              Si: 2.1,
              P: 1.8,
              S: 1.8,
              Cl: 1.75,
              Ar: 1.88,
              K: 2.75,
              Ca: 2.31,
              Ni: 1.63,
              Cu: 1.4,
              Zn: 1.39,
              Ga: 1.87,
              Ge: 2.11,
              As: 1.85,
              Se: 1.9,
              Br: 1.85,
              Kr: 2.02,
              Rb: 3.03,
              Sr: 2.49,
              Pd: 1.63,
              Ag: 1.72,
              Cd: 1.58,
              In: 1.93,
              Sn: 2.17,
              Sb: 2.06,
              Te: 2.06,
              I: 1.98,
              Xe: 2.16,
              Cs: 3.43,
              Ba: 2.68,
              Pt: 1.75,
              Au: 1.66,
              Hg: 1.55,
              Tl: 1.96,
              Pb: 2.02,
              Bi: 2.07,
              Po: 1.97,
              At: 2.02,
              Rn: 2.2,
              Fr: 3.48,
              Ra: 2.83,
              U: 1.86
            }, b.ignoredKeys = /* @__PURE__ */ new Set(["props", "invert", "model", "frame", "byres", "expand", "within", "and", "or", "not"]);
          }
        ),
        /***/
        "./src/GLShape.ts": (
          /*!************************!*\
            !*** ./src/GLShape.ts ***!
            \************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              GLShape: () => (
                /* binding */
                E
              ),
              /* harmony export */
              splitMesh: () => (
                /* binding */
                T
              )
              /* harmony export */
            });
            var o = n(
              /*! ./WebGL */
              "./src/WebGL/index.ts"
            ), l = n(
              /*! ./WebGL/shapes */
              "./src/WebGL/shapes/index.ts"
            ), u = n(
              /*! ./WebGL/math */
              "./src/WebGL/math/index.ts"
            ), f = n(
              /*! ./colors */
              "./src/colors.ts"
            ), h = n(
              /*! ./ProteinSurface4 */
              "./src/ProteinSurface4.ts"
            ), p = n(
              /*! ./VolumeData */
              "./src/VolumeData.ts"
            ), v = n(
              /*! ./GLDraw */
              "./src/GLDraw.ts"
            ), g = n(
              /*! ./glcartoon */
              "./src/glcartoon.ts"
            ), w = n(
              /*! ./utilities */
              "./src/utilities.ts"
            );
            class E {
              static finalizeGeo(_) {
                var b = _.updateGeoGroup(0);
                b.vertices > 0 && b.truncateArrayBuffers(!0, !0);
              }
              /*
               *
               * @param {Geometry}
               *            geo
               * @param {Color | colorlike} color
               */
              static updateColor(_, b) {
                b = b || f.CC.color(b), _.colorsNeedUpdate = !0;
                var M, A, $;
                b.constructor !== Array && (M = b.r, A = b.g, $ = b.b);
                for (let S in _.geometryGroups) {
                  let C = _.geometryGroups[S], D = C.colorArray;
                  for (let O = 0, N = C.vertices; O < N; ++O) {
                    if (b.constructor === Array) {
                      let j = b[O];
                      M = j.r, A = j.g, $ = j.b;
                    }
                    D[O * 3] = M, D[O * 3 + 1] = A, D[O * 3 + 2] = $;
                  }
                }
              }
              /*
               * @param {GLShape}
               *            shape
               * @param {geometryGroup}
               *            geoGroup
               * @param {ArrowSpec}
               *            spec
               */
              static drawArrow(_, b, M) {
                var A = M.start, $ = M.end, S = M.radius, C = M.radiusRatio, D = M.mid, O = M.midpos;
                if (!(A && $))
                  return;
                var N = b.updateGeoGroup(51), j = new u.Vector3($.x, $.y, $.z).sub(A);
                if (O) {
                  let Ee = j.length();
                  O > 0 ? D = O / Ee : D = (Ee + O) / Ee;
                }
                j.multiplyScalar(D);
                var L = new u.Vector3(A.x, A.y, A.z).add(j), z = j.clone().negate();
                let G = new u.Vector3(A.x, A.y, A.z);
                _.intersectionShape.cylinder.push(new l.Cylinder(G, L.clone(), S)), _.intersectionShape.sphere.push(new l.Sphere(G, S));
                var B = [];
                B[0] = j.clone(), Math.abs(B[0].x) > 1e-4 ? B[0].y += 1 : B[0].x += 1, B[0].cross(j), B[0].normalize(), B[4] = B[0].clone(), B[4].crossVectors(B[0], j), B[4].normalize(), B[8] = B[0].clone().negate(), B[12] = B[4].clone().negate(), B[2] = B[0].clone().add(B[4]).normalize(), B[6] = B[4].clone().add(B[8]).normalize(), B[10] = B[8].clone().add(B[12]).normalize(), B[14] = B[12].clone().add(B[0]).normalize(), B[1] = B[0].clone().add(B[2]).normalize(), B[3] = B[2].clone().add(B[4]).normalize(), B[5] = B[4].clone().add(B[6]).normalize(), B[7] = B[6].clone().add(B[8]).normalize(), B[9] = B[8].clone().add(B[10]).normalize(), B[11] = B[10].clone().add(B[12]).normalize(), B[13] = B[12].clone().add(B[14]).normalize(), B[15] = B[14].clone().add(B[0]).normalize();
                var F = N.vertices, H = N.vertexArray, W = N.faceArray, V = N.normalArray, X = N.lineArray, Z, Q, q;
                for (Q = 0, q = B.length; Q < q; ++Q) {
                  Z = 3 * (F + 3 * Q);
                  var J = B[Q].clone().multiplyScalar(S).add(A), ie = B[Q].clone().multiplyScalar(S).add(L), ne = B[Q].clone().multiplyScalar(S * C).add(L);
                  if (H[Z] = J.x, H[Z + 1] = J.y, H[Z + 2] = J.z, H[Z + 3] = ie.x, H[Z + 4] = ie.y, H[Z + 5] = ie.z, H[Z + 6] = ne.x, H[Z + 7] = ne.y, H[Z + 8] = ne.z, Q > 0) {
                    var ge = H[Z - 3], ye = H[Z - 2], xe = H[Z - 1], we = new u.Vector3(ge, ye, xe), de = new u.Vector3($.x, $.y, $.z), Te = L.clone(), Ce = new u.Vector3(ne.x, ne.y, ne.z);
                    _.intersectionShape.triangle.push(new l.Triangle(Ce, de, we)), _.intersectionShape.triangle.push(new l.Triangle(we.clone(), Te, Ce.clone()));
                  }
                }
                N.vertices += 48, Z = N.vertices * 3, H[Z] = A.x, H[Z + 1] = A.y, H[Z + 2] = A.z, H[Z + 3] = L.x, H[Z + 4] = L.y, H[Z + 5] = L.z, H[Z + 6] = $.x, H[Z + 7] = $.y, H[Z + 8] = $.z, N.vertices += 3;
                var ee, Ae, be, Fe, et, Ye, De, Ue, Qe, ue, te, Be, Je, ft, lt, he, ae, se, Re, Oe = N.vertices - 3, We = N.vertices - 2, Ct = N.vertices - 1, le = Oe * 3, ke = We * 3, Ke = Ct * 3;
                for (Q = 0, q = B.length - 1; Q < q; ++Q) {
                  var me = F + 3 * Q;
                  Z = me * 3, Ae = N.faceidx, be = N.lineidx, Fe = me, ue = Fe * 3, et = me + 1, te = et * 3, Ye = me + 2, Be = Ye * 3, De = me + 4, Je = De * 3, Ue = me + 5, ft = Ue * 3, Qe = me + 3, lt = Qe * 3, he = ae = B[Q], se = Re = B[Q + 1], V[ue] = he.x, V[te] = ae.x, V[lt] = Re.x, V[ue + 1] = he.y, V[te + 1] = ae.y, V[lt + 1] = Re.y, V[ue + 2] = he.z, V[te + 2] = ae.z, V[lt + 2] = Re.z, V[te] = ae.x, V[Je] = se.x, V[lt] = Re.x, V[te + 1] = ae.y, V[Je + 1] = se.y, V[lt + 1] = Re.y, V[te + 2] = ae.z, V[Je + 2] = se.z, V[lt + 2] = Re.z, V[Be] = ae.x, V[ft] = se.x, V[Be + 1] = ae.y, V[ft + 1] = se.y, V[Be + 2] = ae.z, V[ft + 2] = se.z, W[Ae] = Fe, W[Ae + 1] = et, W[Ae + 2] = Qe, W[Ae + 3] = et, W[Ae + 4] = De, W[Ae + 5] = Qe, W[Ae + 6] = Fe, W[Ae + 7] = Qe, W[Ae + 8] = Oe, W[Ae + 9] = Ye, W[Ae + 10] = We, W[Ae + 11] = Ue, W[Ae + 12] = Ye, W[Ae + 13] = Ct, W[Ae + 14] = Ue, X[be] = Fe, X[be + 1] = et, X[be + 2] = Fe, X[be + 3] = Qe, X[be + 4] = De, X[be + 5] = Qe, X[be + 6] = Fe, X[be + 7] = Qe, X[be + 8] = Ye, X[be + 9] = et, X[be + 10] = Ye, X[be + 11] = Ue, X[be + 12] = De, X[be + 13] = Ue, X[be + 14] = Ye, X[be + 15] = Ct, X[be + 16] = Ye, X[be + 17] = Ue, X[be + 18] = Ct, X[be + 19] = Ue, N.faceidx += 15, N.lineidx += 20;
                }
                ee = [
                  F + 45,
                  F + 46,
                  F + 1,
                  F,
                  F + 47,
                  F + 2
                ], Ae = N.faceidx, be = N.lineidx, Fe = ee[0], ue = Fe * 3, et = ee[1], te = et * 3, Ye = ee[4], Be = Ye * 3, De = ee[2], Je = De * 3, Ue = ee[5], ft = Ue * 3, Qe = ee[3], lt = Qe * 3, he = ae = B[15], se = Re = B[0], V[ue] = he.x, V[te] = ae.x, V[lt] = Re.x, V[ue + 1] = he.y, V[te + 1] = ae.y, V[lt + 1] = Re.y, V[ue + 2] = he.z, V[te + 2] = ae.z, V[lt + 2] = Re.z, V[te] = ae.x, V[Je] = se.x, V[lt] = Re.x, V[te + 1] = ae.y, V[Je + 1] = se.y, V[lt + 1] = Re.y, V[te + 2] = ae.z, V[Je + 2] = se.z, V[lt + 2] = Re.z, V[Be] = ae.x, V[ft] = se.x, V[Be + 1] = ae.y, V[ft + 1] = se.y, V[Be + 2] = ae.z, V[ft + 2] = se.z, j.normalize(), z.normalize(), V[le] = z.x, V[ke] = V[Ke] = j.x, V[le + 1] = z.y, V[ke + 1] = V[Ke + 1] = j.y, V[le + 2] = z.z, V[ke + 2] = V[Ke + 2] = j.z, W[Ae] = Fe, W[Ae + 1] = et, W[Ae + 2] = Qe, W[Ae + 3] = et, W[Ae + 4] = De, W[Ae + 5] = Qe, W[Ae + 6] = Fe, W[Ae + 7] = Qe, W[Ae + 8] = Oe, W[Ae + 9] = Ye, W[Ae + 10] = We, W[Ae + 11] = Ue, W[Ae + 12] = Ye, W[Ae + 13] = Ct, W[Ae + 14] = Ue, X[be] = Fe, X[be + 1] = et, X[be + 2] = Fe, X[be + 3] = Qe, X[be + 4] = De, X[be + 5] = Qe, X[be + 6] = Fe, X[be + 7] = Qe, X[be + 8] = Ye, X[be + 9] = et, X[be + 10] = Ye, X[be + 11] = Ue, X[be + 12] = De, X[be + 13] = Ue, X[be + 14] = Ye, X[be + 15] = Ct, X[be + 16] = Ye, X[be + 17] = Ue, X[be + 18] = Ct, X[be + 19] = Ue, N.faceidx += 15, N.lineidx += 20;
              }
              // Update a bounding sphere's position and radius
              // from list of centroids and new points
              /*
               * @param {Sphere}
               *            sphere
               * @param {Object}
               *            components, centroid of all objects in shape
               * @param {Array}
               *            points, flat array of all points in shape
               * @param {int} numPoints, number of valid poitns in points
               */
              static updateBoundingFromPoints(_, b, M, A) {
                _.center.set(0, 0, 0);
                let $ = 1 / 0, S = 1 / 0, C = 1 / 0, D = -1 / 0, O = -1 / 0, N = -1 / 0;
                _.box && ($ = _.box.min.x, D = _.box.max.x, S = _.box.min.y, O = _.box.max.y, C = _.box.min.z, N = _.box.max.z);
                for (let G = 0, B = A; G < B; G++) {
                  var j = M[G * 3], L = M[G * 3 + 1], z = M[G * 3 + 2];
                  j < $ && ($ = j), L < S && (S = L), z < C && (C = z), j > D && (D = j), L > O && (O = L), z > N && (N = z);
                }
                _.center.set((D + $) / 2, (O + S) / 2, (N + C) / 2), _.radius = _.center.distanceTo({ x: D, y: O, z: N }), _.box = { min: { x: $, y: S, z: C }, max: { x: D, y: O, z: N } };
              }
              //helper function for adding an appropriately sized mesh
              static addCustomGeo(_, b, M, A, $) {
                var S = b.addGeoGroup(), C = M.vertexArr, D = M.normalArr, O = M.faceArr;
                S.vertices = C.length, S.faceidx = O.length;
                var N, j, L, z, G, B, F, H, W, V = S.vertexArray, X = S.colorArray;
                for (A.constructor !== Array && (H = A.r, W = A.g, z = A.b), B = 0, F = S.vertices; B < F; ++B)
                  N = B * 3, j = C[B], V[N] = j.x, V[N + 1] = j.y, V[N + 2] = j.z, A.constructor === Array && (G = A[B], H = G.r, W = G.g, z = G.b), X[N] = H, X[N + 1] = W, X[N + 2] = z;
                if ($)
                  for (B = 0, F = S.faceidx / 3; B < F; ++B) {
                    N = B * 3, L = O[N], z = O[N + 1], G = O[N + 2];
                    var Z = new u.Vector3(), Q = new u.Vector3(), q = new u.Vector3();
                    _.intersectionShape.triangle.push(new l.Triangle(Z.copy(C[L]), Q.copy(C[z]), q.copy(C[G])));
                  }
                if ($) {
                  var J = new u.Vector3(0, 0, 0), ie = 0;
                  for (let ye = 0; ye < b.geometryGroups.length; ye++)
                    J.add(b.geometryGroups[ye].getCentroid()), ie++;
                  J.divideScalar(ie), E.updateBoundingFromPoints(_.boundingSphere, { centroid: J }, V, S.vertices);
                }
                if (S.faceArray = new Uint16Array(O), S.truncateArrayBuffers(!0, !0), D.length < S.vertices)
                  S.setNormals();
                else {
                  var ne = S.normalArray = new Float32Array(S.vertices * 3), ge;
                  for (B = 0, F = S.vertices; B < F; ++B)
                    N = B * 3, ge = D[B], ne[N] = ge.x, ne[N + 1] = ge.y, ne[N + 2] = ge.z;
                }
                S.setLineIndices(), S.lineidx = S.lineArray.length;
              }
              /*
               *
               * @param {$3Dmol.GLShape}
               *            shape
               * @param {ShapeSpec}
               *            stylespec
               * @returns {undefined}
               */
              static updateFromStyle(_, b) {
                typeof b.color < "u" ? (_.color = b.color || new f.Color(), b.color instanceof f.Color || (_.color = f.CC.color(b.color))) : _.color = f.CC.color(0), _.wireframe = !!b.wireframe, _.opacity = b.alpha ? (0, u.clamp)(b.alpha, 0, 1) : 1, typeof b.opacity < "u" && (_.opacity = (0, u.clamp)(b.opacity, 0, 1)), _.side = b.side !== void 0 ? b.side : o.DoubleSide, _.linewidth = typeof b.linewidth > "u" ? 1 : b.linewidth, _.clickable = !!b.clickable, _.callback = (0, w.makeFunction)(b.callback), _.hoverable = !!b.hoverable, _.hover_callback = (0, w.makeFunction)(b.hover_callback), _.unhover_callback = (0, w.makeFunction)(b.unhover_callback), _.hidden = b.hidden, _.frame = b.frame;
              }
              /**
               * Custom renderable shape
               *
               * @constructor
               *
               * @param {ShapeSpec} stylespec
               */
              constructor(_) {
                this.color = 16777215, this.hidden = !1, this.wireframe = !1, this.opacity = 1, this.linewidth = 1, this.clickable = !1, this.hoverable = !1, this.side = o.DoubleSide, this.stylespec = _ || {}, this.boundingSphere = new l.Sphere(), this.intersectionShape = {
                  sphere: [],
                  cylinder: [],
                  line: [],
                  triangle: []
                }, E.updateFromStyle(this, this.stylespec), this.components = [], this.shapeObj = null, this.renderedShapeObj = null, this.geo = new o.Geometry(!0), this.linegeo = new o.Geometry(!0);
              }
              /** Update shape with new style specification
               * @param {ShapeSpec} newspec
                 @example
                  let sphere = viewer.addSphere({center:{x:0,y:0,z:0},radius:10.0,color:'red'});
                  sphere.updateStyle({color:'yellow',opacity:0.5});
                  viewer.render();
               */
              updateStyle(_) {
                for (var b in _)
                  this.stylespec[b] = _[b];
                if (E.updateFromStyle(this, this.stylespec), _.voldata && _.volscheme) {
                  (0, w.adjustVolumeStyle)(_);
                  const M = _.volscheme, A = _.voldata, $ = f.CC, S = M.range() || [-1, 1];
                  this.geo.setColors(function(C, D, O) {
                    let N = A.getVal(C, D, O);
                    return $.color(M.valueToHex(N, S));
                  }), delete this.color;
                }
              }
              /**
               * Creates a custom shape from supplied vertex and face arrays
               * @param {CustomShapeSpec} customSpec
               */
              addCustom(_) {
                _.vertexArr = _.vertexArr || [], _.faceArr = _.faceArr || [], _.normalArr = _.normalArr || [], E.drawCustom(this, this.geo, _);
              }
              /**
               * Creates a sphere shape
               * @param {SphereSpec} sphereSpec
               @example
               viewer.addSphere({center:{x:0,y:0,z:0},radius:10.0,color:'red'});
               
               viewer.render();
               */
              addSphere(_) {
                _.center || (_.center = new u.Vector3(0, 0, 0)), _.radius = _.radius ? (0, u.clamp)(_.radius, 0, 1 / 0) : 1.5, _.color = f.CC.color(_.color), this.intersectionShape.sphere.push(new l.Sphere(_.center, _.radius)), v.GLDraw.drawSphere(this.geo, _.center, _.radius, _.color, _.quality), this.components.push({
                  centroid: new u.Vector3(_.center.x, _.center.y, _.center.z)
                });
                var b = this.geo.updateGeoGroup(0);
                E.updateBoundingFromPoints(this.boundingSphere, this.components, b.vertexArray, b.vertices);
              }
              /**
               * Creates a box
               * @param {BoxSpec} boxSpec
               @example
               var shape = viewer.addShape({color:'red'});
               shape.addBox({corner: {x:1,y:2,z:0}, dimensions: {w: 4, h: 2, d: 6}});
               shape.addBox({corner: {x:-5,y:-3,z:0},
                             dimensions: { w: {x:1,y:1,z:0},
                                           h: {x:-1,y:1,z:0},
                                           d: {x:0,y:0,z:1} }});
               viewer.zoomTo();
               viewer.rotate(30);
               viewer.render();
               */
              addBox(_) {
                var b = _.dimensions || { w: 1, h: 1, d: 1 }, M;
                typeof b.w == "number" ? M = { x: b.w, y: 0, z: 0 } : M = b.w;
                var A;
                typeof b.h == "number" ? A = { x: 0, y: b.h, z: 0 } : A = b.h;
                var $;
                typeof b.d == "number" ? $ = { x: 0, y: 0, z: b.d } : $ = b.d;
                var S = _.corner;
                S == null && (_.center !== void 0 ? S = {
                  x: _.center.x - 0.5 * (M.x + A.x + $.x),
                  y: _.center.y - 0.5 * (M.y + A.y + $.y),
                  z: _.center.z - 0.5 * (M.z + A.z + $.z)
                } : S = { x: 0, y: 0, z: 0 });
                var C = [
                  { x: S.x, y: S.y, z: S.z },
                  { x: S.x + M.x, y: S.y + M.y, z: S.z + M.z },
                  { x: S.x + A.x, y: S.y + A.y, z: S.z + A.z },
                  { x: S.x + M.x + A.x, y: S.y + M.y + A.y, z: S.z + M.z + A.z },
                  { x: S.x + $.x, y: S.y + $.y, z: S.z + $.z },
                  { x: S.x + M.x + $.x, y: S.y + M.y + $.y, z: S.z + M.z + $.z },
                  { x: S.x + A.x + $.x, y: S.y + A.y + $.y, z: S.z + A.z + $.z },
                  { x: S.x + M.x + A.x + $.x, y: S.y + M.y + A.y + $.y, z: S.z + M.z + A.z + $.z }
                ], D = [], O = [];
                D.splice(D.length, 0, C[0], C[1], C[2], C[3]), O.splice(O.length, 0, 0, 2, 1, 1, 2, 3);
                var N = 4;
                D.splice(D.length, 0, C[2], C[3], C[6], C[7]), O.splice(O.length, 0, N + 0, N + 2, N + 1, N + 1, N + 2, N + 3), N += 4, D.splice(D.length, 0, C[4], C[5], C[0], C[1]), O.splice(O.length, 0, N + 0, N + 2, N + 1, N + 1, N + 2, N + 3), N += 4, D.splice(D.length, 0, C[6], C[7], C[4], C[5]), O.splice(O.length, 0, N + 0, N + 2, N + 1, N + 1, N + 2, N + 3), N += 4, D.splice(D.length, 0, C[3], C[1], C[7], C[5]), O.splice(O.length, 0, N + 0, N + 2, N + 1, N + 1, N + 2, N + 3), N += 4, D.splice(D.length, 0, C[2], C[6], C[0], C[4]), O.splice(O.length, 0, N + 0, N + 2, N + 1, N + 1, N + 2, N + 3), N += 4;
                var j = (0, w.extend)({}, _);
                j.vertexArr = D, j.faceArr = O, j.normalArr = [], E.drawCustom(this, this.geo, j);
                var L = new u.Vector3();
                this.components.push({
                  centroid: L.addVectors(C[0], C[7]).multiplyScalar(0.5)
                });
                var z = this.geo.updateGeoGroup(0);
                E.updateBoundingFromPoints(this.boundingSphere, this.components, z.vertexArray, z.vertices);
              }
              /**
               * Creates a cylinder shape
               * @param {CylinderSpec} cylinderSpec
               @example
                    viewer.addCylinder({start:{x:0.0,y:0.0,z:0.0},
                                        end:{x:10.0,y:0.0,z:0.0},
                                        radius:1.0,
                                        fromCap:1,
                                        toCap:2,
                                        color:'red',
                                        hoverable:true,
                                        clickable:true,
                                        callback:function(){ this.color.setHex(0x00FFFF00);viewer.render( );},
                                        hover_callback: function(){ viewer.render( );},
                                        unhover_callback: function(){ this.color.setHex(0xFF000000);viewer.render( );}
                                       });
                    viewer.addCylinder({start:{x:0.0,y:2.0,z:0.0},
                                        end:{x:0.0,y:10.0,z:0.0},
                                        radius:0.5,
                                        fromCap:false,
                                        toCap:true,
                                        color:'teal'});
                    viewer.addCylinder({start:{x:15.0,y:0.0,z:0.0},
                                        end:{x:20.0,y:0.0,z:0.0},
                                        radius:1.0,
                                        color:'black',
                                        fromCap:false,
                                        toCap:false});
                    viewer.render();
               */
              addCylinder(_) {
                var b, M;
                _.start ? b = new u.Vector3(_.start.x || 0, _.start.y || 0, _.start.z || 0) : b = new u.Vector3(0, 0, 0), _.end ? (M = new u.Vector3(_.end.x, _.end.y || 0, _.end.z || 0), typeof M.x > "u" && (M.x = 3)) : M = new u.Vector3(0, 0, 0);
                var A = _.radius || 0.1, $ = f.CC.color(_.color);
                this.intersectionShape.cylinder.push(new l.Cylinder(b, M, A)), v.GLDraw.drawCylinder(this.geo, b, M, A, $, _.fromCap, _.toCap);
                var S = new u.Vector3();
                this.components.push({
                  centroid: S.addVectors(b, M).multiplyScalar(0.5)
                });
                var C = this.geo.updateGeoGroup(0);
                E.updateBoundingFromPoints(this.boundingSphere, this.components, C.vertexArray, C.vertices);
              }
              /**
               * Creates a dashed cylinder shape
               * @param {CylinderSpec} cylinderSpec
               */
              addDashedCylinder(_) {
                _.dashLength = _.dashLength || 0.25, _.gapLength = _.gapLength || 0.25;
                var b;
                _.start ? b = new u.Vector3(_.start.x || 0, _.start.y || 0, _.start.z || 0) : b = new u.Vector3(0, 0, 0);
                var M;
                _.end ? (M = new u.Vector3(_.end.x, _.end.y || 0, _.end.z || 0), typeof M.x > "u" && (M.x = 3)) : M = new u.Vector3(3, 0, 0);
                for (var A = _.radius || 0.1, $ = f.CC.color(_.color), S = Math.sqrt(Math.pow(b.x - M.x, 2) + Math.pow(b.y - M.y, 2) + Math.pow(b.z - M.z, 2)), C = S / (_.gapLength + _.dashLength), D = new u.Vector3(_.start.x || 0, _.start.y || 0, _.start.z || 0), O = new u.Vector3(_.end.x, _.end.y || 0, _.end.z || 0), N = new u.Vector3((M.x - b.x) / (S / _.gapLength), (M.y - b.y) / (S / _.gapLength), (M.z - b.z) / (S / _.gapLength)), j = new u.Vector3((M.x - b.x) / (S / _.dashLength), (M.y - b.y) / (S / _.dashLength), (M.z - b.z) / (S / _.dashLength)), L = 0; L < C; L++)
                  O = new u.Vector3(D.x + j.x, D.y + j.y, D.z + j.z), this.intersectionShape.cylinder.push(new l.Cylinder(D, O, A)), v.GLDraw.drawCylinder(this.geo, D, O, A, $, _.fromCap, _.toCap), D = new u.Vector3(O.x + N.x, O.y + N.y, O.z + N.z);
                var z = new u.Vector3();
                this.components.push({
                  centroid: z.addVectors(b, M).multiplyScalar(0.5)
                });
                var G = this.geo.updateGeoGroup(0);
                E.updateBoundingFromPoints(this.boundingSphere, this.components, G.vertexArray, G.vertices);
              }
              /**
               * Creates a curved shape
               * @param {CurveSpec} curveSpec
               */
              addCurve(_) {
                _.points = _.points || [], _.smooth = _.smooth || 10, typeof _.fromCap > "u" && (_.fromCap = 2), typeof _.toCap > "u" && (_.toCap = 2);
                var b = (0, g.subdivide_spline)(_.points, _.smooth);
                if (b.length < 3) {
                  console.log("Too few points in addCurve");
                  return;
                }
                var M = _.radius || 0.1, A = f.CC.color(_.color), $ = 0, S = b.length - 1, C = b[0].distanceTo(b[1]), D = Math.ceil(2 * M / C);
                if (_.toArrow) {
                  S -= D;
                  let L = {
                    start: b[S],
                    end: b[b.length - 1],
                    radius: M,
                    color: A,
                    mid: 1e-4
                  };
                  this.addArrow(L);
                }
                if (_.fromArrow) {
                  $ += D;
                  let L = {
                    start: b[$],
                    end: b[0],
                    radius: M,
                    color: A,
                    mid: 1e-4
                  };
                  this.addArrow(L);
                }
                for (var O = Math.ceil(b.length / 2), N = { radius: M, color: A, fromCap: 2, toCap: 2 }, j = $; j < S; j++)
                  N.start = b[j], N.end = b[j + 1], N.fromCap = 2, N.toCap = 2, j < O ? (N.fromCap = 2, N.toCap = 0) : j > O ? (N.fromCap = 0, N.toCap = 2) : (N.fromCap = 2, N.toCap = 2), this.addCylinder(N);
              }
              /**
               * Creates a line shape
               * @param {LineSpec} lineSpec
               @example
               $3Dmol.download("pdb:2ABJ",viewer,{},function(){
                        viewer.addLine({dashed:true,start:{x:0,y:0,z:0},end:{x:100,y:100,z:100}});
                        viewer.render(callback);
                    });
              
               */
              addLine(_) {
                var b, M;
                _.start ? b = new u.Vector3(_.start.x || 0, _.start.y || 0, _.start.z || 0) : b = new u.Vector3(0, 0, 0), _.end ? (M = new u.Vector3(_.end.x, _.end.y || 0, _.end.z || 0), typeof M.x > "u" && (M.x = 3)) : M = new u.Vector3(3, 0, 0);
                var A = this.geo.updateGeoGroup(2), $ = A.vertices, S = $ * 3, C = A.vertexArray;
                C[S] = b.x, C[S + 1] = b.y, C[S + 2] = b.z, C[S + 3] = M.x, C[S + 4] = M.y, C[S + 5] = M.z, A.vertices += 2;
                var D = A.lineArray, O = A.lineidx;
                D[O] = $, D[O + 1] = $ + 1, A.lineidx += 2;
                var N = new u.Vector3();
                this.components.push({
                  centroid: N.addVectors(b, M).multiplyScalar(0.5)
                }), A = this.geo.updateGeoGroup(0), E.updateBoundingFromPoints(this.boundingSphere, this.components, A.vertexArray, A.vertices);
              }
              /**
               * Creates an arrow shape
               * @param {ArrowSpec} arrowSpec
               @example
                $3Dmol.download("pdb:4DM7",viewer,{},function(){
                        viewer.setBackgroundColor(0xffffffff);
                        viewer.addArrow({
                            start: {x:-10.0, y:0.0, z:0.0},
                            end: {x:0.0, y:-10.0, z:0.0},
                            radius: 1.0,
                            radiusRadio:1.0,
                            mid:1.0,
                            clickable:true,
                            callback:function(){
                                this.color.setHex(0xFF0000FF);
                                viewer.render( );
                            }
                        });
                        viewer.render();
                      });
               */
              addArrow(_) {
                if (_.start ? _.start = new u.Vector3(_.start.x || 0, _.start.y || 0, _.start.z || 0) : _.start = new u.Vector3(0, 0, 0), _.dir instanceof u.Vector3 && typeof _.length == "number") {
                  var b = _.dir.clone().multiplyScalar(_.length).add(_.start);
                  _.end = b;
                } else
                  _.end ? (_.end = new u.Vector3(_.end.x, _.end.y || 0, _.end.z || 0), typeof _.end.x > "u" && (_.end.x = 3)) : _.end = new u.Vector3(3, 0, 0);
                _.radius = _.radius || 0.1, _.radiusRatio = _.radiusRatio || 1.618034, _.mid = 0 < _.mid && _.mid < 1 ? _.mid : 0.618034, E.drawArrow(this, this.geo, _);
                var M = new u.Vector3();
                this.components.push({
                  centroid: M.addVectors(_.start, _.end).multiplyScalar(0.5)
                });
                var A = this.geo.updateGeoGroup(0);
                E.updateBoundingFromPoints(this.boundingSphere, this.components, A.vertexArray, A.vertices);
              }
              static distance_from(_, b) {
                return Math.sqrt(Math.pow(_.x - b.x, 2) + Math.pow(_.y - b.y, 2) + Math.pow(_.z - b.z, 2));
              }
              static inSelectedRegion(_, b, M) {
                for (var A = 0; A < b.length; A++)
                  if (E.distance_from(b[A], _) <= M)
                    return !0;
                return !1;
              }
              /**
               * Create isosurface from voluemetric data.
               * @param {VolumeData} data - volumetric input data
               * @param {IsoSurfaceSpec} isoSpec - volumetric data shape specification
               * @example //the user can specify a selected region for the isosurface
               $.get('../test_structs/benzene-homo.cube', function(data){
                        var voldata = new $3Dmol.VolumeData(data, "cube");
                        viewer.addIsosurface(voldata, {isoval: 0.01,
                                                       color: "blue",
                                                       alpha: 0.5,
                                                       smoothness: 10});
                        viewer.addIsosurface(voldata, {isoval: -0.01,
                                                       color: "red",
                                                       smoothness: 5,
                                                       opacity:0.5,
                                                       wireframe:true,
                                                       clickable:true,
                                                       callback:
                                                       function() {
                                                           this.opacity = 0.0;
                                                           viewer.render( );
                                                       }});
                        viewer.setStyle({}, {stick:{}});
                        viewer.zoomTo();
                        viewer.render();
                      });
               */
              addIsosurface(_, b, M) {
                var A = b.isoval !== void 0 && typeof b.isoval == "number" ? b.isoval : 0, $ = !!b.voxel, S = b.smoothness === void 0 ? 1 : b.smoothness, C = _.size.x, D = _.size.y, O = _.size.z, N = new Int16Array(C * D * O), j = _.data, L, z;
                for (L = 0, z = N.length; L < z; ++L)
                  N[L] = -1;
                var G = new Uint8Array(C * D * O);
                for (L = 0, z = j.length; L < z; ++L) {
                  var B = A >= 0 ? j[L] - A : A - j[L];
                  B > 0 && (G[L] |= E.ISDONE);
                }
                var F = [], H = [];
                h.MarchingCube.march(G, F, H, {
                  fulltable: !0,
                  voxel: $,
                  unitCube: _.unit,
                  origin: _.origin,
                  matrix: _.matrix,
                  nX: C,
                  nY: D,
                  nZ: O
                }), !$ && S > 0 && h.MarchingCube.laplacianSmooth(S, F, H);
                var W = [], V = [], X = [];
                if (b.selectedRegion && b.coords === void 0 && (b.coords = b.selectedRegion), b.coords !== void 0) {
                  var Z = b.coords[0].x, Q = b.coords[0].y, q = b.coords[0].z, J = b.coords[0].x, ie = b.coords[0].y, ne = b.coords[0].z;
                  for (let Ae = 0; Ae < b.coords.length; Ae++)
                    b.coords[Ae].x > Z ? Z = b.coords[Ae].x : b.coords[Ae].x < J && (J = b.coords[Ae].x), b.coords[Ae].y > Q ? Q = b.coords[Ae].y : b.coords[Ae].y < ie && (ie = b.coords[Ae].y), b.coords[Ae].z > q ? q = b.coords[Ae].z : b.coords[Ae].z < ne && (ne = b.coords[Ae].z);
                  var ge = 2;
                  b.radius !== void 0 && (ge = b.radius), b.selectedOffset !== void 0 && (ge = b.selectedOffset), b.seldist !== void 0 && (ge = b.seldist), J -= ge, Z += ge, ie -= ge, Q += ge, ne -= ge, q += ge;
                  for (let Ae = 0; Ae < F.length; Ae++)
                    F[Ae].x > J && F[Ae].x < Z && F[Ae].y > ie && F[Ae].y < Q && F[Ae].z > ne && F[Ae].z < q && E.inSelectedRegion(F[Ae], b.coords, ge) ? (W.push(V.length), V.push(F[Ae])) : W.push(-1);
                  for (let Ae = 0; Ae + 2 < H.length; Ae += 3)
                    W[H[Ae]] !== -1 && W[H[Ae + 1]] !== -1 && W[H[Ae + 2]] !== -1 && (X.push(H[Ae] - (H[Ae] - W[H[Ae]])), X.push(H[Ae + 1] - (H[Ae + 1] - W[H[Ae + 1]])), X.push(H[Ae + 2] - (H[Ae + 2] - W[H[Ae + 2]])));
                  F = V, H = X;
                }
                E.drawCustom(this, this.geo, {
                  vertexArr: F,
                  faceArr: H,
                  normalArr: [],
                  clickable: b.clickable,
                  hoverable: b.hoverable
                }), this.updateStyle(b);
                var ye = new u.Vector3(_.origin.x, _.origin.y, _.origin.z), xe = new u.Vector3(_.size.x * _.unit.x, _.size.y * _.unit.y, _.size.z * _.unit.z), we = new u.Vector3(0, 0, 0), de = ye.clone(), Te = ye.clone().add(xe);
                for (let Ae = 0; Ae < F.length; Ae++)
                  we.add(F[Ae]), de.max(F[Ae]), Te.min(F[Ae]);
                we.divideScalar(F.length);
                var Ce = we.distanceTo(Te), ee = we.distanceTo(de);
                this.boundingSphere.center = we, this.boundingSphere.radius = Math.max(Ce, ee), typeof M == "function" && M();
              }
              /**
               * @deprecated Use addIsosurface instead
               * Creates custom shape from volumetric data
               * @param {string} data - Volumetric input data
               * @param {string} fmt - Input data format (e.g. 'cube' for cube file format)
               * @param {IsoSurfaceSpec} isoSpec - Volumetric data shape specification
               */
              addVolumetricData(_, b, M) {
                _ = new p.VolumeData(_, b), this.addIsosurface(_, M);
              }
              //for internal use, truncate buffers to save memory
              finalize() {
                return E.finalizeGeo(this.geo), this.geo.initTypedArrays(), this.geo;
              }
              /*
               * Initialize webgl objects for rendering
               * @param {$3Dmol.Object3D} group
               *
               */
              globj(_) {
                if (this.renderedShapeObj && (_.remove(this.renderedShapeObj), this.renderedShapeObj = null), !this.hidden) {
                  E.finalizeGeo(this.geo), this.geo.initTypedArrays(), this.wireframe && this.geo.setUpWireframe(), typeof this.color < "u" && E.updateColor(this.geo, this.color), this.shapeObj = new o.Object3D();
                  var b = null;
                  this.side == o.DoubleSide ? b = new o.MeshDoubleLambertMaterial({
                    wireframe: this.wireframe,
                    side: this.side,
                    transparent: this.opacity < 1,
                    opacity: this.opacity,
                    wireframeLinewidth: this.linewidth,
                    vertexColors: o.Coloring.VertexColors
                  }) : b = new o.MeshLambertMaterial({
                    wireframe: this.wireframe,
                    side: this.side,
                    transparent: this.opacity < 1,
                    opacity: this.opacity,
                    wireframeLinewidth: this.linewidth,
                    vertexColors: o.Coloring.VertexColors
                  });
                  var M = new o.Mesh(this.geo, b);
                  this.shapeObj.add(M);
                  var A = new o.LineBasicMaterial({
                    linewidth: this.linewidth,
                    color: this.color
                  }), $ = new o.Line(this.linegeo, A, o.LineStyle.LinePieces);
                  this.shapeObj.add($), this.renderedShapeObj = this.shapeObj.clone(), _.add(this.renderedShapeObj);
                }
              }
              removegl(_) {
                this.renderedShapeObj && (this.renderedShapeObj.geometry !== void 0 && this.renderedShapeObj.geometry.dispose(), this.renderedShapeObj.material !== void 0 && this.renderedShapeObj.material.dispose(), _.remove(this.renderedShapeObj), this.renderedShapeObj = null), this.shapeObj = null;
              }
              get position() {
                return this.boundingSphere.center;
              }
              get x() {
                return this.boundingSphere.center.x;
              }
              get y() {
                return this.boundingSphere.center.y;
              }
              get z() {
                return this.boundingSphere.center.z;
              }
            }
            E.ISDONE = 2, E.drawCustom = function(R, _, b) {
              var M = b, A = M.vertexArr, $ = M.faceArr;
              (A.length === 0 || $.length === 0) && console.warn("Error adding custom shape component: No vertices and/or face indices supplied!");
              var S = b.color;
              typeof S > "u" && (S = R.color), S = f.CC.color(S);
              for (var C = T(M), D = 0, O = C.length; D < O; D++)
                E.addCustomGeo(R, _, C[D], C[D].colorArr ? C[D].colorArr : S, b.clickable);
            };
            function T(R) {
              var _ = 64e3;
              if (R.vertexArr.length < _)
                return [R];
              var b = [{ vertexArr: [], normalArr: [], faceArr: [] }];
              R.colorArr && (b.colorArr = []);
              var M = [], A = [], $ = 0, S = R.faceArr;
              for (let D = 0, O = S.length; D < O; D += 3) {
                let N = b[$];
                for (let j = 0; j < 3; j++) {
                  var C = S[D + j];
                  M[C] !== $ && (M[C] = $, A[C] = N.vertexArr.length, N.vertexArr.push(R.vertexArr[C]), R.normalArr && R.normalArr[C] && N.normalArr.push(R.normalArr[C]), R.colorArr && R.colorArr[C] && N.colorArr.push(R.colorArr[C])), N.faceArr.push(A[C]);
                }
                N.vertexArr.length >= _ && (b.push({ vertexArr: [], normalArr: [], faceArr: [] }), R.colorArr && (b.colorArr = []), $++);
              }
              return b;
            }
          }
        ),
        /***/
        "./src/GLViewer.ts": (
          /*!*************************!*\
            !*** ./src/GLViewer.ts ***!
            \*************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              GLViewer: () => (
                /* binding */
                _
              ),
              /* harmony export */
              createStereoViewer: () => (
                /* binding */
                A
              ),
              /* harmony export */
              createViewer: () => (
                /* binding */
                b
              ),
              /* harmony export */
              createViewerGrid: () => (
                /* binding */
                M
              )
              /* harmony export */
            });
            var o = n(
              /*! ./WebGL */
              "./src/WebGL/index.ts"
            ), l = n(
              /*! ./WebGL/math */
              "./src/WebGL/math/index.ts"
            ), u = n(
              /*! ./colors */
              "./src/colors.ts"
            ), f = n(
              /*! ./utilities */
              "./src/utilities.ts"
            ), h = n(
              /*! ./Gradient */
              "./src/Gradient.ts"
            ), p = n(
              /*! ./GLModel */
              "./src/GLModel.ts"
            ), v = n(
              /*! ./Label */
              "./src/Label.ts"
            ), g = n(
              /*! ./GLShape */
              "./src/GLShape.ts"
            ), w = n(
              /*! ./VolumeData */
              "./src/VolumeData.ts"
            ), E = n(
              /*! ./ProteinSurface4 */
              "./src/ProteinSurface4.ts"
            ), T = n(
              /*! ./VolumetricRender */
              "./src/VolumetricRender.ts"
            ), R = n(
              /*! upng-js */
              "./node_modules/upng-js/UPNG.js"
            );
            class _ {
              //reimplement jquery getwidth/height
              getRect() {
                let S = this.container, C = S.getBoundingClientRect();
                if (C.width == 0 && C.height == 0 && S.style.display === "none") {
                  let D = S.style.position, O = S.style.visibility;
                  S.style.display = "block", S.style.visibility = "hidden", S.style.position = "absolute", C = S.getBoundingClientRect(), S.style.display = "none", S.style.visibility = O, S.style.position = D;
                }
                return C;
              }
              getWidth() {
                return this.getRect().width;
              }
              getHeight() {
                return this.getRect().height;
              }
              setupRenderer() {
                this.renderer = new o.Renderer({
                  antialias: this.config.antialias,
                  preserveDrawingBuffer: !0,
                  premultipliedAlpha: !1,
                  id: this.config.id,
                  row: this.config.row,
                  col: this.config.col,
                  rows: this.config.rows,
                  cols: this.config.cols,
                  canvas: this.config.canvas,
                  //cannot initialize with zero size
                  containerWidth: this.WIDTH || 1,
                  containerHeight: this.HEIGHT || 1
                }), this.renderer.domElement.style.width = "100%", this.renderer.domElement.style.height = "100%", this.renderer.domElement.style.padding = "0", this.renderer.domElement.style.position = "absolute", this.renderer.domElement.style.top = "0px", this.renderer.domElement.style.left = "0px", this.renderer.domElement.style.zIndex = "0";
              }
              initializeScene() {
                this.scene = new o.Scene(), this.scene.fog = new o.Fog(this.bgColor, 100, 200), this.modelGroup = new o.Object3D(), this.rotationGroup = new o.Object3D(), this.rotationGroup.useQuaternion = !0, this.rotationGroup.quaternion = new l.Quaternion(0, 0, 0, 1), this.rotationGroup.add(this.modelGroup), this.scene.add(this.rotationGroup);
                var S = new o.Light(16777215);
                S.position = new l.Vector3(0.2, 0.2, 1).normalize(), S.intensity = 1, this.scene.add(S);
              }
              initContainer(S) {
                this.container = S, this.WIDTH = this.getWidth(), this.HEIGHT = this.getHeight(), this.ASPECT = this.renderer.getAspect(this.WIDTH, this.HEIGHT), this.renderer.setSize(this.WIDTH, this.HEIGHT), this.container.append(this.renderer.domElement), this.glDOM = this.renderer.domElement, this.nomouse || (this.glDOM.addEventListener("mousedown", this._handleMouseDown.bind(this), { passive: !1 }), this.glDOM.addEventListener("touchstart", this._handleMouseDown.bind(this), { passive: !1 }), this.glDOM.addEventListener("wheel", this._handleMouseScroll.bind(this), { passive: !1 }), this.glDOM.addEventListener("mousemove", this._handleMouseMove.bind(this), { passive: !1 }), this.glDOM.addEventListener("touchmove", this._handleMouseMove.bind(this), { passive: !1 }), this.glDOM.addEventListener("contextmenu", this._handleContextMenu.bind(this), { passive: !1 }));
              }
              decAnim() {
                this.animated--, this.animated < 0 && (this.animated = 0);
              }
              incAnim() {
                this.animated++;
              }
              nextSurfID() {
                var S = 0;
                for (let D in this.surfaces)
                  if (this.surfaces.hasOwnProperty(D)) {
                    var C = parseInt(D);
                    isNaN(C) || C > S && (S = C);
                  }
                return S + 1;
              }
              setSlabAndFog() {
                let S = this.camera.position.z - this.rotationGroup.position.z;
                S < 1 && (S = 1), this.camera.near = S + this.slabNear, this.camera.near < 1 && (this.camera.near = 1), this.camera.far = S + this.slabFar, this.camera.near + 1 > this.camera.far && (this.camera.far = this.camera.near + 1), this.camera.fov = this.fov, this.camera.right = S * Math.tan(Math.PI / 180 * this.fov), this.camera.left = -this.camera.right, this.camera.top = this.camera.right / this.ASPECT, this.camera.bottom = -this.camera.top, this.camera.updateProjectionMatrix(), this.scene.fog.near = this.camera.near + this.fogStart * (this.camera.far - this.camera.near), this.scene.fog.far = this.camera.far, this.config.disableFog && (this.scene.fog.near = this.scene.fog.far);
              }
              // display scene
              //if nolink is set/true, don't propagate changes to linked viewers
              show(S) {
                if (this.renderer.setViewport(), !!this.scene && (this.setSlabAndFog(), this.renderer.render(this.scene, this.camera), this.viewChangeCallback && this.viewChangeCallback(this._viewer.getView()), !S && this.linkedViewers.length > 0))
                  for (var C = this._viewer.getView(), D = 0; D < this.linkedViewers.length; D++) {
                    var O = this.linkedViewers[D];
                    O.setView(C, !0);
                  }
              }
              //regenerate the list of clickables
              //also updates hoverables
              updateClickables() {
                this.clickables.splice(0, this.clickables.length), this.hoverables.splice(0, this.hoverables.length), this.contextMenuEnabledAtoms.splice(0, this.contextMenuEnabledAtoms.length);
                for (let S = 0, C = this.models.length; S < C; S++) {
                  let D = this.models[S];
                  if (D) {
                    let O = D.selectedAtoms({
                      clickable: !0
                    }), N = D.selectedAtoms({
                      hoverable: !0
                    }), j = D.selectedAtoms({ contextMenuEnabled: !0 });
                    for (let L = 0; L < N.length; L++)
                      this.hoverables.push(N[L]);
                    for (let L = 0; L < O.length; L++)
                      this.clickables.push(O[L]);
                    for (let L = 0; L < j.length; L++)
                      this.contextMenuEnabledAtoms.push(j[L]);
                  }
                }
                for (let S = 0, C = this.shapes.length; S < C; S++) {
                  let D = this.shapes[S];
                  D && D.clickable && this.clickables.push(D), D && D.hoverable && this.hoverables.push(D);
                }
              }
              // Checks for selection intersects on mousedown
              handleClickSelection(S, C, D) {
                let O = this.targetedObjects(S, C, this.clickables);
                if (O.length) {
                  var N = O[0].clickable;
                  N.callback !== void 0 && (typeof N.callback != "function" && (N.callback = (0, f.makeFunction)(N.callback)), typeof N.callback == "function" && N.callback(N, this._viewer, D, this.container, O));
                }
              }
              //return offset of container
              canvasOffset() {
                let S = this.glDOM, C = S.getBoundingClientRect(), D = S.ownerDocument, O = D.documentElement, N = D.defaultView;
                return {
                  top: C.top + N.pageYOffset - O.clientTop,
                  left: C.left + N.pageXOffset - O.clientLeft
                };
              }
              //set current_hover to sel (which can be null), calling appropraite callbacks
              setHover(S, C, D) {
                this.current_hover != S && (this.current_hover && (typeof this.current_hover.unhover_callback != "function" && (this.current_hover.unhover_callback = (0, f.makeFunction)(this.current_hover.unhover_callback)), this.current_hover.unhover_callback(this.current_hover, this._viewer, C, this.container, D)), this.current_hover = S, S && S.hover_callback !== void 0 && (typeof S.hover_callback != "function" && (S.hover_callback = (0, f.makeFunction)(S.hover_callback)), typeof S.hover_callback == "function" && S.hover_callback(S, this._viewer, C, this.container, D)));
              }
              //checks for selection intersects on hover
              handleHoverSelection(S, C, D) {
                if (this.hoverables.length == 0)
                  return;
                let O = this.targetedObjects(S, C, this.hoverables);
                if (O.length) {
                  var N = O[0].clickable;
                  this.setHover(N, D, O), this.current_hover = N;
                } else
                  this.setHover(null);
              }
              //sees if the mouse is still on the object that invoked a hover event and if not then the unhover callback is called
              handleHoverContinue(S, C) {
                let D = this.targetedObjects(S, C, this.hoverables);
                (D.length == 0 || D[0] === void 0) && this.setHover(null), D[0] !== void 0 && D[0].clickable !== this.current_hover && this.setHover(null);
              }
              /**
               * Determine if a positioned event is "close enough" to mouseStart to be considered a click.
               * With a mouse, the position should be exact, but allow a slight delta for a touch interface.
               * @param {Event} event
               * @param {{ allowTolerance, tolerance: number }} options
               */
              closeEnoughForClick(S, { allowTolerance: C = S.targetTouches, tolerance: D = 5 } = {}) {
                const O = this.getX(S), N = this.getY(S);
                if (C) {
                  const j = Math.abs(O - this.mouseStartX), L = Math.abs(N - this.mouseStartY);
                  return j <= D && L <= D;
                } else
                  return O === this.mouseStartX && N === this.mouseStartY;
              }
              calcTouchDistance(S) {
                var C = S.targetTouches[0].pageX - S.targetTouches[1].pageX, D = S.targetTouches[0].pageY - S.targetTouches[1].pageY;
                return Math.hypot(C, D);
              }
              //check targetTouches as well
              getX(S) {
                var C = S.pageX;
                return C == null && (C = S.pageX), S.targetTouches && S.targetTouches[0] ? C = S.targetTouches[0].pageX : S.changedTouches && S.changedTouches[0] && (C = S.changedTouches[0].pageX), C;
              }
              getY(S) {
                var C = S.pageY;
                return C == null && (C = S.pageY), S.targetTouches && S.targetTouches[0] ? C = S.targetTouches[0].pageY : S.changedTouches && S.changedTouches[0] && (C = S.changedTouches[0].pageY), C;
              }
              //for grid viewers, return true if point is in this viewer
              isInViewer(S, C) {
                if (this.viewers != null) {
                  var D = this.WIDTH / this.cols, O = this.HEIGHT / this.rows, N = this.canvasOffset(), j = S - N.left, L = C - N.top, z = this.rows - Math.floor(L / O) - 1, G = Math.floor(j / D);
                  if (z != this.row || G != this.col)
                    return !1;
                }
                return !0;
              }
              //if the user has specify zoom limits, readjust to fit within them
              //also, make sure we don't go past CAMERA_Z
              adjustZoomToLimits(S) {
                if (this.config.lowerZoomLimit && this.config.lowerZoomLimit > 0) {
                  let C = this.CAMERA_Z - this.config.lowerZoomLimit;
                  S > C && (S = C);
                }
                if (this.config.upperZoomLimit && this.config.upperZoomLimit > 0) {
                  let C = this.CAMERA_Z - this.config.upperZoomLimit;
                  S < C && (S = C);
                }
                return S > this.CAMERA_Z - 1 && (S = this.CAMERA_Z - 1), S;
              }
              //interpolate between two normalized quaternions (t between 0 and 1)
              //https://en.wikipedia.org/wiki/Slerp
              static slerp(S, C, D) {
                if (D == 1)
                  return C.clone();
                if (D == 0)
                  return S.clone();
                let O = S.x * C.x + S.y * C.y + S.z * C.z + S.w * C.w;
                if (O > 0.9995) {
                  let F = new l.Quaternion(S.x + D * (C.x - S.x), S.y + D * (C.y - S.y), S.z + D * (C.z - S.z), S.w + D * (C.w - S.w));
                  return F.normalize(), F;
                }
                O < 0 && (C = C.clone().multiplyScalar(-1), O = -O), O > 1 ? O = 1 : O < -1 && (O = -1);
                var N = Math.acos(O), j = N * D, L = C.clone();
                L.sub(S.clone().multiplyScalar(O)), L.normalize();
                var z = Math.cos(j), G = Math.sin(j), B = new l.Quaternion(S.x * z + L.x * G, S.y * z + L.y * G, S.z * z + L.z * G, S.w * z + L.w * G);
                return B.normalize(), B;
              }
              /* @param {Object} element HTML element within which to create viewer
               * @param {ViewerSpec} config Object containing optional configuration for the viewer
               */
              constructor(S, C = {}) {
                this.nomouse = !1, this.glDOM = null, this.models = [], this.surfaces = {}, this.shapes = [], this.labels = [], this.clickables = [], this.hoverables = [], this.contextMenuEnabledAtoms = [], this.current_hover = null, this.hoverDuration = 500, this.viewer_frame = 0, this.viewChangeCallback = null, this.stateChangeCallback = null, this.NEAR = 1, this.FAR = 800, this.CAMERA_Z = 150, this.fov = 20, this.linkedViewers = [], this.renderer = null, this.control_all = !1, this.scene = null, this.rotationGroup = null, this.modelGroup = null, this.fogStart = 0.4, this.slabNear = -50, this.slabFar = 50, this.cq = new l.Quaternion(0, 0, 0, 1), this.dq = new l.Quaternion(0, 0, 0, 1), this.animated = 0, this.animationTimers = /* @__PURE__ */ new Set(), this.isDragging = !1, this.mouseStartX = 0, this.mouseStartY = 0, this.touchDistanceStart = 0, this.touchHold = !1, this.currentModelPos = 0, this.cz = 0, this.cslabNear = 0, this.cslabFar = 0, this.userContextMenuHandler = null, this.config = C, this.callback = this.config.callback, this.defaultcolors = this.config.defaultcolors, this.defaultcolors || (this.defaultcolors = u.elementColors.defaultColors), this.nomouse = this.config.nomouse, this.bgColor = 0, this.config.backgroundColor = this.config.backgroundColor || "#ffffff", typeof this.config.backgroundColor < "u" && (this.bgColor = u.CC.color(this.config.backgroundColor).getHex()), this.config.backgroundAlpha = this.config.backgroundAlpha == null ? 1 : this.config.backgroundAlpha, this.camerax = 0, typeof this.config.camerax < "u" && (this.camerax = parseFloat(this.config.camerax)), this._viewer = this, this.container = S, this.config.hoverDuration != null && (this.hoverDuration = this.config.hoverDuration), this.config.antialias === void 0 && (this.config.antialias = !0), this.config.cartoonQuality === void 0 && (this.config.cartoonQuality = 10), this.WIDTH = this.getWidth(), this.HEIGHT = this.getHeight(), this.setupRenderer(), this.row = this.config.row == null ? 0 : this.config.row, this.col = this.config.col == null ? 0 : this.config.col, this.cols = this.config.cols, this.rows = this.config.rows, this.viewers = this.config.viewers, this.control_all = this.config.control_all, this.ASPECT = this.renderer.getAspect(this.WIDTH, this.HEIGHT), this.camera = new o.Camera(this.fov, this.ASPECT, this.NEAR, this.FAR, this.config.orthographic), this.camera.position = new l.Vector3(this.camerax, 0, this.CAMERA_Z), this.lookingAt = new l.Vector3(), this.camera.lookAt(this.lookingAt), this.raycaster = new o.Raycaster(new l.Vector3(0, 0, 0), new l.Vector3(0, 0, 0)), this.projector = new o.Projector(), this.initializeScene(), this.renderer.setClearColorHex(this.bgColor, this.config.backgroundAlpha), this.scene.fog.color = u.CC.color(this.bgColor), document.body.addEventListener("mouseup", this._handleMouseUp.bind(this)), document.body.addEventListener("touchend", this._handleMouseUp.bind(this)), this.initContainer(this.container), this.config.style && this.setViewStyle(this.config), window.addEventListener("resize", this.resize.bind(this)), typeof window.ResizeObserver < "u" && (this.divwatcher = new window.ResizeObserver(this.resize.bind(this)), this.divwatcher.observe(this.container));
                try {
                  typeof this.callback == "function" && this.callback(this);
                } catch (D) {
                  console.log("error with glviewer callback: " + D);
                }
              }
              /**
              * Return a list of objects that intersect that at the specified viewer position.
              *
              * @param x - x position in screen coordinates
              * @param y - y position in screen coordinates
              * @param {Object[]} - list of objects or selection object specifying what object to check for targeting
              */
              targetedObjects(S, C, D) {
                var O = {
                  x: S,
                  y: C,
                  z: -1
                };
                return Array.isArray(D) || (D = this.selectedAtoms(D)), D.length == 0 ? [] : (this.raycaster.setFromCamera(O, this.camera), this.raycaster.intersectObjects(this.modelGroup, D));
              }
              /** Convert model coordinates to screen coordinates.
               * @param {object | list} - an object or list of objects with x,y,z attributes (e.g. an atom)
               * @return {object | list} - and object or list of {x: screenX, y: screenY}
               */
              modelToScreen(S) {
                let C = !1;
                Array.isArray(S) || (S = [S], C = !0);
                let D = this.renderer.getXRatio(), O = this.renderer.getYRatio(), N = this.col, j = this.row, L = N * (this.WIDTH / D), z = (O - j - 1) * (this.HEIGHT / O), G = [], B = this.canvasOffset();
                return S.forEach((F) => {
                  let H = new l.Vector3(F.x, F.y, F.z);
                  H.applyMatrix4(this.modelGroup.matrixWorld), this.projector.projectVector(H, this.camera);
                  let W = this.WIDTH / D * (H.x + 1) / 2 + B.left + L, V = -(this.HEIGHT / O) * (H.y - 1) / 2 + B.top + z;
                  G.push({ x: W, y: V });
                }), C && (G = G[0]), G;
              }
              /**
               * For a given screen (x,y) displacement return model displacement
               * @param{x} x displacement in screen coordinates
               * @param{y} y displacement in screen corodinates
               * @param{modelz} z coordinate in model coordinates to compute offset for, default is model axis
              */
              screenOffsetToModel(S, C, D) {
                var O = S / this.WIDTH, N = C / this.HEIGHT, j = D === void 0 ? this.rotationGroup.position.z : D, L = this.rotationGroup.quaternion, z = new l.Vector3(0, 0, j);
                return this.projector.projectVector(z, this.camera), z.x += O * 2, z.y -= N * 2, this.projector.unprojectVector(z, this.camera), z.z = 0, z.applyQuaternion(L), z;
              }
              /**
               * Distance from screen coordinate to model coordinate assuming screen point
               * is projected to the same depth as model coordinate
               * @param{screen} xy screen coordinate
               * @param{model} xyz model coordinate
              */
              screenToModelDistance(S, C) {
                let D = this.canvasOffset(), O = new l.Vector3(C.x, C.y, C.z);
                O.applyMatrix4(this.modelGroup.matrixWorld);
                let N = O.clone();
                this.projector.projectVector(O, this.camera);
                let j = new l.Vector3((S.x - D.left) * 2 / this.WIDTH - 1, (S.y - D.top) * 2 / -this.HEIGHT + 1, O.z);
                return this.projector.unprojectVector(j, this.camera), j.distanceTo(N);
              }
              /**
               * Set a callback to call when the view has potentially changed.
               *
              */
              setViewChangeCallback(S) {
                (typeof S == "function" || S == null) && (this.viewChangeCallback = S);
              }
              /**
               * Set a callback to call when the view has potentially changed.
               *
              */
              setStateChangeCallback(S) {
                (typeof S == "function" || S == null) && (this.stateChangeCallback = S);
              }
              /**
               * Return configuration of viewer
               */
              getConfig() {
                return this.config;
              }
              /**
               * Set the configuration object.  Note that some setting may only
               * have an effect at viewer creation time.
               */
              setConfig(S) {
                this.config = S;
              }
              /**
               * Return object representing internal state of
               * the viewer appropriate for passing to setInternalState
               *
              */
              getInternalState() {
                var S = { models: [], surfaces: [], shapes: [], labels: [] };
                for (let C = 0; C < this.models.length; C++)
                  this.models[C] && (S.models[C] = this.models[C].getInternalState());
                return S;
              }
              /**
               * Overwrite internal state of the viewer with passed  object
               * which should come from getInternalState.
               *
              */
              setInternalState(S) {
                this.clear();
                var C = S.models;
                for (let D = 0; D < C.length; D++)
                  C[D] && (this.models[D] = new p.GLModel(D), this.models[D].setInternalState(C[D]));
                this.render();
              }
              /**
               * Set lower and upper limit stops for zoom.
               *
               * @param {lower} - limit on zoom in (positive number).  Default 0.
               * @param {upper} - limit on zoom out (positive number).  Default infinite.
               * @example
                $3Dmol.get("data/set1_122_complex.mol2", function(moldata) {
                      var m = viewer.addModel(moldata);
                      viewer.setStyle({stick:{colorscheme:"Jmol"}});
                      viewer.setZoomLimits(100,200);
                      viewer.zoomTo();
                      viewer.zoom(10); //will not zoom all the way
                      viewer.render();
                  });
              */
              setZoomLimits(S, C) {
                typeof S < "u" && (this.config.lowerZoomLimit = S), C && (this.config.upperZoomLimit = C), this.rotationGroup.position.z = this.adjustZoomToLimits(this.rotationGroup.position.z), this.show();
              }
              /**
               * Set camera parameters (distance to the origin and field of view)
               *
               * @param {parameters} - new camera parameters, with possible fields
               *                       being fov for the field of view, z for the
               *                       distance to the origin, and orthographic (boolean)
               *                       for kind of projection (default false).
               * @example
                $3Dmol.get("data/set1_122_complex.mol2", function(data) {
                      var m = viewer.addModel(data);
                      viewer.setStyle({stick:{}});
                      viewer.zoomTo();
                      viewer.setCameraParameters({ fov: 10 , z: 300 });
                      viewer.render();
                  });
              */
              setCameraParameters(S) {
                S.fov !== void 0 && (this.fov = S.fov, this.camera.fov = this.fov), S.z !== void 0 && (this.CAMERA_Z = S.z, this.camera.z = this.CAMERA_Z), S.orthographic !== void 0 && (this.camera.ortho = S.orthographic);
              }
              _handleMouseDown(S) {
                if (S.preventDefault(), !this.scene)
                  return;
                var C = this.getX(S), D = this.getY(S);
                if (C === void 0)
                  return;
                this.isDragging = !0, this.mouseButton = S.which, this.mouseStartX = C, this.mouseStartY = D, this.touchHold = !0, this.touchDistanceStart = 0, S.targetTouches && S.targetTouches.length == 2 && (this.touchDistanceStart = this.calcTouchDistance(S)), this.cq = this.rotationGroup.quaternion.clone(), this.cz = this.rotationGroup.position.z, this.currentModelPos = this.modelGroup.position.clone(), this.cslabNear = this.slabNear, this.cslabFar = this.slabFar;
                let O = this;
                setTimeout(function() {
                  S.targetTouches && O.touchHold == !0 && (O.glDOM = O.renderer.domElement, O.glDOM.dispatchEvent(new Event("contextmenu")));
                }, 1e3);
              }
              _handleMouseUp(S) {
                if (this.touchHold = !1, this.isDragging && this.scene) {
                  var C = this.getX(S), D = this.getY(S);
                  if (this.closeEnoughForClick(S) && this.isInViewer(C, D)) {
                    let O = this.mouseXY(C, D);
                    this.handleClickSelection(O.x, O.y, S);
                  }
                }
                this.isDragging = !1;
              }
              _handleMouseScroll(S) {
                if (S.preventDefault(), !!this.scene) {
                  var C = this.getX(S), D = this.getY(S);
                  if (C !== void 0 && !(!this.control_all && !this.isInViewer(C, D))) {
                    var O = (this.CAMERA_Z - this.rotationGroup.position.z) * 0.85, N = 1;
                    if (S.ctrlKey && (N = -1), S.detail)
                      this.rotationGroup.position.z += N * O * S.detail / 10;
                    else if (S.wheelDelta) {
                      let j = S.wheelDelta * 600 / (S.wheelDelta + 600);
                      this.rotationGroup.position.z -= N * O * j / 400;
                    }
                    this.rotationGroup.position.z = this.adjustZoomToLimits(this.rotationGroup.position.z), this.show();
                  }
                }
              }
              /**
               * Return image URI of viewer contents (base64 encoded).     *
               */
              pngURI() {
                return this.getCanvas().toDataURL("image/png");
              }
              /**
               * Return a promise that resolves to an animated PNG image URI of
               viewer contents (base64 encoded) for nframes of viewer changes.
               * @return {Promise}
               */
              apngURI(S) {
                let C = this;
                return S = S || 1, new Promise(function(D) {
                  let O = 0, N = C.viewChangeCallback, j = [], L = [], z = Date.now();
                  C.viewChangeCallback = function() {
                    L.push(Date.now() - z), z = Date.now(), j.push(new Promise((G) => {
                      C.getCanvas().toBlob(function(B) {
                        B.arrayBuffer().then(G);
                      }, "image/png");
                    })), O += 1, O == S && (C.viewChangeCallback = N, Promise.all(j).then((G) => {
                      let B = [];
                      for (let Z = 0; Z < G.length; Z++) {
                        let Q = (0, R.decode)(G[Z]);
                        B.push((0, R.toRGBA8)(Q)[0]);
                      }
                      let F = C.getCanvas().width, H = C.getCanvas().height, W = (0, R.encode)(B, F, H, 0, L), V = new Blob([W], { type: "image/png" }), X = new FileReader();
                      X.onload = function(Z) {
                        D(Z.target.result);
                      }, X.readAsDataURL(V);
                    }));
                  };
                });
              }
              /**
               * Return underlying canvas element.
               */
              getCanvas() {
                return this.glDOM;
              }
              /**
               * Return renderer element.
               */
              getRenderer() {
                return this.renderer;
              }
              /**
                   * Set the duration of the hover delay
                   *
                   * @param {number}
                   *            [hoverDuration] - an optional parameter that denotes
                   *            the duration of the hover delay (in milliseconds) before the hover action is called
                   *
               */
              setHoverDuration(S) {
                this.hoverDuration = S;
              }
              mouseXY(S, C) {
                let D = this.canvasOffset(), O = this.renderer.getXRatio(), N = this.renderer.getYRatio(), j = this.col, L = this.row, z = j * (this.WIDTH / O), G = (N - L - 1) * (this.HEIGHT / N), B = (S - D.left - z) / (this.WIDTH / O) * 2 - 1, F = -((C - D.top - G) / (this.HEIGHT / N)) * 2 + 1;
                return { x: B, y: F };
              }
              _handleMouseMove(S) {
                clearTimeout(this.hoverTimeout), S.preventDefault();
                let C = this.getX(S), D = this.getY(S);
                if (C === void 0)
                  return;
                let O = this.renderer.getXRatio(), N = this.renderer.getYRatio(), j = this.mouseXY(C, D), L = this;
                this.current_hover !== null && this.handleHoverContinue(j.x, j.y);
                var z = 0;
                if (!(!this.control_all && !this.isInViewer(C, D)) && this.scene && (this.hoverables.length > 0 && (this.hoverTimeout = setTimeout(function() {
                  L.handleHoverSelection(j.x, j.y, S);
                }, this.hoverDuration)), !!this.isDragging)) {
                  var G = (C - this.mouseStartX) / this.WIDTH, B = (D - this.mouseStartY) / this.HEIGHT;
                  if (this.touchDistanceStart != 0 && S.targetTouches && S.targetTouches.length == 2) {
                    var F = this.calcTouchDistance(S);
                    z = 2, B = (F - this.touchDistanceStart) * 2 / (this.WIDTH + this.HEIGHT);
                  } else
                    S.targetTouches && S.targetTouches.length == 3 && (z = 1);
                  G *= O, B *= N;
                  var H = Math.hypot(G, B), W;
                  if (z == 3 || this.mouseButton == 3 && S.ctrlKey)
                    this.slabNear = this.cslabNear + G * 100, this.slabFar = this.cslabFar - B * 100;
                  else if (z == 2 || this.mouseButton == 3 || S.shiftKey)
                    W = (this.CAMERA_Z - this.rotationGroup.position.z) * 0.85, W < 80 && (W = 80), this.rotationGroup.position.z = this.cz + B * W, this.rotationGroup.position.z = this.adjustZoomToLimits(this.rotationGroup.position.z);
                  else if (z == 1 || this.mouseButton == 2 || S.ctrlKey) {
                    var V = this.screenOffsetToModel(O * (C - this.mouseStartX), N * (D - this.mouseStartY));
                    this.modelGroup.position.addVectors(this.currentModelPos, V);
                  } else if ((z === 0 || this.mouseButton == 1) && H !== 0) {
                    var X = Math.sin(H * Math.PI) / H;
                    this.dq.x = Math.cos(H * Math.PI), this.dq.y = 0, this.dq.z = X * G, this.dq.w = -X * B, this.rotationGroup.quaternion.set(1, 0, 0, 0), this.rotationGroup.quaternion.multiply(this.dq), this.rotationGroup.quaternion.multiply(this.cq);
                  }
                  this.show();
                }
              }
              _handleContextMenu(S) {
                S.preventDefault();
                var C = this.getX(S), D = this.getY(S);
                if (!(C != this.mouseStartX || D != this.mouseStartY)) {
                  var j = this.mouseStartX, L = this.mouseStartY, N = this.canvasOffset();
                  let z = this.mouseXY(j, L), G = z.x, B = z.y, F = this.targetedObjects(G, B, this.contextMenuEnabledAtoms);
                  var O = null;
                  F.length && (O = F[0].clickable);
                  var N = this.canvasOffset(), j = this.mouseStartX - N.left, L = this.mouseStartY - N.top;
                  this.userContextMenuHandler && this.userContextMenuHandler(O, j, L, F);
                }
              }
              /**
              	     * Change the viewer's container element
              	     * Also useful if the original container element was removed from the DOM.
              	     *
              	     * @param {Object | string} element
              	     *            Either HTML element or string identifier. Defaults to the element used to initialize the viewer.
              
              	     */
              setContainer(S) {
                let C = (0, f.getElement)(S) || this.container;
                return this.initContainer(C), this;
              }
              /**
              	     * Set the background color (default white)
              	     *
              	     * @param {number}
              	     *            hex Hexcode specified background color, or standard color spec
              	     * @param {number}
              	     *            a Alpha level (default 1.0)
              	     *
              	     * @example
              	     *
              	     * viewer.setBackgroundColor(0x000000);
              
              
              	     *
              	     */
              setBackgroundColor(S, C) {
                (typeof C > "u" || C < 0 || C > 1) && (C = 1);
                var D = u.CC.color(S);
                return this.scene.fog.color = D, this.bgColor = D.getHex(), this.renderer.setClearColorHex(D.getHex(), C), this.show(), this;
              }
              /**
              	     * Set view projection scheme.  Either orthographic or perspective.
              	     * Default is perspective.  Orthographic can also be enabled on viewer creation
              	     * by setting orthographic to true in the config object.
              	     *
              	     *
              	     * @example
              	     viewer.setViewStyle({style:"outline"});
              	          $3Dmol.get('data/1fas.pqr', function(data){
              	              viewer.addModel(data, "pqr");
              	              $3Dmol.get("data/1fas.cube",function(volumedata){
              	                  viewer.addSurface($3Dmol.SurfaceType.VDW, {opacity:0.85,voldata: new $3Dmol.VolumeData(volumedata, "cube"), volscheme: new $3Dmol.Gradient.RWB(-10,10)},{});
              	              });
              	              viewer.zoomTo();
              
              	              viewer.setProjection("orthographic");
              	              viewer.render(callback);
              	          });
              	     *
              	     */
              setProjection(S) {
                this.camera.ortho = S === "orthographic", this.setSlabAndFog();
              }
              /**
               * Set global view styles.
               *
               * @example
               *   viewer.setViewStyle({style:"outline"});
                    $3Dmol.get('data/1fas.pqr', function(data){
                        viewer.addModel(data, "pqr");
                        $3Dmol.get("data/1fas.cube",function(volumedata){
                            viewer.addSurface($3Dmol.SurfaceType.VDW, {opacity:0.85,voldata: new $3Dmol.VolumeData(volumedata, "cube"), volscheme: new $3Dmol.Gradient.RWB(-10,10)},{});
                        });
                        viewer.zoomTo();
                        viewer.render(callback);
                    });
               *
               */
              setViewStyle(S) {
                if (S.style === "outline") {
                  var C = {};
                  S.color && (C.color = u.CC.color(S.color)), S.width && (C.width = S.width), this.renderer.enableOutline(C);
                } else
                  this.renderer.disableOutline();
                return this;
              }
              updateSize() {
                this.renderer.setSize(this.WIDTH, this.HEIGHT), this.ASPECT = this.renderer.getAspect(this.WIDTH, this.HEIGHT), this.renderer.setSize(this.WIDTH, this.HEIGHT), this.camera.aspect = this.ASPECT, this.camera.updateProjectionMatrix();
              }
              /**
               * Set viewer width independently of the HTML container.  This is probably not what you want.
               *
               * @param {number} w Width in pixels
               */
              setWidth(S) {
                return this.WIDTH = S || this.WIDTH, this.updateSize(), this;
              }
              /**
               * Set viewer height independently of the HTML container.  This is probably not what you want.
               *
               * @param {number} h Height in pixels
               */
              setHeight(S) {
                return this.HEIGHT = S || this.HEIGHT, this.updateSize(), this;
              }
              /**
               * Resize viewer according to containing HTML element's dimensions
               *
               */
              resize() {
                this.WIDTH = this.getWidth(), this.HEIGHT = this.getHeight();
                let S = !1;
                if (this.renderer.isLost() && this.WIDTH > 0 && this.HEIGHT > 0) {
                  let C = !1, D = this.container.querySelector("canvas");
                  D && D != this.renderer.getCanvas() ? this.config.canvas = D : (D.remove(), this.config && this.config.canvas != null && (delete this.config.canvas, C = !0)), this.setupRenderer(), this.initContainer(this.container), S = !0, C && (this.config.canvas = this.renderer.getCanvas());
                }
                if (this.WIDTH == 0 || this.HEIGHT == 0 ? this.animated && this._viewer.pauseAnimate() : this.animated && this._viewer.resumeAnimate(), this.updateSize(), S) {
                  let C = this.renderer.supportedExtensions();
                  if (C.regen = !0, this.viewers)
                    for (let D = 0, O = this.viewers.length; D < O; D++)
                      for (let N = 0, j = this.viewers[D].length; N < j; N++)
                        this.viewers[D][N].render(null, C);
                  this._viewer.render(null, C);
                } else
                  this.show();
                return this;
              }
              /**
               * Return specified model
               *
               * @param {number}
               *            [id=last model id] - Retrieve model with specified id
               * @default Returns last model added to viewer or null if there are no models
               * @return {GLModel}
               *
               * @example // Retrieve reference to first GLModel added var m =
               *    $3Dmol.download("pdb:1UBQ",viewer,{},function(m1){
                        $3Dmol.download("pdb:1UBI", viewer,{}, function(m2) {
                          viewer.zoomTo();
                          m1.setStyle({cartoon: {color:'green'}});
                          //could use m2 here as well
                          viewer.getModel().setStyle({cartoon: {color:'blue'}});
                          viewer.render();
                      })
                    });
               */
              getModel(S) {
                return S === void 0 ? this.models.length == 0 ? null : this.models[this.models.length - 1] : S instanceof p.GLModel ? S : S in this.models ? this.models[S] : this.models.length == 0 ? null : this.models[this.models.length - 1];
              }
              /**
               * Continuously rotate a scene around the specified axis.
               *
               * Call `spin(false)` to stop spinning.
               *
               * @param  {string|boolean|Array} axis
               *            [axis] - Axis ("x", "y", "z", "vx", "vy", or "vz") to rotate around.
               *            Default "y".  View relative (rather than model relative) axes are prefixed with v.
               * @param  {number} speed
               *            [speed] - Speed multiplier for spinning the viewer. 1 is default and a negative
               *             value reverses the direction of the spin.
               *
               */
              spin(S, C = 1) {
                if (clearInterval(this.spinInterval), typeof S > "u" && (S = "y"), typeof S == "boolean")
                  if (S)
                    S = "y";
                  else
                    return;
                Array.isArray(S) && (S = { x: S[0], y: S[1], z: S[2] });
                var D = this;
                this.spinInterval = setInterval(function() {
                  !D.getCanvas().isConnected && D.renderer.isLost() && clearInterval(D.spinInterval), D.rotate(1 * C, S);
                }, 25);
              }
              //animate motion between current position and passed position
              // can set some parameters to null
              //if fixed is true will enforce the request animation, otherwise
              //does relative updates
              //positions objects have modelggroup position, rotation group position.z,
              //and rotationgroup quaternion
              //return array includes final position, but not current
              //the returned array includes an animate method
              animateMotion(S, C, D, O, N, j) {
                var L = 20, z = Math.ceil(S / L);
                z < 1 && (z = 1), this.incAnim();
                var G = {
                  mpos: this.modelGroup.position.clone(),
                  rz: this.rotationGroup.position.z,
                  rot: this.rotationGroup.quaternion.clone(),
                  cam: this.lookingAt.clone()
                };
                if (C) {
                  let H = new Array(z);
                  for (let Z = 0; Z < z; Z++) {
                    let Q = (Z + 1) / z, q = { mpos: G.mpos, rz: G.rz, rot: G.rot };
                    q.mpos = D.clone().sub(G.mpos).multiplyScalar(Q).add(G.mpos), q.rz = G.rz + Q * (O - G.rz), q.rot = _.slerp(G.rot, N, Q), q.cam = j.clone().sub(G.cam).multiplyScalar(Q).add(G.cam), H[Z] = q;
                  }
                  let W = 0, V = this, X = function() {
                    var Z = H[W];
                    W += 1, V.modelGroup.position = Z.mpos, V.rotationGroup.position.z = Z.rz, V.rotationGroup.quaternion = Z.rot, V.camera.lookAt(Z.cam), W < H.length ? setTimeout(X, L) : V.decAnim(), V.show();
                  };
                  setTimeout(X, L);
                } else {
                  var B = {};
                  let H = 1 / z;
                  if (D && (B.mpos = D.clone().sub(G.mpos).multiplyScalar(H)), typeof O < "u" && O != null && (B.rz = H * (O - G.rz)), N) {
                    var F = _.slerp(G.rot, N, H);
                    B.rot = G.rot.clone().inverse().multiply(F);
                  }
                  j && (B.cam = j.clone().sub(G.cam).multiplyScalar(H));
                  let W = 0, V = this, X = function() {
                    W += 1, B.mpos && V.modelGroup.position.add(B.mpos), B.rz && (V.rotationGroup.position.z += B.rz), B.rot && V.rotationGroup.quaternion.multiply(B.rot), B.cam && (V.lookingAt.add(B.cam), V.camera.lookAt(V.lookingAt)), W < z ? setTimeout(X, L) : V.decAnim(), V.show();
                  };
                  setTimeout(X, L);
                }
              }
              /**
              	     * Rotate scene by angle degrees around axis
              	     *
              	     * @param {number}
              	     *            [angle] - Angle, in degrees, to rotate by.
              	     * @param {string}
              	     *            [axis] - Axis ("x", "y", "z", "vx", "vy", or "vz") to rotate around.
              	     *            Default "y".  View relative (rather than model relative) axes are prefixed with v.
              	     *            Axis can also be specified as a vector.
              	     * @param {number}
              	     *            [animationDuration] - an optional parameter that denotes
              	     *            the duration of the rotation animation. Default 0 (no animation)
              	     * @param {boolean} [fixedPath] - if true animation is constrained to
              	     *      requested motion, overriding updates that happen during the animation         *
              	     * @example     $3Dmol.download('cid:4000', viewer, {}, function() {
              	    viewer.setStyle({stick:{}});
              	    viewer.zoomTo();
              	    viewer.rotate(90,'y',1);
              	    viewer.render(callback);
              	    });
              
              	     *
              	     */
              rotate(S, C = "y", D = 0, O = !1) {
                if (C == "x" ? C = { x: 1, y: 0, z: 0 } : C == "y" ? C = { x: 0, y: 1, z: 0 } : C == "z" && (C = { x: 0, y: 0, z: 1 }), C == "vx" ? C = { vx: 1, vy: 0, vz: 0 } : C == "vy" ? C = { vx: 0, vy: 1, vz: 0 } : C == "vz" && (C = { vx: 0, vy: 0, vz: 1 }), typeof C.vx < "u") {
                  var N = new l.Vector3(C.vx, C.vy, C.vz);
                  N.applyQuaternion(this.rotationGroup.quaternion), C = { x: N.x, y: N.y, z: N.z };
                }
                var j = function(B) {
                  var F = Math.sin(B / 2), H = Math.cos(B / 2), W = 0, V = 0, X = 0;
                  return W = C.x * F, V = C.y * F, X = C.z * F, new l.Quaternion(W, V, X, H).normalize();
                }, L = Math.PI * S / 180, z = j(L);
                if (D) {
                  var G = new l.Quaternion().copy(this.rotationGroup.quaternion).multiply(z);
                  this.animateMotion(D, O, this.modelGroup.position, this.rotationGroup.position.z, G, this.lookingAt);
                } else
                  this.rotationGroup.quaternion.multiply(z), this.show();
                return this;
              }
              surfacesFinished() {
                for (var S in this.surfaces)
                  if (!this.surfaces[S][0].done)
                    return !1;
                return !0;
              }
              /** Returns an array representing the current viewpoint.
               * Translation, zoom, and rotation quaternion.
               * @returns {Array.<number>} [ pos.x, pos.y, pos.z, rotationGroup.position.z, q.x, q.y, q.z, q.w ]
               *  */
              getView() {
                if (!this.modelGroup)
                  return [0, 0, 0, 0, 0, 0, 0, 1];
                var S = this.modelGroup.position, C = this.rotationGroup.quaternion;
                return [
                  S.x,
                  S.y,
                  S.z,
                  this.rotationGroup.position.z,
                  C.x,
                  C.y,
                  C.z,
                  C.w
                ];
              }
              /** Sets the view to the specified translation, zoom, and rotation.
               *
               * @param {Array.<number>} arg Array formatted identically to the return value of getView */
              setView(S, C) {
                return S === void 0 || !(S instanceof Array || S.length !== 8) ? this : !this.modelGroup || !this.rotationGroup ? this : (this.modelGroup.position.x = S[0], this.modelGroup.position.y = S[1], this.modelGroup.position.z = S[2], this.rotationGroup.position.z = S[3], this.rotationGroup.quaternion.x = S[4], this.rotationGroup.quaternion.y = S[5], this.rotationGroup.quaternion.z = S[6], this.rotationGroup.quaternion.w = S[7], typeof S[8] < "u" && (this.rotationGroup.position.x = S[8], this.rotationGroup.position.y = S[9]), this.show(C), this);
              }
              // apply styles, models, etc in viewer
              /**
               * Render current state of viewer, after
               * adding/removing models, applying styles, etc.
               *
               */
              render(S, C) {
                this.renderer.setViewport(), this.updateClickables();
                var D = this.getView();
                this.stateChangeCallback && this.stateChangeCallback(this.getInternalState());
                var O, N;
                for (C || (C = this.renderer.supportedExtensions()), O = 0; O < this.models.length; O++)
                  this.models[O] && this.models[O].globj(this.modelGroup, C);
                for (O = 0; O < this.shapes.length; O++)
                  this.shapes[O] && (typeof this.shapes[O].frame > "u" || this.viewer_frame < 0 || this.shapes[O].frame < 0 || this.shapes[O].frame == this.viewer_frame ? this.shapes[O].globj(this.modelGroup, C) : this.shapes[O].removegl(this.modelGroup));
                for (O = 0; O < this.labels.length; O++)
                  C.regen && (this.labels[O].dispose(), this.modelGroup.remove(this.labels[O].sprite), this.labels[O].setContext(), this.modelGroup.add(this.labels[O].sprite)), this.labels[O] && typeof this.labels[O].frame < "u" && this.labels[O].frame >= 0 && (this.modelGroup.remove(this.labels[O].sprite), (this.viewer_frame < 0 || this.labels[O].frame == this.viewer_frame) && this.modelGroup.add(this.labels[O].sprite));
                for (O in this.surfaces)
                  if (this.surfaces.hasOwnProperty(O)) {
                    var j = this.surfaces[O];
                    for (N = 0; N < j.length; N++)
                      if (j.hasOwnProperty(N)) {
                        var L = j[N].geo;
                        if (!j[N].finished || C.regen) {
                          L.verticesNeedUpdate = !0, L.elementsNeedUpdate = !0, L.normalsNeedUpdate = !0, L.colorsNeedUpdate = !0, L.buffersNeedUpdate = !0, L.boundingSphere = null, j[N].mat.needsUpdate = !0, j[N].done && (j[N].finished = !0), j[N].lastGL && this.modelGroup.remove(j[N].lastGL);
                          var z = null;
                          if (j[N].mat instanceof o.LineBasicMaterial ? z = new o.Line(L, j[N].mat) : z = new o.Mesh(L, j[N].mat), j[N].mat.transparent && j[N].mat.opacity == 0 ? z.visible = !1 : z.visible = !0, j[N].symmetries.length > 1 || j[N].symmetries.length == 1 && !j[N].symmetries[N].isIdentity()) {
                            var G, B = new o.Object3D();
                            for (G = 0; G < j[N].symmetries.length; G++) {
                              var F = z.clone();
                              F.matrix = j[N].symmetries[G], F.matrixAutoUpdate = !1, B.add(F);
                            }
                            j[N].lastGL = B, this.modelGroup.add(B);
                          } else
                            j[N].lastGL = z, this.modelGroup.add(z);
                        }
                      }
                  }
                return this.setView(D), typeof S == "function" && S(this), this;
              }
              /* @param {AtomSelectionSpec|any} sel
               * @return list of models specified by sel
               */
              getModelList(S) {
                let C = [];
                if (typeof S > "u" || typeof S.model > "u")
                  for (let O = 0; O < this.models.length; O++)
                    this.models[O] && C.push(this.models[O]);
                else {
                  let O = S.model;
                  Array.isArray(O) || (O = [O]);
                  for (let N = 0; N < O.length; N++)
                    if (typeof O[N] == "number") {
                      var D = O[N];
                      D < 0 && (D += this.models.length), C.push(this.models[D]);
                    } else
                      C.push(O[N]);
                }
                return C;
              }
              /**
               *
               * @param {AtomSelectionSpec}
               *            sel
               * @return {AtomSpec[]}
               */
              getAtomsFromSel(S) {
                var C = [];
                typeof S > "u" && (S = {});
                var D = this.getModelList(S);
                for (let O = 0; O < D.length; O++)
                  C = C.concat(D[O].selectedAtoms(S));
                return C;
              }
              /**
               *
               * @param {AtomSpec}
               *            atom
               * @param {AtomSelectionSpec}
               *            sel
               * @return {boolean}
               */
              atomIsSelected(S, C) {
                typeof C > "u" && (C = {});
                for (var D = this.getModelList(C), O = 0; O < D.length; O++)
                  if (D[O].atomIsSelected(S, C))
                    return !0;
                return !1;
              }
              /** return list of atoms selected by sel
               *
               * @param {AtomSelectionSpec} sel
               * @return {AtomSpec[]}
               */
              selectedAtoms(S) {
                return this.getAtomsFromSel(S);
              }
              /**
              * Returns valid values for the specified attribute in the given selection
              * @param {string} attribute
              * @param {AtomSelectionSpec} sel
              * @return {Array.<Object>}
              *
              */
              getUniqueValues(S, C) {
                typeof C > "u" && (C = {});
                var D = this.getAtomsFromSel(C), O = {};
                for (var N in D)
                  if (D[N].hasOwnProperty(S)) {
                    var j = D[N][S];
                    O[j] = !0;
                  }
                return Object.keys(O);
              }
              /**
               * Return pdb output of selected atoms (if atoms from pdb input)
               *
               * @param {AtomSelectionSpec} sel - Selection specification specifying model and atom properties to select.  Default: all atoms in viewer
               * @return {string} PDB string of selected atoms
               */
              pdbData(S) {
                for (var C = this.getAtomsFromSel(S), D = "", O = 0, N = C.length; O < N; ++O)
                  D += C[O].pdbline + `
`;
                return D;
              }
              /**
              	     * Zoom current view by a constant factor
              	     *
              	     * @param {number}
              	     *            [factor] - Magnification factor. Values greater than 1
              	     *            will zoom in, less than one will zoom out. Default 2.
              	     * @param {number}
              	     *            [animationDuration] - an optional parameter that denotes
              	     *            the duration of a zoom animation
              	     * @param {Boolean} [fixedPath] - if true animation is constrained to
              	     *      requested motion, overriding updates that happen during the animation
              	     * @example
              	    $3Dmol.get('data/4csv.pdb', function(data) {
              	    viewer.addModel(data,'pdb');
              	    viewer.setStyle({cartoon:{},stick:{}});
              	    viewer.zoomTo()
              	    viewer.zoom(2,1000);
              	    viewer.render();
              	    });
              
              	         */
              zoom(S = 2, C = 0, D = !1) {
                var O = (this.CAMERA_Z - this.rotationGroup.position.z) / S, N = this.CAMERA_Z - O;
                return C > 0 ? this.animateMotion(C, D, this.modelGroup.position, this.adjustZoomToLimits(N), this.rotationGroup.quaternion, this.lookingAt) : (this.rotationGroup.position.z = this.adjustZoomToLimits(N), this.show()), this;
              }
              /**
               * Translate current view by x,y screen coordinates
               * This pans the camera rather than translating the model.
               *
               * @param {number} x Relative change in view coordinates of camera
               * @param {number} y Relative change in view coordinates of camera
               * @param {number}
               *            [animationDuration] - an optional parameter that denotes
               *            the duration of a zoom animation
               * @param {Boolean} [fixedPath] - if true animation is constrained to
               *      requested motion, overriding updates that happen during the animation         *
               * @example     $3Dmol.get('data/4csv.pdb', function(data) {
              viewer.addModel(data,'pdb');
              viewer.setStyle({cartoon:{},stick:{}});
              viewer.zoomTo();
              viewer.translate(200,50);
              viewer.rotate(90,'z');
              viewer.render(callback);
              });
               */
              translate(S, C, D = 0, O = !1) {
                var N = S / this.WIDTH, j = C / this.HEIGHT, L = new l.Vector3(0, 0, -this.CAMERA_Z);
                this.projector.projectVector(L, this.camera), L.x -= N, L.y -= j, this.projector.unprojectVector(L, this.camera), L.z = 0;
                var z = this.lookingAt.clone().add(L);
                return D > 0 ? this.animateMotion(D, O, this.modelGroup.position, this.rotationGroup.position.z, this.rotationGroup.quaternion, z) : (this.lookingAt = z, this.camera.lookAt(this.lookingAt), this.show()), this;
              }
              /**
               * Translate current models by x,y screen coordinates
               * This translates the models relative to the current view. It does
               * not change the center of rotation.
               *
               * @param {number} x Relative change in x screen coordinate
               * @param {number} y Relative change in y screen coordinate
               * @param {number}
               *            [animationDuration] - an optional parameter that denotes
               *            the duration of a zoom animation
               * @param {Boolean} [fixedPath] - if true animation is constrained to
               *      requested motion, overriding updates that happen during the animation         *
               * @example     $3Dmol.get('data/4csv.pdb', function(data) {
              viewer.addModel(data,'pdb');
              viewer.setStyle({cartoon:{},stick:{}});
              viewer.zoomTo();
              viewer.translateScene(200,50);
              viewer.rotate(90,'z'); // will no longer be around model center
              viewer.render(callback);
              });
               */
              translateScene(S, C, D = 0, O = !1) {
                var N = this.screenOffsetToModel(S, C), j = this.modelGroup.position.clone().add(N);
                return D > 0 ? this.animateMotion(D, O, this.modelGroup.position, this.rotationGroup.position.z, this.rotationGroup.quaternion, this.lookingAt) : (this.modelGroup.position = j, this.show()), this;
              }
              /**
               * Adjust slab to fully enclose selection (default everything).
               *
               * @param {AtomSelectionSpec} sel
               *            Selection specification specifying model and atom
               *            properties to select. Default: all atoms in viewer
               */
              fitSlab(S) {
                S = S || {};
                var C = this.getAtomsFromSel(S), D = (0, f.getExtent)(C), O = D[1][0] - D[0][0], N = D[1][1] - D[0][1], j = D[1][2] - D[0][2], L = Math.hypot(O, N, j);
                return L < 5 && (L = 5), this.slabNear = -L / 1.9, this.slabFar = L / 2, this;
              }
              /**
               * Re-center the viewer around the provided selection (unlike zoomTo, does not zoom).
               *
               * @param {AtomSelectionSpec}
               *            [sel] - Selection specification specifying model and atom
               *            properties to select. Default: all atoms in viewer
               * @param {number}
               *            [animationDuration] - an optional parameter that denotes
               *            the duration of a zoom animation
               * @param {Boolean} [fixedPath] - if true animation is constrained to
               *      requested motion, overriding updates that happen during the animation         *
               * @example // if the user were to pass the animationDuration value to
               *           // the function like so viewer.zoomTo({resn:'STI'},1000);
               *         //   the program would center on resn 'STI' over the course
               *         //   of 1 second(1000 milleseconds).
               *  // Reposition to centroid of all atoms of all models in this
               * //viewer glviewer.center();
              $3Dmol.get('data/4csv.pdb', function(data) {
              viewer.addModel(data,'pdb');
              viewer.setStyle({cartoon:{},stick:{}});
              viewer.center();
              viewer.render(callback);
              });
               */
              center(S = {}, C = 0, D = !1) {
                var O, N, j = this.getAtomsFromSel(S), L = (0, f.getExtent)(j);
                (0, f.isEmptyObject)(S) ? (this.shapes.forEach((Q) => {
                  if (Q && Q.boundingSphere && Q.boundingSphere.center) {
                    var q = Q.boundingSphere.center, J = Q.boundingSphere.radius;
                    J > 0 ? (j.push(new l.Vector3(q.x + J, q.y, q.z)), j.push(new l.Vector3(q.x - J, q.y, q.z)), j.push(new l.Vector3(q.x, q.y + J, q.z)), j.push(new l.Vector3(q.x, q.y - J, q.z)), j.push(new l.Vector3(q.x, q.y, q.z + J)), j.push(new l.Vector3(q.x, q.y, q.z - J))) : j.push(q);
                  }
                }), L = (0, f.getExtent)(j), O = j, N = L) : (O = this.getAtomsFromSel({}), N = (0, f.getExtent)(O));
                var z = new l.Vector3(L[2][0], L[2][1], L[2][2]), G = N[1][0] - N[0][0], B = N[1][1] - N[0][1], F = N[1][2] - N[0][2], H = Math.hypot(G, B, F);
                H < 5 && (H = 5), this.slabNear = -H / 1.9, this.slabFar = H / 2, G = L[1][0] - L[0][0], B = L[1][1] - L[0][1], F = L[1][2] - L[0][2], H = Math.hypot(G, B, F), H < 5 && (H = 5);
                for (var W = 25, V = 0; V < j.length; V++)
                  if (j[V]) {
                    var X = z.distanceToSquared(j[V]);
                    X > W && (W = X);
                  }
                H = Math.sqrt(W) * 2;
                var Z = z.clone().multiplyScalar(-1);
                return C > 0 ? this.animateMotion(C, D, Z, this.rotationGroup.position.z, this.rotationGroup.quaternion, this.lookingAt) : (this.modelGroup.position = Z, this.show()), this;
              }
              /**
              	     * Zoom to center of atom selection.  The slab will be set appropriately for
              	     * the selection, unless an empty selection is provided, in which case there will be no slab.
              	     *
              	     * @param {Object}
              	     *            [sel] - Selection specification specifying model and atom
              	     *            properties to select. Default: all atoms in viewer
              	     * @param {number}
              	     *            [animationDuration] - an optional parameter that denotes
              	     *            the duration of a zoom animation
              	     * @param {Boolean} [fixedPath] - if true animation is constrained to
              	     *      requested motion, overriding updates that happen during the animation         *
              	      * @example
              
              
              	          $3Dmol.get('data/1fas.pqr', function(data){
              	              viewer.addModel(data, "pqr");
              	              $3Dmol.get("data/1fas.cube",function(volumedata){
              	                  viewer.addSurface($3Dmol.SurfaceType.VDW, {
              	                      opacity:0.85,
              	                      voldata: new $3Dmol.VolumeData(volumedata, "cube"),
              	                      volscheme: new $3Dmol.Gradient.Sinebow($3Dmol.getPropertyRange(viewer.selectedAtoms(),'charge'))
              	                  },{});
              
              	              viewer.render();
              	              });
              	              viewer.zoomTo();
              	            });
              	     */
              zoomTo(S = {}, C = 0, D = !1) {
                let O = this.getAtomsFromSel(S), N = (0, f.getExtent)(O), j = N;
                if ((0, f.isEmptyObject)(S)) {
                  let q = O && O.length;
                  if (this.shapes.forEach((J) => {
                    if (J && J.boundingSphere) {
                      if (J.boundingSphere.box) {
                        let ge = J.boundingSphere.box;
                        O.push(new l.Vector3(ge.min.x, ge.min.y, ge.min.z)), O.push(new l.Vector3(ge.max.x, ge.max.y, ge.max.z));
                      } else if (J.boundingSphere.center) {
                        var ie = J.boundingSphere.center, ne = J.boundingSphere.radius;
                        ne > 0 ? (O.push(new l.Vector3(ie.x + ne, ie.y, ie.z)), O.push(new l.Vector3(ie.x - ne, ie.y, ie.z)), O.push(new l.Vector3(ie.x, ie.y + ne, ie.z)), O.push(new l.Vector3(ie.x, ie.y - ne, ie.z)), O.push(new l.Vector3(ie.x, ie.y, ie.z + ne)), O.push(new l.Vector3(ie.x, ie.y, ie.z - ne))) : O.push(ie);
                      }
                    }
                  }), j = (0, f.getExtent)(O), !q)
                    for (let J = 0; J < 3; J++)
                      N[2][J] = (j[0][J] + j[1][J]) / 2;
                } else {
                  let q = this.getAtomsFromSel({});
                  j = (0, f.getExtent)(q);
                }
                var L = new l.Vector3(N[2][0], N[2][1], N[2][2]), z = j[1][0] - j[0][0], G = j[1][1] - j[0][1], B = j[1][2] - j[0][2], F = Math.hypot(z, G, B);
                F < 5 && (F = 5), this.slabNear = -F / 1.9, this.slabFar = F / 2, Object.keys(S).length === 0 && (this.slabNear = Math.min(-F * 2, -50), this.slabFar = Math.max(F * 2, 50));
                var H = this.config.minimumZoomToDistance || 5;
                z = N[1][0] - N[0][0], G = N[1][1] - N[0][1], B = N[1][2] - N[0][2], F = Math.hypot(z, G, B), F < H && (F = H);
                for (var W = H * H, V = 0; V < O.length; V++)
                  if (O[V]) {
                    var X = L.distanceToSquared(O[V]);
                    X > W && (W = X);
                  }
                F = Math.sqrt(W) * 2;
                var Z = L.clone().multiplyScalar(-1), Q = -(F * 0.5 / Math.tan(Math.PI / 180 * this.camera.fov / 2) - this.CAMERA_Z);
                return Q = this.adjustZoomToLimits(Q), C > 0 ? this.animateMotion(C, D, Z, Q, this.rotationGroup.quaternion, this.lookingAt) : (this.modelGroup.position = Z, this.rotationGroup.position.z = Q, this.show()), this;
              }
              /**
               * Set slab of view (contents outside of slab are clipped).
               * Must call render to update.
               *
               * @param {number} near near clipping plane distance
               * @param {number} far far clipping plane distance
               */
              setSlab(S, C) {
                this.slabNear = S, this.slabFar = C;
              }
              /**
               * Get slab of view (contents outside of slab are clipped).
               *
               * @return {Object}
               *      @property {number} near - near clipping plane distance
               *      @property {number} far - far clipping plane distance
               */
              getSlab() {
                return { near: this.slabNear, far: this.slabFar };
              }
              /**
              	     * Add label to viewer
              	     *
              	     * @param {string}
              	     *            text - Label text
              	     * @param {LabelSpec}
              	     *            options - Label style specification
              	      @param {AtomSelection}
              	     *            sel - Set position of label to center of this selection
              	     * @param {boolean} noshow - if true, do not immediately display label - when adding multiple labels this is more efficient
              	     * @return {Label}
              	     *
              	     * @example
              	     *  $3Dmol.download("pdb:2EJ0",viewer,{},function(){
              
              	              viewer.addLabel("Aromatic", {position: {x:-6.89, y:0.75, z:0.35}, backgroundColor: 0x800080, backgroundOpacity: 0.8});
              	              viewer.addLabel("Label",{font:'sans-serif',fontSize:18,fontColor:'white',fontOpacity:1,borderThickness:1.0,
              	                                       borderColor:'red',borderOpacity:0.5,backgroundColor:'black',backgroundOpacity:0.5,
              	                                       position:{x:50.0,y:0.0,z:0.0},inFront:true,showBackground:true});
              	              viewer.setStyle({chain:'A'},{cross:{hidden:true}});
              	              viewer.setStyle({chain:'B'},{cross:{hidden:false,
              	                                                  linewidth:1.0,
              	                                                  colorscheme:'greenCarbon'}});
              	              viewer.setStyle({chain:'C'},{cross:{hidden:false,
              	                                                  linewidth:1.0,
              	                                                  radius:0.5}});
              	              viewer.setStyle({chain:'D'},{cross:{hidden:false,
              	                                                  linewidth:10.0}});
              	              viewer.setStyle({chain:'E'},{cross:{hidden:false,
              	                                                  linewidth:1.0,
              	                                                  color:'black'}});
              
              	              viewer.render();
              
              
              	            });
              
              	     */
              addLabel(S, C = {}, D, O = !1) {
                if (D) {
                  var N = (0, f.getExtent)(this.getAtomsFromSel(D));
                  C.position = { x: N[2][0], y: N[2][1], z: N[2][2] };
                }
                var j = new v.Label(S, C);
                return j.setContext(), this.modelGroup.add(j.sprite), this.labels.push(j), O || this.show(), j;
              }
              /** Add residue labels.  This will generate one label per a
               * residue within the selected atoms.  The label will be at the
               * centroid of the atoms and styled according to the passed style.
               * The label text will be [resn][resi]
               *
               * @param {AtomSelectionSpec} sel
               * @param {AtomStyleSpec} style
               * @param {boolean} byframe - if true, create labels for every individual frame, not just current
               *
               * @example
                   $3Dmol.download("mmtf:2ll5",viewer,{},function(){
                        viewer.setStyle({stick:{radius:0.15},cartoon:{}});
                        viewer.addResLabels({hetflag:false}, {font: 'Arial', fontColor:'black',showBackground:false, screenOffset: {x:0,y:0}});
                        viewer.zoomTo();
                        viewer.render();
                      });
               */
              addResLabels(S, C, D = !1) {
                let O = this.labels.length;
                return this.applyToModels("addResLabels", S, this, C, D), this.show(), this.labels.slice(O);
              }
              /** Add property labels.  This will generate one label per a selected
               * atom at the atom's coordinates with the property value as the label text.
               *
               * @param {string} prop - property name
               * @param {AtomSelectionSpec} sel
               * @param {AtomStyleSpec} style
               *
               * * @example
                   $3Dmol.download("cid:5291",viewer,{},function(){
                        viewer.setStyle({stick: {radius:.2}});
                        viewer.addPropertyLabels("index",{not:{elem:'H'}}, {fontColor:'black',font: 'sans-serif', fontSize: 28, showBackground:false,alignment:'center'});
                        viewer.zoomTo();
                        viewer.render();
                      });
               */
              addPropertyLabels(S, C, D) {
                return this.applyToModels("addPropertyLabels", S, C, this, D), this.show(), this;
              }
              /**
              	     * Remove label from viewer
              	     *
              	     * @param {Label} label - $3Dmol label
              	     *
              	     * @example // Remove labels created in
              	     $3Dmol.download("pdb:2EJ0",viewer,{},function(){
              	              var toremove = viewer.addLabel("Aromatic", {position: {x:-6.89, y:0.75, z:0.35}, backgroundColor: 0x800080, backgroundOpacity: 0.8});
              	              viewer.addLabel("Label",{font:'sans-serif',fontSize:18,fontColor:'white',fontOpacity:1,borderThickness:1.0,
              	                                       borderColor:'red',borderOpacity:0.5,backgroundColor:'black',backgroundOpacity:0.5,
              	                                       position:{x:50.0,y:0.0,z:0.0},inFront:true,showBackground:true});
              	              viewer.removeLabel(toremove);
              	              viewer.render();
              
              
              	            });
              
              	     */
              removeLabel(S) {
                for (var C = 0; C < this.labels.length; C++)
                  if (this.labels[C] == S) {
                    this.labels.splice(C, 1), S.dispose(), this.modelGroup.remove(S.sprite);
                    break;
                  }
                return this.show(), this;
              }
              /**
              	     * Remove all labels from viewer
              	     *
              	     *         @example
              	    $3Dmol.download("pdb:1ubq",viewer,{},function(){
              
              	           viewer.addResLabels();
              	           viewer.setStyle({},{stick:{}});
              	           viewer.render( ); //show labels
              
              	           viewer.removeAllLabels();
              	           viewer.render(); //hide labels
              	    });
              	     */
              removeAllLabels() {
                for (var S = 0; S < this.labels.length; S++)
                  this.labels[S] && this.labels[S].sprite && this.modelGroup.remove(this.labels[S].sprite);
                return this.labels.splice(0, this.labels.length), this.show(), this;
              }
              // Modify label style
              /**
               * Modify existing label's style
               *
               * @param {Label} label - $3Dmol label
               * @param {LabelSpec}
               *            stylespec - Label style specification
               * @return {Label}
               */
              setLabelStyle(S, C) {
                return this.modelGroup.remove(S.sprite), S.dispose(), S.stylespec = C, S.setContext(), this.modelGroup.add(S.sprite), this.show(), S;
              }
              // Change label text
              /**
               * Modify existing label's text
               *
               * @param {Label}  label - $3Dmol label
               * @param {String}
               *            text - Label text
               * @return {Label}
               */
              setLabelText(S, C) {
                return this.modelGroup.remove(S.sprite), S.dispose(), S.text = C, S.setContext(), this.modelGroup.add(S.sprite), this.show(), S;
              }
              /**
               * Add shape object to viewer
               * @see {GLShape}
               *
               * @param {ShapeSpec} shapeSpec - style specification for label
               * @return {GLShape}
               */
              addShape(S) {
                S = S || {};
                var C = new g.GLShape(S);
                return C.shapePosition = this.shapes.length, this.shapes.push(C), C;
              }
              /**
               * Remove shape object from viewer
               *
               * @param {GLShape} shape - Reference to shape object to remove
               */
              removeShape(S) {
                if (!S)
                  return this;
                for (S.removegl(this.modelGroup), delete this.shapes[S.shapePosition]; this.shapes.length > 0 && typeof this.shapes[this.shapes.length - 1] > "u"; )
                  this.shapes.pop();
                return this;
              }
              /**
               * Remove all shape objects from viewer
               */
              removeAllShapes() {
                for (var S = 0; S < this.shapes.length; S++) {
                  var C = this.shapes[S];
                  C && C.removegl(this.modelGroup);
                }
                return this.shapes.splice(0, this.shapes.length), this;
              }
              //gets the center of the selection
              getSelectionCenter(S) {
                if (S.hasOwnProperty("x") && S.hasOwnProperty("y") && S.hasOwnProperty("z"))
                  return S;
                var C = this.getAtomsFromSel(S);
                if (C.length == 0)
                  return { x: 0, y: 0, z: 0 };
                var D = (0, f.getExtent)(C);
                return { x: D[0][0] + (D[1][0] - D[0][0]) / 2, y: D[0][1] + (D[1][1] - D[0][1]) / 2, z: D[0][2] + (D[1][2] - D[0][2]) / 2 };
              }
              /**
              	     * Create and add sphere shape. This method provides a shorthand
              	     * way to create a spherical shape object
              	     *
              	     * @param {SphereShapeSpec} spec - Sphere shape style specification
              	     * @return {GLShape}
              	     @example
              
              	     viewer.addSphere({center:{x:0,y:0,z:0},radius:10.0,color:'red'});
              
              	     viewer.render();
              	     */
              addSphere(S) {
                S = S || {}, S.center = this.getSelectionCenter(S.center);
                var C = new g.GLShape(S);
                return C.shapePosition = this.shapes.length, C.addSphere(S), this.shapes.push(C), C.finalize(), C;
              }
              /**
              	     * Create and add box shape. This method provides a shorthand
              	     * way to create a box shape object
              	     *
              	     * @param {BoxSpec} spec - Box shape style specification
              	     * @return {GLShape}
              	     @example
              
              	     viewer.addLine({color:'red',start:{x:0,y:0,z:0},end:{x:5,y:0,z:0}});
              	     viewer.addLine({color:'blue',start:{x:0,y:0,z:0},end:{x:0,y:5,z:0}});
              	     viewer.addLine({color:'green',start:{x:0,y:0,z:0},end:{x:0,y:0,z:5}});
              
              	     viewer.addBox({center:{x:0,y:0,z:0},dimensions: {w:3,h:4,d:2},color:'magenta'});
              	     viewer.zoomTo();
              	     viewer.rotate(45, {x:1,y:1,z:1});
              	     viewer.render();
              	     */
              addBox(S = {}) {
                S.corner != null && (S.corner = this.getSelectionCenter(S.corner)), S.center != null && (S.center = this.getSelectionCenter(S.center));
                var C = new g.GLShape(S);
                return C.shapePosition = this.shapes.length, C.addBox(S), this.shapes.push(C), C.finalize(), C;
              }
              /**
              	     * Create and add arrow shape
              	     *
              	     * @param {ArrowSpec} spec - Style specification
              	     * @return {GLShape}
              	     @example
              	    $3Dmol.download("pdb:4DM7",viewer,{},function(){
              
              	              viewer.setBackgroundColor(0xffffffff);
              	              viewer.addArrow({
              	                  start: {x:-10.0, y:0.0, z:0.0},
              	                  end: {x:0.0, y:-10.0, z:0.0},
              	                  radius: 1.0,
              	                  radiusRadio:1.0,
              	                  mid:1.0,
              	                  clickable:true,
              	                  callback:function(){
              	                      this.color.setHex(0xFF0000FF);
              	                      viewer.render( );
              	                  }
              	              });
              	              viewer.render();
              	            });
              	     */
              addArrow(S = {}) {
                S.start = this.getSelectionCenter(S.start), S.end = this.getSelectionCenter(S.end);
                var C = new g.GLShape(S);
                return C.shapePosition = this.shapes.length, C.addArrow(S), this.shapes.push(C), C.finalize(), C;
              }
              /**
              	     * Create and add cylinder shape
              	     *
              	     * @param {CylinderSpec} spec - Style specification
              	     * @return {GLShape}
              
              	      @example
              	     viewer.setBackgroundColor(0xffffffff);
              	          viewer.addCylinder({start:{x:0.0,y:0.0,z:0.0},
              	                              end:{x:10.0,y:0.0,z:0.0},
              	                              radius:1.0,
              	                              fromCap:1,
              	                              toCap:2,
              	                              color:'red',
              	                              hoverable:true,
              	                              clickable:true,
              	                              callback:function(){ this.color.setHex(0x00FFFF00);viewer.render( );},
              	                              hover_callback: function(){ viewer.render( );},
              	                              unhover_callback: function(){ this.color.setHex(0xFF000000);viewer.render( );}
              	                             });
              	          viewer.addCylinder({start:{x:0.0,y:2.0,z:0.0},
              	                              end:{x:0.0,y:10.0,z:0.0},
              	                              radius:0.5,
              	                              fromCap:false,
              	                              toCap:true,
              	                              color:'teal'});
              	          viewer.addCylinder({start:{x:15.0,y:0.0,z:0.0},
              	                              end:{x:20.0,y:0.0,z:0.0},
              	                              radius:1.0,
              	                              color:'black',
              	                              fromCap:false,
              	                              toCap:false});
              	          viewer.render();
              	     */
              addCylinder(S = {}) {
                S.start = this.getSelectionCenter(S.start), S.end = this.getSelectionCenter(S.end);
                var C = new g.GLShape(S);
                return C.shapePosition = this.shapes.length, S.dashed ? C.addDashedCylinder(S) : C.addCylinder(S), this.shapes.push(C), C.finalize(), C;
              }
              /**
              	     * Create and add Curve shape
              	     *
              	     * @param {CurveSpec} spec - Style specification
              	     * @return {GLShape}
              
              	     @example
              	          viewer.addCurve({points: [{x:0.0,y:0.0,z:0.0}, {x:5.0,y:3.0,z:0.0}, {x:5.0,y:7.0,z:0.0}, {x:0.0,y:10.0,z:0.0}],
              	                              radius:0.5,
              	                              smooth: 10,
              	                              fromArrow:false,
              	                              toArrow: true,
              	                              color:'orange',
              	                              });
              	          viewer.addCurve({points: [{x:-1,y:0.0,z:0.0}, {x:-5.0,y:5.0,z:0.0}, {x:-2,y:10.0,z:0.0}],
              	                              radius:1,
              	                              fromArrow:true,
              	                              toArrow: false,
              	                              color:'purple',
              	                              });
              	          viewer.zoomTo();
              	          viewer.render();
              	     */
              addCurve(S = {}) {
                var C = new g.GLShape(S);
                return C.shapePosition = this.shapes.length, C.addCurve(S), this.shapes.push(C), C.finalize(), C;
              }
              /**
              	     * Create and add line shape
              	     *
              	     * @param {LineSpec} spec - Style specification, can specify dashed, dashLength, and gapLength
              	     * @return {GLShape}
              	     @example
              	     $3Dmol.download("pdb:2ABJ",viewer,{},function(){
              
              	              viewer.setViewStyle({style:"outline"});
              	              viewer.setStyle({chain:'A'},{sphere:{hidden:true}});
              	              viewer.setStyle({chain:'D'},{sphere:{radius:3.0}});
              	              viewer.setStyle({chain:'G'},{sphere:{colorscheme:'greenCarbon'}});
              	              viewer.setStyle({chain:'J'},{sphere:{color:'blue'}});
              	              viewer.addLine({dashed:true,start:{x:0,y:0,z:0},end:{x:100,y:100,z:100}});
              	              viewer.render();
              	          });
              
              	     */
              addLine(S = {}) {
                S.start = this.getSelectionCenter(S.start), S.end = this.getSelectionCenter(S.end), S.wireframe = !0;
                var C = new g.GLShape(S);
                return C.shapePosition = this.shapes.length, S.dashed ? C = this.addLineDashed(S, C) : C.addLine(S), this.shapes.push(C), C.finalize(), C;
              }
              /**
              	     * Create and add unit cell visualization.
              	     *
              	     * @param {GLModel|number} model - Model with unit cell information (e.g., pdb derived).  If omitted uses most recently added model.
              	     * @param {UnitCellStyleSpec} spec - visualization style
              	       @example
              
              	            $3Dmol.get('data/1jpy.cif', function(data) {
              	              let m = viewer.addModel(data);
              	              viewer.addUnitCell(m, {box:{color:'purple'},alabel:'X',blabel:'Y',clabel:'Z',alabelstyle: {fontColor: 'black',backgroundColor:'white',inFront:true,fontSize:40},astyle:{color:'darkred', radius:5,midpos: -10}});
              	              viewer.zoomTo();
              	              viewer.render();
              	    });
              	     */
              addUnitCell(S, C) {
                S = this.getModel(S), C = C || { alabel: "a", blabel: "b", clabel: "c" }, C.box = C.box || {}, C.astyle = C.astyle || { color: "red", radius: 0.1, midpos: -1 }, C.bstyle = C.bstyle || { color: "green", radius: 0.1, midpos: -1 }, C.cstyle = C.cstyle || { color: "blue", radius: 0.1, midpos: -1 }, C.alabelstyle = C.alabelstyle || { fontColor: "red", showBackground: !1, alignment: "center", inFront: !1 }, C.blabelstyle = C.blabelstyle || { fontColor: "green", showBackground: !1, alignment: "center", inFront: !1 }, C.clabelstyle = C.clabelstyle || { fontColor: "blue", showBackground: !1, alignment: "center", inFront: !1 }, S.unitCellObjects && this.removeUnitCell(S), S.unitCellObjects = { shapes: [], labels: [] };
                var D = S.getCrystData(), O = null;
                if (D) {
                  if (D.matrix)
                    O = D.matrix;
                  else {
                    var N = D.a, j = D.b, L = D.c, z = D.alpha, G = D.beta, B = D.gamma;
                    z = z * Math.PI / 180, G = G * Math.PI / 180, B = B * Math.PI / 180;
                    var F, H, W;
                    F = Math.cos(G), H = (Math.cos(z) - Math.cos(G) * Math.cos(B)) / Math.sin(B), W = Math.sqrt(Math.max(0, 1 - F * F - H * H)), O = new l.Matrix3(N, j * Math.cos(B), L * F, 0, j * Math.sin(B), L * H, 0, 0, L * W);
                  }
                  var V = [
                    new l.Vector3(0, 0, 0),
                    new l.Vector3(1, 0, 0),
                    new l.Vector3(0, 1, 0),
                    new l.Vector3(0, 0, 1),
                    new l.Vector3(1, 1, 0),
                    new l.Vector3(0, 1, 1),
                    new l.Vector3(1, 0, 1),
                    new l.Vector3(1, 1, 1)
                  ];
                  if (D.matrix4)
                    for (let Z = 0; Z < V.length; Z++)
                      D.size && V[Z].multiplyVectors(V[Z], D.size), V[Z] = V[Z].applyMatrix4(D.matrix4);
                  else
                    for (let Z = 0; Z < V.length; Z++)
                      V[Z] = V[Z].applyMatrix3(O);
                  if (C.box && !C.box.hidden) {
                    C.box.wireframe = !0;
                    var X = new g.GLShape(C.box);
                    X.shapePosition = this.shapes.length, X.addLine({ start: V[0], end: V[1] }), X.addLine({ start: V[0], end: V[2] }), X.addLine({ start: V[1], end: V[4] }), X.addLine({ start: V[2], end: V[4] }), X.addLine({ start: V[0], end: V[3] }), X.addLine({ start: V[3], end: V[5] }), X.addLine({ start: V[2], end: V[5] }), X.addLine({ start: V[1], end: V[6] }), X.addLine({ start: V[4], end: V[7] }), X.addLine({ start: V[6], end: V[7] }), X.addLine({ start: V[3], end: V[6] }), X.addLine({ start: V[5], end: V[7] }), this.shapes.push(X), S.unitCellObjects.shapes.push(X), X.finalize();
                  }
                  if (!C.astyle.hidden) {
                    C.astyle.start = V[0], C.astyle.end = V[1];
                    let Z = this.addArrow(C.astyle);
                    S.unitCellObjects.shapes.push(Z);
                  }
                  if (!C.bstyle.hidden) {
                    C.bstyle.start = V[0], C.bstyle.end = V[2];
                    let Z = this.addArrow(C.bstyle);
                    S.unitCellObjects.shapes.push(Z);
                  }
                  if (!C.cstyle.hidden) {
                    C.cstyle.start = V[0], C.cstyle.end = V[3];
                    let Z = this.addArrow(C.cstyle);
                    S.unitCellObjects.shapes.push(Z);
                  }
                  if (C.alabel) {
                    C.alabelstyle.position = V[1];
                    let Z = this.addLabel(C.alabel, C.alabelstyle);
                    S.unitCellObjects.labels.push(Z);
                  }
                  if (C.blabel) {
                    C.blabelstyle.position = V[2];
                    let Z = this.addLabel(C.blabel, C.blabelstyle);
                    S.unitCellObjects.labels.push(Z);
                  }
                  if (C.clabel) {
                    C.clabelstyle.position = V[3];
                    let Z = this.addLabel(C.clabel, C.clabelstyle);
                    S.unitCellObjects.labels.push(Z);
                  }
                }
              }
              /**
              * Remove unit cell visualization from model.
              *
              * @param {GLModel|number} model - Model with unit cell information (e.g., pdb derived).  If omitted uses most recently added model.
                @example
                     $3Dmol.get('data/icsd_200866.cif', function(data) {
                       let m = viewer.addModel(data);
                       viewer.setStyle({sphere:{}})
                       viewer.addUnitCell();
                       viewer.zoomTo();
                       viewer.removeUnitCell();
                       viewer.render();
                 });
              */
              removeUnitCell(S) {
                if (S = this.getModel(S), S.unitCellObjects) {
                  let C = this;
                  S.unitCellObjects.shapes.forEach(function(D) {
                    C.removeShape(D);
                  }), S.unitCellObjects.labels.forEach(function(D) {
                    C.removeLabel(D);
                  });
                }
                delete S.unitCellObjects;
              }
              /**
              * Replicate atoms in model to form a super cell of the specified dimensions.
              * Original cell will be centered as much as possible.
              *
              * @param {integer} A - number of times to replicate cell in X dimension.
              * @param {integer} B - number of times to replicate cell in Y dimension.  If absent, X value is used.
              * @param {integer} C - number of times to replicate cell in Z dimension.  If absent, Y value is used.
              * @param {GLModel} model - Model with unit cell information (e.g., pdb derived).  If omitted uses most recently added model.
              * @param {boolean} addBonds - Create bonds between unit cells based on distances.
              * @param {boolean} prune - Keep only atoms that are within the original unit cell (i.e., on edges).  Alternatively, call replicateUnitCell(1).
                @example
                     $3Dmol.get('data/icsd_200866.cif', function(data) {
                       let m = viewer.addModel(data);
                       viewer.setStyle({sphere:{scale:.25}})
                       viewer.addUnitCell();
                       viewer.zoomTo();
                       viewer.replicateUnitCell(3,2,1,m);
                       viewer.render();
                 });
              */
              replicateUnitCell(S = 3, C = S, D = C, O, N, j) {
                O = this.getModel(O);
                let L = O.getCrystData();
                if (L) {
                  const z = O.selectedAtoms({}), G = L.matrix;
                  let B = function(H) {
                    return H % 2 == 0 ? -H / 2 : Math.ceil(H / 2);
                  };
                  S <= 1 && C <= 1 && D <= 1 && (j = !0, S = C = D = 3);
                  let F = function(H, W, V) {
                    return !1;
                  };
                  if (j) {
                    const H = new l.Matrix3().getInverse3(G);
                    F = function(W, V, X) {
                      let Z = new l.Vector3(W, V, X).applyMatrix3(H);
                      return !(Z.x > -1e-4 && Z.x < 1.0001 && Z.y > -1e-4 && Z.y < 1.0001 && Z.z > -1e-4 && Z.z < 1.0001);
                    };
                  }
                  for (let H = 0; H < S; H++)
                    for (let W = 0; W < C; W++)
                      for (let V = 0; V < D; V++) {
                        if (H == 0 && W == 0 && V == 0)
                          continue;
                        let X = new l.Vector3(B(H), B(W), B(V));
                        X.applyMatrix3(G);
                        let Z = [];
                        for (let Q = 0; Q < z.length; Q++) {
                          let q = z[Q].x + X.x, J = z[Q].y + X.y, ie = z[Q].z + X.z;
                          if (F(q, J, ie))
                            continue;
                          let ne = {};
                          for (let ge in z[Q])
                            ne[ge] = z[Q][ge];
                          ne.x = q, ne.y = J, ne.z = ie, Z.push(ne);
                        }
                        O.addAtoms(Z);
                      }
                  N && O.assignBonds();
                }
              }
              /** Add dashed line to shape */
              addLineDashed(S, C) {
                S.dashLength = S.dashLength || 0.5, S.gapLength = S.gapLength || 0.5;
                var D;
                S.start ? D = new l.Vector3(S.start.x || 0, S.start.y || 0, S.start.z || 0) : D = new l.Vector3(0, 0, 0);
                var O;
                S.end ? O = new l.Vector3(S.end.x, S.end.y || 0, S.end.z || 0) : O = new l.Vector3(0, 0, 0);
                var N = new l.Vector3(), j = new l.Vector3(), L = new l.Vector3(), z, G, B, F = D.clone(), H = 0;
                for (N.subVectors(O, D), z = N.length(), N.normalize(), j = N.clone(), L = N.clone(), j.multiplyScalar(S.dashLength), L.multiplyScalar(S.gapLength), G = j.length(), B = L.length(); H < z; ) {
                  if (H + G > z) {
                    S.start = D, S.end = O, C.addLine(S);
                    break;
                  }
                  F.addVectors(D, j), S.start = D, S.end = F, C.addLine(S), D = F.clone(), H += G, F.addVectors(D, L), D = F.clone(), H += B;
                }
                return C.finalize(), C;
              }
              /**
              	     * Add custom shape component from user supplied function
              	     *
              	     * @param {CustomSpec} spec - Style specification
              	     * @return {GLShape}
              	     @example
              	     function triangle(viewer) {
              	        var vertices = [];
              	        var normals = [];
              	        var colors = [];
              	        var r = 20;
              	        //triangle
              	        vertices.push(new $3Dmol.Vector3(0,0,0));
              	        vertices.push(new $3Dmol.Vector3(r,0,0));
              	        vertices.push(new $3Dmol.Vector3(0,r,0));
              
              	        normals.push(new $3Dmol.Vector3(0,0,1));
              	        normals.push(new $3Dmol.Vector3(0,0,1));
              	        normals.push(new $3Dmol.Vector3(0,0,1));
              
              	        colors.push({r:1,g:0,b:0});
              	        colors.push({r:0,g:1,b:0});
              	        colors.push({r:0,g:0,b:1});
              
              	        var faces = [ 0,1,2 ];
              
              	        var spec = {vertexArr:vertices, normalArr: normals, faceArr:faces,color:colors};
              	        viewer.addCustom(spec);
              	    }
              	    triangle(viewer);
              	    viewer.render();
              	     */
              addCustom(S) {
                S = S || {};
                var C = new g.GLShape(S);
                return C.shapePosition = this.shapes.length, C.addCustom(S), this.shapes.push(C), C.finalize(), C;
              }
              /**
              	     * Construct isosurface from volumetric data in gaussian cube format
              	     * @param {String} data - Input file contents
              	     * @param {String} format - Input file format
              	     * @param {VolumetricRendererSpec|IsoSurfaceSpec} spec - Shape style specification
              	     * @return {GLShape}
              	     *
              	     * @example
              
              
              	    $3Dmol.get('data/bohr.cube', function(data) {
              
              	    viewer.addVolumetricData(data, "cube", {isoval: -0.01, color: "red", opacity: 0.95});
              	    viewer.setStyle({cartoon:{},stick:{}});
              	    viewer.zoomTo();
              	    viewer.render();
              	    });
              
              
              	     */
              addVolumetricData(S, C, D = {}) {
                var O = new w.VolumeData(S, C);
                return D.hasOwnProperty("transferfn") ? this.addVolumetricRender(O, D) : this.addIsosurface(O, D);
              }
              /**
               * Construct isosurface from volumetric data.  This is more flexible
              * than addVolumetricData, but can not be used with py3Dmol.
               * @param {VolumeData} data - volumetric data
               * @param {IsoSurfaceSpec} spec - Shape style specification
               * @return {GLShape}
               *
               @example
               $3Dmol.get('../test_structs/benzene-homo.cube', function(data){
                        var voldata = new $3Dmol.VolumeData(data, "cube");
                        viewer.addIsosurface(voldata, {isoval: 0.01,
                                                       color: "blue"});
                        viewer.addIsosurface(voldata, {isoval: -0.01,
                                                       color: "red"});
                        viewer.zoomTo();
                        viewer.render();
                      });
               */
              addIsosurface(S, C = {}, D) {
                var O = new g.GLShape(C);
                return O.shapePosition = this.shapes.length, O.addIsosurface(S, C, D), this.shapes.push(O), O;
              }
              /**
               * Create volumetric renderer for volumetricData
               * @param {VolumeData} data - volumetric data
               * @param {VolumetricRenderSpec} spec - specification of volumetric render
               *
               * @return {GLShape}
               *
               */
              addVolumetricRender(S, C) {
                C = C || {};
                var D = new T.GLVolumetricRender(S, C);
                return D.shapePosition = this.shapes.length, this.shapes.push(D), D;
              }
              /**
               * Return true if volumetric rendering is supported (WebGL 2.0 required)
               *
               * @return {boolean}
               */
              hasVolumetricRender() {
                return this.renderer.supportsVolumetric();
              }
              /**
               * Enable/disable fog for content far from the camera
               *
               * @param {boolean} fog whether to enable or disable the fog
               */
              enableFog(S) {
                S ? this.scene.fog = new o.Fog(this.bgColor, 100, 200) : (this.config.disableFog = !0, this.show());
              }
              /**
               * Sets the atomlists of all models in the viewer to specified frame.
               * Shapes and labels can also be displayed by frame.
               * Sets to last frame if framenum out of range
               *
               * @param {number} framenum - fame index to use, starts at zero
               * @return {Promise}
               */
              setFrame(S) {
                this.viewer_frame = S;
                let C = this;
                return new Promise(function(D) {
                  var O = C.models.map(function(N) {
                    return N.setFrame(S, C);
                  });
                  Promise.all(O).then(function() {
                    D();
                  });
                });
              }
              /**
               * Gets the current viewer frame.
               *
               */
              getFrame() {
                return this.viewer_frame;
              }
              /**
               * Returns the number of frames that the model with the most frames in the viewer has
               *
               * @return {number}
               */
              getNumFrames() {
                var S = 0;
                for (let C = 0; C < this.models.length; C++)
                  this.models[C].getNumFrames() > S && (S = this.models[C].getNumFrames());
                for (let C = 0; C < this.shapes.length; C++)
                  this.shapes[C].frame && this.shapes[C].frame >= S && (S = this.shapes[C].frame + 1);
                for (let C = 0; C < this.labels.length; C++)
                  this.labels[C].frame && this.labels[C].frame >= S && (S = this.labels[C].frame + 1);
                return S;
              }
              /**
               * Animate all models in viewer from their respective frames
               * @param {Object} options - can specify interval (speed of animation), loop (direction
               * of looping, 'backward', 'forward' or 'backAndForth'), step interval between frames ('step'), startFrame, and reps (numer of repetitions, 0 indicates infinite loop)
               *
               */
              animate(S) {
                this.incAnim();
                var C = 100, D = "forward", O = 0;
                S = S || {}, S.interval && (C = S.interval), S.loop && (D = S.loop), S.reps && (O = S.reps);
                var N = this.getNumFrames(), j = this, L = 0;
                S.startFrame && (L = S.startFrame % N);
                var z = 1;
                S.step && (z = S.step, O /= z);
                var G = 0, B = N * O, F = /* @__PURE__ */ new Date(), H, W, V = function(X) {
                  F = /* @__PURE__ */ new Date(), X == "forward" ? j.setFrame(L).then(function() {
                    L = (L + z) % N, H();
                  }) : X == "backward" ? j.setFrame(N - 1 - L).then(function() {
                    L = (L + z) % N, H();
                  }) : j.setFrame(L).then(function() {
                    L += z, z *= L % (N - 1) == 0 ? -1 : 1, H();
                  });
                };
                return H = function() {
                  if (j.render(), !j.getCanvas().isConnected)
                    j.stopAnimate();
                  else if (++G == B || !j.isAnimated())
                    W.cancel(), j.animationTimers.delete(W), j.decAnim();
                  else {
                    var X = C - ((/* @__PURE__ */ new Date()).getTime() - F.getTime());
                    X = X > 0 ? X : 0, j.animationTimers.delete(W), W = new f.PausableTimer(V, X, D), j.animationTimers.add(W);
                  }
                }, W = new f.PausableTimer(V, 0, D), this.animationTimers.add(W), this;
              }
              /**
               * Stop animation of all models in viewer
               */
              stopAnimate() {
                return this.animated = 0, this.animationTimers.forEach(function(S) {
                  S.cancel();
                }), this.animationTimers = /* @__PURE__ */ new Set(), this;
              }
              /**
               * Pause animation of all models in viewer
               */
              pauseAnimate() {
                return this.animationTimers.forEach(function(S) {
                  S.pause();
                }), this;
              }
              /**
               * Resume animation of all models in viewer
               */
              resumeAnimate() {
                return this.animationTimers.forEach(function(S) {
                  S.resume();
                }), this;
              }
              /**
               * Return true if viewer is currently being animated, false otherwise
               * @return {boolean}
               */
              isAnimated() {
                return this.animated > 0;
              }
              //setup options dict
              getModelOpt(S) {
                return S && !S.defaultcolors ? (S.defaultcolors = this.defaultcolors, S.cartoonQuality = S.cartoonQuality || this.config.cartoonQuality) : typeof S > "u" && (S = { defaultcolors: this.defaultcolors, cartoonQuality: this.config.cartoonQuality }), S;
              }
              /**
              	     * Create and add model to viewer, given molecular data and its format
              	     *
              	     * @param {string} data - Input data
              	     * @param {string} format - Input format ('pdb', 'sdf', 'xyz', 'pqr', or 'mol2')
              	     * @param {ParserOptionsSpec} options - format dependent options. Attributes depend on the input file format.
              	     * @example
              
              
              	          viewer.setViewStyle({style:"outline"});
              	          $3Dmol.get('data/1fas.pqr', function(data){
              	              viewer.addModel(data, "pqr");
              	              $3Dmol.get("data/1fas.cube",function(volumedata){
              	                  viewer.addSurface($3Dmol.SurfaceType.VDW, {opacity:0.85,voldata: new $3Dmol.VolumeData(volumedata, "cube"), volscheme: new $3Dmol.Gradient.RWB(-10,10)},{});
              
              	              viewer.render();
              	              });
              	              viewer.zoomTo();
              	          });
              	     *
              	     * @return {GLModel}
              	     */
              addModel(S, C = "", D) {
                D = this.getModelOpt(D);
                var O = new p.GLModel(this.models.length, D);
                return O.addMolData(S, C, D), this.models.push(O), O;
              }
              /**
               * Given multimodel file and its format, add atom data to the viewer as separate models
               * and return list of these models
               *
               * @param {string} data - Input data
               * @param {string} format - Input format (see {@link FileFormats})
               * @return {Array<GLModel>}
               */
              addModels(S, C, D) {
                D = this.getModelOpt(D), D.multimodel = !0, D.frames = !0;
                for (var O = p.GLModel.parseMolData(S, C, D), N = 0; N < O.length; N++) {
                  var j = new p.GLModel(this.models.length, D);
                  j.setAtomDefaults(O[N]), j.addFrame(O[N]), j.setFrame(0), O.modelData && j.setModelData(O.modelData[N]), j.setDontDuplicateAtoms(!D.duplicateAssemblyAtoms), this.models.push(j);
                }
                return this.models;
              }
              /**
               * Create and add model to viewer. Given multimodel file and its format,
               * different atomlists are stored in model's frame
               * property and model's atoms are set to the 0th frame
               *
               * @param {string} data - Input data
               * @param {string} format - Input format (see {@link FileFormats})
               * @return {GLModel}
               *
               * @example
                      $3Dmol.get('../test_structs/multiple2.xyz', function(data){
                        viewer.addModelsAsFrames(data, "xyz");
                        viewer.animate({loop: "forward",reps: 1});
                        viewer.setStyle({stick:{colorscheme:'magentaCarbon'}});
                        viewer.zoomTo();
                        viewer.render();
                    });
               */
              addModelsAsFrames(S, C, D) {
                D = this.getModelOpt(D), D.multimodel = !0, D.frames = !0;
                var O = new p.GLModel(this.models.length, D);
                return O.addMolData(S, C, D), this.models.push(O), O;
              }
              /**
              	     * Create and add model to viewer. Given multimodel file and its format,
              	     * all atoms are added to one model
              	     *
              	     * @param {string} data - Input data
              	     * @param {string} format - Input format (see {@link FileFormats})
              	     * @return {GLModel}
              	     @example
              
              
              	          $3Dmol.get('../test_structs/multiple.sdf', function(data){
              	              viewer.addAsOneMolecule(data, "sdf");
              	              viewer.zoomTo();
              	              viewer.render();
              	          });
              	     */
              addAsOneMolecule(S, C, D) {
                D = this.getModelOpt(D), D.multimodel = !0, D.onemol = !0;
                var O = new p.GLModel(this.models.length, D);
                return O.addMolData(S, C, D), this.models.push(O), O;
              }
              /**
               * Delete specified model from viewer
               *
               * @param {GLModel|number} model
               */
              removeModel(S) {
                if (S = this.getModel(S), !!S) {
                  for (S.removegl(this.modelGroup), delete this.models[S.getID()]; this.models.length > 0 && typeof this.models[this.models.length - 1] > "u"; )
                    this.models.pop();
                  return this;
                }
              }
              /**
               * Delete all existing models
               */
              removeAllModels() {
                for (var S = 0; S < this.models.length; S++) {
                  var C = this.models[S];
                  C && C.removegl(this.modelGroup);
                }
                return this.models.splice(0, this.models.length), this;
              }
              /**
               * Export one or all of the loaded models into ChemDoodle compatible JSON.
               * @param {boolean} includeStyles - Whether or not to include style information.
               * @param {number} modelID - Optional parameter for which model to export. If left out, export all of them.
               * @return {string}
               */
              exportJSON(S, C) {
                var D = {};
                return C === void 0 ? D.m = this.models.map(function(O) {
                  return O.toCDObject(S);
                }) : D.m = [this.models[C].toCDObject()], JSON.stringify(D);
              }
              /** return a VRML string representation of the scene.  Include VRML header information
               * @return VRML
               */
              exportVRML() {
                var S = this.modelGroup;
                this.applyToModels("removegl", this.modelGroup), this.modelGroup = new o.Object3D(), this.render(null, { supportsImposters: !1, supportsAIA: !1, regen: !0 });
                var C = `#VRML V2.0 utf8
` + this.modelGroup.vrml() + `
`;
                return this.applyToModels("removegl", this.modelGroup), this.modelGroup = S, C;
              }
              /**
               * Create a new model from atoms specified by sel.
               * If extract, removes selected atoms from existing models
               *
               * @param {AtomSelectionSpec} sel - Atom selection specification
               * @param {boolean=} extract - If true, remove selected atoms from existing models
               * @return {GLModel}
               */
              createModelFrom(S, C = !1) {
                for (var D = new p.GLModel(this.models.length, this.defaultcolors), O = 0; O < this.models.length; O++)
                  if (this.models[O]) {
                    var N = this.models[O].selectedAtoms(S);
                    D.addAtoms(N), C && this.models[O].removeAtoms(N);
                  }
                return this.models.push(D), D;
              }
              applyToModels(S, C, D, O, N, j, L) {
                for (var z = this.getModelList(C), G = 0; G < z.length; G++)
                  z[G][S](C, D, O, N, j, L);
              }
              setStyle(S, C) {
                return typeof C > "u" && (C = S, S = {}), this.applyToModels("setStyle", S, C, !1), this;
              }
              addStyle(S, C) {
                return typeof C > "u" && (C = S, S = {}), this.applyToModels("setStyle", S, C, !0), this;
              }
              /**
              	     * Set click-handling properties to all selected atoms. *Important*: render must be called for this to take effect.
              	     *
              	     * @param {AtomSelectionSpec} sel - atom selection to apply clickable settings to
              	     * @param {boolean} clickable - whether click-handling is enabled for the selection
              	     * @param {function} callback - function called when an atom in the selection is clicked. The function is passed
              	     * the selected (foremost) object, the viewer, the triggering event, the associated container, and a list
              	     * of all intersecting objects with their distances from the viewer.
              	     *
              	     * @example
              	        $3Dmol.download("cid:307900",viewer,{},function(){
              
              	               viewer.setStyle({},{sphere:{}});
              	               viewer.setClickable({},true,function(atom,viewer,event,container) {
              	                   viewer.addLabel(atom.resn+":"+atom.atom,{position: atom, backgroundColor: 'darkgreen', backgroundOpacity: 0.8});
              	               });
              	               viewer.render();
              	    });
              	     */
              setClickable(S, C, D) {
                return this.applyToModels("setClickable", S, C, D), this;
              }
              /** Set hoverable and callback of selected atoms
              	     *
              	     * @param {AtomSelectionSpec} sel - atom selection to apply hoverable settings to
              	     * @param {boolean} hoverable - whether hover-handling is enabled for the selection
              	     * @param {function} hover_callback - function called when an atom in the selection is hovered over.  The function has the same signature as a click handler.
              	     * @param {function} unhover_callback - function called when the mouse moves out of the hover area
              	    @example
              	    $3Dmol.download("pdb:1ubq",viewer,{},function(){
              
              	           viewer.setHoverable({},true,function(atom,viewer,event,container) {
              	               if(!atom.label) {
              	                atom.label = viewer.addLabel(atom.resn+":"+atom.atom,{position: atom, backgroundColor: 'mintcream', fontColor:'black'});
              	               }
              	           },
              	           function(atom) {
              	               if(atom.label) {
              	                viewer.removeLabel(atom.label);
              	                delete atom.label;
              	               }
              	            }
              	           );
              	           viewer.setStyle({},{stick:{}});
              	           viewer.render();
              	    });
              
              	     */
              setHoverable(S, C, D, O) {
                return this.applyToModels("setHoverable", S, C, D, O), this;
              }
              /** enable context menu and callback of selected atoms
              	     *
              	     * @param {AtomSelectionSpec} sel - atom selection to apply hoverable settings to
              	     * @param {boolean} contextMenuEnabled - whether contextMenu-handling is enabled for the selection
              
              	     */
              enableContextMenu(S, C) {
                return this.applyToModels("enableContextMenu", S, C), this;
              }
              /**
               * If  atoms have dx, dy, dz properties (in some xyz files), vibrate populates each model's frame property based on parameters.
               * Models can then be animated
               *
               * @param {number} numFrames - number of frames to be created, default to 10
               * @param {number} amplitude - amplitude of distortion, default to 1 (full)
               * @param {boolean} bothWays - if true, extend both in positive and negative directions by numFrames
               * @param {ArrowSpec} arrowSpec - specification for drawing animated arrows. If color isn't specified, atom color (sphere, stick, line preference) is used.
               */
              vibrate(S, C, D, O) {
                return this.applyToModels("vibrate", S, C, D, this, O), this;
              }
              /**
               * @param {AtomSelectionSpec} sel
               * @param {string} prop
               * @param {Gradient|string} scheme
               * @param {object} range
               */
              setColorByProperty(S, C, D, O) {
                return this.applyToModels("setColorByProperty", S, C, D, O), this;
              }
              /**
               * @param {AtomSelectionSpec} sel
               * @param {object} colors
               */
              setColorByElement(S, C) {
                return this.applyToModels("setColorByElement", S, C), this;
              }
              /**
               *
               * @param {AtomSpec[]} atomlist
               * @param {Array}
               *            extent
               * @return {Array}
               */
              static getAtomsWithin(S, C) {
                var D = [];
                for (let N = 0; N < S.length; N++) {
                  var O = S[N];
                  typeof O > "u" || O.x < C[0][0] || O.x > C[1][0] || O.y < C[0][1] || O.y > C[1][1] || O.z < C[0][2] || O.z > C[1][2] || D.push(O);
                }
                return D;
              }
              // return volume of extent
              static volume(S) {
                var C = S[1][0] - S[0][0], D = S[1][1] - S[0][1], O = S[1][2] - S[0][2];
                return C * D * O;
              }
              // volume
              /*
               * Break up bounding box/atoms into smaller pieces so we can parallelize
               * with webworkers and also limit the size of the working memory Returns
               * a list of bounding boxes with the corresponding atoms. These extents
               * are expanded by 4 angstroms on each side.
               */
              /**
               *
               * @param {Array}
               *            extent
               * @param {AtomSpec[]} atomlist
               * @param {AtomSpec[]} atomstoshow
               * @return {Array}
               */
              carveUpExtent(S, C, D) {
                let O = [], N = {};
                for (let F = 0, H = C.length; F < H; F++)
                  N[C[F].index] = F;
                let j = function(F) {
                  let H = [];
                  for (let W = 0, V = F.length; W < V; W++)
                    F[W].index in N && H.push(N[F[W].index]);
                  return H;
                }, L = function(F) {
                  let H = [];
                  return H[0] = [F[0][0], F[0][1], F[0][2]], H[1] = [F[1][0], F[1][1], F[1][2]], H;
                }, z = function(F) {
                  if (_.volume(F) < _.maxVolume)
                    return [F];
                  var H = F[1][0] - F[0][0], W = F[1][1] - F[0][1], V = F[1][2] - F[0][2], X;
                  H > W && H > V ? X = 0 : W > H && W > V ? X = 1 : X = 2;
                  var Z = L(F), Q = L(F), q = (F[1][X] - F[0][X]) / 2 + F[0][X];
                  Z[1][X] = q, Q[0][X] = q;
                  var J = z(Z), ie = z(Q);
                  return J.concat(ie);
                }, G = z(S), B = 6;
                for (let F = 0, H = G.length; F < H; F++) {
                  let W = L(G[F]);
                  W[0][0] -= B, W[0][1] -= B, W[0][2] -= B, W[1][0] += B, W[1][1] += B, W[1][2] += B;
                  let V = _.getAtomsWithin(C, W), X = _.getAtomsWithin(D, G[F]);
                  O.push({
                    extent: G[F],
                    atoms: j(V),
                    toshow: j(X)
                  });
                }
                return O;
              }
              // create a mesh defined from the passed vertices and faces and material
              // Just create a single geometry chunk - broken up whether sync or not
              /**
               *
               * @param {AtomSpec[]} atoms
               * @param {{vertices:number,faces:number}}
               *            VandF
               * @param {MeshLambertMaterial}
               *            mat
               * @return {Mesh}
               */
              static generateSurfaceMesh(S, C, D) {
                var O = new o.Geometry(!0), N = O.updateGeoGroup(0), j = [];
                for (let Ce = 0, ee = S.length; Ce < ee; Ce++) {
                  var L = S[Ce];
                  L && (typeof L.surfaceColor < "u" ? j[Ce] = L.surfaceColor : L.color && (j[Ce] = u.CC.color(L.color)));
                }
                var z = N.vertexArray, G = C.vertices;
                for (let Ce = 0, ee = G.length; Ce < ee; Ce++) {
                  let Ae = N.vertices * 3;
                  z[Ae] = G[Ce].x, z[Ae + 1] = G[Ce].y, z[Ae + 2] = G[Ce].z, N.vertices++;
                }
                var B = N.colorArray;
                if (D.voldata && D.volscheme) {
                  var F = D.volscheme, H = D.voldata, W = F.range() || [-1, 1];
                  for (let Ce = 0, ee = G.length; Ce < ee; Ce++) {
                    let Ae = H.getVal(G[Ce].x, G[Ce].y, G[Ce].z), be = u.CC.color(F.valueToHex(Ae, W)), Fe = Ce * 3;
                    B[Fe] = be.r, B[Fe + 1] = be.g, B[Fe + 2] = be.b;
                  }
                } else if (j.length > 0)
                  for (let Ce = 0, ee = G.length; Ce < ee; Ce++) {
                    let Ae = G[Ce].atomid, be = Ce * 3;
                    B[be] = j[Ae].r, B[be + 1] = j[Ae].g, B[be + 2] = j[Ae].b;
                  }
                var V = C.faces;
                N.faceidx = V.length, O.initTypedArrays();
                var X = N.vertexArray, Z = N.normalArray, Q, q, J, ie;
                for (let Ce = 0, ee = V.length; Ce < ee; Ce += 3) {
                  var ne = V[Ce], ge = V[Ce + 1], ye = V[Ce + 2], xe = ne * 3, we = ge * 3, de = ye * 3;
                  Q = new l.Vector3(X[xe], X[xe + 1], X[xe + 2]), q = new l.Vector3(X[we], X[we + 1], X[we + 2]), J = new l.Vector3(X[de], X[de + 1], X[de + 2]), J.subVectors(J, q), Q.subVectors(Q, q), J.cross(Q), ie = J, ie.normalize(), Z[xe] += ie.x, Z[we] += ie.x, Z[de] += ie.x, Z[xe + 1] += ie.y, Z[we + 1] += ie.y, Z[de + 1] += ie.y, Z[xe + 2] += ie.z, Z[we + 2] += ie.z, Z[de + 2] += ie.z;
                }
                N.faceArray = new Uint16Array(V);
                var Te = new o.Mesh(O, D);
                return Te;
              }
              // do same thing as worker in main thread
              /**
               *
               * @param {SurfaceType}
               *            type
               * @param {Array}
               *            expandedExtent
               * @param {AtomSpec[]}
               *            extendedAtoms
               * @param {AtomSpec[]}
               *            atomsToShow
               * @param {AtomSpec[]} atoms
               * @param {number}
               *            vol
               * @return {Object}
               */
              static generateMeshSyncHelper(S, C, D, O, N, j) {
                var L = new E.ProteinSurface();
                return L.initparm(C, S !== 1, j), L.fillvoxels(N, D), L.buildboundary(), (S == E.SurfaceType.SES || S == E.SurfaceType.MS) && (L.fastdistancemap(), L.boundingatom(!1), L.fillvoxelswaals(N, D)), L.marchingcube(S), L.getFacesAndVertices(O);
              }
              /*
               *
               * @param {SurfaceStyleSpec}
               *            style
               * @return {MeshLambertMaterial}
               */
              static getMatWithStyle(S) {
                var C = new o.MeshLambertMaterial();
                C.vertexColors = o.Coloring.VertexColors;
                for (var D in S)
                  D === "color" || D === "map" || S.hasOwnProperty(D) && (C[D] = S[D]);
                return S.opacity !== void 0 && (S.opacity === 1 ? C.transparent = !1 : C.transparent = !0), C;
              }
              /**
               * Adds an explicit mesh as a surface object.
               * @param {Mesh}
               *            mesh
               * @param {Object}
               *            style
               * @returns {number} surfid
               */
              addMesh(S) {
                var C = {
                  geo: S.geometry,
                  mat: S.material,
                  done: !0,
                  finished: !1
                  //the rendered finishes surfaces when they are done
                }, D = this.nextSurfID();
                return this.surfaces[D] = C, D;
              }
              //return a shallow copy of list l, e.g., for atoms so we can
              //ignore superficial changes (ie surfacecolor, position) that happen
              //while we're surface building
              static shallowCopy(S) {
                var C = [];
                let D = S.length;
                for (let O = 0; O < D; O++)
                  C[O] = (0, f.extend)({}, S[O]);
                return C;
              }
              /**
               * Add surface representation to atoms
               * @param {SurfaceType|string} type - Surface type (VDW, MS, SAS, or SES)
               * @param {SurfaceStyleSpec} style - optional style specification for surface material (e.g. for different coloring scheme, etc)
               * @param {AtomSelectionSpec} atomsel - Show surface for atoms in this selection
               * @param {AtomSelectionSpec} allsel - Use atoms in this selection to calculate surface; may be larger group than 'atomsel'
               * @param {AtomSelectionSpec} focus - Optionally begin rendering surface specified atoms
               * @param {function} surfacecallback - function to be called after setting the surface
               * @return {Promise} promise - Returns a promise that ultimately resovles to the surfid.  Returns surfid immediately if surfacecallback is specified.  Returned promise has a [surfid, GLViewer, style, atomsel, allsel, focus] fields for immediate access.
               */
              addSurface(S, C = {}, D = {}, O, N, j) {
                let L = this.nextSurfID(), z = null, G = this, B = E.SurfaceType.VDW;
                typeof S == "string" ? _.surfaceTypeMap[S.toUpperCase()] !== void 0 ? B = _.surfaceTypeMap[S] : console.log("Surface type : " + S + " is not recognized") : typeof S == "number" && (B = S);
                var F = null, H = null, W = _.shallowCopy(this.getAtomsFromSel(D));
                O ? F = _.shallowCopy(this.getAtomsFromSel(O)) : F = W, (0, f.adjustVolumeStyle)(C);
                var V = !1, X;
                for (X = 0; X < this.models.length; X++)
                  if (this.models[X]) {
                    var Z = this.models[X].getSymmetries();
                    if (Z.length > 1 || Z.length == 1 && !Z[0].isIdentity()) {
                      V = !0;
                      break;
                    }
                  }
                var Q = function(ye, xe, we) {
                  N ? H = _.shallowCopy(G.getAtomsFromSel(N)) : H = we;
                  var de, Te = (0, f.getExtent)(we, !0);
                  if (C.map && C.map.prop) {
                    var Ce = C.map.prop;
                    let te = (0, h.getGradient)(C.map.scheme || C.map.gradient || new h.Gradient.RWB()), Be = te.range();
                    Be || (Be = (0, f.getPropertyRange)(we, Ce)), C.colorscheme = { prop: Ce, gradient: te };
                  }
                  for (let te = 0, Be = xe.length; te < Be; te++)
                    de = xe[te], de.surfaceColor = (0, f.getColorFromStyle)(de, C);
                  var ee = _.volume(Te), Ae = G.carveUpExtent(Te, xe, we);
                  if (H && H.length && H.length > 0) {
                    var be = (0, f.getExtent)(H, !0), Fe = function(te, Be) {
                      var Je = function(he, ae) {
                        var se = he.extent, Re = se[1][0] - se[0][0], Oe = se[1][1] - se[0][1], We = se[1][2] - se[0][2], Ct = Re - ae[2][0];
                        Ct *= Ct;
                        var le = Oe - ae[2][1];
                        le *= le;
                        var ke = We - ae[2][2];
                        return ke *= ke, Ct + le + ke;
                      }, ft = Je(te, be), lt = Je(Be, be);
                      return ft - lt;
                    };
                    Ae.sort(Fe);
                  }
                  var et = [];
                  for (let te = 0, Be = xe.length; te < Be; te++)
                    de = xe[te], et[te] = {
                      x: de.x,
                      y: de.y,
                      z: de.z,
                      serial: te,
                      elem: de.elem
                    };
                  var Ye = !!E.syncSurface;
                  if (Ye) {
                    var De = function(te) {
                      return new Promise(function(Be) {
                        for (var Je = _.generateMeshSyncHelper(B, Ae[te].extent, Ae[te].atoms, Ae[te].toshow, et, ee), ft = (0, g.splitMesh)({ vertexArr: Je.vertices, faceArr: Je.faces }), lt = 0, he = ft.length; lt < he; lt++) {
                          Je = {
                            vertices: ft[lt].vertexArr,
                            faces: ft[lt].faceArr
                          };
                          var ae = _.generateSurfaceMesh(xe, Je, z);
                          (0, f.mergeGeos)(ye.geo, ae);
                        }
                        G.render(), Be();
                      });
                    }, Ue = [];
                    for (let te = 0; te < Ae.length; te++)
                      Ue.push(De(te));
                    return Promise.all(Ue).then(function() {
                      return ye.done = !0, Promise.resolve(L);
                    });
                  } else {
                    var Qe = [];
                    B < 0 && (B = 0);
                    for (let te = 0, Be = _.numWorkers; te < Be; te++) {
                      var ue = new Worker($3Dmol.SurfaceWorker);
                      Qe.push(ue), ue.postMessage({
                        type: -1,
                        atoms: et,
                        volume: ee
                      });
                    }
                    return new Promise(function(te, Be) {
                      var Je = 0, ft = function() {
                        !Qe || !Qe.length || Qe.forEach(function(se) {
                          se && se.terminate && se.terminate();
                        });
                      }, lt = function(se) {
                        for (var Re = (0, g.splitMesh)({
                          vertexArr: se.data.vertices,
                          faceArr: se.data.faces
                        }), Oe = 0, We = Re.length; Oe < We; Oe++) {
                          var Ct = {
                            vertices: Re[Oe].vertexArr,
                            faces: Re[Oe].faceArr
                          }, le = _.generateSurfaceMesh(xe, Ct, z);
                          (0, f.mergeGeos)(ye.geo, le);
                        }
                        G.render(), Je++, Je == Ae.length && (ye.done = !0, ft(), te(L));
                      }, he = function(se) {
                        ft(), console.log(se.message + " (" + se.filename + ":" + se.lineno + ")"), Be(se);
                      };
                      for (let se = 0; se < Ae.length; se++) {
                        var ae = Qe[se % Qe.length];
                        ae.onmessage = lt, ae.onerror = he, ae.postMessage({
                          type: B,
                          expandedExtent: Ae[se].extent,
                          extendedAtoms: Ae[se].atoms,
                          atomsToShow: Ae[se].toshow
                        });
                      }
                    });
                  }
                };
                C = C || {}, z = _.getMatWithStyle(C);
                var q = [];
                q.style = C, q.atomsel = D, q.allsel = O, q.focus = N;
                var J = null;
                if (V) {
                  var ie = {}, ne = {};
                  for (X = 0; X < this.models.length; X++)
                    ie[X] = [], ne[X] = [];
                  for (X = 0; X < F.length; X++)
                    ie[F[X].model].push(F[X]);
                  for (X = 0; X < W.length; X++)
                    ne[W[X].model].push(W[X]);
                  var ge = [];
                  for (X = 0; X < this.models.length; X++)
                    ne[X].length > 0 && (q.push({
                      geo: new o.Geometry(!0),
                      mat: z,
                      done: !1,
                      finished: !1,
                      symmetries: this.models[X].getSymmetries()
                      // also webgl initialized
                    }), ge.push(Q(q[q.length - 1], ie[X], ne[X])));
                  J = Promise.all(ge);
                } else
                  q.push({
                    geo: new o.Geometry(!0),
                    mat: z,
                    done: !1,
                    finished: !1,
                    symmetries: [new l.Matrix4()]
                  }), J = Q(q[q.length - 1], F, W);
                return this.surfaces[L] = q, J.surfid = L, j && typeof j == "function" ? (J.then(function(ye) {
                  j(ye);
                }), L) : J;
              }
              /**
               * Set the surface material to something else, must render change
               * @param {number} surf - Surface ID to apply changes to
               * @param {SurfaceStyleSpec} style - new material style specification
               @example
               $3Dmol.get("data/9002806.cif",function(data){
                  viewer.addModel(data);
                  viewer.setStyle({stick:{}});
                  let surf = viewer.addSurface("SAS");
                  surf.then(function() {
                      viewer.setSurfaceMaterialStyle(surf.surfid, {color:'blue',opacity:0.5});
                      viewer.render();
                      });
                 });
               */
              setSurfaceMaterialStyle(S, C) {
                if ((0, f.adjustVolumeStyle)(C), this.surfaces[S]) {
                  var D = this.surfaces[S];
                  D.style = C;
                  for (var O = 0; O < D.length; O++) {
                    var N = D[O].mat = _.getMatWithStyle(C);
                    if (D[O].mat.side = o.FrontSide, C.color) {
                      D[O].mat.color = C.color, D[O].geo.colorsNeedUpdate = !0;
                      const j = u.CC.color(C.color);
                      D[O].geo.setColors(function() {
                        return j;
                      });
                    } else if (N.voldata && N.volscheme) {
                      const j = N.volscheme, L = N.voldata, z = u.CC, G = j.range() || [-1, 1];
                      D[O].geo.setColors(function(B, F, H) {
                        let W = L.getVal(B, F, H);
                        return z.color(j.valueToHex(W, G));
                      });
                    }
                    D[O].finished = !1;
                  }
                }
                return this;
              }
              /**
               * Return surface object
               * @param {number} surf - surface id
               */
              getSurface(S) {
                return this.surfaces[S];
              }
              /**
               * Remove surface with given ID
               * @param {number} surf - surface id
               */
              removeSurface(S) {
                for (var C = this.surfaces[S], D = 0; D < C.length; D++)
                  C[D] && C[D].lastGL && (C[D].geo !== void 0 && C[D].geo.dispose(), C[D].mat !== void 0 && C[D].mat.dispose(), this.modelGroup.remove(C[D].lastGL));
                return delete this.surfaces[S], this.show(), this;
              }
              /** Remove all surfaces.
               **/
              removeAllSurfaces() {
                for (var S in this.surfaces)
                  if (this.surfaces.hasOwnProperty(S)) {
                    for (var C = this.surfaces[S], D = 0; D < C.length; D++)
                      C[D] && C[D].lastGL && (C[D].geo !== void 0 && C[D].geo.dispose(), C[D].mat !== void 0 && C[D].mat.dispose(), this.modelGroup.remove(C[D].lastGL));
                    delete this.surfaces[S];
                  }
                return this.show(), this;
              }
              /** return Jmol moveto command to position this scene */
              jmolMoveTo() {
                var S = this.modelGroup.position, C = "center { " + -S.x + " " + -S.y + " " + -S.z + " }; ", D = this.rotationGroup.quaternion;
                return C += "moveto .5 quaternion { " + D.x + " " + D.y + " " + D.z + " " + D.w + " };", C;
              }
              /** Clear scene of all objects
               * */
              clear() {
                return this.removeAllSurfaces(), this.removeAllModels(), this.removeAllLabels(), this.removeAllShapes(), this.show(), this;
              }
              // props is a list of objects that select certain atoms and enumerate
              // properties for those atoms
              /**
               * Add specified properties to all atoms matching input argument
               * @param {Object} props, either array of atom selectors with associated props, or function that takes atom and sets its properties
               * @param {AtomSelectionSpec} sel  - subset of atoms to work on - model selection must be specified here
                   @example
                   $3Dmol.get('../test_structs/b.sdf', function(data){
                            viewer.addModel(data,'sdf');
                            let props = [];
                            //make the atom index a property x
                            for(let i = 0; i < 8; i++) {
                              props.push({index:i,props:{'x':i}});
                            }
                            viewer.mapAtomProperties(props);
                            viewer.setStyle({sphere:{colorscheme:{gradient:'roygb',prop:'x',min:0,max:8}}});
                            viewer.zoomTo();
                            viewer.render();
                          });
               */
              mapAtomProperties(S, C) {
                C = C || {};
                var D = this.getAtomsFromSel(C);
                if (typeof S == "function")
                  for (let j = 0, L = D.length; j < L; j++) {
                    let z = D[j];
                    S(z);
                  }
                else
                  for (let j = 0, L = D.length; j < L; j++) {
                    var O = D[j];
                    for (let z = 0, G = S.length; z < G; z++) {
                      let B = S[z];
                      if (B.props)
                        for (var N in B.props)
                          B.props.hasOwnProperty(N) && this.atomIsSelected(O, B) && (O.properties || (O.properties = {}), O.properties[N] = B.props[N]);
                    }
                  }
                return this;
              }
              /**
               * Synchronize this view matrix of this viewer to the passed viewer.
               * When the viewpoint of this viewer changes, the other viewer will
               * be set to this viewer's view.
               * @param {$3Dmol.GLViewer} otherview
               */
              linkViewer(S) {
                return this.linkedViewers.push(S), this;
              }
              /**
               * Return the z distance between the model and the camera
               * @return {number} distance
               */
              getPerceivedDistance() {
                return this.CAMERA_Z - this.rotationGroup.position.z;
              }
              /**
               * Set the distance between the model and the camera
               * Essentially zooming. Useful while stereo rendering.
               */
              setPerceivedDistance(S) {
                this.rotationGroup.position.z = this.CAMERA_Z - S;
              }
              /**
               * Used for setting an approx value of eyeSeparation. Created for calling by StereoViewer object
               * @return {number} camera x position
               */
              setAutoEyeSeparation(S, C) {
                var D = this.getPerceivedDistance();
                return C || (C = 5), S || this.camera.position.x > 0 ? this.camera.position.x = D * Math.tan(Math.PI / 180 * C) : this.camera.position.x = -D * Math.tan(Math.PI / 180 * C), this.camera.lookAt(new l.Vector3(0, 0, this.rotationGroup.position.z)), this.camera.position.x;
              }
              /**
               * Set the default cartoon quality for newly created models.  Default is 5.
               * Current models are not affected.
               * @number quality, higher results in higher resolution renders
               */
              setDefaultCartoonQuality(S) {
                this.config.cartoonQuality = S;
              }
            }
            _.numWorkers = 4, _.maxVolume = 64e3, _.surfaceTypeMap = {
              VDW: E.SurfaceType.VDW,
              MS: E.SurfaceType.MS,
              SAS: E.SurfaceType.SAS,
              SES: E.SurfaceType.SES
            };
            function b($, S) {
              if ($ = (0, f.getElement)($), !!$) {
                S = S || {};
                try {
                  var C = new _($, S);
                  return C;
                } catch (D) {
                  throw "error creating viewer: " + D;
                }
              }
            }
            function M($, S = {}, C = {}) {
              if ($ = (0, f.getElement)($), !!$) {
                var D = [], O = document.createElement("canvas");
                C.rows = S.rows, C.cols = S.cols, C.control_all = S.control_all != null ? S.control_all : !1, $.appendChild(O);
                try {
                  for (var N = 0; N < S.rows; N++) {
                    for (var j = [], L = 0; L < S.cols; L++) {
                      C.row = N, C.col = L, C.canvas = O, C.viewers = D, C.control_all = S.control_all;
                      var z = b($, (0, f.extend)({}, C));
                      j.push(z);
                    }
                    D.unshift(j);
                  }
                } catch (G) {
                  throw "error creating viewer grid: " + G;
                }
                return D;
              }
            }
            function A($) {
              var S = this;
              if ($ = (0, f.getElement)($), !!$) {
                var C = M($, { rows: 1, cols: 2, control_all: !0 });
                this.glviewer1 = C[0][0], this.glviewer2 = C[0][1], this.glviewer1.setAutoEyeSeparation(!1), this.glviewer2.setAutoEyeSeparation(!0), this.glviewer1.linkViewer(this.glviewer2), this.glviewer2.linkViewer(this.glviewer1);
                for (var D = Object.getOwnPropertyNames(this.glviewer1.__proto__).filter(function(N) {
                  return typeof S.glviewer1[N] == "function";
                }), O = 0; O < D.length; O++)
                  this[D[O]] = /* @__PURE__ */ function(N) {
                    return function() {
                      var j = this.glviewer1[N].apply(this.glviewer1, arguments), L = this.glviewer2[N].apply(this.glviewer2, arguments);
                      return [j, L];
                    };
                  }(D[O]);
                this.setCoordinates = function(N, j, L) {
                  for (var z = 0; z < N.length; z++)
                    N[z].setCoordinates(j, L);
                }, this.surfacesFinished = function() {
                  return this.glviewer1.surfacesFinished() && this.glviewer2.surfacesFinished();
                }, this.isAnimated = function() {
                  return this.glviewer1.isAnimated() || this.glviewer2.isAnimated();
                }, this.render = function(N) {
                  this.glviewer1.render(), this.glviewer2.render(), N && N(this);
                }, this.getCanvas = function() {
                  return this.glviewer1.getCanvas();
                };
              }
            }
          }
        ),
        /***/
        "./src/Gradient.ts": (
          /*!*************************!*\
            !*** ./src/Gradient.ts ***!
            \*************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              CustomLinear: () => (
                /* binding */
                g
              ),
              /* harmony export */
              Gradient: () => (
                /* binding */
                E
              ),
              /* harmony export */
              GradientType: () => (
                /* binding */
                l
              ),
              /* harmony export */
              ROYGB: () => (
                /* binding */
                p
              ),
              /* harmony export */
              RWB: () => (
                /* binding */
                h
              ),
              /* harmony export */
              Sinebow: () => (
                /* binding */
                v
              ),
              /* harmony export */
              builtinGradients: () => (
                /* binding */
                w
              ),
              /* harmony export */
              getGradient: () => (
                /* binding */
                f
              ),
              /* harmony export */
              normalizeValue: () => (
                /* binding */
                u
              )
              /* harmony export */
            });
            var o = n(
              /*! ./colors */
              "./src/colors.ts"
            );
            class l {
            }
            function u(T, R, _) {
              return R >= T ? (_ < T && (_ = T), _ > R && (_ = R), { lo: T, hi: R, val: _ }) : (_ > T && (_ = T), _ < R && (_ = R), _ = T - _ + R, { lo: R, hi: T, val: _ });
            }
            function f(T) {
              if (T instanceof l)
                return T;
              if (T.gradient !== void 0 && w[T.gradient]) {
                let R = T.min === void 0 ? -1 : T.min, _ = T.max === void 0 ? 1 : T.max;
                return T.mid === void 0 ? T.colors === void 0 ? new w[T.gradient](R, _) : new w[T.gradient](R, _, T.colors) : new w[T.gradient](R, _, T.mid);
              }
              return T;
            }
            class h extends l {
              constructor(R, _, b) {
                super(), this.gradient = "RWB", this.mult = 1, this.mid = b, this.min = R, this.max = _, typeof _ > "u" && Array.isArray(R) && R.length >= 2 ? (this.max = R[1], this.min = R[0]) : R && _ && !Array.isArray(R) && (this.min = R, this.max = _);
              }
              //return range used for color mapping, null if none set
              range() {
                return typeof this.min < "u" && typeof this.max < "u" ? [this.min, this.max] : null;
              }
              //map value to hex color, range is provided
              valueToHex(R, _) {
                var b, M;
                if (R = this.mult * R, _ ? (b = _[0], M = _[1]) : (b = this.min, M = this.max), R === void 0)
                  return 16777215;
                var A = u(b, M, R);
                b = A.lo, M = A.hi, R = A.val;
                var $ = (M + b) / 2;
                _ && typeof _[2] < "u" ? $ = _[2] : typeof this.mid < "u" ? $ = this.mid : $ = (b + M) / 2;
                var S, C;
                return R < $ ? (S = Math.floor(255 * Math.sqrt((R - b) / ($ - b))), C = 16711680 + 256 * S + S, C) : R > $ ? (S = Math.floor(255 * Math.sqrt(1 - (R - $) / (M - $))), C = 65536 * S + 256 * S + 255, C) : 16777215;
              }
            }
            class p extends l {
              constructor(R, _) {
                super(), this.gradient = "ROYGB", this.mult = 1, this.min = R, this.max = _, typeof _ > "u" && Array.isArray(R) && R.length >= 2 ? (this.max = R[1], this.min = R[0]) : R && _ && !Array.isArray(R) && (this.min = R, this.max = _);
              }
              //map value to hex color, range is provided
              valueToHex(R, _) {
                var b, M;
                if (R = this.mult * R, _ ? (b = _[0], M = _[1]) : (b = this.min, M = this.max), typeof R > "u")
                  return 16777215;
                var A = u(b, M, R);
                b = A.lo, M = A.hi, R = A.val;
                var $ = (b + M) / 2, S = (b + $) / 2, C = ($ + M) / 2, D, O;
                return R < S ? (D = Math.floor(255 * Math.sqrt((R - b) / (S - b))), O = 16711680 + 256 * D + 0, O) : R < $ ? (D = Math.floor(255 * Math.sqrt(1 - (R - S) / ($ - S))), O = 65536 * D + 65280 + 0, O) : R < C ? (D = Math.floor(255 * Math.sqrt((R - $) / (C - $))), O = 65280 + 1 * D, O) : (D = Math.floor(255 * Math.sqrt(1 - (R - C) / (M - C))), O = 0 + 256 * D + 255, O);
              }
              //return range used for color mapping, null if none set
              range() {
                return typeof this.min < "u" && typeof this.max < "u" ? [this.min, this.max] : null;
              }
            }
            class v extends l {
              constructor(R, _) {
                super(), this.gradient = "Sinebow", this.mult = 1, this.min = R, this.max = _, typeof _ > "u" && Array.isArray(R) && R.length >= 2 && (this.max = R[1], this.min = R[0]), _ < R && (this.mult = -1, this.min *= -1, this.max *= -1);
              }
              //map value to hex color, range is provided
              valueToHex(R, _) {
                var b, M;
                if (R = this.mult * R, _ ? (b = _[0], M = _[1]) : (b = this.min, M = this.max), typeof R > "u")
                  return 16777215;
                var A = E.normalizeValue(b, M, R);
                b = A.lo, M = A.hi, R = A.val;
                var $ = (R - b) / (M - b), S = 5 * $ / 6 + 0.5, C = Math.sin(Math.PI * S);
                C *= C * 255;
                var D = Math.sin(Math.PI * (S + 1 / 3));
                D *= D * 255;
                var O = Math.sin(Math.PI * (S + 2 / 3));
                return O *= O * 255, 65536 * Math.floor(C) + 256 * Math.floor(O) + 1 * Math.floor(D);
              }
              //return range used for color mapping, null if none set
              range() {
                return typeof this.min < "u" && typeof this.max < "u" ? [this.min, this.max] : null;
              }
            }
            class g extends l {
              constructor(R, _, b) {
                super(), this.gradient = "linear", this.colors = new Array();
                var M;
                if (Array.isArray(R) && R.length >= 2 ? (this.max = R[1], this.min = R[0], M = _) : (this.min = R, this.max = _, M = b), M)
                  for (let A of M)
                    this.colors.push(o.CC.color(A));
                else
                  this.colors.push(o.CC.color(0));
              }
              //return range used for color mapping, null if none set
              range() {
                return typeof this.min < "u" && typeof this.max < "u" ? [this.min, this.max] : null;
              }
              //map value to hex color, range is provided
              valueToHex(R, _) {
                var b, M;
                if (_ ? (b = _[0], M = _[1]) : (b = this.min, M = this.max), R === void 0)
                  return 16777215;
                var A = u(b, M, R);
                b = A.lo, M = A.hi, R = A.val;
                let $ = this.colors.length, S = (M - b) / $, C = Math.min(Math.floor((R - b) / S), $ - 1), D = Math.min(C + 1, $ - 1), O = (R - b - C * S) / S, N = this.colors[C], j = this.colors[D];
                return new o.Color(N.r + O * (j.r - N.r), N.g + O * (j.g - N.g), N.b + O * (j.b - N.b)).getHex();
              }
            }
            const w = {
              rwb: h,
              RWB: h,
              roygb: p,
              ROYGB: p,
              sinebow: v,
              linear: g
            };
            class E extends l {
              valueToHex(R, _) {
                return 0;
              }
              range() {
                return null;
              }
            }
            E.RWB = h, E.ROYGB = p, E.Sinebow = v, E.CustomLinear = g, E.builtinGradients = w, E.normalizeValue = u, E.getGradient = f;
          }
        ),
        /***/
        "./src/Label.ts": (
          /*!**********************!*\
            !*** ./src/Label.ts ***!
            \**********************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              Label: () => (
                /* binding */
                v
              ),
              /* harmony export */
              LabelCount: () => (
                /* binding */
                f
              )
              /* harmony export */
            });
            var o = n(
              /*! ./WebGL */
              "./src/WebGL/index.ts"
            ), l = n(
              /*! ./Gradient */
              "./src/Gradient.ts"
            ), u = n(
              /*! ./colors */
              "./src/colors.ts"
            );
            let f = 0;
            function h(g, w, E, T, R, _, b) {
              g.beginPath(), g.moveTo(w + _, E), g.lineTo(w + T - _, E), g.quadraticCurveTo(w + T, E, w + T, E + _), g.lineTo(w + T, E + R - _), g.quadraticCurveTo(w + T, E + R, w + T - _, E + R), g.lineTo(w + _, E + R), g.quadraticCurveTo(w, E + R, w, E + R - _), g.lineTo(w, E + _), g.quadraticCurveTo(w, E, w + _, E), g.closePath(), g.fill(), b && g.stroke();
            }
            function p(g, w, E) {
              var T = E;
              return typeof g < "u" && (g instanceof u.Color ? T = g.scaled() : (T = u.CC.color(g), typeof T.scaled < "u" && (T = T.scaled()))), typeof w < "u" && (T.a = parseFloat(w)), T;
            }
            class v {
              constructor(w, E) {
                this.id = f++, this.stylespec = E || {}, this.canvas = document.createElement("canvas"), this.canvas.width = 134, this.canvas.height = 35, this.context = this.canvas.getContext("2d"), this.sprite = new o.Sprite(), this.text = w, this.frame = this.stylespec.frame;
              }
              getStyle() {
                return this.stylespec;
              }
              setContext() {
                var w = this.stylespec, E = typeof w.useScreen > "u" ? !1 : w.useScreen, T = w.showBackground;
                (T === "0" || T === "false") && (T = !1), typeof T > "u" && (T = !0);
                var R = w.font ? w.font : "sans-serif", _ = parseInt(w.fontSize) ? parseInt(w.fontSize) : 18, b = p(w.fontColor, w.fontOpacity, {
                  r: 255,
                  g: 255,
                  b: 255,
                  a: 1
                }), M = w.padding ? w.padding : 4, A = w.borderThickness ? w.borderThickness : 0, $ = p(w.backgroundColor, w.backgroundOpacity, {
                  r: 0,
                  g: 0,
                  b: 0,
                  a: 1
                }), S = p(w.borderColor, w.borderOpacity, $), C = w.position ? w.position : {
                  x: -10,
                  y: 1,
                  z: 1
                }, D = w.inFront !== void 0 ? w.inFront : !0;
                (D === "false" || D === "0") && (D = !1);
                var O = w.alignment || o.SpriteAlignment.topLeft;
                typeof O == "string" && O in o.SpriteAlignment && (O = o.SpriteAlignment[O]);
                var N = "";
                w.bold && (N = "bold "), this.context.font = N + _ + "px  " + R;
                var j = this.context.measureText(this.text), L = j.width;
                T || (A = 0);
                var z = L + 2.5 * A + 2 * M, G = _ * 1.25 + 2 * A + 2 * M;
                if (w.backgroundImage) {
                  var B = w.backgroundImage, F = w.backgroundWidth ? w.backgroundWidth : B.width, H = w.backgroundHeight ? w.backgroundHeight : B.height;
                  F > z && (z = F), H > G && (G = H);
                }
                if (this.canvas.width = z, this.canvas.height = G, this.context.clearRect(0, 0, this.canvas.width, this.canvas.height), N = "", w.bold && (N = "bold "), this.context.font = N + _ + "px  " + R, this.context.fillStyle = "rgba(" + $.r + "," + $.g + "," + $.b + "," + $.a + ")", this.context.strokeStyle = "rgba(" + S.r + "," + S.g + "," + S.b + "," + S.a + ")", w.backgroundGradient) {
                  let V = this.context.createLinearGradient(0, G / 2, z, G / 2), X = l.Gradient.getGradient(w.backgroundGradient), Z = X.range(), Q = -1, q = 1;
                  Z && (Q = Z[0], q = Z[1]);
                  let J = q - Q;
                  for (let ie = 0; ie < 1.01; ie += 0.1) {
                    let ne = p(X.valueToHex(Q + J * ie)), ge = "rgba(" + ne.r + "," + ne.g + "," + ne.b + "," + ne.a + ")";
                    V.addColorStop(ie, ge);
                  }
                  this.context.fillStyle = V;
                }
                this.context.lineWidth = A, T && h(this.context, A, A, z - 2 * A, G - 2 * A, 6, A > 0), w.backgroundImage && this.context.drawImage(B, 0, 0, z, G), this.context.fillStyle = "rgba(" + b.r + "," + b.g + "," + b.b + "," + b.a + ")", this.context.fillText(this.text, A + M, _ + A + M, L);
                var W = new o.Texture(this.canvas);
                W.needsUpdate = !0, this.sprite.material = new o.SpriteMaterial({
                  map: W,
                  useScreenCoordinates: E,
                  alignment: O,
                  depthTest: !D,
                  screenOffset: w.screenOffset || null
                }), this.sprite.scale.set(1, 1, 1), this.sprite.position.set(C.x, C.y, C.z);
              }
              // clean up material and texture
              dispose() {
                this.sprite.material.map !== void 0 && this.sprite.material.map.dispose(), this.sprite.material !== void 0 && this.sprite.material.dispose();
              }
            }
          }
        ),
        /***/
        "./src/ProteinSurface4.ts": (
          /*!********************************!*\
            !*** ./src/ProteinSurface4.ts ***!
            \********************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              MarchingCube: () => (
                /* binding */
                p
              ),
              /* harmony export */
              MarchingCubeInitializer: () => (
                /* binding */
                h
              ),
              /* harmony export */
              PointGrid: () => (
                /* binding */
                v
              ),
              /* harmony export */
              ProteinSurface: () => (
                /* binding */
                g
              ),
              /* harmony export */
              SurfaceType: () => (
                /* binding */
                l
              ),
              /* harmony export */
              setSyncSurface: () => (
                /* binding */
                f
              ),
              /* harmony export */
              syncSurface: () => (
                /* binding */
                u
              )
              /* harmony export */
            });
            var o = n(
              /*! ./WebGL/math */
              "./src/WebGL/math/index.ts"
            ), l;
            (function(w) {
              w[w.VDW = 1] = "VDW", w[w.MS = 2] = "MS", w[w.SAS = 3] = "SAS", w[w.SES = 4] = "SES";
            })(l || (l = {}));
            var u = !1;
            function f(w) {
              u = w;
            }
            (window.navigator.userAgent.indexOf("MSIE ") >= 0 || window.navigator.userAgent.indexOf("Trident/") >= 0) && (u = !0);
            class h {
              constructor() {
                this.ISDONE = 2, this.edgeTable = new Uint32Array([
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  2816,
                  0,
                  0,
                  0,
                  1792,
                  0,
                  3328,
                  3584,
                  3840,
                  0,
                  0,
                  0,
                  138,
                  0,
                  21,
                  0,
                  134,
                  0,
                  0,
                  0,
                  652,
                  0,
                  2067,
                  3865,
                  3600,
                  0,
                  0,
                  0,
                  42,
                  0,
                  0,
                  0,
                  294,
                  0,
                  0,
                  21,
                  28,
                  0,
                  3875,
                  1049,
                  3360,
                  0,
                  168,
                  162,
                  170,
                  0,
                  645,
                  2475,
                  2210,
                  0,
                  687,
                  293,
                  172,
                  4010,
                  3747,
                  3497,
                  3232,
                  0,
                  0,
                  0,
                  0,
                  0,
                  69,
                  0,
                  900,
                  0,
                  0,
                  0,
                  1792,
                  138,
                  131,
                  1608,
                  1920,
                  0,
                  81,
                  0,
                  2074,
                  84,
                  85,
                  84,
                  86,
                  0,
                  81,
                  0,
                  3676,
                  330,
                  1105,
                  1881,
                  1616,
                  0,
                  0,
                  0,
                  42,
                  0,
                  69,
                  0,
                  502,
                  0,
                  0,
                  21,
                  3580,
                  138,
                  2035,
                  1273,
                  1520,
                  2816,
                  104,
                  2337,
                  106,
                  840,
                  581,
                  367,
                  102,
                  2816,
                  3695,
                  3429,
                  3180,
                  1898,
                  1635,
                  1385,
                  1120,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  3910,
                  0,
                  0,
                  69,
                  588,
                  42,
                  2083,
                  41,
                  2880,
                  0,
                  0,
                  0,
                  1722,
                  0,
                  2293,
                  4095,
                  3830,
                  0,
                  255,
                  757,
                  764,
                  2538,
                  2291,
                  3065,
                  2800,
                  0,
                  0,
                  81,
                  338,
                  0,
                  3925,
                  1119,
                  3414,
                  84,
                  855,
                  85,
                  340,
                  2130,
                  2899,
                  89,
                  2384,
                  1792,
                  712,
                  194,
                  1162,
                  4036,
                  3781,
                  3535,
                  3270,
                  708,
                  719,
                  197,
                  204,
                  3018,
                  2755,
                  2505,
                  2240,
                  0,
                  0,
                  0,
                  0,
                  168,
                  420,
                  168,
                  1958,
                  162,
                  162,
                  676,
                  2988,
                  170,
                  163,
                  680,
                  928,
                  3328,
                  3096,
                  3328,
                  3642,
                  52,
                  53,
                  1855,
                  1590,
                  2340,
                  2111,
                  2869,
                  2620,
                  298,
                  51,
                  825,
                  560,
                  3584,
                  3584,
                  3090,
                  3482,
                  1668,
                  1941,
                  1183,
                  1430,
                  146,
                  2975,
                  2069,
                  2460,
                  154,
                  915,
                  153,
                  400,
                  3840,
                  3592,
                  3329,
                  3082,
                  1796,
                  1541,
                  1295,
                  1030,
                  2818,
                  2575,
                  2309,
                  2060,
                  778,
                  515,
                  265,
                  0
                ]), this.triTable = [
                  [],
                  [],
                  [],
                  [],
                  [],
                  [],
                  [],
                  [11, 9, 8],
                  [],
                  [],
                  [],
                  [8, 10, 9],
                  [],
                  [10, 8, 11],
                  [9, 11, 10],
                  [8, 10, 9, 8, 11, 10],
                  [],
                  [],
                  [],
                  [1, 7, 3],
                  [],
                  [4, 2, 0],
                  [],
                  [2, 1, 7],
                  [],
                  [],
                  [],
                  [2, 7, 3, 2, 9, 7],
                  [],
                  [1, 4, 11, 1, 0, 4],
                  [3, 8, 0, 11, 9, 4, 11, 10, 9],
                  [4, 11, 9, 11, 10, 9],
                  [],
                  [],
                  [],
                  [5, 3, 1],
                  [],
                  [],
                  [],
                  [2, 5, 8, 2, 1, 5],
                  [],
                  [],
                  [2, 4, 0],
                  [3, 2, 4],
                  [],
                  [0, 9, 1, 8, 10, 5, 8, 11, 10],
                  [3, 4, 0, 3, 10, 4],
                  [5, 8, 10, 8, 11, 10],
                  [],
                  [3, 5, 7],
                  [7, 1, 5],
                  [1, 7, 3, 1, 5, 7],
                  [],
                  [9, 2, 0, 9, 7, 2],
                  [0, 3, 8, 1, 7, 11, 1, 5, 7],
                  [11, 1, 7, 1, 5, 7],
                  [],
                  [9, 1, 0, 5, 3, 2, 5, 7, 3],
                  [8, 2, 5, 8, 0, 2],
                  [2, 5, 3, 5, 7, 3],
                  [3, 9, 1, 3, 8, 9, 7, 11, 10, 7, 10, 5],
                  [9, 1, 0, 10, 7, 11, 10, 5, 7],
                  [3, 8, 0, 7, 10, 5, 7, 11, 10],
                  [11, 5, 7, 11, 10, 5],
                  [],
                  [],
                  [],
                  [],
                  [],
                  [0, 6, 2],
                  [],
                  [7, 2, 9, 7, 9, 8],
                  [],
                  [],
                  [],
                  [8, 10, 9],
                  [7, 1, 3],
                  [7, 1, 0],
                  [6, 9, 3, 6, 10, 9],
                  [7, 10, 8, 10, 9, 8],
                  [],
                  [6, 0, 4],
                  [],
                  [11, 1, 4, 11, 3, 1],
                  [2, 4, 6],
                  [2, 0, 4, 2, 4, 6],
                  [2, 4, 6],
                  [1, 4, 2, 4, 6, 2],
                  [],
                  [6, 0, 4],
                  [],
                  [2, 11, 3, 6, 9, 4, 6, 10, 9],
                  [8, 6, 1, 8, 1, 3],
                  [10, 0, 6, 0, 4, 6],
                  [8, 0, 3, 9, 6, 10, 9, 4, 6],
                  [10, 4, 6, 10, 9, 4],
                  [],
                  [],
                  [],
                  [5, 3, 1],
                  [],
                  [0, 6, 2],
                  [],
                  [7, 4, 8, 5, 2, 1, 5, 6, 2],
                  [],
                  [],
                  [2, 4, 0],
                  [7, 4, 8, 2, 11, 3, 10, 5, 6],
                  [7, 1, 3],
                  [5, 6, 10, 0, 9, 1, 8, 7, 4],
                  [5, 6, 10, 7, 0, 3, 7, 4, 0],
                  [10, 5, 6, 4, 8, 7],
                  [9, 11, 8],
                  [3, 5, 6],
                  [0, 5, 11, 0, 11, 8],
                  [6, 3, 5, 3, 1, 5],
                  [3, 9, 6, 3, 8, 9],
                  [9, 6, 0, 6, 2, 0],
                  [0, 3, 8, 2, 5, 6, 2, 1, 5],
                  [1, 6, 2, 1, 5, 6],
                  [9, 11, 8],
                  [1, 0, 9, 6, 10, 5, 11, 3, 2],
                  [6, 10, 5, 2, 8, 0, 2, 11, 8],
                  [3, 2, 11, 10, 5, 6],
                  [10, 5, 6, 9, 3, 8, 9, 1, 3],
                  [0, 9, 1, 5, 6, 10],
                  [8, 0, 3, 10, 5, 6],
                  [10, 5, 6],
                  [],
                  [],
                  [],
                  [],
                  [],
                  [],
                  [],
                  [1, 10, 2, 9, 11, 6, 9, 8, 11],
                  [],
                  [],
                  [6, 0, 2],
                  [3, 6, 9, 3, 2, 6],
                  [3, 5, 1],
                  [0, 5, 1, 0, 11, 5],
                  [0, 3, 5],
                  [6, 9, 11, 9, 8, 11],
                  [],
                  [],
                  [],
                  [4, 5, 9, 7, 1, 10, 7, 3, 1],
                  [],
                  [11, 6, 7, 2, 4, 5, 2, 0, 4],
                  [11, 6, 7, 8, 0, 3, 1, 10, 2, 9, 4, 5],
                  [6, 7, 11, 1, 10, 2, 9, 4, 5],
                  [],
                  [4, 1, 0, 4, 5, 1, 6, 7, 3, 6, 3, 2],
                  [9, 4, 5, 0, 6, 7, 0, 2, 6],
                  [4, 5, 9, 6, 3, 2, 6, 7, 3],
                  [6, 7, 11, 5, 3, 8, 5, 1, 3],
                  [6, 7, 11, 4, 1, 0, 4, 5, 1],
                  [4, 5, 9, 3, 8, 0, 11, 6, 7],
                  [9, 4, 5, 7, 11, 6],
                  [],
                  [],
                  [0, 6, 4],
                  [8, 6, 4, 8, 1, 6],
                  [],
                  [0, 10, 2, 0, 9, 10, 4, 8, 11, 4, 11, 6],
                  [10, 2, 1, 6, 0, 3, 6, 4, 0],
                  [10, 2, 1, 11, 4, 8, 11, 6, 4],
                  [4, 2, 6],
                  [1, 0, 9, 2, 4, 8, 2, 6, 4],
                  [2, 4, 0, 2, 6, 4],
                  [8, 2, 4, 2, 6, 4],
                  [11, 4, 1, 11, 6, 4],
                  [0, 9, 1, 4, 11, 6, 4, 8, 11],
                  [3, 6, 0, 6, 4, 0],
                  [8, 6, 4, 8, 11, 6],
                  [10, 8, 9],
                  [6, 3, 9, 6, 7, 3],
                  [6, 7, 1],
                  [10, 7, 1, 7, 3, 1],
                  [7, 11, 6, 8, 10, 2, 8, 9, 10],
                  [11, 6, 7, 10, 0, 9, 10, 2, 0],
                  [2, 1, 10, 7, 11, 6, 8, 0, 3],
                  [1, 10, 2, 6, 7, 11],
                  [7, 2, 6, 7, 9, 2],
                  [1, 0, 9, 3, 6, 7, 3, 2, 6],
                  [7, 0, 6, 0, 2, 6],
                  [2, 7, 3, 2, 6, 7],
                  [7, 11, 6, 3, 9, 1, 3, 8, 9],
                  [9, 1, 0, 11, 6, 7],
                  [0, 3, 8, 11, 6, 7],
                  [11, 6, 7],
                  [],
                  [],
                  [],
                  [],
                  [5, 3, 7],
                  [8, 5, 2, 8, 7, 5],
                  [5, 3, 7],
                  [1, 10, 2, 5, 8, 7, 5, 9, 8],
                  [1, 7, 5],
                  [1, 7, 5],
                  [9, 2, 7, 9, 7, 5],
                  [11, 3, 2, 8, 5, 9, 8, 7, 5],
                  [1, 3, 7, 1, 7, 5],
                  [0, 7, 1, 7, 5, 1],
                  [9, 3, 5, 3, 7, 5],
                  [9, 7, 5, 9, 8, 7],
                  [8, 10, 11],
                  [3, 4, 10, 3, 10, 11],
                  [8, 10, 11],
                  [5, 9, 4, 1, 11, 3, 1, 10, 11],
                  [2, 4, 5],
                  [5, 2, 4, 2, 0, 4],
                  [0, 3, 8, 5, 9, 4, 10, 2, 1],
                  [2, 1, 10, 9, 4, 5],
                  [2, 8, 5, 2, 11, 8],
                  [3, 2, 11, 1, 4, 5, 1, 0, 4],
                  [9, 4, 5, 8, 2, 11, 8, 0, 2],
                  [11, 3, 2, 9, 4, 5],
                  [8, 5, 3, 5, 1, 3],
                  [5, 0, 4, 5, 1, 0],
                  [3, 8, 0, 4, 5, 9],
                  [9, 4, 5],
                  [11, 9, 10],
                  [11, 9, 10],
                  [1, 11, 4, 1, 10, 11],
                  [8, 7, 4, 11, 1, 10, 11, 3, 1],
                  [2, 7, 9, 2, 9, 10],
                  [4, 8, 7, 0, 10, 2, 0, 9, 10],
                  [2, 1, 10, 0, 7, 4, 0, 3, 7],
                  [10, 2, 1, 8, 7, 4],
                  [1, 7, 4],
                  [3, 2, 11, 4, 8, 7, 9, 1, 0],
                  [11, 4, 2, 4, 0, 2],
                  [2, 11, 3, 7, 4, 8],
                  [4, 1, 7, 1, 3, 7],
                  [1, 0, 9, 8, 7, 4],
                  [3, 4, 0, 3, 7, 4],
                  [8, 7, 4],
                  [8, 9, 10, 8, 10, 11],
                  [3, 9, 11, 9, 10, 11],
                  [0, 10, 8, 10, 11, 8],
                  [10, 3, 1, 10, 11, 3],
                  [2, 8, 10, 8, 9, 10],
                  [9, 2, 0, 9, 10, 2],
                  [8, 0, 3, 1, 10, 2],
                  [10, 2, 1],
                  [1, 11, 9, 11, 8, 9],
                  [11, 3, 2, 0, 9, 1],
                  [11, 0, 2, 11, 8, 0],
                  [11, 3, 2],
                  [8, 1, 3, 8, 9, 1],
                  [9, 1, 0],
                  [8, 0, 3],
                  []
                ], this.edgeTable2 = [
                  0,
                  265,
                  515,
                  778,
                  2060,
                  2309,
                  2575,
                  2822,
                  1030,
                  1295,
                  1541,
                  1804,
                  3082,
                  3331,
                  3593,
                  3840,
                  400,
                  153,
                  915,
                  666,
                  2460,
                  2197,
                  2975,
                  2710,
                  1430,
                  1183,
                  1941,
                  1692,
                  3482,
                  3219,
                  3993,
                  3728,
                  560,
                  825,
                  51,
                  314,
                  2620,
                  2869,
                  2111,
                  2358,
                  1590,
                  1855,
                  1077,
                  1340,
                  3642,
                  3891,
                  3129,
                  3376,
                  928,
                  681,
                  419,
                  170,
                  2988,
                  2725,
                  2479,
                  2214,
                  1958,
                  1711,
                  1445,
                  1196,
                  4010,
                  3747,
                  3497,
                  3232,
                  2240,
                  2505,
                  2755,
                  3018,
                  204,
                  453,
                  719,
                  966,
                  3270,
                  3535,
                  3781,
                  4044,
                  1226,
                  1475,
                  1737,
                  1984,
                  2384,
                  2137,
                  2899,
                  2650,
                  348,
                  85,
                  863,
                  598,
                  3414,
                  3167,
                  3925,
                  3676,
                  1370,
                  1107,
                  1881,
                  1616,
                  2800,
                  3065,
                  2291,
                  2554,
                  764,
                  1013,
                  255,
                  502,
                  3830,
                  4095,
                  3317,
                  3580,
                  1786,
                  2035,
                  1273,
                  1520,
                  2912,
                  2665,
                  2403,
                  2154,
                  876,
                  613,
                  367,
                  102,
                  3942,
                  3695,
                  3429,
                  3180,
                  1898,
                  1635,
                  1385,
                  1120,
                  1120,
                  1385,
                  1635,
                  1898,
                  3180,
                  3429,
                  3695,
                  3942,
                  102,
                  367,
                  613,
                  876,
                  2154,
                  2403,
                  2665,
                  2912,
                  1520,
                  1273,
                  2035,
                  1786,
                  3580,
                  3317,
                  4095,
                  3830,
                  502,
                  255,
                  1013,
                  764,
                  2554,
                  2291,
                  3065,
                  2800,
                  1616,
                  1881,
                  1107,
                  1370,
                  3676,
                  3925,
                  3167,
                  3414,
                  598,
                  863,
                  85,
                  348,
                  2650,
                  2899,
                  2137,
                  2384,
                  1984,
                  1737,
                  1475,
                  1226,
                  4044,
                  3781,
                  3535,
                  3270,
                  966,
                  719,
                  453,
                  204,
                  3018,
                  2755,
                  2505,
                  2240,
                  3232,
                  3497,
                  3747,
                  4010,
                  1196,
                  1445,
                  1711,
                  1958,
                  2214,
                  2479,
                  2725,
                  2988,
                  170,
                  419,
                  681,
                  928,
                  3376,
                  3129,
                  3891,
                  3642,
                  1340,
                  1077,
                  1855,
                  1590,
                  2358,
                  2111,
                  2869,
                  2620,
                  314,
                  51,
                  825,
                  560,
                  3728,
                  3993,
                  3219,
                  3482,
                  1692,
                  1941,
                  1183,
                  1430,
                  2710,
                  2975,
                  2197,
                  2460,
                  666,
                  915,
                  153,
                  400,
                  3840,
                  3593,
                  3331,
                  3082,
                  1804,
                  1541,
                  1295,
                  1030,
                  2822,
                  2575,
                  2309,
                  2060,
                  778,
                  515,
                  265,
                  0
                ], this.triTable2 = [
                  [],
                  [8, 3, 0],
                  [9, 0, 1],
                  [8, 3, 1, 8, 1, 9],
                  [11, 2, 3],
                  [11, 2, 0, 11, 0, 8],
                  [11, 2, 3, 0, 1, 9],
                  [2, 1, 11, 1, 9, 11, 11, 9, 8],
                  [10, 1, 2],
                  [8, 3, 0, 1, 2, 10],
                  [9, 0, 2, 9, 2, 10],
                  [3, 2, 8, 2, 10, 8, 8, 10, 9],
                  [10, 1, 3, 10, 3, 11],
                  [1, 0, 10, 0, 8, 10, 10, 8, 11],
                  [0, 3, 9, 3, 11, 9, 9, 11, 10],
                  [8, 10, 9, 8, 11, 10],
                  [8, 4, 7],
                  [3, 0, 4, 3, 4, 7],
                  [1, 9, 0, 8, 4, 7],
                  [9, 4, 1, 4, 7, 1, 1, 7, 3],
                  [2, 3, 11, 7, 8, 4],
                  [7, 11, 4, 11, 2, 4, 4, 2, 0],
                  [3, 11, 2, 4, 7, 8, 9, 0, 1],
                  [2, 7, 11, 2, 1, 7, 1, 4, 7, 1, 9, 4],
                  [10, 1, 2, 8, 4, 7],
                  [2, 10, 1, 0, 4, 7, 0, 7, 3],
                  [4, 7, 8, 0, 2, 10, 0, 10, 9],
                  [2, 7, 3, 2, 9, 7, 7, 9, 4, 2, 10, 9],
                  [8, 4, 7, 11, 10, 1, 11, 1, 3],
                  [11, 4, 7, 1, 4, 11, 1, 11, 10, 1, 0, 4],
                  [3, 8, 0, 7, 11, 4, 11, 9, 4, 11, 10, 9],
                  [7, 11, 4, 4, 11, 9, 11, 10, 9],
                  [9, 5, 4],
                  [3, 0, 8, 4, 9, 5],
                  [5, 4, 0, 5, 0, 1],
                  [4, 8, 5, 8, 3, 5, 5, 3, 1],
                  [11, 2, 3, 9, 5, 4],
                  [9, 5, 4, 8, 11, 2, 8, 2, 0],
                  [3, 11, 2, 1, 5, 4, 1, 4, 0],
                  [8, 5, 4, 2, 5, 8, 2, 8, 11, 2, 1, 5],
                  [2, 10, 1, 9, 5, 4],
                  [0, 8, 3, 5, 4, 9, 10, 1, 2],
                  [10, 5, 2, 5, 4, 2, 2, 4, 0],
                  [3, 4, 8, 3, 2, 4, 2, 5, 4, 2, 10, 5],
                  [5, 4, 9, 1, 3, 11, 1, 11, 10],
                  [0, 9, 1, 4, 8, 5, 8, 10, 5, 8, 11, 10],
                  [3, 4, 0, 3, 10, 4, 4, 10, 5, 3, 11, 10],
                  [4, 8, 5, 5, 8, 10, 8, 11, 10],
                  [9, 5, 7, 9, 7, 8],
                  [0, 9, 3, 9, 5, 3, 3, 5, 7],
                  [8, 0, 7, 0, 1, 7, 7, 1, 5],
                  [1, 7, 3, 1, 5, 7],
                  [11, 2, 3, 8, 9, 5, 8, 5, 7],
                  [9, 2, 0, 9, 7, 2, 2, 7, 11, 9, 5, 7],
                  [0, 3, 8, 2, 1, 11, 1, 7, 11, 1, 5, 7],
                  [2, 1, 11, 11, 1, 7, 1, 5, 7],
                  [1, 2, 10, 5, 7, 8, 5, 8, 9],
                  [9, 1, 0, 10, 5, 2, 5, 3, 2, 5, 7, 3],
                  [5, 2, 10, 8, 2, 5, 8, 5, 7, 8, 0, 2],
                  [10, 5, 2, 2, 5, 3, 5, 7, 3],
                  [3, 9, 1, 3, 8, 9, 7, 11, 10, 7, 10, 5],
                  [9, 1, 0, 10, 7, 11, 10, 5, 7],
                  [3, 8, 0, 7, 10, 5, 7, 11, 10],
                  [11, 5, 7, 11, 10, 5],
                  [11, 7, 6],
                  [0, 8, 3, 11, 7, 6],
                  [9, 0, 1, 11, 7, 6],
                  [7, 6, 11, 3, 1, 9, 3, 9, 8],
                  [2, 3, 7, 2, 7, 6],
                  [8, 7, 0, 7, 6, 0, 0, 6, 2],
                  [1, 9, 0, 3, 7, 6, 3, 6, 2],
                  [7, 6, 2, 7, 2, 9, 2, 1, 9, 7, 9, 8],
                  [1, 2, 10, 6, 11, 7],
                  [2, 10, 1, 7, 6, 11, 8, 3, 0],
                  [11, 7, 6, 10, 9, 0, 10, 0, 2],
                  [7, 6, 11, 3, 2, 8, 8, 2, 10, 8, 10, 9],
                  [6, 10, 7, 10, 1, 7, 7, 1, 3],
                  [6, 10, 1, 6, 1, 7, 7, 1, 0, 7, 0, 8],
                  [9, 0, 3, 6, 9, 3, 6, 10, 9, 6, 3, 7],
                  [6, 10, 7, 7, 10, 8, 10, 9, 8],
                  [8, 4, 6, 8, 6, 11],
                  [11, 3, 6, 3, 0, 6, 6, 0, 4],
                  [0, 1, 9, 4, 6, 11, 4, 11, 8],
                  [1, 9, 4, 11, 1, 4, 11, 3, 1, 11, 4, 6],
                  [3, 8, 2, 8, 4, 2, 2, 4, 6],
                  [2, 0, 4, 2, 4, 6],
                  [1, 9, 0, 3, 8, 2, 2, 8, 4, 2, 4, 6],
                  [9, 4, 1, 1, 4, 2, 4, 6, 2],
                  [10, 1, 2, 11, 8, 4, 11, 4, 6],
                  [10, 1, 2, 11, 3, 6, 6, 3, 0, 6, 0, 4],
                  [0, 2, 10, 0, 10, 9, 4, 11, 8, 4, 6, 11],
                  [2, 11, 3, 6, 9, 4, 6, 10, 9],
                  [8, 4, 6, 8, 6, 1, 6, 10, 1, 8, 1, 3],
                  [1, 0, 10, 10, 0, 6, 0, 4, 6],
                  [8, 0, 3, 9, 6, 10, 9, 4, 6],
                  [10, 4, 6, 10, 9, 4],
                  [9, 5, 4, 7, 6, 11],
                  [4, 9, 5, 3, 0, 8, 11, 7, 6],
                  [6, 11, 7, 4, 0, 1, 4, 1, 5],
                  [6, 11, 7, 4, 8, 5, 5, 8, 3, 5, 3, 1],
                  [4, 9, 5, 6, 2, 3, 6, 3, 7],
                  [9, 5, 4, 8, 7, 0, 0, 7, 6, 0, 6, 2],
                  [4, 0, 1, 4, 1, 5, 6, 3, 7, 6, 2, 3],
                  [7, 4, 8, 5, 2, 1, 5, 6, 2],
                  [6, 11, 7, 1, 2, 10, 9, 5, 4],
                  [11, 7, 6, 8, 3, 0, 1, 2, 10, 9, 5, 4],
                  [11, 7, 6, 10, 5, 2, 2, 5, 4, 2, 4, 0],
                  [7, 4, 8, 2, 11, 3, 10, 5, 6],
                  [4, 9, 5, 6, 10, 7, 7, 10, 1, 7, 1, 3],
                  [5, 6, 10, 0, 9, 1, 8, 7, 4],
                  [5, 6, 10, 7, 0, 3, 7, 4, 0],
                  [10, 5, 6, 4, 8, 7],
                  [5, 6, 9, 6, 11, 9, 9, 11, 8],
                  [0, 9, 5, 0, 5, 3, 3, 5, 6, 3, 6, 11],
                  [0, 1, 5, 0, 5, 11, 5, 6, 11, 0, 11, 8],
                  [11, 3, 6, 6, 3, 5, 3, 1, 5],
                  [9, 5, 6, 3, 9, 6, 3, 8, 9, 3, 6, 2],
                  [5, 6, 9, 9, 6, 0, 6, 2, 0],
                  [0, 3, 8, 2, 5, 6, 2, 1, 5],
                  [1, 6, 2, 1, 5, 6],
                  [1, 2, 10, 5, 6, 9, 9, 6, 11, 9, 11, 8],
                  [1, 0, 9, 6, 10, 5, 11, 3, 2],
                  [6, 10, 5, 2, 8, 0, 2, 11, 8],
                  [3, 2, 11, 10, 5, 6],
                  [10, 5, 6, 9, 3, 8, 9, 1, 3],
                  [0, 9, 1, 5, 6, 10],
                  [8, 0, 3, 10, 5, 6],
                  [10, 5, 6],
                  [10, 6, 5],
                  [8, 3, 0, 10, 6, 5],
                  [0, 1, 9, 5, 10, 6],
                  [10, 6, 5, 9, 8, 3, 9, 3, 1],
                  [3, 11, 2, 10, 6, 5],
                  [6, 5, 10, 2, 0, 8, 2, 8, 11],
                  [1, 9, 0, 6, 5, 10, 11, 2, 3],
                  [1, 10, 2, 5, 9, 6, 9, 11, 6, 9, 8, 11],
                  [1, 2, 6, 1, 6, 5],
                  [0, 8, 3, 2, 6, 5, 2, 5, 1],
                  [5, 9, 6, 9, 0, 6, 6, 0, 2],
                  [9, 6, 5, 3, 6, 9, 3, 9, 8, 3, 2, 6],
                  [11, 6, 3, 6, 5, 3, 3, 5, 1],
                  [0, 5, 1, 0, 11, 5, 5, 11, 6, 0, 8, 11],
                  [0, 5, 9, 0, 3, 5, 3, 6, 5, 3, 11, 6],
                  [5, 9, 6, 6, 9, 11, 9, 8, 11],
                  [10, 6, 5, 4, 7, 8],
                  [5, 10, 6, 7, 3, 0, 7, 0, 4],
                  [5, 10, 6, 0, 1, 9, 8, 4, 7],
                  [4, 5, 9, 6, 7, 10, 7, 1, 10, 7, 3, 1],
                  [7, 8, 4, 2, 3, 11, 10, 6, 5],
                  [11, 6, 7, 10, 2, 5, 2, 4, 5, 2, 0, 4],
                  [11, 6, 7, 8, 0, 3, 1, 10, 2, 9, 4, 5],
                  [6, 7, 11, 1, 10, 2, 9, 4, 5],
                  [7, 8, 4, 5, 1, 2, 5, 2, 6],
                  [4, 1, 0, 4, 5, 1, 6, 7, 3, 6, 3, 2],
                  [9, 4, 5, 8, 0, 7, 0, 6, 7, 0, 2, 6],
                  [4, 5, 9, 6, 3, 2, 6, 7, 3],
                  [6, 7, 11, 4, 5, 8, 5, 3, 8, 5, 1, 3],
                  [6, 7, 11, 4, 1, 0, 4, 5, 1],
                  [4, 5, 9, 3, 8, 0, 11, 6, 7],
                  [9, 4, 5, 7, 11, 6],
                  [10, 6, 4, 10, 4, 9],
                  [8, 3, 0, 9, 10, 6, 9, 6, 4],
                  [1, 10, 0, 10, 6, 0, 0, 6, 4],
                  [8, 6, 4, 8, 1, 6, 6, 1, 10, 8, 3, 1],
                  [2, 3, 11, 6, 4, 9, 6, 9, 10],
                  [0, 10, 2, 0, 9, 10, 4, 8, 11, 4, 11, 6],
                  [10, 2, 1, 11, 6, 3, 6, 0, 3, 6, 4, 0],
                  [10, 2, 1, 11, 4, 8, 11, 6, 4],
                  [9, 1, 4, 1, 2, 4, 4, 2, 6],
                  [1, 0, 9, 3, 2, 8, 2, 4, 8, 2, 6, 4],
                  [2, 4, 0, 2, 6, 4],
                  [3, 2, 8, 8, 2, 4, 2, 6, 4],
                  [1, 4, 9, 11, 4, 1, 11, 1, 3, 11, 6, 4],
                  [0, 9, 1, 4, 11, 6, 4, 8, 11],
                  [11, 6, 3, 3, 6, 0, 6, 4, 0],
                  [8, 6, 4, 8, 11, 6],
                  [6, 7, 10, 7, 8, 10, 10, 8, 9],
                  [9, 3, 0, 6, 3, 9, 6, 9, 10, 6, 7, 3],
                  [6, 1, 10, 6, 7, 1, 7, 0, 1, 7, 8, 0],
                  [6, 7, 10, 10, 7, 1, 7, 3, 1],
                  [7, 11, 6, 3, 8, 2, 8, 10, 2, 8, 9, 10],
                  [11, 6, 7, 10, 0, 9, 10, 2, 0],
                  [2, 1, 10, 7, 11, 6, 8, 0, 3],
                  [1, 10, 2, 6, 7, 11],
                  [7, 2, 6, 7, 9, 2, 2, 9, 1, 7, 8, 9],
                  [1, 0, 9, 3, 6, 7, 3, 2, 6],
                  [8, 0, 7, 7, 0, 6, 0, 2, 6],
                  [2, 7, 3, 2, 6, 7],
                  [7, 11, 6, 3, 9, 1, 3, 8, 9],
                  [9, 1, 0, 11, 6, 7],
                  [0, 3, 8, 11, 6, 7],
                  [11, 6, 7],
                  [11, 7, 5, 11, 5, 10],
                  [3, 0, 8, 7, 5, 10, 7, 10, 11],
                  [9, 0, 1, 10, 11, 7, 10, 7, 5],
                  [3, 1, 9, 3, 9, 8, 7, 10, 11, 7, 5, 10],
                  [10, 2, 5, 2, 3, 5, 5, 3, 7],
                  [5, 10, 2, 8, 5, 2, 8, 7, 5, 8, 2, 0],
                  [9, 0, 1, 10, 2, 5, 5, 2, 3, 5, 3, 7],
                  [1, 10, 2, 5, 8, 7, 5, 9, 8],
                  [2, 11, 1, 11, 7, 1, 1, 7, 5],
                  [0, 8, 3, 2, 11, 1, 1, 11, 7, 1, 7, 5],
                  [9, 0, 2, 9, 2, 7, 2, 11, 7, 9, 7, 5],
                  [11, 3, 2, 8, 5, 9, 8, 7, 5],
                  [1, 3, 7, 1, 7, 5],
                  [8, 7, 0, 0, 7, 1, 7, 5, 1],
                  [0, 3, 9, 9, 3, 5, 3, 7, 5],
                  [9, 7, 5, 9, 8, 7],
                  [4, 5, 8, 5, 10, 8, 8, 10, 11],
                  [3, 0, 4, 3, 4, 10, 4, 5, 10, 3, 10, 11],
                  [0, 1, 9, 4, 5, 8, 8, 5, 10, 8, 10, 11],
                  [5, 9, 4, 1, 11, 3, 1, 10, 11],
                  [3, 8, 4, 3, 4, 2, 2, 4, 5, 2, 5, 10],
                  [10, 2, 5, 5, 2, 4, 2, 0, 4],
                  [0, 3, 8, 5, 9, 4, 10, 2, 1],
                  [2, 1, 10, 9, 4, 5],
                  [8, 4, 5, 2, 8, 5, 2, 11, 8, 2, 5, 1],
                  [3, 2, 11, 1, 4, 5, 1, 0, 4],
                  [9, 4, 5, 8, 2, 11, 8, 0, 2],
                  [11, 3, 2, 9, 4, 5],
                  [4, 5, 8, 8, 5, 3, 5, 1, 3],
                  [5, 0, 4, 5, 1, 0],
                  [3, 8, 0, 4, 5, 9],
                  [9, 4, 5],
                  [7, 4, 11, 4, 9, 11, 11, 9, 10],
                  [3, 0, 8, 7, 4, 11, 11, 4, 9, 11, 9, 10],
                  [11, 7, 4, 1, 11, 4, 1, 10, 11, 1, 4, 0],
                  [8, 7, 4, 11, 1, 10, 11, 3, 1],
                  [2, 3, 7, 2, 7, 9, 7, 4, 9, 2, 9, 10],
                  [4, 8, 7, 0, 10, 2, 0, 9, 10],
                  [2, 1, 10, 0, 7, 4, 0, 3, 7],
                  [10, 2, 1, 8, 7, 4],
                  [2, 11, 7, 2, 7, 1, 1, 7, 4, 1, 4, 9],
                  [3, 2, 11, 4, 8, 7, 9, 1, 0],
                  [7, 4, 11, 11, 4, 2, 4, 0, 2],
                  [2, 11, 3, 7, 4, 8],
                  [9, 1, 4, 4, 1, 7, 1, 3, 7],
                  [1, 0, 9, 8, 7, 4],
                  [3, 4, 0, 3, 7, 4],
                  [8, 7, 4],
                  [8, 9, 10, 8, 10, 11],
                  [0, 9, 3, 3, 9, 11, 9, 10, 11],
                  [1, 10, 0, 0, 10, 8, 10, 11, 8],
                  [10, 3, 1, 10, 11, 3],
                  [3, 8, 2, 2, 8, 10, 8, 9, 10],
                  [9, 2, 0, 9, 10, 2],
                  [8, 0, 3, 1, 10, 2],
                  [10, 2, 1],
                  [2, 11, 1, 1, 11, 9, 11, 8, 9],
                  [11, 3, 2, 0, 9, 1],
                  [11, 0, 2, 11, 8, 0],
                  [11, 3, 2],
                  [8, 1, 3, 8, 9, 1],
                  [9, 1, 0],
                  [8, 0, 3],
                  []
                ];
              }
              march(E, T, R, _) {
                let b = !!_.fulltable, M = _.hasOwnProperty("origin") && _.origin.hasOwnProperty("x") ? _.origin : { x: 0, y: 0, z: 0 }, A = !!_.voxel, $ = _.matrix, S = _.nX || 0, C = _.nY || 0, D = _.nZ || 0, O = _.scale || 1, N = null;
                _.unitCube ? N = _.unitCube : N = { x: O, y: O, z: O };
                let j = new Int32Array(S * C * D), L, z;
                for (L = 0, z = j.length; L < z; ++L)
                  j[L] = -1;
                let G = function(W, V, X, Z, Q, q) {
                  let J = { x: 0, y: 0, z: 0 }, ie = !!(Z & 1 << Q), ne = !!(Z & 1 << q), ge = Q;
                  if (!ie && ne && (ge = q), ge & 1 && X++, ge & 2 && V++, ge & 4 && W++, $) {
                    let xe = new o.Vector3(W, V, X);
                    xe = xe.applyMatrix4($), J = { x: xe.x, y: xe.y, z: xe.z };
                  } else
                    J.x = M.x + N.x * W, J.y = M.y + N.y * V, J.z = M.z + N.z * X;
                  let ye = (C * W + V) * D + X;
                  return A ? (T.push(J), T.length - 1) : (j[ye] < 0 && (j[ye] = T.length, T.push(J)), j[ye]);
                }, B = new Int32Array(12), F = b ? this.edgeTable2 : this.edgeTable, H = b ? this.triTable2 : this.triTable;
                for (L = 0; L < S - 1; ++L)
                  for (let W = 0; W < C - 1; ++W)
                    for (let V = 0; V < D - 1; ++V) {
                      let X = 0;
                      for (let q = 0; q < 8; ++q) {
                        let J = (C * (L + ((q & 4) >> 2)) + W + ((q & 2) >> 1)) * D + V + (q & 1), ie = !!(E[J] & this.ISDONE);
                        X |= ie << q;
                      }
                      if (X === 0 || X === 255)
                        continue;
                      let Z = F[X];
                      if (Z === 0)
                        continue;
                      let Q = H[X];
                      Z & 1 && (B[0] = G(L, W, V, X, 0, 1)), Z & 2 && (B[1] = G(L, W, V, X, 1, 3)), Z & 4 && (B[2] = G(L, W, V, X, 3, 2)), Z & 8 && (B[3] = G(L, W, V, X, 2, 0)), Z & 16 && (B[4] = G(L, W, V, X, 4, 5)), Z & 32 && (B[5] = G(L, W, V, X, 5, 7)), Z & 64 && (B[6] = G(L, W, V, X, 7, 6)), Z & 128 && (B[7] = G(L, W, V, X, 6, 4)), Z & 256 && (B[8] = G(L, W, V, X, 0, 4)), Z & 512 && (B[9] = G(L, W, V, X, 1, 5)), Z & 1024 && (B[10] = G(L, W, V, X, 3, 7)), Z & 2048 && (B[11] = G(L, W, V, X, 2, 6));
                      for (let q = 0; q < Q.length; q += 3) {
                        let J = B[Q[q]], ie = B[Q[q + 1]], ne = B[Q[q + 2]];
                        A && q >= 3 && (T.push(T[J]), J = T.length - 1, T.push(T[ie]), ie = T.length - 1, T.push(T[ne]), ne = T.length - 1), R.push(J), R.push(ie), R.push(ne);
                      }
                    }
              }
              laplacianSmooth(E, T, R) {
                let _ = new Array(T.length), b, M, A, $, S;
                for (b = 0, M = T.length; b < M; b++)
                  _[b] = {
                    x: 0,
                    y: 0,
                    z: 0
                  };
                let C = new Array(20), D;
                for (b = 0; b < 20; b++)
                  C[b] = new Array(T.length);
                for (b = 0, M = T.length; b < M; b++)
                  C[0][b] = 0;
                for (b = 0, M = R.length / 3; b < M; b++) {
                  let j = b * 3, L = b * 3 + 1, z = b * 3 + 2;
                  for (D = !0, A = 0, $ = C[0][R[j]]; A < $; A++)
                    if (R[L] == C[A + 1][R[j]]) {
                      D = !1;
                      break;
                    }
                  for (D && (C[0][R[j]]++, C[C[0][R[j]]][R[j]] = R[L]), D = !0, A = 0, $ = C[0][R[j]]; A < $; A++)
                    if (R[z] == C[A + 1][R[j]]) {
                      D = !1;
                      break;
                    }
                  for (D && (C[0][R[j]]++, C[C[0][R[j]]][R[j]] = R[z]), D = !0, A = 0, $ = C[0][R[L]]; A < $; A++)
                    if (R[j] == C[A + 1][R[L]]) {
                      D = !1;
                      break;
                    }
                  for (D && (C[0][R[L]]++, C[C[0][R[L]]][R[L]] = R[j]), D = !0, A = 0, $ = C[0][R[L]]; A < $; A++)
                    if (R[z] == C[A + 1][R[L]]) {
                      D = !1;
                      break;
                    }
                  for (D && (C[0][R[L]]++, C[C[0][R[L]]][R[L]] = R[z]), D = !0, A = 0; A < C[0][R[z]]; A++)
                    if (R[j] == C[A + 1][R[z]]) {
                      D = !1;
                      break;
                    }
                  for (D && (C[0][R[z]]++, C[C[0][R[z]]][R[z]] = R[j]), D = !0, A = 0, $ = C[0][R[z]]; A < $; A++)
                    if (R[L] == C[A + 1][R[z]]) {
                      D = !1;
                      break;
                    }
                  D && (C[0][R[z]]++, C[C[0][R[z]]][R[z]] = R[L]);
                }
                let O = 1, N = 0.5;
                for (S = 0; S < E; S++) {
                  for (b = 0, M = T.length; b < M; b++)
                    if (C[0][b] < 3)
                      _[b].x = T[b].x, _[b].y = T[b].y, _[b].z = T[b].z;
                    else if (C[0][b] == 3 || C[0][b] == 4) {
                      for (_[b].x = 0, _[b].y = 0, _[b].z = 0, A = 0, $ = C[0][b]; A < $; A++)
                        _[b].x += T[C[A + 1][b]].x, _[b].y += T[C[A + 1][b]].y, _[b].z += T[C[A + 1][b]].z;
                      _[b].x += N * T[b].x, _[b].y += N * T[b].y, _[b].z += N * T[b].z, _[b].x /= N + C[0][b], _[b].y /= N + C[0][b], _[b].z /= N + C[0][b];
                    } else {
                      for (_[b].x = 0, _[b].y = 0, _[b].z = 0, A = 0, $ = C[0][b]; A < $; A++)
                        _[b].x += T[C[A + 1][b]].x, _[b].y += T[C[A + 1][b]].y, _[b].z += T[C[A + 1][b]].z;
                      _[b].x += O * T[b].x, _[b].y += O * T[b].y, _[b].z += O * T[b].z, _[b].x /= O + C[0][b], _[b].y /= O + C[0][b], _[b].z /= O + C[0][b];
                    }
                  for (b = 0, M = T.length; b < M; b++)
                    T[b].x = _[b].x, T[b].y = _[b].y, T[b].z = _[b].z;
                }
              }
            }
            let p = new h();
            class v {
              constructor(E, T, R) {
                this.data = new Int32Array(E * T * R * 3), this.width = T, this.height = R;
              }
              // set position x,y,z to pt, which has ix,iy,and iz
              set(E, T, R, _) {
                let b = ((E * this.width + T) * this.height + R) * 3;
                this.data[b] = _.ix, this.data[b + 1] = _.iy, this.data[b + 2] = _.iz;
              }
              // return point at x,y,z
              get(E, T, R) {
                let _ = ((E * this.width + T) * this.height + R) * 3;
                return {
                  ix: this.data[_],
                  iy: this.data[_ + 1],
                  iz: this.data[_ + 2]
                };
              }
            }
            class g {
              constructor() {
                this.INOUT = 1, this.ISDONE = 2, this.ISBOUND = 4, this.ptranx = 0, this.ptrany = 0, this.ptranz = 0, this.probeRadius = 1.4, this.defaultScaleFactor = 2, this.scaleFactor = this.defaultScaleFactor, this.pHeight = 0, this.pWidth = 0, this.pLength = 0, this.cutRadius = 0, this.vpBits = null, this.vpDistance = null, this.vpAtomID = null, this.pminx = 0, this.pminy = 0, this.pminz = 0, this.pmaxx = 0, this.pmaxy = 0, this.pmaxz = 0, this.depty = {}, this.widxz = {}, this.faces = [], this.verts = [], this.vdwRadii = {
                  H: 1.2,
                  Li: 1.82,
                  Na: 2.27,
                  K: 2.75,
                  C: 1.7,
                  N: 1.55,
                  O: 1.52,
                  F: 1.47,
                  P: 1.8,
                  S: 1.8,
                  CL: 1.75,
                  BR: 1.85,
                  SE: 1.9,
                  ZN: 1.39,
                  CU: 1.4,
                  NI: 1.63,
                  X: 2
                }, this.nb = [
                  new Int32Array([1, 0, 0]),
                  new Int32Array([-1, 0, 0]),
                  new Int32Array([0, 1, 0]),
                  new Int32Array([0, -1, 0]),
                  new Int32Array([0, 0, 1]),
                  new Int32Array([0, 0, -1]),
                  new Int32Array([1, 1, 0]),
                  new Int32Array([1, -1, 0]),
                  new Int32Array([-1, 1, 0]),
                  new Int32Array([-1, -1, 0]),
                  new Int32Array([1, 0, 1]),
                  new Int32Array([1, 0, -1]),
                  new Int32Array([-1, 0, 1]),
                  new Int32Array([-1, 0, -1]),
                  new Int32Array([0, 1, 1]),
                  new Int32Array([0, 1, -1]),
                  new Int32Array([0, -1, 1]),
                  new Int32Array([0, -1, -1]),
                  new Int32Array([1, 1, 1]),
                  new Int32Array([1, 1, -1]),
                  new Int32Array([1, -1, 1]),
                  new Int32Array([-1, 1, 1]),
                  new Int32Array([1, -1, -1]),
                  new Int32Array([-1, -1, 1]),
                  new Int32Array([-1, 1, -1]),
                  new Int32Array([-1, -1, -1])
                ], g.MarchingCube || (g.MarchingCube = new h());
              }
              getVDWIndex(E) {
                return !E.elem || typeof this.vdwRadii[E.elem] > "u" ? "X" : E.elem;
              }
              getFacesAndVertices(E) {
                let T = {};
                for (let b = 0, M = E.length; b < M; b++)
                  T[E[b]] = !0;
                let R = this.verts;
                for (let b = 0, M = R.length; b < M; b++)
                  R[b].x = R[b].x / this.scaleFactor - this.ptranx, R[b].y = R[b].y / this.scaleFactor - this.ptrany, R[b].z = R[b].z / this.scaleFactor - this.ptranz;
                let _ = [];
                for (let b = 0, M = this.faces.length; b < M; b += 3) {
                  let A = this.faces[b], $ = this.faces[b + 1], S = this.faces[b + 2], C = R[A].atomid, D = R[$].atomid, O = R[S].atomid, N = C;
                  D < N && (N = D), O < N && (N = O), T[N] && A !== $ && $ !== S && A !== S && (_.push(A), _.push($), _.push(S));
                }
                return this.vpBits = null, this.vpDistance = null, this.vpAtomID = null, {
                  vertices: R,
                  faces: _
                };
              }
              initparm(E, T, R) {
                R > 1e6 && (this.scaleFactor = this.defaultScaleFactor / 2);
                let _ = 1 / this.scaleFactor * 5.5;
                this.pminx = E[0][0], this.pmaxx = E[1][0], this.pminy = E[0][1], this.pmaxy = E[1][1], this.pminz = E[0][2], this.pmaxz = E[1][2], T ? (this.pminx -= this.probeRadius + _, this.pminy -= this.probeRadius + _, this.pminz -= this.probeRadius + _, this.pmaxx += this.probeRadius + _, this.pmaxy += this.probeRadius + _, this.pmaxz += this.probeRadius + _) : (this.pminx -= _, this.pminy -= _, this.pminz -= _, this.pmaxx += _, this.pmaxy += _, this.pmaxz += _), this.pminx = Math.floor(this.pminx * this.scaleFactor) / this.scaleFactor, this.pminy = Math.floor(this.pminy * this.scaleFactor) / this.scaleFactor, this.pminz = Math.floor(this.pminz * this.scaleFactor) / this.scaleFactor, this.pmaxx = Math.ceil(this.pmaxx * this.scaleFactor) / this.scaleFactor, this.pmaxy = Math.ceil(this.pmaxy * this.scaleFactor) / this.scaleFactor, this.pmaxz = Math.ceil(this.pmaxz * this.scaleFactor) / this.scaleFactor, this.ptranx = -this.pminx, this.ptrany = -this.pminy, this.ptranz = -this.pminz, this.pLength = Math.ceil(this.scaleFactor * (this.pmaxx - this.pminx)) + 1, this.pWidth = Math.ceil(this.scaleFactor * (this.pmaxy - this.pminy)) + 1, this.pHeight = Math.ceil(this.scaleFactor * (this.pmaxz - this.pminz)) + 1, this.boundingatom(T), this.cutRadius = this.probeRadius * this.scaleFactor, this.vpBits = new Uint8Array(this.pLength * this.pWidth * this.pHeight), this.vpDistance = new Float64Array(this.pLength * this.pWidth * this.pHeight), this.vpAtomID = new Int32Array(this.pLength * this.pWidth * this.pHeight);
              }
              boundingatom(E) {
                let T = {};
                for (const R in this.vdwRadii) {
                  let _ = this.vdwRadii[R];
                  E ? T[R] = (_ + this.probeRadius) * this.scaleFactor + 0.5 : T[R] = _ * this.scaleFactor + 0.5;
                  let b = T[R] * T[R];
                  this.widxz[R] = Math.floor(T[R]) + 1, this.depty[R] = new Int32Array(this.widxz[R] * this.widxz[R]);
                  let M = 0;
                  for (let A = 0; A < this.widxz[R]; A++)
                    for (let $ = 0; $ < this.widxz[R]; $++) {
                      let S = A * A + $ * $;
                      if (S > b)
                        this.depty[R][M] = -1;
                      else {
                        let C = Math.sqrt(b - S);
                        this.depty[R][M] = Math.floor(C);
                      }
                      M++;
                    }
                }
              }
              fillvoxels(E, T) {
                for (let R = 0, _ = this.vpBits.length; R < _; R++)
                  this.vpBits[R] = 0, this.vpDistance[R] = -1, this.vpAtomID[R] = -1;
                for (let R in T) {
                  let _ = E[T[R]];
                  _ !== void 0 && this.fillAtom(_, E);
                }
                for (let R = 0, _ = this.vpBits.length; R < _; R++)
                  this.vpBits[R] & this.INOUT && (this.vpBits[R] |= this.ISDONE);
              }
              fillAtom(E, T) {
                let R = Math.floor(0.5 + this.scaleFactor * (E.x + this.ptranx)), _ = Math.floor(0.5 + this.scaleFactor * (E.y + this.ptrany)), b = Math.floor(0.5 + this.scaleFactor * (E.z + this.ptranz)), M = this.getVDWIndex(E), A = 0, $ = this.pWidth * this.pHeight;
                for (let S = 0, C = this.widxz[M]; S < C; S++)
                  for (let D = 0; D < C; D++) {
                    if (this.depty[M][A] != -1) {
                      for (let O = -1; O < 2; O++)
                        for (let N = -1; N < 2; N++)
                          for (let j = -1; j < 2; j++)
                            if (O !== 0 && N !== 0 && j !== 0) {
                              let L = O * S, z = j * D;
                              for (let G = 0; G <= this.depty[M][A]; G++) {
                                let B = G * N, F = R + L, H = _ + B, W = b + z;
                                if (F < 0 || H < 0 || W < 0 || F >= this.pLength || H >= this.pWidth || W >= this.pHeight)
                                  continue;
                                let V = F * $ + H * this.pHeight + W;
                                if (!(this.vpBits[V] & this.INOUT))
                                  this.vpBits[V] |= this.INOUT, this.vpAtomID[V] = E.serial;
                                else {
                                  let X = T[this.vpAtomID[V]];
                                  if (X.serial != E.serial) {
                                    let Z = R + L - Math.floor(0.5 + this.scaleFactor * (X.x + this.ptranx)), Q = _ + B - Math.floor(0.5 + this.scaleFactor * (X.y + this.ptrany)), q = b + z - Math.floor(0.5 + this.scaleFactor * (X.z + this.ptranz));
                                    L * L + B * B + z * z < Z * Z + Q * Q + q * q && (this.vpAtomID[V] = E.serial);
                                  }
                                }
                              }
                            }
                    }
                    A++;
                  }
              }
              fillvoxelswaals(E, T) {
                for (let R = 0, _ = this.vpBits.length; R < _; R++)
                  this.vpBits[R] &= ~this.ISDONE;
                for (let R in T) {
                  let _ = E[T[R]];
                  _ !== void 0 && this.fillAtomWaals(_, E);
                }
              }
              fillAtomWaals(E, T) {
                let R = 0, _ = Math.floor(0.5 + this.scaleFactor * (E.x + this.ptranx)), b = Math.floor(0.5 + this.scaleFactor * (E.y + this.ptrany)), M = Math.floor(0.5 + this.scaleFactor * (E.z + this.ptranz)), A = this.getVDWIndex(E), $ = this.pWidth * this.pHeight;
                for (let S = 0, C = this.widxz[A]; S < C; S++)
                  for (let D = 0; D < C; D++) {
                    if (this.depty[A][R] != -1) {
                      for (let O = -1; O < 2; O++)
                        for (let N = -1; N < 2; N++)
                          for (let j = -1; j < 2; j++)
                            if (O !== 0 && N !== 0 && j !== 0) {
                              let L = O * S, z = j * D;
                              for (let G = 0; G <= this.depty[A][R]; G++) {
                                let B = G * N, F = _ + L, H = b + B, W = M + z;
                                if (F < 0 || H < 0 || W < 0 || F >= this.pLength || H >= this.pWidth || W >= this.pHeight)
                                  continue;
                                let V = F * $ + H * this.pHeight + W;
                                if (!(this.vpBits[V] & this.ISDONE))
                                  this.vpBits[V] |= this.ISDONE, this.vpAtomID[V] = E.serial;
                                else {
                                  let X = T[this.vpAtomID[V]];
                                  if (X.serial != E.serial) {
                                    let Z = _ + L - Math.floor(0.5 + this.scaleFactor * (X.x + this.ptranx)), Q = b + B - Math.floor(0.5 + this.scaleFactor * (X.y + this.ptrany)), q = M + z - Math.floor(0.5 + this.scaleFactor * (X.z + this.ptranz));
                                    L * L + B * B + z * z < Z * Z + Q * Q + q * q && (this.vpAtomID[V] = E.serial);
                                  }
                                }
                              }
                            }
                    }
                    R++;
                  }
              }
              buildboundary() {
                let E = this.pWidth * this.pHeight;
                for (let T = 0; T < this.pLength; T++)
                  for (let R = 0; R < this.pHeight; R++)
                    for (let _ = 0; _ < this.pWidth; _++) {
                      let b = T * E + _ * this.pHeight + R;
                      if (this.vpBits[b] & this.INOUT) {
                        let M = 0;
                        for (; M < 26; ) {
                          let A = T + this.nb[M][0], $ = R + this.nb[M][2], S = _ + this.nb[M][1];
                          if (A > -1 && A < this.pLength && S > -1 && S < this.pWidth && $ > -1 && $ < this.pHeight && !(this.vpBits[A * E + S * this.pHeight + $] & this.INOUT)) {
                            this.vpBits[b] |= this.ISBOUND;
                            break;
                          } else
                            M++;
                        }
                      }
                    }
              }
              fastdistancemap() {
                let E = new v(this.pLength, this.pWidth, this.pHeight), T = this.pWidth * this.pHeight, R = this.cutRadius * this.cutRadius, _ = [], b = [], M;
                for (let S = 0; S < this.pLength; S++)
                  for (let C = 0; C < this.pWidth; C++)
                    for (let D = 0; D < this.pHeight; D++)
                      if (M = S * T + C * this.pHeight + D, this.vpBits[M] &= ~this.ISDONE, this.vpBits[M] & this.INOUT && this.vpBits[M] & this.ISBOUND) {
                        let O = {
                          ix: S,
                          iy: C,
                          iz: D
                        };
                        E.set(S, C, D, O), _.push(O), this.vpDistance[M] = 0, this.vpBits[M] |= this.ISDONE, this.vpBits[M] &= ~this.ISBOUND;
                      }
                do {
                  b = this.fastoneshell(_, E), _ = [];
                  for (let S = 0, C = b.length; S < C; S++)
                    M = T * b[S].ix + this.pHeight * b[S].iy + b[S].iz, this.vpBits[M] &= ~this.ISBOUND, this.vpDistance[M] <= 1.0404 * R && _.push({
                      ix: b[S].ix,
                      iy: b[S].iy,
                      iz: b[S].iz
                    });
                } while (_.length !== 0);
                _ = [], b = [], E = null;
                let A = this.scaleFactor - 0.5;
                A < 0 && (A = 0);
                let $ = R - 0.5 / (0.1 + A);
                for (let S = 0; S < this.pLength; S++)
                  for (let C = 0; C < this.pWidth; C++)
                    for (let D = 0; D < this.pHeight; D++)
                      M = S * T + C * this.pHeight + D, this.vpBits[M] &= ~this.ISBOUND, this.vpBits[M] & this.INOUT && (!(this.vpBits[M] & this.ISDONE) || this.vpBits[M] & this.ISDONE && this.vpDistance[M] >= $) && (this.vpBits[M] |= this.ISBOUND);
              }
              fastoneshell(E, T) {
                let R, _, b, M, A, $, S, C, D, O = [];
                if (E.length === 0)
                  return O;
                let N = {
                  ix: -1,
                  iy: -1,
                  iz: -1
                }, j = this.pWidth * this.pHeight;
                for (let L = 0, z = E.length; L < z; L++) {
                  R = E[L].ix, _ = E[L].iy, b = E[L].iz, C = T.get(R, _, b);
                  for (let G = 0; G < 6; G++)
                    N.ix = R + this.nb[G][0], N.iy = _ + this.nb[G][1], N.iz = b + this.nb[G][2], N.ix < this.pLength && N.ix > -1 && N.iy < this.pWidth && N.iy > -1 && N.iz < this.pHeight && N.iz > -1 && (D = N.ix * j + this.pHeight * N.iy + N.iz, this.vpBits[D] & this.INOUT && !(this.vpBits[D] & this.ISDONE) ? (T.set(N.ix, N.iy, b + this.nb[G][2], C), M = N.ix - C.ix, A = N.iy - C.iy, $ = N.iz - C.iz, S = M * M + A * A + $ * $, this.vpDistance[D] = S, this.vpBits[D] |= this.ISDONE, this.vpBits[D] |= this.ISBOUND, O.push({
                      ix: N.ix,
                      iy: N.iy,
                      iz: N.iz
                    })) : this.vpBits[D] & this.INOUT && this.vpBits[D] & this.ISDONE && (M = N.ix - C.ix, A = N.iy - C.iy, $ = N.iz - C.iz, S = M * M + A * A + $ * $, S < this.vpDistance[D] && (T.set(N.ix, N.iy, N.iz, C), this.vpDistance[D] = S, this.vpBits[D] & this.ISBOUND || (this.vpBits[D] |= this.ISBOUND, O.push({
                      ix: N.ix,
                      iy: N.iy,
                      iz: N.iz
                    })))));
                }
                for (let L = 0, z = E.length; L < z; L++) {
                  R = E[L].ix, _ = E[L].iy, b = E[L].iz, C = T.get(R, _, b);
                  for (let G = 6; G < 18; G++)
                    N.ix = R + this.nb[G][0], N.iy = _ + this.nb[G][1], N.iz = b + this.nb[G][2], N.ix < this.pLength && N.ix > -1 && N.iy < this.pWidth && N.iy > -1 && N.iz < this.pHeight && N.iz > -1 && (D = N.ix * j + this.pHeight * N.iy + N.iz, this.vpBits[D] & this.INOUT && !(this.vpBits[D] & this.ISDONE) ? (T.set(N.ix, N.iy, b + this.nb[G][2], C), M = N.ix - C.ix, A = N.iy - C.iy, $ = N.iz - C.iz, S = M * M + A * A + $ * $, this.vpDistance[D] = S, this.vpBits[D] |= this.ISDONE, this.vpBits[D] |= this.ISBOUND, O.push({
                      ix: N.ix,
                      iy: N.iy,
                      iz: N.iz
                    })) : this.vpBits[D] & this.INOUT && this.vpBits[D] & this.ISDONE && (M = N.ix - C.ix, A = N.iy - C.iy, $ = N.iz - C.iz, S = M * M + A * A + $ * $, S < this.vpDistance[D] && (T.set(N.ix, N.iy, N.iz, C), this.vpDistance[D] = S, this.vpBits[D] & this.ISBOUND || (this.vpBits[D] |= this.ISBOUND, O.push({
                      ix: N.ix,
                      iy: N.iy,
                      iz: N.iz
                    })))));
                }
                for (let L = 0, z = E.length; L < z; L++) {
                  R = E[L].ix, _ = E[L].iy, b = E[L].iz, C = T.get(R, _, b);
                  for (let G = 18; G < 26; G++)
                    N.ix = R + this.nb[G][0], N.iy = _ + this.nb[G][1], N.iz = b + this.nb[G][2], N.ix < this.pLength && N.ix > -1 && N.iy < this.pWidth && N.iy > -1 && N.iz < this.pHeight && N.iz > -1 && (D = N.ix * j + this.pHeight * N.iy + N.iz, this.vpBits[D] & this.INOUT && !(this.vpBits[D] & this.ISDONE) ? (T.set(N.ix, N.iy, b + this.nb[G][2], C), M = N.ix - C.ix, A = N.iy - C.iy, $ = N.iz - C.iz, S = M * M + A * A + $ * $, this.vpDistance[D] = S, this.vpBits[D] |= this.ISDONE, this.vpBits[D] |= this.ISBOUND, O.push({
                      ix: N.ix,
                      iy: N.iy,
                      iz: N.iz
                    })) : this.vpBits[D] & this.INOUT && this.vpBits[D] & this.ISDONE && (M = N.ix - C.ix, A = N.iy - C.iy, $ = N.iz - C.iz, S = M * M + A * A + $ * $, S < this.vpDistance[D] && (T.set(N.ix, N.iy, N.iz, C), this.vpDistance[D] = S, this.vpBits[D] & this.ISBOUND || (this.vpBits[D] |= this.ISBOUND, O.push({
                      ix: N.ix,
                      iy: N.iy,
                      iz: N.iz
                    })))));
                }
                return O;
              }
              marchingcubeinit(E) {
                for (let T = 0, R = this.vpBits.length; T < R; T++)
                  E == 1 ? this.vpBits[T] &= ~this.ISBOUND : E == 4 ? (this.vpBits[T] &= ~this.ISDONE, this.vpBits[T] & this.ISBOUND && (this.vpBits[T] |= this.ISDONE), this.vpBits[T] &= ~this.ISBOUND) : E == 2 ? this.vpBits[T] & this.ISBOUND && this.vpBits[T] & this.ISDONE ? this.vpBits[T] &= ~this.ISBOUND : this.vpBits[T] & this.ISBOUND && !(this.vpBits[T] & this.ISDONE) && (this.vpBits[T] |= this.ISDONE) : E == 3 && (this.vpBits[T] &= ~this.ISBOUND);
              }
              marchingcube(E) {
                this.marchingcubeinit(E), this.verts = [], this.faces = [], g.MarchingCube.march(this.vpBits, this.verts, this.faces, {
                  smooth: 1,
                  nX: this.pLength,
                  nY: this.pWidth,
                  nZ: this.pHeight
                });
                let T = this.pWidth * this.pHeight;
                for (let R = 0, _ = this.verts.length; R < _; R++)
                  this.verts[R].atomid = this.vpAtomID[this.verts[R].x * T + this.pHeight * this.verts[R].y + this.verts[R].z];
                g.MarchingCube.laplacianSmooth(1, this.verts, this.faces);
              }
            }
            g.MarchingCube = new h();
          }
        ),
        /***/
        "./src/VolumeData.ts": (
          /*!***************************!*\
            !*** ./src/VolumeData.ts ***!
            \***************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              VolumeData: () => (
                /* binding */
                p
              )
              /* harmony export */
            });
            var o = n(
              /*! ./utilities */
              "./src/utilities.ts"
            ), l = n(
              /*! ./WebGL/math */
              "./src/WebGL/math/index.ts"
            ), u = n(
              /*! ./parsers/VASP */
              "./src/parsers/VASP.ts"
            ), f = n(
              /*! ./parsers/CUBE */
              "./src/parsers/CUBE.ts"
            ), h = n(
              /*! pako */
              "./node_modules/pako/dist/pako.esm.mjs"
            );
            class p {
              constructor(g, w, E) {
                if (this.unit = {
                  x: 1,
                  y: 1,
                  z: 1
                }, this.origin = {
                  x: 0,
                  y: 0,
                  z: 0
                }, this.size = {
                  x: 0,
                  y: 0,
                  z: 0
                }, this.data = new Float32Array([]), this.matrix = null, this.inversematrix = null, this.isbinary = /* @__PURE__ */ new Set(["ccp4", "CCP4"]), this.getCoordinates = function(M) {
                  var A = M / (this.size.y * this.size.z), $ = M % (this.size.y * this.size.z), S = M % this.size.z;
                  return A *= this.unit.x, $ *= this.unit.y, S *= this.unit.z, A += this.origin.x, $ += this.origin.y, S += this.origin.z, { x: A, y: $, z: S };
                }, this.vasp = function(M) {
                  var A = M.replace(/^\s+/, "").split(/[\n\r]/), $ = (0, u.VASP)(M)[0], S = $.length;
                  if (S == 0) {
                    console.log("No good formating of CHG or CHGCAR file, not atomic information provided in the file."), this.data = [];
                    return;
                  }
                  var C = 1.889725992, D = 0.036749309, O = parseFloat(A[1]), N;
                  N = A[2].replace(/^\s+/, "").split(/\s+/);
                  var j = new l.Vector3(parseFloat(N[0]), parseFloat(N[1]), parseFloat(N[2])).multiplyScalar(O * C);
                  N = A[3].replace(/^\s+/, "").split(/\s+/);
                  var L = new l.Vector3(parseFloat(N[0]), parseFloat(N[1]), parseFloat(N[2])).multiplyScalar(O * C);
                  N = A[4].replace(/^\s+/, "").split(/\s+/);
                  var z = new l.Vector3(parseFloat(N[0]), parseFloat(N[1]), parseFloat(N[2])).multiplyScalar(O * C), G = j.x * (L.y * z.z - z.y * L.z) - L.x * (j.y * z.z - z.y * j.z) + z.x * (j.y * L.z - L.y * j.z);
                  G = Math.abs(G) / Math.pow(C, 3);
                  var B = 1 / G;
                  A.splice(0, 8 + S + 1);
                  var F = A[0].replace(/^\s+/, "").replace(/\s+/g, " ").split(" "), H = Math.abs(parseFloat(F[0])), W = Math.abs(parseFloat(F[1])), V = Math.abs(parseFloat(F[2])), X = this.origin = new l.Vector3(0, 0, 0);
                  this.size = { x: H, y: W, z: V }, this.unit = new l.Vector3(j.x, L.y, z.z), j = j.multiplyScalar(1 / (C * H)), L = L.multiplyScalar(1 / (C * W)), z = z.multiplyScalar(1 / (C * V)), (j.y != 0 || j.z != 0 || L.x != 0 || L.z != 0 || z.x != 0 || z.y != 0) && (this.matrix = new l.Matrix4(j.x, L.x, z.x, 0, j.y, L.y, z.y, 0, j.z, L.z, z.z, 0, 0, 0, 0, 1), this.matrix = this.matrix.multiplyMatrices(this.matrix, new l.Matrix4().makeTranslation(X.x, X.y, X.z)), this.origin = new l.Vector3(0, 0, 0), this.unit = new l.Vector3(1, 1, 1)), A.splice(0, 1);
                  var Z = A.join(" ");
                  Z = Z.replace(/^\s+/, "");
                  var Q = Z.split(/[\s\r]+/);
                  Q.splice(H * W * V + 1);
                  for (var q = Float32Array.from(Q, parseFloat), J = 0; J < q.length; J++)
                    q[J] = q[J] * B * D;
                  this.data = q;
                }, this.dx = function(M) {
                  var A = M.split(/[\n\r]+/), $, S = /gridpositions\s+counts\s+(\d+)\s+(\d+)\s+(\d+)/, C = /^origin\s+(\S+)\s+(\S+)\s+(\S+)/, D = /^delta\s+(\S+)\s+(\S+)\s+(\S+)/, O = /data follows/, N = 0;
                  for (N = 0; N < A.length; N++) {
                    var j = A[N];
                    if ($ = S.exec(j)) {
                      var L = parseInt($[1]), z = parseInt($[2]), G = parseInt($[3]);
                      this.size = { x: L, y: z, z: G };
                    } else if ($ = D.exec(j)) {
                      var B = parseFloat($[1]);
                      if ((parseFloat($[2]) != 0 || parseFloat($[3]) != 0) && console.log("Non-orthogonal delta matrix not currently supported in dx format"), N += 1, j = A[N], $ = D.exec(j), $ == null) {
                        console.log("Parse error in dx delta matrix");
                        return;
                      }
                      var F = parseFloat($[2]);
                      if ((parseFloat($[1]) != 0 || parseFloat($[3]) != 0) && console.log("Non-orthogonal delta matrix not currently supported in dx format"), N += 1, j = A[N], $ = D.exec(j), $ == null) {
                        console.log("Parse error in dx delta matrix");
                        return;
                      }
                      var H = parseFloat($[3]);
                      (parseFloat($[1]) != 0 || parseFloat($[2]) != 0) && console.log("Non-orthogonal delta matrix not currently supported in dx format"), this.unit = new l.Vector3(B, F, H);
                    } else if ($ = C.exec(j)) {
                      var W = parseFloat($[1]), V = parseFloat($[2]), X = parseFloat($[3]);
                      this.origin = new l.Vector3(W, V, X);
                    } else if ($ = O.exec(j))
                      break;
                  }
                  if (N += 1, !this.size || !this.origin || !this.unit || !this.size) {
                    console.log("Error parsing dx format");
                    return;
                  }
                  var Z = A.splice(N).join(" "), Q = Z.split(/[\s\r]+/);
                  this.data = Float32Array.from(Q, parseFloat);
                }, w = w.toLowerCase(), /\.gz$/.test(w)) {
                  w = w.replace(/\.gz$/, "");
                  try {
                    this[w] && this.isbinary.has(w) ? (typeof g == "string" && (g = (0, o.base64ToArray)(g)), g = (0, h.inflate)(g)) : g = new TextDecoder("utf-8").decode((0, h.inflate)(g));
                  } catch (M) {
                    console.log(M);
                  }
                }
                if (this[w] && (this.isbinary.has(w) && typeof g == "string" && (g = (0, o.base64ToArray)(g)), this[w](g)), E) {
                  if (E.negate)
                    for (let M = 0, A = this.data.length; M < A; M++)
                      this.data[M] = -this.data[M];
                  if (E.normalize) {
                    var T = 0;
                    for (let M = 0, A = this.data.length; M < A; M++)
                      T += this.data[M];
                    var R = T / this.data.length;
                    T = 0;
                    for (let M = 0, A = this.data.length; M < A; M++) {
                      var _ = this.data[M] - R;
                      T += _ * _;
                    }
                    var b = T / this.data.length;
                    for (let M = 0, A = this.data.length; M < A; M++)
                      this.data[M] = (this.data[M] - R) / b;
                  }
                }
              }
              /**
               * @function $3Dmol.VolumeData.getIndex
               * @param {number} x,y,z - the coordinates
               * @returns - index into flat array closest to provided coordinate; -1 if invalid
               */
              getIndex(g, w, E) {
                if (this.matrix) {
                  this.inversematrix == null && (this.inversematrix = new l.Matrix4().getInverse(this.matrix));
                  var T = new l.Vector3(g, w, E);
                  T = T.applyMatrix4(this.inversematrix), g = T.x, w = T.y, E = T.z;
                } else
                  g -= this.origin.x, w -= this.origin.y, E -= this.origin.z, g /= this.unit.x, w /= this.unit.y, E /= this.unit.z;
                return g = Math.round(g), w = Math.round(w), E = Math.round(E), g < 0 || g >= this.size.x || w < 0 || w >= this.size.y || E < 0 || E >= this.size.z ? -1 : g * this.size.y * this.size.z + w * this.size.z + E;
              }
              /**
               * @function $3Dmol.VolumeData.getVal
               * @param {number} x,y,z - the coordinates
               * @returns - value closest to provided coordinate; zero if coordinate invalid
               */
              getVal(g, w, E) {
                let T = this.getIndex(g, w, E);
                return T < 0 ? 0 : this.data[T];
              }
              // parse cube data
              cube(g) {
                var w = g.split(/\r?\n/);
                if (!(w.length < 6)) {
                  var E = (0, f.CUBE)(g, {}).modelData[0].cryst, T = w[2].replace(/^\s+/, "").replace(/\s+/g, " ").split(" "), R = parseFloat(T[0]), _ = Math.abs(R);
                  this.origin = E.origin, this.size = E.size, this.unit = E.unit, this.matrix = E.matrix4;
                  var b = 6;
                  R < 0 && b++;
                  var M = w.splice(_ + b).join(" ");
                  M = M.replace(/^\s+/, "");
                  var A = M.split(/[\s\r]+/);
                  this.data = Float32Array.from(A, parseFloat);
                }
              }
              //parse cp4 files
              ccp4(g) {
                var w = {};
                g = new Int8Array(g);
                var E = new Int32Array(g.buffer, 0, 56), T = new Float32Array(g.buffer, 0, 56), R = new DataView(g.buffer);
                if (w.MAP = String.fromCharCode(R.getUint8(208), R.getUint8(209), R.getUint8(210), R.getUint8(211)), w.MACHST = [R.getUint8(212), R.getUint8(213)], w.MACHST[0] === 17 && w.MACHST[1] === 17)
                  for (var _ = g.byteLength, b = 0; b < _; b += 4)
                    R.setFloat32(b, R.getFloat32(b), !0);
                w.NX = E[0], w.NY = E[1], w.NZ = E[2], w.MODE = E[3], w.NXSTART = E[4], w.NYSTART = E[5], w.NZSTART = E[6], w.MX = E[7], w.MY = E[8], w.MZ = E[9], w.xlen = T[10], w.ylen = T[11], w.zlen = T[12], w.alpha = T[13], w.beta = T[14], w.gamma = T[15], w.MAPC = E[16], w.MAPR = E[17], w.MAPS = E[18], w.DMIN = T[19], w.DMAX = T[20], w.DMEAN = T[21], w.ISPG = E[22], w.NSYMBT = E[23], w.LSKFLG = E[24], w.originX = T[49], w.originY = T[50], w.originZ = T[51], w.ARMS = T[54];
                var M = w, A = [
                  M.xlen,
                  0,
                  0
                ], $ = [
                  M.ylen * Math.cos(Math.PI / 180 * M.gamma),
                  M.ylen * Math.sin(Math.PI / 180 * M.gamma),
                  0
                ], S = [
                  M.zlen * Math.cos(Math.PI / 180 * M.beta),
                  M.zlen * (Math.cos(Math.PI / 180 * M.alpha) - Math.cos(Math.PI / 180 * M.gamma) * Math.cos(Math.PI / 180 * M.beta)) / Math.sin(Math.PI / 180 * M.gamma),
                  0
                ];
                S[2] = Math.sqrt(M.zlen * M.zlen * Math.sin(Math.PI / 180 * M.beta) * Math.sin(Math.PI / 180 * M.beta) - S[1] * S[1]);
                var C = [0, A, $, S], D = [0, M.MX, M.MY, M.MZ], O = [0, M.MAPC, M.MAPR, M.MAPS];
                this.matrix = new l.Matrix4(), this.matrix.set(C[O[1]][0] / D[O[1]], C[O[2]][0] / D[O[2]], C[O[3]][0] / D[O[3]], 0, C[O[1]][1] / D[O[1]], C[O[2]][1] / D[O[2]], C[O[3]][1] / D[O[3]], 0, C[O[1]][2] / D[O[1]], C[O[2]][2] / D[O[2]], C[O[3]][2] / D[O[3]], 0, 0, 0, 0, 1), this.matrix = this.matrix.multiplyMatrices(this.matrix, new l.Matrix4().makeTranslation(M.NXSTART + M.originX, M.NYSTART + M.originY, M.NZSTART + M.originZ)), this.origin = new l.Vector3(0, 0, 0), this.unit = new l.Vector3(1, 1, 1), this.size = { x: w.NX, y: w.NY, z: w.NZ }, this.dimensionorder = [w.MAPC, w.MAPR, w.MAPS];
                var N = new Float32Array(g.buffer, 1024 + w.NSYMBT), j = w.NX, L = w.NY, z = w.NZ;
                this.data = new Float32Array(j * L * z);
                for (let G = 0; G < j; G++)
                  for (let B = 0; B < L; B++)
                    for (let F = 0; F < z; F++)
                      this.data[(G * L + B) * z + F] = N[(F * L + B) * j + G];
              }
            }
          }
        ),
        /***/
        "./src/VolumetricRender.ts": (
          /*!*********************************!*\
            !*** ./src/VolumetricRender.ts ***!
            \*********************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              GLVolumetricRender: () => (
                /* binding */
                p
              )
              /* harmony export */
            });
            var o = n(
              /*! ./WebGL/shapes */
              "./src/WebGL/shapes/index.ts"
            ), l = n(
              /*! ./WebGL/math */
              "./src/WebGL/math/index.ts"
            ), u = n(
              /*! ./WebGL */
              "./src/WebGL/index.ts"
            ), f = n(
              /*! ./colors */
              "./src/colors.ts"
            ), h = n(
              /*! ./GLShape */
              "./src/GLShape.ts"
            );
            class p {
              static interpolateArray(g, w) {
                function E(S, C, D) {
                  return S + (C - S) * D;
                }
                var T = [], R = (g.length - 1) / (w - 1);
                T[0] = g[0];
                for (var _ = 1; _ < w - 1; _++) {
                  var b = _ * R, M = Math.floor(b), A = Math.ceil(b), $ = b - M;
                  T[_] = E(g[M], g[A], $);
                }
                return T[w - 1] = g[g.length - 1], T;
              }
              constructor(g, w) {
                this.hidden = !1, this.boundingSphere = new o.Sphere(), this.renderedShapeObj = null, this.shapeObj = null, this.subsamples = 5, this.data = null, this.transferfunctionbuffer = [], this.min = 0, this.max = 0, w = w || {};
                var E = Object.assign([], w.transferfn);
                this.subsamples = w.subsamples || 5;
                let T = 256;
                E.forEach(function(j) {
                  j.value = parseFloat(j.value);
                }), E.sort(function(j, L) {
                  return j.value - L.value;
                }), this.min = E[0].value, E.length == 0 && E.push(E[0]), this.max = E[E.length - 1].value;
                var R, _, b, M, A, $, S, C, D, O;
                for (let j = 0; j < E.length - 1; j++)
                  if (b = f.CC.color(E[j].color), M = f.CC.color(E[j + 1].color), D = E[j].opacity, O = E[j + 1].opacity, R = Math.floor((E[j].value - this.min) * T / (this.max - this.min)), _ = Math.floor((E[j + 1].value - this.min) * T / (this.max - this.min)), R != _) {
                    A = p.interpolateArray([b.r * 255, M.r * 255], _ - R), $ = p.interpolateArray([b.g * 255, M.g * 255], _ - R), S = p.interpolateArray([b.b * 255, M.b * 255], _ - R), C = p.interpolateArray([D * 255, O * 255], _ - R);
                    for (let L = 0; L < A.length; L++)
                      this.transferfunctionbuffer.push(A[L]), this.transferfunctionbuffer.push($[L]), this.transferfunctionbuffer.push(S[L]), this.transferfunctionbuffer.push(C[L]);
                  }
                if (this.transferfunctionbuffer = new Uint8ClampedArray(this.transferfunctionbuffer), g.matrix) {
                  let j = new l.Vector3(0, 0, 0), L = new l.Vector3(g.size.x, g.size.y, g.size.z), z = new l.Vector3(1, 1, 1);
                  j.applyMatrix4(g.matrix), L.applyMatrix4(g.matrix), z.applyMatrix4(g.matrix).sub(j), this.extent = [[j.x, j.y, j.z], [L.x, L.y, L.z]];
                  for (let H = 1; H < 7; H++)
                    L.x = H & 1 ? g.size.x : 0, L.y = H & 2 ? g.size.y : 0, L.z = H & 4 ? g.size.z : 0, L.applyMatrix4(g.matrix), this.extent[0][0] = Math.min(this.extent[0][0], L.x), this.extent[0][1] = Math.min(this.extent[0][1], L.y), this.extent[0][2] = Math.min(this.extent[0][2], L.z), this.extent[1][0] = Math.max(this.extent[1][0], L.x), this.extent[1][1] = Math.max(this.extent[1][1], L.y), this.extent[1][2] = Math.max(this.extent[1][2], L.z);
                  let G = L.x - j.x, B = L.y - j.y, F = L.z - j.z;
                  this.maxdepth = Math.sqrt(G * G + B * B + F * F), this.minunit = Math.min(Math.min(z.x, z.y), z.z), this.texmatrix = new l.Matrix4().identity().scale({ x: g.size.x, y: g.size.y, z: g.size.z }), this.texmatrix = this.texmatrix.multiplyMatrices(g.matrix, this.texmatrix), this.texmatrix = this.texmatrix.getInverse(this.texmatrix);
                } else {
                  this.texmatrix = new l.Matrix4().identity();
                  let j = g.unit.x * g.size.x, L = g.unit.y * g.size.y, z = g.unit.z * g.size.z;
                  this.texmatrix.makeTranslation(-g.origin.x / j, -g.origin.y / L, -g.origin.z / z), this.texmatrix.scale({ x: 1 / j, y: 1 / L, z: 1 / z }), this.minunit = Math.min(Math.min(g.unit.x, g.unit.y), g.unit.z), this.extent = [
                    [g.origin.x, g.origin.y, g.origin.z],
                    [g.origin.x + j, g.origin.y + L, g.origin.z + z]
                  ], this.maxdepth = Math.sqrt(j * j + L * L + z * z);
                }
                var N = new h.GLShape({});
                if (N.addBox({
                  corner: { x: this.extent[0][0], y: this.extent[0][1], z: this.extent[0][2] },
                  dimensions: {
                    w: this.extent[1][0] - this.extent[0][0],
                    h: this.extent[1][1] - this.extent[0][1],
                    d: this.extent[1][2] - this.extent[0][2]
                  }
                }), this.geo = N.finalize(), this.boundingSphere.center = new l.Vector3((this.extent[0][0] + this.extent[1][0]) / 2, (this.extent[0][1] + this.extent[1][1]) / 2, (this.extent[0][2] + this.extent[1][2]) / 2), this.boundingSphere.radius = this.maxdepth / 2, w.coords !== void 0 && w.seldist !== void 0) {
                  let j = new Uint8Array(g.data.length), L = w.seldist, z = L * L;
                  for (let G = 0, B = w.coords.length; G < B; G++) {
                    let F = w.coords[G], H = F.x - L, W = F.y - L, V = F.z - L, X = F.x + L, Z = F.y + L, Q = F.z + L;
                    if (g.getIndex(H, W, V) >= 0 || g.getIndex(X, Z, Q) >= 0)
                      for (let q = H; q < X; q += this.minunit)
                        for (let J = W; J < Z; J += this.minunit)
                          for (let ie = V; ie < Q; ie += this.minunit) {
                            let ne = g.getIndex(q, J, ie);
                            ne >= 0 && !j[ne] && (q - F.x) * (q - F.x) + (J - F.y) * (J - F.y) + (ie - F.z) * (ie - F.z) < z && (j[ne] = 1);
                          }
                  }
                  for (let G = 0, B = g.data.length; G < B; G++)
                    j[G] == 0 && (g.data[G] = 1 / 0);
                }
                this.data = g;
              }
              /**
               * Initialize webgl objects for rendering
               * @param {Object3D} group
               *
               */
              globj(g) {
                if (this.renderedShapeObj && (g.remove(this.renderedShapeObj), this.renderedShapeObj = null), !this.hidden) {
                  this.shapeObj = new u.Object3D();
                  var w = null, E = new u.Texture(this.data, !0), T = new u.Texture(this.transferfunctionbuffer, !1);
                  E.needsUpdate = !0, T.needsUpdate = !0, T.flipY = !1, w = new u.VolumetricMaterial({
                    transferfn: T,
                    transfermin: this.min,
                    transfermax: this.max,
                    map: E,
                    extent: this.extent,
                    maxdepth: this.maxdepth,
                    texmatrix: this.texmatrix,
                    unit: this.minunit,
                    subsamples: this.subsamples
                  });
                  var R = new u.Mesh(this.geo, w);
                  this.shapeObj.add(R), this.renderedShapeObj = this.shapeObj.clone(), g.add(this.renderedShapeObj);
                }
              }
              removegl(g) {
                this.renderedShapeObj && (this.renderedShapeObj.geometry !== void 0 && this.renderedShapeObj.geometry.dispose(), this.renderedShapeObj.material !== void 0 && this.renderedShapeObj.material.dispose(), g.remove(this.renderedShapeObj), this.renderedShapeObj = null), this.shapeObj = null;
              }
              get position() {
                return this.boundingSphere.center;
              }
              get x() {
                return this.boundingSphere.center.x;
              }
              get y() {
                return this.boundingSphere.center.y;
              }
              get z() {
                return this.boundingSphere.center.z;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/Camera.ts": (
          /*!*****************************!*\
            !*** ./src/WebGL/Camera.ts ***!
            \*****************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              Camera: () => (
                /* binding */
                u
              )
              /* harmony export */
            });
            var o = n(
              /*! ./core */
              "./src/WebGL/core/index.ts"
            ), l = n(
              /*! ./math */
              "./src/WebGL/math/index.ts"
            );
            class u extends o.Object3D {
              constructor(h = 50, p = 1, v = 0.1, g = 2e3, w = !1) {
                super(), this.projectionMatrix = new l.Matrix4(), this.projectionMatrixInverse = new l.Matrix4(), this.matrixWorldInverse = new l.Matrix4(), this.fov = h, this.aspect = p, this.near = v, this.far = g;
                var E = this.position.z;
                this.right = E * Math.tan(Math.PI / 180 * h), this.left = -this.right, this.top = this.right / this.aspect, this.bottom = -this.top, this.ortho = !!w, this.updateProjectionMatrix();
              }
              lookAt(h) {
                this.matrix.lookAt(this.position, h, this.up), this.rotationAutoUpdate && (this.useQuaternion === !1 && this.rotation instanceof l.Vector3 ? this.rotation.setEulerFromRotationMatrix(this.matrix, this.eulerOrder) : console.error("Unimplemented math operation."));
              }
              updateProjectionMatrix() {
                this.ortho ? this.projectionMatrix.makeOrthographic(this.left, this.right, this.top, this.bottom, this.near, this.far) : this.projectionMatrix.makePerspective(this.fov, this.aspect, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix);
              }
            }
          }
        ),
        /***/
        "./src/WebGL/Fog.ts": (
          /*!**************************!*\
            !*** ./src/WebGL/Fog.ts ***!
            \**************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              Fog: () => (
                /* binding */
                l
              )
              /* harmony export */
            });
            var o = n(
              /*! ../colors */
              "./src/colors.ts"
            );
            class l {
              constructor(f, h = 1, p = 1e3) {
                this.name = "", this.color = new o.Color(f), this.near = h, this.far = p;
              }
              clone() {
                return new l(this.color.getHex(), this.near, this.far);
              }
            }
          }
        ),
        /***/
        "./src/WebGL/Renderer.ts": (
          /*!*******************************!*\
            !*** ./src/WebGL/Renderer.ts ***!
            \*******************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              Renderer: () => (
                /* binding */
                T
              )
              /* harmony export */
            });
            var o = n(
              /*! ./Camera */
              "./src/WebGL/Camera.ts"
            ), l = n(
              /*! ./constants/Sides */
              "./src/WebGL/constants/Sides.ts"
            ), u = n(
              /*! ./constants/TextureConstants */
              "./src/WebGL/constants/TextureConstants.ts"
            ), f = n(
              /*! ./core */
              "./src/WebGL/core/index.ts"
            ), h = n(
              /*! ../colors */
              "./src/colors.ts"
            ), p = n(
              /*! ./materials */
              "./src/WebGL/materials/index.ts"
            ), v = n(
              /*! ./math */
              "./src/WebGL/math/index.ts"
            ), g = n(
              /*! ./objects */
              "./src/WebGL/objects/index.ts"
            ), w = n(
              /*! ./shaders */
              "./src/WebGL/shaders/index.ts"
            ), E = n(
              /*! ./SpritePlugin */
              "./src/WebGL/SpritePlugin.ts"
            );
            class T {
              constructor(_) {
                this.context = null, this.devicePixelRatio = 1, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.autoUpdateObjects = !0, this.autoUpdateScene = !0, this.info = {
                  memory: {
                    programs: 0,
                    geometries: 0,
                    textures: 0
                  },
                  render: {
                    calls: 0,
                    vertices: 0,
                    faces: 0,
                    points: 0
                  }
                }, this._programs = [], this._programs_counter = 0, this._webglversion = 1, this._currentProgram = null, this._currentMaterialId = -1, this._currentGeometryGroupHash = null, this._currentCamera = null, this._geometryGroupCounter = 0, this._oldDoubleSided = -1, this._oldFlipSided = -1, this._oldDepthTest = -1, this._oldDepthWrite = -1, this._oldPolygonOffset = null, this._oldLineWidth = null, this._viewportWidth = 0, this._viewportHeight = 0, this._currentWidth = 0, this._currentHeight = 0, this._enabledAttributes = {}, this._projScreenMatrix = new v.Matrix4(), this._vector3 = new v.Vector3(), this._worldInverse = new v.Matrix4(), this._projInverse = new v.Matrix4(), this._textureMatrix = new v.Matrix4(), this._direction = new v.Vector3(), this._lightsNeedUpdate = !0, this._lights = {
                  ambient: [0, 0, 0],
                  directional: {
                    length: 0,
                    colors: [],
                    positions: []
                  },
                  point: {
                    length: 0,
                    colors: [],
                    positions: [],
                    distances: []
                  },
                  spot: {
                    length: 0,
                    colors: [],
                    positions: [],
                    distances: [],
                    directions: [],
                    anglesCos: [],
                    exponents: []
                  },
                  hemi: {
                    length: 0,
                    skyColors: [],
                    groundColors: [],
                    positions: []
                  }
                }, this.sprites = new E.SpritePlugin(), this._screenshader = null, this._vertexattribpos = null, this._screenQuadVBO = null, this._fb = null, this._targetTexture = null, this._depthTexture = null, _ = _ || {}, this.row = _.row, this.col = _.col, this.rows = _.rows, this.cols = _.cols, this._canvas = _.canvas !== void 0 ? _.canvas : document.createElement("canvas"), this._precision = _.precision !== void 0 ? _.precision : "highp", this._alpha = _.alpha !== void 0 ? _.alpha : !0, this._premultipliedAlpha = _.premultipliedAlpha !== void 0 ? _.premultipliedAlpha : !0, this._antialias = _.antialias !== void 0 ? _.antialias : !1, this._stencil = _.stencil !== void 0 ? _.stencil : !0, this._preserveDrawingBuffer = _.preserveDrawingBuffer !== void 0 ? _.preserveDrawingBuffer : !1, this._clearColor = _.clearColor !== void 0 ? new h.Color(_.clearColor) : new h.Color(0), this._clearAlpha = _.clearAlpha !== void 0 ? _.clearAlpha : 0, this._outlineMaterial = new p.MeshOutlineMaterial(_.outline), this._outlineSphereImposterMaterial = new p.SphereImposterOutlineMaterial(_.outline), this._outlineStickImposterMaterial = new p.StickImposterOutlineMaterial(_.outline), this._outlineEnabled = !!_.outline, this.domElement = this._canvas, this._canvas.id = _.id, this.initGL(), this.setDefaultGLState(), this.context = this._gl, this.isWebGL1() ? this._extInstanced = this._gl.getExtension("ANGLE_instanced_arrays") : this._extInstanced = {
                  vertexAttribDivisorANGLE: this._gl.vertexAttribDivisor.bind(this._gl),
                  drawElementsInstancedANGLE: this._gl.drawElementsInstanced.bind(this._gl)
                }, this._extFragDepth = this._gl.getExtension("EXT_frag_depth"), this._extFloatLinear = this._gl.getExtension("OES_texture_float_linear"), this._extColorBufferFloat = this._gl.getExtension("EXT_color_buffer_float"), this.sprites.init(this);
              }
              // API
              supportedExtensions() {
                return {
                  supportsAIA: !!this._extInstanced,
                  supportsImposters: !!this._extFragDepth || !this.isWebGL1(),
                  regen: !1
                };
              }
              getContext() {
                return this._gl;
              }
              getCanvas() {
                return this._canvas;
              }
              isLost() {
                return this._gl.isContextLost();
              }
              getPrecision() {
                return this._precision;
              }
              setClearColorHex(_, b) {
                this._clearColor.setHex(_), this._clearAlpha = b, this._gl.clearColor(this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearAlpha);
              }
              enableOutline(_) {
                this._outlineMaterial = new p.MeshOutlineMaterial(_), this._outlineSphereImposterMaterial = new p.SphereImposterOutlineMaterial(_), this._outlineStickImposterMaterial = new p.StickImposterOutlineMaterial(_), this._outlineEnabled = !0;
              }
              disableOutline() {
                this._outlineEnabled = !1;
              }
              setViewport() {
                if (this.rows != null && this.cols != null && this.row != null && this.col != null) {
                  var _ = this._canvas.width / this.cols, b = this._canvas.height / this.rows;
                  this._viewportWidth = _, this._viewportHeight = b, this._gl.enable(this._gl.SCISSOR_TEST), this._gl.scissor(_ * this.col, b * this.row, _, b), this._gl.viewport(_ * this.col, b * this.row, _, b);
                }
              }
              setSize(_, b) {
                if (this.devicePixelRatio = window.devicePixelRatio !== void 0 ? window.devicePixelRatio : 1, this._antialias && this.devicePixelRatio < 2 && (this.devicePixelRatio *= 2), this.rows != null && this.cols != null && this.row != null && this.col != null) {
                  var M = _ / this.cols, A = b / this.rows;
                  this._canvas.width = _ * this.devicePixelRatio, this._canvas.height = b * this.devicePixelRatio, this._viewportWidth = M * this.devicePixelRatio, this._viewportHeight = A * this.devicePixelRatio, this._canvas.style.width = _ + "px", this._canvas.style.height = b + "px", this.setViewport();
                } else
                  this._viewportWidth = this._canvas.width = _ * this.devicePixelRatio, this._viewportHeight = this._canvas.height = b * this.devicePixelRatio, this._canvas.style.width = _ + "px", this._canvas.style.height = b + "px", this._gl.viewport(0, 0, this._gl.drawingBufferWidth, this._gl.drawingBufferHeight);
                this.initFrameBuffer();
              }
              clear(_, b, M) {
                var A = 0;
                (_ === void 0 || _) && (A |= this._gl.COLOR_BUFFER_BIT), (b === void 0 || b) && (A |= this._gl.DEPTH_BUFFER_BIT), (M === void 0 || M) && (A |= this._gl.STENCIL_BUFFER_BIT), this._gl.clear(A);
              }
              clearTarget(_, b, M) {
                this.clear(_, b, M);
              }
              setMaterialFaces(_, b) {
                var M = _.side === l.DoubleSide, A = _.side === l.BackSide;
                _.imposter || (A = b ? !A : A), this._oldDoubleSided !== M && (M ? this._gl.disable(this._gl.CULL_FACE) : this._gl.enable(this._gl.CULL_FACE), this._oldDoubleSided = M), this._oldFlipSided !== A && (A ? this._gl.frontFace(this._gl.CW) : this._gl.frontFace(this._gl.CCW), this._oldFlipSided = A), this._gl.cullFace(this._gl.BACK);
              }
              setDepthTest(_) {
                this._oldDepthTest !== _ && (_ ? this._gl.enable(this._gl.DEPTH_TEST) : this._gl.disable(this._gl.DEPTH_TEST), this._oldDepthTest = _);
              }
              setDepthWrite(_) {
                this._oldDepthWrite !== _ && (this._gl.depthMask(_), this._oldDepthWrite = _);
              }
              setBlending(_) {
                _ ? (this._gl.enable(this._gl.BLEND), this._gl.blendEquationSeparate(this._gl.FUNC_ADD, this._gl.FUNC_ADD), this._gl.blendFuncSeparate(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA)) : this._gl.disable(this._gl.BLEND);
              }
              // TODO: need to set up shader attributes and uniforms as attributes on
              // material object after attaching prgm
              // We need to attach appropriate uniform variables to material after shaders
              // have been chosen
              initMaterial(_, b, M, A) {
                _.addEventListener("dispose", this.onMaterialDispose.bind(this));
                var $, S;
                if (S = _.shaderID, S) {
                  var C = w.ShaderLib[S];
                  _.vertexShader = C.vertexShader, _.fragmentShader = C.fragmentShader, _.uniforms = w.ShaderUtils.clone(C.uniforms);
                }
                $ = {
                  wireframe: _.wireframe,
                  fragdepth: _.imposter,
                  volumetric: _.volumetric
                }, _.program = this.buildProgram(_.fragmentShader, _.vertexShader, _.uniforms, $);
              }
              renderBuffer(_, b, M, A, $, S) {
                if (A.visible) {
                  var C, D;
                  if (C = this.setProgram(_, b, M, A, S, this), !!C) {
                    D = C.attributes;
                    var O = !1, N = A.wireframe ? 1 : 0, j = $.id * 16777215 + C.id * 2 + N;
                    j !== this._currentGeometryGroupHash && (this._currentGeometryGroupHash = j, O = !0), O && (this.disableAttributes(), D.position >= 0 && (this._gl.bindBuffer(this._gl.ARRAY_BUFFER, $.__webglVertexBuffer), this.enableAttribute(D.position), this._gl.vertexAttribPointer(D.position, 3, this._gl.FLOAT, !1, 0, 0)), D.color >= 0 && (this._gl.bindBuffer(this._gl.ARRAY_BUFFER, $.__webglColorBuffer), this.enableAttribute(D.color), this._gl.vertexAttribPointer(D.color, 3, this._gl.FLOAT, !1, 0, 0)), D.normal >= 0 && (this._gl.bindBuffer(this._gl.ARRAY_BUFFER, $.__webglNormalBuffer), this.enableAttribute(D.normal), this._gl.vertexAttribPointer(D.normal, 3, this._gl.FLOAT, !1, 0, 0)), D.offset >= 0 && (this._gl.bindBuffer(this._gl.ARRAY_BUFFER, $.__webglOffsetBuffer), this.enableAttribute(D.offset), this._gl.vertexAttribPointer(D.offset, 3, this._gl.FLOAT, !1, 0, 0)), D.radius >= 0 && (this._gl.bindBuffer(this._gl.ARRAY_BUFFER, $.__webglRadiusBuffer), this.enableAttribute(D.radius), this._gl.vertexAttribPointer(D.radius, 1, this._gl.FLOAT, !1, 0, 0)));
                    var L, z;
                    if (S instanceof g.Mesh) {
                      if (A.shaderID === "instanced") {
                        var G = A.sphere.geometryGroups[0];
                        O && (this._gl.bindBuffer(this._gl.ARRAY_BUFFER, $.__webglVertexBuffer), this._gl.bufferData(this._gl.ARRAY_BUFFER, G.vertexArray, this._gl.STATIC_DRAW), this._gl.bindBuffer(this._gl.ARRAY_BUFFER, $.__webglNormalBuffer), this._gl.bufferData(this._gl.ARRAY_BUFFER, G.normalArray, this._gl.STATIC_DRAW), this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, $.__webglFaceBuffer), this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, G.faceArray, this._gl.STATIC_DRAW)), L = G.faceidx, this._extInstanced.vertexAttribDivisorANGLE(D.offset, 1), this._extInstanced.vertexAttribDivisorANGLE(D.radius, 1), this._extInstanced.vertexAttribDivisorANGLE(D.color, 1), this._extInstanced.drawElementsInstancedANGLE(this._gl.TRIANGLES, L, this._gl.UNSIGNED_SHORT, 0, $.radiusArray.length), this._extInstanced.vertexAttribDivisorANGLE(D.offset, 0), this._extInstanced.vertexAttribDivisorANGLE(D.radius, 0), this._extInstanced.vertexAttribDivisorANGLE(D.color, 0);
                      } else
                        A.wireframe ? (z = $.lineidx, this.setLineWidth(A.wireframeLinewidth), O && this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, $.__webglLineBuffer), this._gl.drawElements(this._gl.LINES, z, this._gl.UNSIGNED_SHORT, 0)) : (L = $.faceidx, O && this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, $.__webglFaceBuffer), this._gl.drawElements(this._gl.TRIANGLES, L, this._gl.UNSIGNED_SHORT, 0));
                      this.info.render.calls++, this.info.render.vertices += L, this.info.render.faces += L / 3;
                    } else
                      S instanceof g.Line && (z = $.vertices, this.setLineWidth(A.linewidth), this._gl.drawArrays(this._gl.LINES, 0, z), this.info.render.calls++);
                  }
                }
              }
              render(_, b, M) {
                if (!(b instanceof o.Camera)) {
                  console.error("Renderer.render: camera is not an instance of Camera.");
                  return;
                }
                var A, $, S, C, D, O = _.__lights, N = _.fog;
                this._currentMaterialId = -1, this._lightsNeedUpdate = !0, this.autoUpdateScene && _.updateMatrixWorld(), b.parent === void 0 && b.updateMatrixWorld(), b.matrixWorldInverse.getInverse(b.matrixWorld), this._projScreenMatrix.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse), this.autoUpdateObjects && this.initWebGLObjects(_), this.info.render.calls = 0, this.info.render.vertices = 0, this.info.render.faces = 0, this.info.render.points = 0, this._currentWidth = this._viewportWidth, this._currentHeight = this._viewportHeight, this.setViewport(), this.setFrameBuffer(), (this.autoClear || M) && (this._gl.clearColor(this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearAlpha), this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil)), D = _.__webglObjects;
                var j = !1;
                for (A = 0, $ = D.length; A < $; A++)
                  S = D[A], C = S.object, S.render = !1, C.visible && (this.setupMatrices(C, b), this.unrollBufferMaterial(S), S.render = !0, S.volumetric && (j = !0));
                var L = null;
                this.setBlending(!1), this.renderObjects(_.__webglObjects, !0, "opaque", b, O, N, !1, L), this.renderSprites(_, b, !1), this.renderObjects(_.__webglObjects, !0, "blank", b, O, N, !0, L), this.renderObjects(_.__webglObjects, !1, "transparent", b, O, N, !0, L), j && this._fb && (this.reinitFrameBuffer(), this.renderObjects(_.__webglObjects, !1, "volumetric", b, O, N, !0, L)), this.renderFrameBuffertoScreen(), this.setDepthTest(!0), this.setDepthWrite(!0), this.renderSprites(_, b, !0);
              }
              //reinitialize framebuffer without the depth texture attached so we can read to it
              //do not allocate new textures
              reinitFrameBuffer() {
                this.isWebGL1() || (this._fb = this._gl.createFramebuffer(), this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._fb), this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.COLOR_ATTACHMENT0, this._gl.TEXTURE_2D, this._targetTexture, 0));
              }
              //setup framebuffer for drawing into, assumes buffers already allocated
              setFrameBuffer() {
                if (this.isWebGL1() || !this._fb)
                  return;
                let _ = this._viewportWidth, b = this._viewportHeight;
                this._gl.enable(this._gl.SCISSOR_TEST), this._gl.scissor(0, 0, _, b), this._gl.viewport(0, 0, _, b), this._gl.bindTexture(this._gl.TEXTURE_2D, this._targetTexture), this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, _, b, 0, this._gl.RGBA, this._gl.UNSIGNED_BYTE, null), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.LINEAR), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.LINEAR), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE), this._gl.bindTexture(this._gl.TEXTURE_2D, this._depthTexture), this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.DEPTH_COMPONENT32F, _, b, 0, this._gl.DEPTH_COMPONENT, this._gl.FLOAT, null), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.NEAREST), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.NEAREST), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE), this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._fb), this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.COLOR_ATTACHMENT0, this._gl.TEXTURE_2D, this._targetTexture, 0), this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.DEPTH_ATTACHMENT, this._gl.TEXTURE_2D, this._depthTexture, 0);
              }
              //allocate buffers for framebuffer, needs to be called with every resize
              initFrameBuffer() {
                if (this.isWebGL1())
                  return;
                let _ = this._viewportWidth, b = this._viewportHeight;
                this._gl.enable(this._gl.SCISSOR_TEST), this._gl.scissor(0, 0, _, b), this._gl.viewport(0, 0, _, b), this._targetTexture = this._gl.createTexture(), this._depthTexture = this._gl.createTexture(), this._fb = this._gl.createFramebuffer();
                var M = w.ShaderLib.screen;
                this._screenshader = this.buildProgram(M.fragmentShader, M.vertexShader, M.uniforms, {}), this._vertexattribpos = this._gl.getAttribLocation(this._screenshader, "vertexPosition");
                var A = [
                  // First triangle:
                  1,
                  1,
                  -1,
                  1,
                  -1,
                  -1,
                  // Second triangle:
                  -1,
                  -1,
                  1,
                  -1,
                  1,
                  1
                ];
                this._screenQuadVBO = this._gl.createBuffer(), this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._screenQuadVBO), this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array(A), this._gl.STATIC_DRAW);
              }
              renderFrameBuffertoScreen() {
                this.isWebGL1() || this._fb === null || (this.setViewport(), this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, null), this._gl.clear(this._gl.COLOR_BUFFER_BIT | this._gl.DEPTH_BUFFER_BIT), this._gl.frontFace(this._gl.CCW), this._gl.cullFace(this._gl.BACK), this._gl.useProgram(this._screenshader), this._currentProgram = this._screenshader, this.setDepthTest(-1), this.setDepthWrite(-1), this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._screenQuadVBO), this._gl.enableVertexAttribArray(this._vertexattribpos), this._gl.vertexAttribPointer(this._vertexattribpos, 2, this._gl.FLOAT, !1, 0, 0), this._gl.activeTexture(this._gl.TEXTURE0), this._gl.bindTexture(this._gl.TEXTURE_2D, this._targetTexture), this._gl.drawArrays(this._gl.TRIANGLES, 0, 6));
              }
              initWebGLObjects(_) {
                if (_.__webglObjects || (_.__webglObjects = [], _.__webglObjectsImmediate = [], _.__webglSprites = [], _.__webglFlares = []), _.__objectsAdded.length) {
                  for (; _.__objectsAdded.length; )
                    this.addObject(_.__objectsAdded[0], _), _.__objectsAdded.splice(0, 1);
                  this._currentGeometryGroupHash = -1;
                }
                for (; _.__objectsRemoved.length; )
                  this.removeObject(_.__objectsRemoved[0], _), _.__objectsRemoved.splice(0, 1);
                for (var b = 0, M = _.__webglObjects.length; b < M; b++)
                  this.updateObject(_.__webglObjects[b].object);
              }
              getYRatio() {
                return this.rows !== void 0 && this.row !== void 0 ? this.rows : 1;
              }
              getXRatio() {
                return this.cols !== void 0 && this.col !== void 0 ? this.cols : 1;
              }
              getAspect(_, b) {
                (_ == null || b == null) && (_ = this._canvas.width, b = this._canvas.height);
                var M = _ / b;
                if (this.rows != null && this.cols != null && this.row != null && this.col != null) {
                  var A = _ / this.cols, $ = b / this.rows;
                  M = A / $;
                }
                return M;
              }
              setTexture(_, b, M) {
                if (_.needsUpdate) {
                  _.__webglInit || (_.__webglInit = !0, _.addEventListener("dispose", this.onTextureDispose.bind(this)), _.__webglTexture = this._gl.createTexture(), this.info.memory.textures++), this._gl.activeTexture(this._gl.TEXTURE0 + b);
                  var A = M ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D;
                  this._gl.bindTexture(A, _.__webglTexture), this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, _.flipY), this._gl.pixelStorei(this._gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, _.premultiplyAlpha), this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, _.unpackAlignment), this._gl.pixelStorei(this._gl.PACK_ALIGNMENT, _.unpackAlignment);
                  var $ = this.paramToGL(_.format), S = this.paramToGL(_.type);
                  if (M)
                    this.setTextureParameters(this._gl.TEXTURE_3D, _), this._gl.texImage3D(this._gl.TEXTURE_3D, 0, this._gl.R32F, _.image.size.z, _.image.size.y, _.image.size.x, 0, this._gl.RED, this._gl.FLOAT, _.image.data);
                  else {
                    var C = _.image, D = C.width, O = C.height;
                    typeof D > "u" && (D = C.length, $ == this._gl.RGBA && (D /= 4), O = 1), this.setTextureParameters(this._gl.TEXTURE_2D, _), this.isWebGL1() ? this._gl.texImage2D(this._gl.TEXTURE_2D, 0, $, $, S, _.image) : this._gl.texImage2D(this._gl.TEXTURE_2D, 0, $, D, O, 0, $, S, _.image);
                  }
                  _.needsUpdate = !1, _.onUpdate && _.onUpdate();
                } else
                  this._gl.activeTexture(this._gl.TEXTURE0 + b), M ? this._gl.bindTexture(this._gl.TEXTURE_3D, _.__webglTexture) : this._gl.bindTexture(this._gl.TEXTURE_2D, _.__webglTexture);
              }
              supportsVolumetric() {
                return !this.isWebGL1();
              }
              enableAttribute(_) {
                this._enabledAttributes[_] || (this._gl.enableVertexAttribArray(_), this._enabledAttributes[_] = !0);
              }
              disableAttributes() {
                for (let _ in this._enabledAttributes)
                  this._enabledAttributes[_] && (this._gl.disableVertexAttribArray(_), this._enabledAttributes[_] = !1);
              }
              setPolygonOffset(_, b, M) {
                this._oldPolygonOffset !== _ && (_ ? this._gl.enable(this._gl.POLYGON_OFFSET_FILL) : this._gl.disable(this._gl.POLYGON_OFFSET_FILL));
              }
              setLineWidth(_) {
                _ !== this._oldLineWidth && (this._gl.lineWidth(_), this._oldLineWidth = _);
              }
              deallocateGeometry(_) {
                if (_.__webglInit = void 0, _.__webglVertexBuffer !== void 0 && this._gl.deleteBuffer(_.__webglVertexBuffer), _.__webglColorBuffer !== void 0 && this._gl.deleteBuffer(_.__webglColorBuffer), _.geometryGroups !== void 0)
                  for (var b = 0, M = _.groups; b < M; b++) {
                    var A = _.geometryGroups[b];
                    A.__webglVertexBuffer !== void 0 && this._gl.deleteBuffer(A.__webglVertexBuffer), A.__webglColorBuffer !== void 0 && this._gl.deleteBuffer(A.__webglColorBuffer), A.__webglNormalBuffer !== void 0 && this._gl.deleteBuffer(A.__webglNormalBuffer), A.__webglFaceBuffer !== void 0 && this._gl.deleteBuffer(A.__webglFaceBuffer), A.__webglLineBuffer !== void 0 && this._gl.deleteBuffer(A.__webglLineBuffer);
                  }
              }
              deallocateMaterial(_) {
                var b = _.program;
                if (b !== void 0) {
                  _.program = void 0;
                  var M, A, $, S = !1;
                  for (M = 0, A = this._programs.length; M < A; M++)
                    if ($ = this._programs[M], $.program === b) {
                      $.usedTimes--, $.usedTimes === 0 && (S = !0);
                      break;
                    }
                  if (S === !0) {
                    var C = [];
                    for (M = 0, A = this._programs.length; M < A; M++)
                      $ = this._programs[M], $.program !== b && C.push($);
                    this._programs = C, this._gl.deleteProgram(b), this.info.memory.programs--;
                  }
                }
              }
              deallocateTexture(_) {
                if (_.image && _.image.__webglTextureCube)
                  this._gl.deleteTexture(_.image.__webglTextureCube);
                else {
                  if (!_.__webglInit)
                    return;
                  _.__webglInit = !1, this._gl.deleteTexture(_.__webglTexture);
                }
              }
              onGeometryDispose(_) {
                var b = _.target;
                b.removeEventListener("dispose", this.onGeometryDispose), this.deallocateGeometry(b), this.info.memory.geometries--;
              }
              onTextureDispose(_) {
                var b = _.target;
                b.removeEventListener("dispose", this.onTextureDispose), this.deallocateTexture(b), this.info.memory.textures--;
              }
              onMaterialDispose(_) {
                var b = _.target;
                b.removeEventListener("dispose", this.onMaterialDispose), this.deallocateMaterial(b);
              }
              // Compile and return shader
              getShader(_, b) {
                var M;
                return !this.isWebGL1() && !b.startsWith("#version") && (b = b.replace(/gl_FragDepthEXT/g, "gl_FragDepth"), _ == "fragment" ? b = b.replace(/varying/g, "in") : b = b.replace(/varying/g, "out"), b = b.replace(/attribute/g, "in"), b = b.replace(/texture2D/g, "texture"), b = b.replace(/\/\/DEFINEFRAGCOLOR/g, "out vec4 glFragColor;"), b = b.replace(/gl_FragColor/g, "glFragColor"), b = `#version 300 es
` + b), _ === "fragment" ? M = this._gl.createShader(this._gl.FRAGMENT_SHADER) : _ === "vertex" && (M = this._gl.createShader(this._gl.VERTEX_SHADER)), M == null ? null : (this._gl.shaderSource(M, b), this._gl.compileShader(M), this._gl.getShaderParameter(M, this._gl.COMPILE_STATUS) ? M : (console.error(this._gl.getShaderInfoLog(M)), console.error("could not initialize shader"), null));
              }
              // Compile appropriate shaders (if necessary) from source code and attach to
              // gl program.
              buildProgram(_, b, M, A) {
                var $, S, C, D, O = [];
                O.push(_), O.push(b);
                for ($ in A)
                  O.push($), O.push(A[$]);
                for (D = O.join(), $ = 0, S = this._programs.length; $ < S; $++) {
                  var N = this._programs[$];
                  if (N.code === D)
                    return N.usedTimes++, N.program;
                }
                if (this.isWebGL1() && A.volumetric)
                  throw new Error("Volumetric rendering requires webgl2 which is not supported by your hardware.");
                if (C = this._gl.createProgram(), C == null)
                  return null;
                var j = this._precision, L = "precision " + j + " float;", z = [
                  A.volumetric ? "#version 300 es" : "",
                  L
                ].join(`
`), G = [
                  A.volumetric ? "#version 300 es" : "",
                  A.fragdepth && this.isWebGL1() ? "#extension GL_EXT_frag_depth: enable" : "",
                  A.wireframe ? "#define WIREFRAME 1" : "",
                  L
                ].join(`
`), B = this.getShader("fragment", G + _), F = this.getShader("vertex", z + b);
                F != null && this._gl.attachShader(C, F), B != null && this._gl.attachShader(C, B), this._gl.linkProgram(C), this._gl.getProgramParameter(C, this._gl.LINK_STATUS) || console.error("Could not initialize shader"), C.uniforms = {}, C.attributes = {};
                var H, W, V;
                H = [
                  "viewMatrix",
                  "modelViewMatrix",
                  "projectionMatrix",
                  "normalMatrix"
                ];
                for (W in M)
                  H.push(W);
                for (V = 0; V < H.length; V++) {
                  var X = H[V];
                  C.uniforms[X] = this._gl.getUniformLocation(C, X);
                }
                for (H = [
                  "position",
                  "normal",
                  "color",
                  "lineDistance",
                  "offset",
                  "radius"
                ], V = 0; V < H.length; V++) {
                  var Z = H[V];
                  C.attributes[Z] = this._gl.getAttribLocation(C, Z);
                }
                return C.id = this._programs_counter++, this._programs.push({
                  program: C,
                  code: D,
                  usedTimes: 1
                }), this.info.memory.programs = this._programs.length, C;
              }
              setProgram(_, b, M, A, $, S) {
                if (A.needsUpdate && (A.program && this.deallocateMaterial(A), this.initMaterial(A, b, M, $), A.needsUpdate = !1), A.program == null)
                  return null;
                var C = !1, D = A.program, O = D.uniforms, N = A.uniforms;
                if (D != this._currentProgram && (this._gl.useProgram(D), this._currentProgram = D, C = !0), A.id != this._currentMaterialId && (this._currentMaterialId = A.id, C = !0), _ != this._currentCamera && (this._currentCamera = _, C = !0), this._gl.uniformMatrix4fv(O.projectionMatrix, !1, _.projectionMatrix.elements), this._gl.uniformMatrix4fv(O.modelViewMatrix, !1, $._modelViewMatrix.elements), this._gl.uniformMatrix3fv(O.normalMatrix, !1, $._normalMatrix.elements), C) {
                  if (N.fogColor.value = M.color, N.fogNear.value = M.near, N.fogFar.value = M.far, A.shaderID.startsWith("lambert") || A.shaderID === "instanced" || A.shaderID.endsWith("imposter"))
                    this._gl.uniformMatrix4fv(O.viewMatrix, !1, _.matrixWorldInverse.elements), this._lightsNeedUpdate && (this.setupLights(D, b), this._lightsNeedUpdate = !1), N.directionalLightColor.value = this._lights.directional.colors, N.directionalLightDirection.value = this._lights.directional.positions;
                  else if (A.shaderID.endsWith("outline"))
                    N.outlineColor.value = A.outlineColor, N.outlineWidth.value = A.outlineWidth, N.outlinePushback.value = A.outlinePushback;
                  else if (A.shaderID === "volumetric") {
                    $._modelViewMatrix.getScale(this._direction), this._worldInverse.getInverse($._modelViewMatrix), this._projInverse.getInverse(_.projectionMatrix), this._textureMatrix.multiplyMatrices($.material.texmatrix, this._worldInverse), this._gl.uniformMatrix4fv(O.textmat, !1, this._textureMatrix.elements), this._gl.uniformMatrix4fv(O.projinv, !1, this._projInverse.elements);
                    let j = Math.min(Math.min(this._direction.x, this._direction.y), this._direction.z);
                    N.step.value = $.material.unit * j, N.maxdepth.value = $.material.maxdepth * j, N.transfermax.value = $.material.transfermax, N.transfermin.value = $.material.transfermin, N.subsamples.value = $.material.subsamples, S.setTexture($.material.transferfn, 4, !1), S.setTexture($.material.map, 3, !0), this._gl.activeTexture(this._gl.TEXTURE5), this._gl.bindTexture(this._gl.TEXTURE_2D, this._depthTexture);
                  }
                  N.opacity.value = A.opacity, this.loadMaterialUniforms(O, N);
                }
                return D;
              }
              loadMaterialUniforms(_, b) {
                var M, A, $, S;
                for (M in b)
                  _[M] && (A = b[M].type, $ = b[M].value, S = _[M], A === "f" ? this._gl.uniform1f(S, $) : A === "i" ? this._gl.uniform1i(S, $) : A === "fv" ? this._gl.uniform3fv(S, $) : A === "c" ? this._gl.uniform3f(S, $.r, $.g, $.b) : A === "f4" && this._gl.uniform4f(S, $[0], $[1], $[2], $[3]));
              }
              // Objects adding
              addObject(_, b) {
                var M, A, $, S;
                if (!_.__webglInit && (_.__webglInit = !0, _._modelViewMatrix = new v.Matrix4(), _._normalMatrix = new v.Matrix3(), _.geometry !== void 0 && _.geometry.__webglInit === void 0 && (_.geometry.__webglInit = !0, _.geometry.addEventListener("dispose", this.onGeometryDispose.bind(this))), _ instanceof g.Mesh || _ instanceof g.Line))
                  for ($ = _.geometry, M = 0, A = $.geometryGroups.length; M < A; M++)
                    S = $.geometryGroups[M], S.id = this._geometryGroupCounter++, S.__webglVertexBuffer || (_ instanceof g.Mesh ? (this.createMeshBuffers(S), $.elementsNeedUpdate = !0, $.normalsNeedUpdate = !0) : _ instanceof g.Line && this.createLineBuffers(S), $.verticesNeedUpdate = !0, $.colorsNeedUpdate = !0);
                if (!_.__webglActive) {
                  if (_ instanceof g.Mesh || _ instanceof g.Line)
                    for ($ = _.geometry, M = 0, A = $.geometryGroups.length; M < A; M++)
                      S = $.geometryGroups[M], this.addBuffer(b.__webglObjects, S, _);
                  else
                    _ instanceof g.Sprite && b.__webglSprites.push(_);
                  _.__webglActive = !0;
                }
              }
              updateObject(_) {
                var b = _.geometry, M;
                if (_ instanceof g.Mesh || _ instanceof g.Line) {
                  for (var A = 0, $ = b.geometryGroups.length; A < $; A++)
                    M = b.geometryGroups[A], (b.verticesNeedUpdate || b.elementsNeedUpdate || b.colorsNeedUpdate || b.normalsNeedUpdate) && this.setBuffers(M, this._gl.STATIC_DRAW);
                  b.verticesNeedUpdate = !1, b.elementsNeedUpdate = !1, b.normalsNeedUpdate = !1, b.colorsNeedUpdate = !1, b.buffersNeedUpdate = !1;
                }
              }
              removeObject(_, b) {
                _ instanceof g.Mesh || _ instanceof g.Line ? this.removeInstances(b.__webglObjects, _) : _ instanceof g.Sprite && this.removeInstancesDirect(b.__webglSprites, _), _.__webglActive = !1;
              }
              removeInstances(_, b) {
                for (var M = _.length - 1; M >= 0; --M)
                  _[M].object === b && _.splice(M, 1);
              }
              removeInstancesDirect(_, b) {
                for (var M = _.length - 1; M >= 0; --M)
                  _[M] === b && _.splice(M, 1);
              }
              unrollBufferMaterial(_) {
                var b = _.object, M = b.material;
                if (M.volumetric)
                  _.opaque = null, _.transparent = null, _.volumetric = M;
                else if (M.transparent) {
                  if (_.opaque = null, _.volumetric = null, _.transparent = M, !M.wireframe) {
                    var A = M.clone();
                    A.opacity = 0, _.blank = A;
                  }
                } else
                  _.opaque = M, _.transparent = null, _.volumetric = null;
              }
              setBuffers(_, b) {
                var M = _.vertexArray, A = _.colorArray;
                if (_.__webglOffsetBuffer !== void 0 ? (this._gl.bindBuffer(this._gl.ARRAY_BUFFER, _.__webglOffsetBuffer), this._gl.bufferData(this._gl.ARRAY_BUFFER, M, b)) : (this._gl.bindBuffer(this._gl.ARRAY_BUFFER, _.__webglVertexBuffer), this._gl.bufferData(this._gl.ARRAY_BUFFER, M, b)), this._gl.bindBuffer(this._gl.ARRAY_BUFFER, _.__webglColorBuffer), this._gl.bufferData(this._gl.ARRAY_BUFFER, A, b), _.normalArray && _.__webglNormalBuffer !== void 0) {
                  var $ = _.normalArray;
                  this._gl.bindBuffer(this._gl.ARRAY_BUFFER, _.__webglNormalBuffer), this._gl.bufferData(this._gl.ARRAY_BUFFER, $, b);
                }
                if (_.radiusArray && _.__webglRadiusBuffer !== void 0 && (this._gl.bindBuffer(this._gl.ARRAY_BUFFER, _.__webglRadiusBuffer), this._gl.bufferData(this._gl.ARRAY_BUFFER, _.radiusArray, b)), _.faceArray && _.__webglFaceBuffer !== void 0) {
                  var S = _.faceArray;
                  this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, _.__webglFaceBuffer), this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, S, b);
                }
                if (_.lineArray && _.__webglLineBuffer !== void 0) {
                  var C = _.lineArray;
                  this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, _.__webglLineBuffer), this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, C, b);
                }
              }
              // Creates appropriate gl buffers for geometry chunk
              // TODO: do we need line buffer for mesh objects?
              // Also, can we integrate this with createLineBuffers?
              createMeshBuffers(_) {
                _.radiusArray && (_.__webglRadiusBuffer = this._gl.createBuffer()), _.useOffset && (_.__webglOffsetBuffer = this._gl.createBuffer()), _.__webglVertexBuffer = this._gl.createBuffer(), _.__webglNormalBuffer = this._gl.createBuffer(), _.__webglColorBuffer = this._gl.createBuffer(), _.__webglFaceBuffer = this._gl.createBuffer(), _.__webglLineBuffer = this._gl.createBuffer(), this.info.memory.geometries++;
              }
              createLineBuffers(_) {
                _.__webglVertexBuffer = this._gl.createBuffer(), _.__webglColorBuffer = this._gl.createBuffer(), this.info.memory.geometries++;
              }
              addBuffer(_, b, M) {
                _.push({
                  buffer: b,
                  object: M,
                  opaque: null,
                  transparent: null
                });
              }
              setupMatrices(_, b) {
                _._modelViewMatrix.multiplyMatrices(b.matrixWorldInverse, _.matrixWorld), _._normalMatrix.getInverse(_._modelViewMatrix), _._normalMatrix.transpose();
              }
              // Fallback filters for non-power-of-2 textures
              filterFallback(_) {
                return this._gl.LINEAR;
              }
              setTextureParameters(_, b) {
                _ == this._gl.TEXTURE_2D ? (this._gl.texParameteri(_, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE), this._gl.texParameteri(_, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE), this._gl.texParameteri(_, this._gl.TEXTURE_MAG_FILTER, this.filterFallback(b.magFilter)), this._gl.texParameteri(_, this._gl.TEXTURE_MIN_FILTER, this.filterFallback(b.minFilter))) : (this._gl.texParameteri(_, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE), this._gl.texParameteri(_, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE), this._gl.texParameteri(_, this._gl.TEXTURE_WRAP_R, this._gl.CLAMP_TO_EDGE), this._extColorBufferFloat && this._extFloatLinear ? (this._gl.texParameteri(_, this._gl.TEXTURE_MAG_FILTER, this._gl.LINEAR), this._gl.texParameteri(_, this._gl.TEXTURE_MIN_FILTER, this._gl.LINEAR)) : (this._gl.texParameteri(_, this._gl.TEXTURE_MAG_FILTER, this._gl.NEAREST), this._gl.texParameteri(_, this._gl.TEXTURE_MIN_FILTER, this._gl.NEAREST)));
              }
              // Map constants to WebGL constants
              paramToGL(_) {
                return _ === u.UnsignedByteType ? this._gl.UNSIGNED_BYTE : _ === u.RGBAFormat ? this._gl.RGBA : _ === u.NearestFilter ? this._gl.NEAREST : 0;
              }
              setupLights(_, b) {
                var M, A, $, S = 0, C = 0, D = 0, O, N, j = this._lights, L = j.directional.colors, z = j.directional.positions, G = 0, B = 0;
                for (M = 0, A = b.length; M < A; M++)
                  if ($ = b[M], O = $.color, N = $.intensity, $ instanceof f.Light) {
                    if (this._direction.getPositionFromMatrix($.matrixWorld), this._vector3.getPositionFromMatrix($.target.matrixWorld), this._direction.sub(this._vector3), this._direction.normalize(), this._direction.x === 0 && this._direction.y === 0 && this._direction.z === 0)
                      continue;
                    z[B] = this._direction.x, z[B + 1] = this._direction.y, z[B + 2] = this._direction.z, L[B] = O.r * N, L[B + 1] = O.g * N, L[B + 2] = O.b * N, B += 3, G++;
                  }
                j.ambient[0] = S, j.ambient[1] = C, j.ambient[2] = D, j.directional.length = G;
              }
              initGL() {
                try {
                  if (!(this._gl = this._canvas.getContext("webgl2", {
                    alpha: this._alpha,
                    premultipliedAlpha: this._premultipliedAlpha,
                    antialias: this._antialias,
                    stencil: this._stencil,
                    preserveDrawingBuffer: this._preserveDrawingBuffer
                  })) && !(this._gl = this._canvas.getContext("experimental-webgl", {
                    alpha: this._alpha,
                    premultipliedAlpha: this._premultipliedAlpha,
                    antialias: this._antialias,
                    stencil: this._stencil,
                    preserveDrawingBuffer: this._preserveDrawingBuffer
                  })) && !(this._gl = this._canvas.getContext("webgl", {
                    alpha: this._alpha,
                    premultipliedAlpha: this._premultipliedAlpha,
                    antialias: this._antialias,
                    stencil: this._stencil,
                    preserveDrawingBuffer: this._preserveDrawingBuffer
                  })))
                    throw "Error creating WebGL context.";
                  var _ = this._gl.getParameter(this._gl.VERSION);
                  this._webglversion = parseInt(_[6]);
                } catch (b) {
                  console.error(b);
                }
              }
              isWebGL1() {
                return this._webglversion == 1;
              }
              setDefaultGLState() {
                this._gl.clearColor(0, 0, 0, 1), this._gl.clearDepth(1), this._gl.clearStencil(0), this._gl.enable(this._gl.DEPTH_TEST), this._gl.depthFunc(this._gl.LEQUAL), this._gl.frontFace(this._gl.CCW), this._gl.cullFace(this._gl.BACK), this._gl.enable(this._gl.CULL_FACE), this._gl.enable(this._gl.BLEND), this._gl.blendEquation(this._gl.FUNC_ADD), this._gl.blendFunc(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA), this._gl.clearColor(this._clearColor.r, this._clearColor.g, this._clearColor.b, this._clearAlpha);
              }
              // rendering
              renderObjects(_, b, M, A, $, S, C, L) {
                var O, N, j, L, z, G, B;
                b ? (z = _.length - 1, G = -1, B = -1) : (z = 0, G = _.length, B = 1);
                for (var F = z; F !== G; F += B)
                  if (O = _[F], O.render) {
                    if (N = O.object, j = O.buffer, L = O[M], !L)
                      continue;
                    C && this.setBlending(!0), this.setDepthTest(L.depthTest), this.setDepthWrite(L.depthWrite), this.setPolygonOffset(L.polygonOffset, L.polygonOffsetFactor, L.polygonOffsetUnits);
                    var H = N._modelViewMatrix.isReflected();
                    this.setMaterialFaces(L, H), this.renderBuffer(A, $, S, L, j, N), (this._outlineEnabled || L.outline) && (L.shaderID == "sphereimposter" ? this.renderBuffer(A, $, S, this._outlineSphereImposterMaterial, j, N) : L.shaderID == "stickimposter" ? this.renderBuffer(A, $, S, this._outlineStickImposterMaterial, j, N) : !L.wireframe && L.shaderID !== "basic" && L.opacity !== 0 && this.renderBuffer(A, $, S, this._outlineMaterial, j, N));
                  }
              }
              renderSprites(_, b, M) {
                this._currentGeometryGroupHash = -1, this._currentProgram = null, this._currentCamera = null, this._oldDepthWrite = -1, this._oldDepthTest = -1, this._oldDoubleSided = -1, this._currentMaterialId = -1, this._oldFlipSided = -1, this._lightsNeedUpdate = !0, this.sprites.render(_, b, this._currentWidth, this._currentHeight, M), this._currentGeometryGroupHash = -1, this._currentProgram = null, this._currentCamera = null, this._oldDepthWrite = -1, this._oldDepthTest = -1, this._oldDoubleSided = -1, this._currentMaterialId = -1, this._oldFlipSided = -1;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/SpritePlugin.ts": (
          /*!***********************************!*\
            !*** ./src/WebGL/SpritePlugin.ts ***!
            \***********************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              SpritePlugin: () => (
                /* binding */
                l
              )
              /* harmony export */
            });
            var o = n(
              /*! ./shaders/index */
              "./src/WebGL/shaders/index.ts"
            );
            class l {
              constructor() {
                this.sprite = {
                  vertices: null,
                  faces: null,
                  vertexBuffer: null,
                  elementBuffer: null,
                  program: null,
                  attributes: {},
                  uniforms: null
                };
              }
              init(h) {
                this.gl = h.context, this.renderer = h, this.precision = h.getPrecision(), this.sprite.vertices = new Float32Array(16), this.sprite.faces = new Uint16Array(6);
                var p = 0;
                this.sprite.vertices[p++] = -1, this.sprite.vertices[p++] = -1, this.sprite.vertices[p++] = 0, this.sprite.vertices[p++] = 0, this.sprite.vertices[p++] = 1, this.sprite.vertices[p++] = -1, this.sprite.vertices[p++] = 1, this.sprite.vertices[p++] = 0, this.sprite.vertices[p++] = 1, this.sprite.vertices[p++] = 1, this.sprite.vertices[p++] = 1, this.sprite.vertices[p++] = 1, this.sprite.vertices[p++] = -1, this.sprite.vertices[p++] = 1, this.sprite.vertices[p++] = 0, this.sprite.vertices[p++] = 1, p = 0, this.sprite.faces[p++] = 0, this.sprite.faces[p++] = 1, this.sprite.faces[p++] = 2, this.sprite.faces[p++] = 0, this.sprite.faces[p++] = 2, this.sprite.faces[p++] = 3, this.sprite.vertexBuffer = this.gl.createBuffer(), this.sprite.elementBuffer = this.gl.createBuffer(), this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.sprite.vertexBuffer), this.gl.bufferData(this.gl.ARRAY_BUFFER, this.sprite.vertices, this.gl.STATIC_DRAW), this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.sprite.elementBuffer), this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, this.sprite.faces, this.gl.STATIC_DRAW), this.sprite.program = this.createProgram(
                  o.ShaderLib.sprite,
                  this.precision || 1
                  /** added default to single precision */
                ), this.sprite.attributes = {};
                const v = {};
                this.sprite.attributes.position = this.gl.getAttribLocation(this.sprite.program, "position"), this.sprite.attributes.uv = this.gl.getAttribLocation(this.sprite.program, "uv"), v.uvOffset = this.gl.getUniformLocation(this.sprite.program, "uvOffset"), v.uvScale = this.gl.getUniformLocation(this.sprite.program, "uvScale"), v.rotation = this.gl.getUniformLocation(this.sprite.program, "rotation"), v.scale = this.gl.getUniformLocation(this.sprite.program, "scale"), v.alignment = this.gl.getUniformLocation(this.sprite.program, "alignment"), v.color = this.gl.getUniformLocation(this.sprite.program, "color"), v.map = this.gl.getUniformLocation(this.sprite.program, "map"), v.opacity = this.gl.getUniformLocation(this.sprite.program, "opacity"), v.useScreenCoordinates = this.gl.getUniformLocation(this.sprite.program, "useScreenCoordinates"), v.screenPosition = this.gl.getUniformLocation(this.sprite.program, "screenPosition"), v.modelViewMatrix = this.gl.getUniformLocation(this.sprite.program, "modelViewMatrix"), v.projectionMatrix = this.gl.getUniformLocation(this.sprite.program, "projectionMatrix"), v.fogType = this.gl.getUniformLocation(this.sprite.program, "fogType"), v.fogDensity = this.gl.getUniformLocation(this.sprite.program, "fogDensity"), v.fogNear = this.gl.getUniformLocation(this.sprite.program, "fogNear"), v.fogFar = this.gl.getUniformLocation(this.sprite.program, "fogFar"), v.fogColor = this.gl.getUniformLocation(this.sprite.program, "fogColor"), v.alphaTest = this.gl.getUniformLocation(this.sprite.program, "alphaTest"), this.sprite.uniforms = v;
              }
              render(h, p, v, g, w) {
                var E, T, R, _, b, M, A, $, S, C;
                if (!this.gl)
                  throw new Error("WebGLRenderer not initialized");
                let D = [];
                (E = h == null ? void 0 : h.__webglSprites) === null || E === void 0 || E.forEach((ie) => {
                  (w && ie.material.depthTest == !1 || !w && ie.material.depthTest) && D.push(ie);
                });
                let O = D.length;
                if (!O)
                  return;
                const N = this.sprite.attributes, j = this.sprite.uniforms;
                if (!j)
                  throw new Error("Uniforms not defined");
                var L = v * 0.5, z = g * 0.5;
                this.gl.useProgram(this.sprite.program), this.gl.enableVertexAttribArray(N.position), this.gl.enableVertexAttribArray(N.uv), this.gl.disable(this.gl.CULL_FACE), this.gl.enable(this.gl.BLEND), this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.sprite.vertexBuffer), this.gl.vertexAttribPointer(N.position, 2, this.gl.FLOAT, !1, 16, 0), this.gl.vertexAttribPointer(N.uv, 2, this.gl.FLOAT, !1, 16, 8), this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.sprite.elementBuffer), this.gl.uniformMatrix4fv(j.projectionMatrix, !1, p.projectionMatrix.elements), this.gl.activeTexture(this.gl.TEXTURE0), this.gl.uniform1i(j.map, 0);
                var G = 0, B = 0, F = h.fog;
                F ? (this.gl.uniform3f(j.fogColor, F.color.r, F.color.g, F.color.b), this.gl.uniform1f(j.fogNear, F.near), this.gl.uniform1f(j.fogFar, F.far), this.gl.uniform1i(j.fogType, 1), G = 1, B = 1) : (this.gl.uniform1i(j.fogType, 0), G = 0, B = 0);
                var H;
                let W, V, X, Z, Q = [];
                for (H = 0; H < O; H++)
                  W = D[H], V = W.material, V && (V.depthTest == !1 && !w || !W.visible || V.opacity === 0 || (V.useScreenCoordinates ? W.z = -W.position.z : (W._modelViewMatrix.multiplyMatrices(p.matrixWorldInverse, W.matrixWorld), W.z = -W._modelViewMatrix.elements[14])));
                for (D.sort(u), H = 0; H < O; H++)
                  if (W = D[H], V = W.material, !!V && !(!W.visible || V.opacity === 0) && V.map && V.map.image && V.map.image.width) {
                    this.gl.uniform1f((j == null ? void 0 : j.alphaTest) || null, V.alphaTest);
                    var q = V.map.image.width, J = V.map.image.height;
                    Q[0] = q * this.renderer.devicePixelRatio / v, Q[1] = J * this.renderer.devicePixelRatio / g, V.useScreenCoordinates === !0 ? (this.gl.uniform1i(j.useScreenCoordinates, 1), this.gl.uniform3f(j.screenPosition, (W.position.x * this.renderer.devicePixelRatio - L) / L, (z - W.position.y * this.renderer.devicePixelRatio) / z, Math.max(0, Math.min(1, W.position.z)))) : (this.gl.uniform1i(j.useScreenCoordinates, 0), this.gl.uniformMatrix4fv(j.modelViewMatrix, !1, W._modelViewMatrix.elements)), h.fog && V.fog ? Z = B : Z = 0, G !== Z && (this.gl.uniform1i(j.fogType, Z), G = Z), X = 1 / (V.scaleByViewport ? g : 1), Q[0] *= X * W.scale.x, Q[1] *= X * W.scale.y;
                    let ie = (T = V == null ? void 0 : V.alignment) === null || T === void 0 ? void 0 : T.x, ne = (R = V == null ? void 0 : V.alignment) === null || R === void 0 ? void 0 : R.y;
                    V.screenOffset && (ie = (ie || 0) + 2 * V.screenOffset.x / q, ne = (ne || 0) + 2 * V.screenOffset.y / J), this.gl.uniform2f(j.uvScale, ((_ = V == null ? void 0 : V.uvScale) === null || _ === void 0 ? void 0 : _.x) || 1, ((b = V == null ? void 0 : V.uvScale) === null || b === void 0 ? void 0 : b.y) || 1), this.gl.uniform2f(j.uvOffset, ((M = V == null ? void 0 : V.uvOffset) === null || M === void 0 ? void 0 : M.x) || 0, ((A = V == null ? void 0 : V.uvOffset) === null || A === void 0 ? void 0 : A.y) || 0), this.gl.uniform2f(j.alignment, ie || 0, ne || 0), this.gl.uniform1f(j.opacity, V.opacity), this.gl.uniform3f(j.color, (($ = V == null ? void 0 : V.color) === null || $ === void 0 ? void 0 : $.r) || 0, ((S = V == null ? void 0 : V.color) === null || S === void 0 ? void 0 : S.g) || 0, ((C = V == null ? void 0 : V.color) === null || C === void 0 ? void 0 : C.b) || 0), this.gl.uniform1f(j.rotation, W.rotation), this.gl.uniform2fv(j.scale, Q), this.renderer.setDepthTest(V.depthTest), this.renderer.setDepthWrite(V.depthWrite), this.renderer.setTexture(V.map, 0), this.gl.drawElements(this.gl.TRIANGLES, 6, this.gl.UNSIGNED_SHORT, 0);
                  }
                this.gl.enable(this.gl.CULL_FACE);
              }
              createProgram(h, p) {
                if (!this.gl)
                  throw new Error("WebGL Rendering context not found");
                var v = this.gl.createProgram();
                if (!v)
                  throw new Error("Error creating webgl program");
                var g = this.gl.createShader(this.gl.FRAGMENT_SHADER), w = this.gl.createShader(this.gl.VERTEX_SHADER);
                if (!g)
                  throw new Error("Unable to create fragment shader SpritePlugin.createProgram");
                if (!w)
                  throw new Error("Unable to create vertex shader SpritePlugin.createProgram");
                var E = "precision " + p + ` float;
`;
                if (this.gl.shaderSource(g, E + h.fragmentShader), this.gl.shaderSource(w, E + h.vertexShader), this.gl.compileShader(g), this.gl.compileShader(w), !this.gl.getShaderParameter(g, this.gl.COMPILE_STATUS) || !this.gl.getShaderParameter(w, this.gl.COMPILE_STATUS))
                  throw new Error(`Error compiling shader: 
      ${this.gl.getShaderInfoLog(g)} 
      ${this.gl.getShaderInfoLog(w)}`);
                return this.gl.attachShader(v, g), this.gl.attachShader(v, w), this.gl.linkProgram(v), this.gl.getProgramParameter(v, this.gl.LINK_STATUS) || console.error("Could not initialize shader"), v;
              }
            }
            function u(f, h) {
              return f.z !== h.z ? h.z - f.z : h.id - f.id;
            }
          }
        ),
        /***/
        "./src/WebGL/constants/Coloring.ts": (
          /*!*****************************************!*\
            !*** ./src/WebGL/constants/Coloring.ts ***!
            \*****************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              Coloring: () => (
                /* binding */
                o
              )
              /* harmony export */
            });
            var o;
            (function(l) {
              l[l.NoColors = 0] = "NoColors", l[l.FaceColors = 1] = "FaceColors", l[l.VertexColors = 2] = "VertexColors";
            })(o || (o = {}));
          }
        ),
        /***/
        "./src/WebGL/constants/Shading.ts": (
          /*!****************************************!*\
            !*** ./src/WebGL/constants/Shading.ts ***!
            \****************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              Shading: () => (
                /* binding */
                o
              )
              /* harmony export */
            });
            var o;
            (function(l) {
              l[l.NoShading = 0] = "NoShading", l[l.FlatShading = 1] = "FlatShading", l[l.SmoothShading = 2] = "SmoothShading";
            })(o || (o = {}));
          }
        ),
        /***/
        "./src/WebGL/constants/Sides.ts": (
          /*!**************************************!*\
            !*** ./src/WebGL/constants/Sides.ts ***!
            \**************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              BackSide: () => (
                /* binding */
                l
              ),
              /* harmony export */
              DoubleSide: () => (
                /* binding */
                u
              ),
              /* harmony export */
              FrontSide: () => (
                /* binding */
                o
              )
              /* harmony export */
            });
            const o = 0, l = 1, u = 2;
          }
        ),
        /***/
        "./src/WebGL/constants/SpriteAlignment.ts": (
          /*!************************************************!*\
            !*** ./src/WebGL/constants/SpriteAlignment.ts ***!
            \************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              SpriteAlignment: () => (
                /* binding */
                l
              )
              /* harmony export */
            });
            var o = n(
              /*! ../math */
              "./src/WebGL/math/index.ts"
            );
            const l = {
              topLeft: new o.Vector2(1, -1),
              topCenter: new o.Vector2(0, -1),
              topRight: new o.Vector2(-1, -1),
              centerLeft: new o.Vector2(1, 0),
              center: new o.Vector2(0, 0),
              centerRight: new o.Vector2(-1, 0),
              bottomLeft: new o.Vector2(1, 1),
              bottomCenter: new o.Vector2(0, 1),
              bottomRight: new o.Vector2(-1, 1)
            };
          }
        ),
        /***/
        "./src/WebGL/constants/TextureConstants.ts": (
          /*!*************************************************!*\
            !*** ./src/WebGL/constants/TextureConstants.ts ***!
            \*************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              ClampToEdgeWrapping: () => (
                /* binding */
                o
              ),
              /* harmony export */
              FloatType: () => (
                /* binding */
                p
              ),
              /* harmony export */
              LinearFilter: () => (
                /* binding */
                l
              ),
              /* harmony export */
              LinearMipMapLinearFilter: () => (
                /* binding */
                f
              ),
              /* harmony export */
              NearestFilter: () => (
                /* binding */
                u
              ),
              /* harmony export */
              R32Format: () => (
                /* binding */
                w
              ),
              /* harmony export */
              RFormat: () => (
                /* binding */
                g
              ),
              /* harmony export */
              RGBAFormat: () => (
                /* binding */
                v
              ),
              /* harmony export */
              UnsignedByteType: () => (
                /* binding */
                h
              )
              /* harmony export */
            });
            const o = 1001, l = 1006, u = 1007, f = 1008, h = 1009, p = 1010, v = 1021, g = 1022, w = 1023;
          }
        ),
        /***/
        "./src/WebGL/constants/TextureOperations.ts": (
          /*!**************************************************!*\
            !*** ./src/WebGL/constants/TextureOperations.ts ***!
            \**************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              TextureOperations: () => (
                /* binding */
                o
              )
              /* harmony export */
            });
            var o;
            (function(l) {
              l[l.MultiplyOperation = 0] = "MultiplyOperation", l[l.MixOperation = 1] = "MixOperation", l[l.AddOperation = 2] = "AddOperation";
            })(o || (o = {}));
          }
        ),
        /***/
        "./src/WebGL/constants/index.ts": (
          /*!**************************************!*\
            !*** ./src/WebGL/constants/index.ts ***!
            \**************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              BackSide: () => (
                /* reexport safe */
                l.BackSide
              ),
              /* harmony export */
              ClampToEdgeWrapping: () => (
                /* reexport safe */
                h.ClampToEdgeWrapping
              ),
              /* harmony export */
              Coloring: () => (
                /* reexport safe */
                o.Coloring
              ),
              /* harmony export */
              DoubleSide: () => (
                /* reexport safe */
                l.DoubleSide
              ),
              /* harmony export */
              FloatType: () => (
                /* reexport safe */
                h.FloatType
              ),
              /* harmony export */
              FrontSide: () => (
                /* reexport safe */
                l.FrontSide
              ),
              /* harmony export */
              LinearFilter: () => (
                /* reexport safe */
                h.LinearFilter
              ),
              /* harmony export */
              LinearMipMapLinearFilter: () => (
                /* reexport safe */
                h.LinearMipMapLinearFilter
              ),
              /* harmony export */
              NearestFilter: () => (
                /* reexport safe */
                h.NearestFilter
              ),
              /* harmony export */
              R32Format: () => (
                /* reexport safe */
                h.R32Format
              ),
              /* harmony export */
              RFormat: () => (
                /* reexport safe */
                h.RFormat
              ),
              /* harmony export */
              RGBAFormat: () => (
                /* reexport safe */
                h.RGBAFormat
              ),
              /* harmony export */
              Shading: () => (
                /* reexport safe */
                u.Shading
              ),
              /* harmony export */
              SpriteAlignment: () => (
                /* reexport safe */
                f.SpriteAlignment
              ),
              /* harmony export */
              TextureOperations: () => (
                /* reexport safe */
                p.TextureOperations
              ),
              /* harmony export */
              UnsignedByteType: () => (
                /* reexport safe */
                h.UnsignedByteType
              )
              /* harmony export */
            });
            var o = n(
              /*! ./Coloring */
              "./src/WebGL/constants/Coloring.ts"
            ), l = n(
              /*! ./Sides */
              "./src/WebGL/constants/Sides.ts"
            ), u = n(
              /*! ./Shading */
              "./src/WebGL/constants/Shading.ts"
            ), f = n(
              /*! ./SpriteAlignment */
              "./src/WebGL/constants/SpriteAlignment.ts"
            ), h = n(
              /*! ./TextureConstants */
              "./src/WebGL/constants/TextureConstants.ts"
            ), p = n(
              /*! ./TextureOperations */
              "./src/WebGL/constants/TextureOperations.ts"
            );
          }
        ),
        /***/
        "./src/WebGL/core/EventDispatcher.ts": (
          /*!*******************************************!*\
            !*** ./src/WebGL/core/EventDispatcher.ts ***!
            \*******************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              EventDispatcher: () => (
                /* binding */
                o
              )
              /* harmony export */
            });
            class o {
              constructor() {
                this.listeners = {};
              }
              dispatchEvent(u) {
                var f = this.listeners[u.type];
                if (f !== void 0) {
                  u.target = this;
                  for (var h = 0, p = f.length; h < p; h++)
                    f[h].call(this, u);
                }
              }
              removeEventListener(u, f) {
                if (!f)
                  this.listeners[u] = [];
                else {
                  var h = this.listeners[u].indexOf(f);
                  h !== -1 && this.listeners[u].splice(h, 1);
                }
              }
              addEventListener(u, f) {
                this.listeners[u] === void 0 && (this.listeners[u] = []), this.listeners[u].indexOf(f) === -1 && this.listeners[u].push(f);
              }
            }
          }
        ),
        /***/
        "./src/WebGL/core/Geometry.ts": (
          /*!************************************!*\
            !*** ./src/WebGL/core/Geometry.ts ***!
            \************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              Geometry: () => (
                /* binding */
                v
              ),
              /* harmony export */
              GeometryGroup: () => (
                /* binding */
                p
              ),
              /* harmony export */
              GeometryIDCount: () => (
                /* binding */
                g
              )
              /* harmony export */
            });
            var o = n(
              /*! ../materials/LineBasicMaterial */
              "./src/WebGL/materials/LineBasicMaterial.ts"
            ), l = n(
              /*! ./EventDispatcher */
              "./src/WebGL/core/EventDispatcher.ts"
            ), u = n(
              /*! ../math */
              "./src/WebGL/math/index.ts"
            ), f = n(
              /*! ../../colors */
              "./src/colors.ts"
            );
            const h = 65535;
            class p {
              constructor(E = 0) {
                this.vertexArray = null, this.colorArray = null, this.normalArray = null, this.radiusArray = null, this.faceArray = null, this.lineArray = null, this.vertices = 0, this.faceidx = 0, this.lineidx = 0, this.__inittedArrays = !1, this.id = E;
              }
              setColors(E) {
                var T = this.vertexArray, R = this.colorArray;
                if (!T)
                  throw new Error("vertex array not initialized");
                if (!R)
                  throw new Error("color array not initialized");
                if (T.length != R.length) {
                  console.log("Cannot re-color geometry group due to mismatched lengths.");
                  return;
                }
                for (var _ = 0; _ < T.length; _ += 3) {
                  var b = E(T[_], T[_ + 1], T[_ + 2]);
                  b instanceof f.Color || (b = f.CC.color(b)), R[_] = b.r, R[_ + 1] = b.g, R[_ + 2] = b.b;
                }
              }
              getNumVertices() {
                return this.vertices;
              }
              getVertices() {
                return this.vertexArray;
              }
              getCentroid() {
                if (!this.vertexArray)
                  throw new Error("vertex array not initialized");
                for (var E = new u.Vector3(), T, R, _, b, M = 0; M < this.vertices; ++M)
                  T = M * 3, R = this.vertexArray[T], _ = this.vertexArray[T + 1], b = this.vertexArray[T + 2], E.x += R, E.y += _, E.z += b;
                return E.divideScalar(this.vertices), E;
              }
              //setup normals - vertex and face array must exist
              setNormals() {
                var E = this.faceArray, T = this.vertexArray, R = this.normalArray;
                if (!(!this.vertices || !this.faceidx)) {
                  if (!E)
                    throw new Error("face array not initialized");
                  if (!T)
                    throw new Error("vertex array not initialized");
                  if (!R)
                    throw new Error("normal array not initialized");
                  for (var _, b, M, A, $, S, C, D = 0; D < E.length / 3; ++D)
                    _ = E[D * 3] * 3, b = E[D * 3 + 1] * 3, M = E[D * 3 + 2] * 3, A = new u.Vector3(T[_], T[_ + 1], T[_ + 2]), $ = new u.Vector3(T[b], T[b + 1], T[b + 2]), S = new u.Vector3(T[M], T[M + 1], T[M + 2]), A.subVectors(A, $), S.subVectors(S, $), S.cross(A), C = S, C.normalize(), R[_] += C.x, R[b] += C.x, R[M] += C.x, R[_ + 1] += C.y, R[b + 1] += C.y, R[M + 1] += C.y, R[_ + 2] += C.z, R[b + 2] += C.z, R[M + 2] += C.z;
                }
              }
              /* sets line index array from face arr
              Note - assumes all faces are triangles (i.e. there will
              be an extra diagonal for four-sided faces - user should
              specify linearr for custom shape generation to show wireframe squares
              as rectangles rather than two triangles) */
              setLineIndices() {
                if (this.faceidx && !(this.lineArray && this.lineArray.length == this.faceidx * 2 && this.lineidx == this.faceidx * 2)) {
                  var E = this.faceArray, T = this.lineArray = new Uint16Array(this.faceidx * 2);
                  if (this.lineidx = this.faceidx * 2, !E)
                    throw new Error("face array not initialized");
                  for (var R = 0; R < this.faceidx / 3; ++R) {
                    var _ = R * 3, b = _ * 2, M = E[_], A = E[_ + 1], $ = E[_ + 2];
                    T[b] = M, T[b + 1] = A, T[b + 2] = M, T[b + 3] = $, T[b + 4] = A, T[b + 5] = $;
                  }
                }
              }
              vrml(E, T) {
                var R, _, b, M, A, $, S, C, D, O, N, j, L, z, G, B, F, H, W = "";
                if (W += E + `Shape {
` + E + ` appearance Appearance {
` + E + `  material Material {
` + E + "   diffuseColor " + ((R = T == null ? void 0 : T.color) === null || R === void 0 ? void 0 : R.r) + " " + ((_ = T == null ? void 0 : T.color) === null || _ === void 0 ? void 0 : _.g) + " " + ((b = T == null ? void 0 : T.color) === null || b === void 0 ? void 0 : b.b) + `
`, T.wireframe && this.colorArray) {
                  let X = this.colorArray;
                  W += E + "    emissiveColor " + X[0] + " " + X[1] + " " + X[2] + `
`;
                }
                T != null && T.transparent && (W += E + "   transparency " + (1 - T.opacity) + `
`), W += E + `  }
`, W += E + ` }
`;
                var V = E;
                if (E += " ", T instanceof o.LineBasicMaterial || T.wireframe) {
                  W += E + `geometry IndexedLineSet {
` + E + ` colorPerVertex TRUE
` + E + ` coord Coordinate {
` + E + `  point [
`;
                  let X, Z, Q;
                  for (let q = 0; q < this.vertices; ++q) {
                    let J = q * 3;
                    X = (M = this.vertexArray) === null || M === void 0 ? void 0 : M[J], Z = (A = this.vertexArray) === null || A === void 0 ? void 0 : A[J + 1], Q = ($ = this.vertexArray) === null || $ === void 0 ? void 0 : $[J + 2], W += E + "   " + X + " " + Z + " " + Q + `,
`;
                  }
                  if (W += E + `  ]
`, W += E + ` }
`, this.colorArray && !T.wireframe) {
                    W += E + ` color Color {
` + E + `  color [
`;
                    for (let q = 0; q < this.vertices; ++q) {
                      let J = q * 3;
                      X = this.colorArray[J], Z = this.colorArray[J + 1], Q = this.colorArray[J + 2], W += E + "   " + X + " " + Z + " " + Q + `,
`;
                    }
                    W += E + `  ]
`, W += E + ` }
`;
                  }
                  if (W += E + ` coordIndex [
`, T.wireframe && this.faceArray)
                    for (let q = 0; q < this.faceidx; q += 3)
                      X = (S = this.faceArray) === null || S === void 0 ? void 0 : S[q], Z = (C = this.faceArray) === null || C === void 0 ? void 0 : C[q + 1], Q = (D = this.faceArray) === null || D === void 0 ? void 0 : D[q + 2], W += E + "  " + X + ", " + Z + ", " + Q + `, -1,
`;
                  else
                    for (let q = 0; q < this.vertices - 1; q += 2)
                      W += E + "  " + q + ", " + (q + 1) + `, -1,
`;
                  W += E + ` ]
`, W += E + `}
`;
                } else {
                  W += E + `geometry IndexedFaceSet {
` + E + ` colorPerVertex TRUE
` + E + ` normalPerVertex TRUE
` + E + ` solid FALSE
`, W += E + ` coord Coordinate {
` + E + `  point [
`;
                  let X, Z, Q;
                  for (let q = 0; q < this.vertices; ++q) {
                    let J = q * 3;
                    X = (O = this.vertexArray) === null || O === void 0 ? void 0 : O[J], Z = (N = this.vertexArray) === null || N === void 0 ? void 0 : N[J + 1], Q = (j = this.vertexArray) === null || j === void 0 ? void 0 : j[J + 2], W += E + "   " + X + " " + Z + " " + Q + `,
`;
                  }
                  W += E + `  ]
`, W += E + ` }
`, W += E + ` normal Normal {
` + E + `  vector [
`;
                  for (let q = 0; q < this.vertices; ++q) {
                    let J = q * 3;
                    X = (L = this.normalArray) === null || L === void 0 ? void 0 : L[J], Z = (z = this.normalArray) === null || z === void 0 ? void 0 : z[J + 1], Q = (G = this.normalArray) === null || G === void 0 ? void 0 : G[J + 2], W += E + "   " + X + " " + Z + " " + Q + `,
`;
                  }
                  if (W += E + `  ]
`, W += E + ` }
`, this.colorArray) {
                    W += E + ` color Color {
` + E + `  color [
`;
                    for (let q = 0; q < this.vertices; ++q) {
                      let J = q * 3;
                      X = this.colorArray[J], Z = this.colorArray[J + 1], Q = this.colorArray[J + 2], W += E + "   " + X + " " + Z + " " + Q + `,
`;
                    }
                    W += E + `  ]
`, W += E + ` }
`;
                  }
                  W += E + ` coordIndex [
`;
                  for (let q = 0; q < this.faceidx; q += 3)
                    X = (B = this.faceArray) === null || B === void 0 ? void 0 : B[q], Z = (F = this.faceArray) === null || F === void 0 ? void 0 : F[q + 1], Q = (H = this.faceArray) === null || H === void 0 ? void 0 : H[q + 2], W += E + "  " + X + ", " + Z + ", " + Q + `, -1,
`;
                  W += E + ` ]
`, W += E + `}
`;
                }
                return W += V + "}", W;
              }
              truncateArrayBuffers(E = !0, T = !1) {
                var R = this.vertexArray, _ = this.colorArray, b = this.normalArray, M = this.faceArray, A = this.lineArray, $ = this.radiusArray;
                this.vertexArray = (R == null ? void 0 : R.subarray(0, this.vertices * 3)) || null, this.colorArray = (_ == null ? void 0 : _.subarray(0, this.vertices * 3)) || null, E ? (this.normalArray = (b == null ? void 0 : b.subarray(0, this.vertices * 3)) || null, this.faceArray = (M == null ? void 0 : M.subarray(0, this.faceidx)) || null, this.lineidx > 0 ? this.lineArray = (A == null ? void 0 : A.subarray(0, this.lineidx)) || null : this.lineArray = new Uint16Array(0)) : (this.normalArray = new Float32Array(0), this.faceArray = new Uint16Array(0), this.lineArray = new Uint16Array(0)), $ && (this.radiusArray = $.subarray(0, this.vertices)), T && (this.normalArray && (this.normalArray = new Float32Array(this.normalArray)), this.faceArray && (this.faceArray = new Uint16Array(this.faceArray)), this.lineArray && (this.lineArray = new Uint16Array(this.lineArray)), this.vertexArray && (this.vertexArray = new Float32Array(this.vertexArray)), this.colorArray && (this.colorArray = new Float32Array(this.colorArray)), this.radiusArray && (this.radiusArray = new Float32Array(this.radiusArray))), this.__inittedArrays = !0;
              }
            }
            class v extends l.EventDispatcher {
              constructor(E = !1, T = !1, R = !1) {
                super(), this.name = "", this.hasTangents = !1, this.dynamic = !0, this.verticesNeedUpdate = !1, this.elementsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.buffersNeedUpdate = !1, this.imposter = !1, this.instanced = !1, this.geometryGroups = [], this.groups = 0, this.id = g++, this.mesh = E, this.radii = T, this.offset = R;
              }
              //Get geometry group to accomodate addVertices new vertices - create
              // new group if necessary
              updateGeoGroup(E = 0) {
                var T, R = this.groups > 0 ? this.geometryGroups[this.groups - 1] : null;
                return (!R || R.vertices + E > (((T = R == null ? void 0 : R.vertexArray) === null || T === void 0 ? void 0 : T.length) || 0) / 3) && (R = this.addGeoGroup()), R;
              }
              //return comma separated list of IndexedFace (or Line) sets from geometry groups
              vrml(E, T) {
                for (var R = "", _ = this.geometryGroups.length, b = 0; b < _; b++) {
                  var M = this.geometryGroups[b];
                  R += M.vrml(E, T) + `,
`;
                }
                return R;
              }
              addGeoGroup() {
                var E = new p(this.geometryGroups.length);
                return this.geometryGroups.push(E), this.groups = this.geometryGroups.length, E.vertexArray = new Float32Array(h * 3), E.colorArray = new Float32Array(h * 3), this.mesh && (E.normalArray = new Float32Array(h * 3), E.faceArray = new Uint16Array(h * 6), E.lineArray = new Uint16Array(h * 6)), this.radii && (E.radiusArray = new Float32Array(h)), E.useOffset = this.offset, E;
              }
              setUpNormals(...E) {
                for (var T = 0; T < this.groups; T++) {
                  var R = this.geometryGroups[T];
                  R.setNormals(...E);
                }
              }
              setColors(...E) {
                for (var T = this.geometryGroups.length, R = 0; R < T; R++) {
                  var _ = this.geometryGroups[R];
                  _.setColors(...E);
                }
              }
              setUpWireframe(...E) {
                for (var T = 0; T < this.groups; T++) {
                  var R = this.geometryGroups[T];
                  R.setLineIndices(...E);
                }
              }
              //After vertices, colors, etc are collected in regular or typed arrays,
              //  create typed arrays from regular arrays if they don't already exist,
              initTypedArrays() {
                for (var E = 0; E < this.groups; E++) {
                  var T = this.geometryGroups[E];
                  T.__inittedArrays !== !0 && T.truncateArrayBuffers(this.mesh, !1);
                }
              }
              dispose() {
                this.dispatchEvent({ type: "dispose" });
              }
              get vertices() {
                for (var E = 0, T = 0; T < this.groups; T++)
                  E += this.geometryGroups[T].vertices;
                return E;
              }
            }
            let g = 0;
          }
        ),
        /***/
        "./src/WebGL/core/Object3D.ts": (
          /*!************************************!*\
            !*** ./src/WebGL/core/Object3D.ts ***!
            \************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              Light: () => (
                /* binding */
                p
              ),
              /* harmony export */
              Object3D: () => (
                /* binding */
                f
              ),
              /* harmony export */
              Object3DIDCount: () => (
                /* binding */
                u
              ),
              /* harmony export */
              Scene: () => (
                /* binding */
                h
              )
              /* harmony export */
            });
            var o = n(
              /*! ../math */
              "./src/WebGL/math/index.ts"
            ), l = n(
              /*! ../../colors */
              "./src/colors.ts"
            );
            let u = 0;
            class f {
              constructor() {
                this.id = u++, this.name = "", this.children = [], this.position = new o.Vector3(), this.rotation = new o.Vector3(), this.matrix = new o.Matrix4(), this.matrixWorld = new o.Matrix4(), this.quaternion = new o.Quaternion(), this.eulerOrder = "XYZ", this.up = new o.Vector3(0, 1, 0), this.scale = new o.Vector3(1, 1, 1), this.matrixAutoUpdate = !0, this.matrixWorldNeedsUpdate = !0, this.rotationAutoUpdate = !0, this.useQuaternion = !1, this.visible = !0;
              }
              lookAt(g) {
                this.matrix.lookAt(g, this.position, this.up), this.rotationAutoUpdate && (this.useQuaternion === !0 ? console.error("Unimplemented math operation.") : this.rotation instanceof o.Vector3 && this.rotation.setEulerFromRotationMatrix(this.matrix, this.eulerOrder));
              }
              //add child object
              add(g) {
                if (g === this) {
                  console.error("Can't add $3Dmol.Object3D to itself");
                  return;
                }
                g.parent = this, this.children.push(g);
                for (var w = this; w.parent !== void 0; )
                  w = w.parent;
                w !== void 0 && w instanceof h && w.__addObject(g);
              }
              remove(g) {
                var w = this.children.indexOf(g);
                if (w !== -1) {
                  g.parent = void 0, this.children.splice(w, 1);
                  for (var E = this; E.parent !== void 0; )
                    E = E.parent;
                  E !== void 0 && E instanceof h && E.__removeObject(g);
                }
              }
              //convert to vrml
              vrml(g) {
                g || (g = " ");
                var w = 2 * Math.atan2(this.quaternion.lengthxyz(), this.quaternion.w), E = 0, T = 0, R = 0;
                if (w != 0) {
                  let M = Math.sin(w / 2);
                  E = this.quaternion.x / M, T = this.quaternion.y / M, R = this.quaternion.z / M;
                }
                var _ = g + `Transform {
` + g + " center " + this.position.x + " " + this.position.y + " " + this.position.z + `
` + g + " rotation " + E + " " + T + " " + R + " " + w + `
` + g + ` children [
`;
                this.geometry && (_ += this.geometry.vrml(g, this.material));
                for (var b = 0; b < this.children.length; b++)
                  _ += this.children[b].vrml(g + " ") + `,
`;
                return _ += ` ]
`, _ += "}", _;
              }
              updateMatrix() {
                this.matrix.setPosition(this.position), this.useQuaternion === !1 && this.rotation instanceof o.Vector3 ? this.matrix.setRotationFromEuler(this.rotation, this.eulerOrder) : this.matrix.setRotationFromQuaternion(this.quaternion), (this.scale.x !== 1 || this.scale.y !== 1 || this.scale.z !== 1) && this.matrix.scale(this.scale), this.matrixWorldNeedsUpdate = !0;
              }
              updateMatrixWorld(g) {
                this.matrixAutoUpdate === !0 && this.updateMatrix(), (this.matrixWorldNeedsUpdate === !0 || g === !0) && (this.parent === void 0 ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1;
                for (var w = 0; w < this.children.length; w++)
                  this.children[w].updateMatrixWorld(!0);
              }
              clone(g) {
                g === void 0 && (g = new f()), g.name = this.name, g.up.copy(this.up), g.position.copy(this.position), g.rotation instanceof o.Vector3 && this.rotation instanceof o.Vector3 ? g.rotation.copy(this.rotation) : g.rotation = this.rotation, g.eulerOrder = this.eulerOrder, g.scale.copy(this.scale), g.rotationAutoUpdate = this.rotationAutoUpdate, g.matrix.copy(this.matrix), g.matrixWorld.copy(this.matrixWorld), g.quaternion.copy(this.quaternion), g.matrixAutoUpdate = this.matrixAutoUpdate, g.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate, g.useQuaternion = this.useQuaternion, g.visible = this.visible;
                for (var w = 0; w < this.children.length; w++) {
                  var E = this.children[w];
                  g.add(E.clone());
                }
                return g;
              }
              setVisible(g) {
                this.visible = g;
                for (var w = 0; w < this.children.length; w++) {
                  var E = this.children[w];
                  E.setVisible(g);
                }
              }
            }
            class h extends f {
              constructor() {
                super(...arguments), this.fog = null, this.overrideMaterial = null, this.matrixAutoUpdate = !1, this.__objects = [], this.__lights = [], this.__objectsAdded = [], this.__objectsRemoved = [];
              }
              __addObject(g) {
                if (g instanceof p)
                  this.__lights.indexOf(g) === -1 && this.__lights.push(g), g.target && g.target.parent === void 0 && this.add(g.target);
                else if (this.__objects.indexOf(g) === -1) {
                  this.__objects.push(g), this.__objectsAdded.push(g);
                  var w = this.__objectsRemoved.indexOf(g);
                  w !== -1 && this.__objectsRemoved.splice(w, 1);
                }
                for (var E = 0; E < g.children.length; E++)
                  this.__addObject(g.children[E]);
              }
              __removeObject(g) {
                var w;
                if (g instanceof p)
                  w = this.__lights.indexOf(g), w !== -1 && this.__lights.splice(w, 1);
                else if (w = this.__objects.indexOf(g), w !== -1) {
                  this.__objects.splice(w, 1), this.__objectsRemoved.push(g);
                  var E = this.__objectsAdded.indexOf(g);
                  E !== -1 && this.__objectsAdded.splice(w, 1);
                }
                for (var T = 0; T < g.children.length; T++)
                  this.__removeObject(g.children[T]);
              }
            }
            class p extends f {
              constructor(g, w = 1) {
                super(), this.position = new o.Vector3(0, 1, 0), this.target = new f(), this.castShadow = !1, this.onlyShadow = !1, this.color = new l.Color(g), this.intensity = w;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/core/Projector.ts": (
          /*!*************************************!*\
            !*** ./src/WebGL/core/Projector.ts ***!
            \*************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              Projector: () => (
                /* binding */
                u
              )
              /* harmony export */
            });
            var o = n(
              /*! ../math */
              "./src/WebGL/math/index.ts"
            );
            const l = new o.Matrix4();
            class u {
              static unprojectVector(h, p) {
                return p.projectionMatrixInverse.getInverse(p.projectionMatrix), l.multiplyMatrices(p.matrixWorld, p.projectionMatrixInverse), h.applyProjection(l);
              }
              static projectVector(h, p) {
                return p.matrixWorldInverse.getInverse(p.matrixWorld), l.multiplyMatrices(p.projectionMatrix, p.matrixWorldInverse), h.applyProjection(l);
              }
              projectVector(h, p) {
                return u.projectVector(h, p);
              }
              unprojectVector(h, p) {
                return u.unprojectVector(h, p);
              }
            }
          }
        ),
        /***/
        "./src/WebGL/core/Raycaster.ts": (
          /*!*************************************!*\
            !*** ./src/WebGL/core/Raycaster.ts ***!
            \*************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              Raycaster: () => (
                /* binding */
                h
              ),
              /* harmony export */
              intersectObject: () => (
                /* binding */
                M
              )
              /* harmony export */
            });
            var o = n(
              /*! ../math */
              "./src/WebGL/math/index.ts"
            ), l = n(
              /*! ../shapes */
              "./src/WebGL/shapes/index.ts"
            );
            const u = (A, $) => A.distance - $.distance, f = new o.Matrix4();
            class h {
              constructor($, S, C, D) {
                this.precision = 1e-4, this.linePrecision = 0.2, this.ray = new o.Ray($, S), this.ray.direction.lengthSq() > 0 && this.ray.direction.normalize(), this.near = D || 0, this.far = C || 1 / 0;
              }
              set($, S) {
                this.ray.set($, S);
              }
              setFromCamera($, S) {
                S.ortho ? (this.ray.origin.set($.x, $.y, (S.near + S.far) / (S.near - S.far)).unproject(S), this.ray.direction.set(0, 0, -1).transformDirection(S.matrixWorld)) : (this.ray.origin.setFromMatrixPosition(S.matrixWorld), this.ray.direction.set($.x, $.y, $.z), S.projectionMatrixInverse.getInverse(S.projectionMatrix), f.multiplyMatrices(S.matrixWorld, S.projectionMatrixInverse), this.ray.direction.applyProjection(f), this.ray.direction.sub(this.ray.origin).normalize());
              }
              intersectObjects($, S) {
                for (var C = [], D = 0, O = S.length; D < O; D++)
                  M($, S[D], this, C);
                return C.sort(u), C;
              }
            }
            const p = (A) => Math.min(Math.max(A, -1), 1);
            var v = new l.Sphere(), g = new l.Cylinder(), w = new l.Triangle(), E = new o.Vector3(), T = new o.Vector3(), R = new o.Vector3(), _ = new o.Vector3(), b = new o.Vector3();
            function M(A, $, S, C) {
              if (b.getPositionFromMatrix(A.matrixWorld), $.intersectionShape === void 0)
                return C;
              var D = $.intersectionShape, O = S.linePrecision;
              O *= A.matrixWorld.getMaxScaleOnAxis();
              var N = O * O;
              if ($.boundingSphere !== void 0 && $.boundingSphere instanceof l.Sphere && (v.copy($.boundingSphere), v.applyMatrix4(A.matrixWorld), !S.ray.isIntersectionSphere(v)))
                return C;
              var j, L, z, G, B, F, H, W, V, X, Z, Q, q, J;
              for (j = 0, L = D.triangle.length; j < L; j++)
                if (D.triangle[j] instanceof l.Triangle) {
                  if (w.copy(D.triangle[j]), w.applyMatrix4(A.matrixWorld), z = w.getNormal(), G = S.ray.direction.dot(z), G >= 0 || (E.subVectors(w.a, S.ray.origin), H = z.dot(E) / G, H < 0))
                    continue;
                  T.copy(S.ray.direction).multiplyScalar(H).add(S.ray.origin), T.sub(w.a), R.copy(w.b).sub(w.a), _.copy(w.c).sub(w.a);
                  var ie = R.dot(_), ne = R.lengthSq(), ge = _.lengthSq();
                  if (Q = (ne * T.dot(_) - ie * T.dot(R)) / (ne * ge - ie * ie), Q < 0 || Q > 1 || (Z = (T.dot(R) - Q * ie) / ne, Z < 0 || Z > 1 || Z + Q > 1))
                    continue;
                  C.push({ clickable: $, distance: H });
                }
              for (j = 0, L = D.cylinder.length; j < L; j++)
                if (D.cylinder[j] instanceof l.Cylinder) {
                  if (g.copy(D.cylinder[j]), g.applyMatrix4(A.matrixWorld), E.subVectors(g.c1, S.ray.origin), B = E.dot(g.direction), F = E.dot(S.ray.direction), G = p(S.ray.direction.dot(g.direction)), V = 1 - G * G, V === 0)
                    continue;
                  q = (G * F - B) / V, J = (F - G * B) / V, T.copy(g.direction).multiplyScalar(q).add(g.c1), R.copy(S.ray.direction).multiplyScalar(J).add(S.ray.origin), W = _.subVectors(T, R).lengthSq();
                  var ye = g.radius * g.radius;
                  if (W <= ye) {
                    if (X = (G * B - F) * (G * B - F) - V * (E.lengthSq() - B * B - ye), X <= 0 ? Q = H = Math.sqrt(W) : Q = H = (F - G * B - Math.sqrt(X)) / V, Z = G * Q - B, Z < 0 || Z * Z > g.lengthSq() || Q < 0)
                      continue;
                    C.push({ clickable: $, distance: H });
                  }
                }
              for (j = 0, L = D.line.length; j < L; j += 2) {
                T.copy(D.line[j]), T.applyMatrix4(A.matrixWorld), R.copy(D.line[j + 1]), R.applyMatrix4(A.matrixWorld), _.subVectors(R, T);
                var xe = _.lengthSq();
                _.normalize(), E.subVectors(T, S.ray.origin);
                var we = E.dot(_);
                F = E.dot(S.ray.direction), G = p(S.ray.direction.dot(_)), V = 1 - G * G, V !== 0 && (q = (G * F - we) / V, J = (F - G * we) / V, T.add(_.multiplyScalar(q)), R.copy(S.ray.direction).multiplyScalar(J).add(S.ray.origin), W = _.subVectors(R, T).lengthSq(), W < N && q * q < xe && C.push({ clickable: $, distance: J }));
              }
              for (j = 0, L = D.sphere.length; j < L; j++)
                if (D.sphere[j] instanceof l.Sphere && (v.copy(D.sphere[j]), v.applyMatrix4(A.matrixWorld), S.ray.isIntersectionSphere(v))) {
                  T.subVectors(v.center, S.ray.origin);
                  var de = T.dot(S.ray.direction);
                  if (X = de * de - (T.lengthSq() - v.radius * v.radius), de < 0)
                    return C;
                  X <= 0 ? H = de : H = de - Math.sqrt(X), C.push({ clickable: $, distance: H });
                }
              return C;
            }
          }
        ),
        /***/
        "./src/WebGL/core/Texture.ts": (
          /*!***********************************!*\
            !*** ./src/WebGL/core/Texture.ts ***!
            \***********************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              Texture: () => (
                /* binding */
                h
              ),
              /* harmony export */
              TextureIdCount: () => (
                /* binding */
                p
              )
              /* harmony export */
            });
            var o = n(
              /*! ../constants/TextureConstants */
              "./src/WebGL/constants/TextureConstants.ts"
            ), l = n(
              /*! ../math */
              "./src/WebGL/math/index.ts"
            ), u = n(
              /*! ./EventDispatcher */
              "./src/WebGL/core/EventDispatcher.ts"
            ), f = n(
              /*! ./UVMapping */
              "./src/WebGL/core/UVMapping.ts"
            );
            class h extends u.EventDispatcher {
              constructor(g, w) {
                super(), this.id = p++, this.name = "", this.image = g, this.mapping = new f.UVMapping(), this.wrapS = o.ClampToEdgeWrapping, this.wrapT = o.ClampToEdgeWrapping, this.anisotropy = 1, w ? (this.format = o.RFormat, this.type = o.FloatType, this.premultiplyAlpha = !1, this.flipY = !1, this.unpackAlignment = 1, this.magFilter = o.NearestFilter, this.minFilter = o.NearestFilter) : (this.format = o.RGBAFormat, this.type = o.UnsignedByteType, this.offset = new l.Vector2(0, 0), this.repeat = new l.Vector2(1, 1), this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.magFilter = o.LinearFilter, this.minFilter = o.LinearMipMapLinearFilter), this.needsUpdate = !1, this.onUpdate = null;
              }
              clone(g = new h()) {
                return g.image = this.image, g.mapping = this.mapping, g.wrapS = this.wrapS, g.wrapT = this.wrapT, g.magFilter = this.magFilter, g.minFilter = this.minFilter, g.anisotropy = this.anisotropy, g.format = this.format, g.type = this.type, g.offset.copy(this.offset), g.repeat.copy(this.repeat), g.premultiplyAlpha = this.premultiplyAlpha, g.flipY = this.flipY, g.unpackAlignment = this.unpackAlignment, g;
              }
              dispose() {
                this.dispatchEvent({ type: "dispose" });
              }
            }
            let p = 0;
          }
        ),
        /***/
        "./src/WebGL/core/UVMapping.ts": (
          /*!*************************************!*\
            !*** ./src/WebGL/core/UVMapping.ts ***!
            \*************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              UVMapping: () => (
                /* binding */
                o
              )
              /* harmony export */
            });
            class o {
            }
          }
        ),
        /***/
        "./src/WebGL/core/index.ts": (
          /*!*********************************!*\
            !*** ./src/WebGL/core/index.ts ***!
            \*********************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              EventDispatcher: () => (
                /* reexport safe */
                o.EventDispatcher
              ),
              /* harmony export */
              Geometry: () => (
                /* reexport safe */
                l.Geometry
              ),
              /* harmony export */
              GeometryGroup: () => (
                /* reexport safe */
                l.GeometryGroup
              ),
              /* harmony export */
              GeometryIDCount: () => (
                /* reexport safe */
                l.GeometryIDCount
              ),
              /* harmony export */
              Light: () => (
                /* reexport safe */
                u.Light
              ),
              /* harmony export */
              Object3D: () => (
                /* reexport safe */
                u.Object3D
              ),
              /* harmony export */
              Object3DIDCount: () => (
                /* reexport safe */
                u.Object3DIDCount
              ),
              /* harmony export */
              Projector: () => (
                /* reexport safe */
                f.Projector
              ),
              /* harmony export */
              Raycaster: () => (
                /* reexport safe */
                h.Raycaster
              ),
              /* harmony export */
              Scene: () => (
                /* reexport safe */
                u.Scene
              ),
              /* harmony export */
              Texture: () => (
                /* reexport safe */
                p.Texture
              ),
              /* harmony export */
              TextureIdCount: () => (
                /* reexport safe */
                p.TextureIdCount
              ),
              /* harmony export */
              UVMapping: () => (
                /* reexport safe */
                v.UVMapping
              ),
              /* harmony export */
              intersectObject: () => (
                /* reexport safe */
                h.intersectObject
              )
              /* harmony export */
            });
            var o = n(
              /*! ./EventDispatcher */
              "./src/WebGL/core/EventDispatcher.ts"
            ), l = n(
              /*! ./Geometry */
              "./src/WebGL/core/Geometry.ts"
            ), u = n(
              /*! ./Object3D */
              "./src/WebGL/core/Object3D.ts"
            ), f = n(
              /*! ./Projector */
              "./src/WebGL/core/Projector.ts"
            ), h = n(
              /*! ./Raycaster */
              "./src/WebGL/core/Raycaster.ts"
            ), p = n(
              /*! ./Texture */
              "./src/WebGL/core/Texture.ts"
            ), v = n(
              /*! ./UVMapping */
              "./src/WebGL/core/UVMapping.ts"
            );
          }
        ),
        /***/
        "./src/WebGL/index.ts": (
          /*!****************************!*\
            !*** ./src/WebGL/index.ts ***!
            \****************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              BackSide: () => (
                /* reexport safe */
                o.BackSide
              ),
              /* harmony export */
              Camera: () => (
                /* reexport safe */
                g.Camera
              ),
              /* harmony export */
              ClampToEdgeWrapping: () => (
                /* reexport safe */
                o.ClampToEdgeWrapping
              ),
              /* harmony export */
              Coloring: () => (
                /* reexport safe */
                o.Coloring
              ),
              /* harmony export */
              Cylinder: () => (
                /* reexport safe */
                v.Cylinder
              ),
              /* harmony export */
              DoubleSide: () => (
                /* reexport safe */
                o.DoubleSide
              ),
              /* harmony export */
              EventDispatcher: () => (
                /* reexport safe */
                l.EventDispatcher
              ),
              /* harmony export */
              FloatType: () => (
                /* reexport safe */
                o.FloatType
              ),
              /* harmony export */
              Fog: () => (
                /* reexport safe */
                w.Fog
              ),
              /* harmony export */
              FrontSide: () => (
                /* reexport safe */
                o.FrontSide
              ),
              /* harmony export */
              Geometry: () => (
                /* reexport safe */
                l.Geometry
              ),
              /* harmony export */
              GeometryGroup: () => (
                /* reexport safe */
                l.GeometryGroup
              ),
              /* harmony export */
              GeometryIDCount: () => (
                /* reexport safe */
                l.GeometryIDCount
              ),
              /* harmony export */
              ImposterMaterial: () => (
                /* reexport safe */
                u.ImposterMaterial
              ),
              /* harmony export */
              InstancedMaterial: () => (
                /* reexport safe */
                u.InstancedMaterial
              ),
              /* harmony export */
              Light: () => (
                /* reexport safe */
                l.Light
              ),
              /* harmony export */
              Line: () => (
                /* reexport safe */
                h.Line
              ),
              /* harmony export */
              LineBasicMaterial: () => (
                /* reexport safe */
                u.LineBasicMaterial
              ),
              /* harmony export */
              LineStyle: () => (
                /* reexport safe */
                h.LineStyle
              ),
              /* harmony export */
              LinearFilter: () => (
                /* reexport safe */
                o.LinearFilter
              ),
              /* harmony export */
              LinearMipMapLinearFilter: () => (
                /* reexport safe */
                o.LinearMipMapLinearFilter
              ),
              /* harmony export */
              Material: () => (
                /* reexport safe */
                u.Material
              ),
              /* harmony export */
              MaterialIdCount: () => (
                /* reexport safe */
                u.MaterialIdCount
              ),
              /* harmony export */
              Matrix3: () => (
                /* reexport safe */
                f.Matrix3
              ),
              /* harmony export */
              Matrix4: () => (
                /* reexport safe */
                f.Matrix4
              ),
              /* harmony export */
              Mesh: () => (
                /* reexport safe */
                h.Mesh
              ),
              /* harmony export */
              MeshDoubleLambertMaterial: () => (
                /* reexport safe */
                u.MeshDoubleLambertMaterial
              ),
              /* harmony export */
              MeshLambertMaterial: () => (
                /* reexport safe */
                u.MeshLambertMaterial
              ),
              /* harmony export */
              MeshOutlineMaterial: () => (
                /* reexport safe */
                u.MeshOutlineMaterial
              ),
              /* harmony export */
              NearestFilter: () => (
                /* reexport safe */
                o.NearestFilter
              ),
              /* harmony export */
              Object3D: () => (
                /* reexport safe */
                l.Object3D
              ),
              /* harmony export */
              Object3DIDCount: () => (
                /* reexport safe */
                l.Object3DIDCount
              ),
              /* harmony export */
              Projector: () => (
                /* reexport safe */
                l.Projector
              ),
              /* harmony export */
              Quaternion: () => (
                /* reexport safe */
                f.Quaternion
              ),
              /* harmony export */
              R32Format: () => (
                /* reexport safe */
                o.R32Format
              ),
              /* harmony export */
              RFormat: () => (
                /* reexport safe */
                o.RFormat
              ),
              /* harmony export */
              RGBAFormat: () => (
                /* reexport safe */
                o.RGBAFormat
              ),
              /* harmony export */
              Ray: () => (
                /* reexport safe */
                f.Ray
              ),
              /* harmony export */
              Raycaster: () => (
                /* reexport safe */
                l.Raycaster
              ),
              /* harmony export */
              Renderer: () => (
                /* reexport safe */
                E.Renderer
              ),
              /* harmony export */
              Scene: () => (
                /* reexport safe */
                l.Scene
              ),
              /* harmony export */
              ShaderLib: () => (
                /* reexport safe */
                p.ShaderLib
              ),
              /* harmony export */
              ShaderUtils: () => (
                /* reexport safe */
                p.ShaderUtils
              ),
              /* harmony export */
              Shading: () => (
                /* reexport safe */
                o.Shading
              ),
              /* harmony export */
              Sphere: () => (
                /* reexport safe */
                v.Sphere
              ),
              /* harmony export */
              SphereImposterMaterial: () => (
                /* reexport safe */
                u.SphereImposterMaterial
              ),
              /* harmony export */
              SphereImposterOutlineMaterial: () => (
                /* reexport safe */
                u.SphereImposterOutlineMaterial
              ),
              /* harmony export */
              Sprite: () => (
                /* reexport safe */
                h.Sprite
              ),
              /* harmony export */
              SpriteAlignment: () => (
                /* reexport safe */
                o.SpriteAlignment
              ),
              /* harmony export */
              SpriteMaterial: () => (
                /* reexport safe */
                u.SpriteMaterial
              ),
              /* harmony export */
              SpritePlugin: () => (
                /* reexport safe */
                T.SpritePlugin
              ),
              /* harmony export */
              StickImposterMaterial: () => (
                /* reexport safe */
                u.StickImposterMaterial
              ),
              /* harmony export */
              StickImposterOutlineMaterial: () => (
                /* reexport safe */
                u.StickImposterOutlineMaterial
              ),
              /* harmony export */
              Texture: () => (
                /* reexport safe */
                l.Texture
              ),
              /* harmony export */
              TextureIdCount: () => (
                /* reexport safe */
                l.TextureIdCount
              ),
              /* harmony export */
              TextureOperations: () => (
                /* reexport safe */
                o.TextureOperations
              ),
              /* harmony export */
              Triangle: () => (
                /* reexport safe */
                v.Triangle
              ),
              /* harmony export */
              UVMapping: () => (
                /* reexport safe */
                l.UVMapping
              ),
              /* harmony export */
              UnsignedByteType: () => (
                /* reexport safe */
                o.UnsignedByteType
              ),
              /* harmony export */
              Vector2: () => (
                /* reexport safe */
                f.Vector2
              ),
              /* harmony export */
              Vector3: () => (
                /* reexport safe */
                f.Vector3
              ),
              /* harmony export */
              VolumetricMaterial: () => (
                /* reexport safe */
                u.VolumetricMaterial
              ),
              /* harmony export */
              basic: () => (
                /* reexport safe */
                p.basic
              ),
              /* harmony export */
              clamp: () => (
                /* reexport safe */
                f.clamp
              ),
              /* harmony export */
              clone: () => (
                /* reexport safe */
                p.clone
              ),
              /* harmony export */
              conversionMatrix3: () => (
                /* reexport safe */
                f.conversionMatrix3
              ),
              /* harmony export */
              degToRad: () => (
                /* reexport safe */
                f.degToRad
              ),
              /* harmony export */
              instanced: () => (
                /* reexport safe */
                p.instanced
              ),
              /* harmony export */
              intersectObject: () => (
                /* reexport safe */
                l.intersectObject
              ),
              /* harmony export */
              lambert: () => (
                /* reexport safe */
                p.lambert
              ),
              /* harmony export */
              lambertdouble: () => (
                /* reexport safe */
                p.lambertdouble
              ),
              /* harmony export */
              outline: () => (
                /* reexport safe */
                p.outline
              ),
              /* harmony export */
              screen: () => (
                /* reexport safe */
                p.screen
              ),
              /* harmony export */
              screenaa: () => (
                /* reexport safe */
                p.screenaa
              ),
              /* harmony export */
              sphereimposter: () => (
                /* reexport safe */
                p.sphereimposter
              ),
              /* harmony export */
              sphereimposteroutline: () => (
                /* reexport safe */
                p.sphereimposteroutline
              ),
              /* harmony export */
              sprite: () => (
                /* reexport safe */
                p.sprite
              ),
              /* harmony export */
              stickimposter: () => (
                /* reexport safe */
                p.stickimposter
              ),
              /* harmony export */
              stickimposteroutline: () => (
                /* reexport safe */
                p.stickimposteroutline
              ),
              /* harmony export */
              volumetric: () => (
                /* reexport safe */
                p.volumetric
              )
              /* harmony export */
            });
            var o = n(
              /*! ./constants */
              "./src/WebGL/constants/index.ts"
            ), l = n(
              /*! ./core */
              "./src/WebGL/core/index.ts"
            ), u = n(
              /*! ./materials */
              "./src/WebGL/materials/index.ts"
            ), f = n(
              /*! ./math */
              "./src/WebGL/math/index.ts"
            ), h = n(
              /*! ./objects */
              "./src/WebGL/objects/index.ts"
            ), p = n(
              /*! ./shaders */
              "./src/WebGL/shaders/index.ts"
            ), v = n(
              /*! ./shapes */
              "./src/WebGL/shapes/index.ts"
            ), g = n(
              /*! ./Camera */
              "./src/WebGL/Camera.ts"
            ), w = n(
              /*! ./Fog */
              "./src/WebGL/Fog.ts"
            ), E = n(
              /*! ./Renderer */
              "./src/WebGL/Renderer.ts"
            ), T = n(
              /*! ./SpritePlugin */
              "./src/WebGL/SpritePlugin.ts"
            );
          }
        ),
        /***/
        "./src/WebGL/materials/ImposterMaterial.ts": (
          /*!*************************************************!*\
            !*** ./src/WebGL/materials/ImposterMaterial.ts ***!
            \*************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              ImposterMaterial: () => (
                /* binding */
                p
              )
              /* harmony export */
            });
            var o = n(
              /*! ./../constants/Coloring */
              "./src/WebGL/constants/Coloring.ts"
            ), l = n(
              /*! ./../constants/Shading */
              "./src/WebGL/constants/Shading.ts"
            ), u = n(
              /*! ../../colors */
              "./src/colors.ts"
            ), f = n(
              /*! ../math */
              "./src/WebGL/math/index.ts"
            ), h = n(
              /*! ./Material */
              "./src/WebGL/materials/Material.ts"
            );
            class p extends h.Material {
              constructor(g) {
                super(), this.color = new u.Color(16777215), this.ambient = new u.Color(1048575), this.emissive = new u.Color(0), this.imposter = !0, this.wrapAround = !1, this.wrapRGB = new f.Vector3(1, 1, 1), this.map = void 0, this.lightMap = null, this.specularMap = null, this.envMap = null, this.reflectivity = 1, this.refractionRatio = 0.98, this.fog = !0, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.shading = l.Shading.SmoothShading, this.shaderID = null, this.vertexColors = o.Coloring.NoColors, this.skinning = !1, this.setValues(g);
              }
              clone(g = new p()) {
                return super.clone.call(this, g), g.color.copy(this.color), g.ambient.copy(this.ambient), g.emissive.copy(this.emissive), g.wrapAround = this.wrapAround, g.wrapRGB.copy(this.wrapRGB), g.map = this.map, g.lightMap = this.lightMap, g.specularMap = this.specularMap, g.envMap = this.envMap, g.combine = this.combine, g.reflectivity = this.reflectivity, g.refractionRatio = this.refractionRatio, g.fog = this.fog, g.shading = this.shading, g.shaderID = this.shaderID, g.vertexColors = this.vertexColors, g.skinning = this.skinning, g.morphTargets = this.morphTargets, g.morphNormals = this.morphNormals, g;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/materials/InstancedMaterial.ts": (
          /*!**************************************************!*\
            !*** ./src/WebGL/materials/InstancedMaterial.ts ***!
            \**************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              InstancedMaterial: () => (
                /* binding */
                p
              )
              /* harmony export */
            });
            var o = n(
              /*! ../constants/Coloring */
              "./src/WebGL/constants/Coloring.ts"
            ), l = n(
              /*! ../constants/Shading */
              "./src/WebGL/constants/Shading.ts"
            ), u = n(
              /*! ../../colors */
              "./src/colors.ts"
            ), f = n(
              /*! ../math */
              "./src/WebGL/math/index.ts"
            ), h = n(
              /*! ./Material */
              "./src/WebGL/materials/Material.ts"
            );
            class p extends h.Material {
              constructor(g) {
                super(), this.color = new u.Color(16777215), this.ambient = new u.Color(1048575), this.emissive = new u.Color(0), this.wrapAround = !1, this.wrapRGB = new f.Vector3(1, 1, 1), this.map = void 0, this.lightMap = null, this.specularMap = null, this.envMap = null, this.reflectivity = 1, this.refractionRatio = 0.98, this.fog = !0, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.shading = l.Shading.SmoothShading, this.shaderID = "instanced", this.vertexColors = o.Coloring.NoColors, this.skinning = !1, this.sphere = null, this.setValues(g);
              }
              clone(g = new p()) {
                return super.clone.call(this, g), g.color.copy(this.color), g.ambient.copy(this.ambient), g.emissive.copy(this.emissive), g.wrapAround = this.wrapAround, g.wrapRGB.copy(this.wrapRGB), g.map = this.map, g.lightMap = this.lightMap, g.specularMap = this.specularMap, g.envMap = this.envMap, g.combine = this.combine, g.reflectivity = this.reflectivity, g.refractionRatio = this.refractionRatio, g.fog = this.fog, g.shading = this.shading, g.shaderID = this.shaderID, g.vertexColors = this.vertexColors, g.skinning = this.skinning, g.morphTargets = this.morphTargets, g.morphNormals = this.morphNormals, g.sphere = this.sphere, g;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/materials/LineBasicMaterial.ts": (
          /*!**************************************************!*\
            !*** ./src/WebGL/materials/LineBasicMaterial.ts ***!
            \**************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              LineBasicMaterial: () => (
                /* binding */
                u
              )
              /* harmony export */
            });
            var o = n(
              /*! ../../colors */
              "./src/colors.ts"
            ), l = n(
              /*! ./Material */
              "./src/WebGL/materials/Material.ts"
            );
            class u extends l.Material {
              constructor(h) {
                super(), this.color = new o.Color(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.vertexColors = !1, this.fog = !0, this.shaderID = "basic", this.setValues(h);
              }
              clone(h = new u()) {
                return super.clone.call(this, h), h.color.copy(this.color), h;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/materials/Material.ts": (
          /*!*****************************************!*\
            !*** ./src/WebGL/materials/Material.ts ***!
            \*****************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              Material: () => (
                /* binding */
                h
              ),
              /* harmony export */
              MaterialIdCount: () => (
                /* binding */
                p
              )
              /* harmony export */
            });
            var o = n(
              /*! ../constants/Sides */
              "./src/WebGL/constants/Sides.ts"
            ), l = n(
              /*! ../core */
              "./src/WebGL/core/index.ts"
            ), u = n(
              /*! ../math */
              "./src/WebGL/math/index.ts"
            ), f = n(
              /*! ../../colors */
              "./src/colors.ts"
            );
            class h extends l.EventDispatcher {
              constructor() {
                super(...arguments), this.id = p++, this.name = "", this.side = o.FrontSide, this.opacity = 1, this.transparent = !1, this.depthTest = !0, this.depthWrite = !0, this.stencilTest = !0, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.alphaTest = 0, this.visible = !0, this.needsUpdate = !0, this.outline = !1, this.wireframe = !1;
              }
              setValues(g = {}) {
                if (g !== void 0)
                  for (var w in g) {
                    var E = g[w];
                    if (E === void 0) {
                      console.warn("$3Dmol.Material: '" + w + "' parameter is undefined.");
                      continue;
                    }
                    if (w in this) {
                      var T = this[w];
                      T instanceof f.Color && E instanceof f.Color ? T.copy(E) : T instanceof f.Color ? T.set(E) : T instanceof u.Vector3 && E instanceof u.Vector3 ? T.copy(E) : this[w] = E;
                    }
                  }
              }
              //TODO: might want to look into blending equations
              clone(g = new h()) {
                return g.name = this.name, g.side = this.side, g.opacity = this.opacity, g.transparent = this.transparent, g.depthTest = this.depthTest, g.depthWrite = this.depthWrite, g.stencilTest = this.stencilTest, g.polygonOffset = this.polygonOffset, g.polygonOffsetFactor = this.polygonOffsetFactor, g.polygonOffsetUnits = this.polygonOffsetUnits, g.alphaTest = this.alphaTest, g.overdraw = this.overdraw, g.visible = this.visible, g;
              }
              dispose() {
                this.dispatchEvent({ type: "dispose" });
              }
            }
            let p = 0;
          }
        ),
        /***/
        "./src/WebGL/materials/MeshDoubleLambertMaterial.ts": (
          /*!**********************************************************!*\
            !*** ./src/WebGL/materials/MeshDoubleLambertMaterial.ts ***!
            \**********************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              MeshDoubleLambertMaterial: () => (
                /* binding */
                u
              )
              /* harmony export */
            });
            var o = n(
              /*! ./../constants/Sides */
              "./src/WebGL/constants/Sides.ts"
            ), l = n(
              /*! ./MeshLambertMaterial */
              "./src/WebGL/materials/MeshLambertMaterial.ts"
            );
            class u extends l.MeshLambertMaterial {
              constructor(h) {
                super(h), this.shaderID = "lambertdouble", this.side = o.DoubleSide, this.outline = !1;
              }
              clone(h = new u()) {
                return super.clone.call(this, h), h;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/materials/MeshLambertMaterial.ts": (
          /*!****************************************************!*\
            !*** ./src/WebGL/materials/MeshLambertMaterial.ts ***!
            \****************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              MeshLambertMaterial: () => (
                /* binding */
                p
              )
              /* harmony export */
            });
            var o = n(
              /*! ./../constants/Coloring */
              "./src/WebGL/constants/Coloring.ts"
            ), l = n(
              /*! ./../constants/Shading */
              "./src/WebGL/constants/Shading.ts"
            ), u = n(
              /*! ./Material */
              "./src/WebGL/materials/Material.ts"
            ), f = n(
              /*! ../../colors */
              "./src/colors.ts"
            ), h = n(
              /*! ../math */
              "./src/WebGL/math/index.ts"
            );
            class p extends u.Material {
              constructor(g) {
                super(), this.color = new f.Color(16777215), this.ambient = new f.Color(1048575), this.emissive = new f.Color(0), this.wrapAround = !1, this.wrapRGB = new h.Vector3(1, 1, 1), this.map = void 0, this.lightMap = null, this.specularMap = null, this.envMap = null, this.reflectivity = 1, this.refractionRatio = 0.98, this.fog = !0, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.shading = l.Shading.SmoothShading, this.shaderID = "lambert", this.vertexColors = o.Coloring.NoColors, this.skinning = !1, this.setValues(g);
              }
              clone(g = new p()) {
                return super.clone.call(this, g), g.color.copy(this.color), g.ambient.copy(this.ambient), g.emissive.copy(this.emissive), g.wrapAround = this.wrapAround, g.wrapRGB.copy(this.wrapRGB), g.map = this.map, g.lightMap = this.lightMap, g.specularMap = this.specularMap, g.envMap = this.envMap, g.combine = this.combine, g.reflectivity = this.reflectivity, g.refractionRatio = this.refractionRatio, g.fog = this.fog, g.shading = this.shading, g.shaderID = this.shaderID, g.vertexColors = this.vertexColors, g.skinning = this.skinning, g.morphTargets = this.morphTargets, g.morphNormals = this.morphNormals, g;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/materials/MeshOutlineMaterial.ts": (
          /*!****************************************************!*\
            !*** ./src/WebGL/materials/MeshOutlineMaterial.ts ***!
            \****************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              MeshOutlineMaterial: () => (
                /* binding */
                u
              )
              /* harmony export */
            });
            var o = n(
              /*! ../../colors */
              "./src/colors.ts"
            ), l = n(
              /*! ./Material */
              "./src/WebGL/materials/Material.ts"
            );
            class u extends l.Material {
              constructor(h) {
                super(), h = h || {}, this.fog = !0, this.shaderID = "outline", this.wireframe = !1, this.outlineColor = h.color || new o.Color(0, 0, 0), this.outlineWidth = h.width || 0.1, this.outlinePushback = h.pushback || 1;
              }
              clone(h = new u()) {
                return super.clone.call(this, h), h.fog = this.fog, h.shaderID = this.shaderID, h.wireframe = this.wireframe, h;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/materials/SphereImposterMaterial.ts": (
          /*!*******************************************************!*\
            !*** ./src/WebGL/materials/SphereImposterMaterial.ts ***!
            \*******************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              SphereImposterMaterial: () => (
                /* binding */
                l
              )
              /* harmony export */
            });
            var o = n(
              /*! ./ImposterMaterial */
              "./src/WebGL/materials/ImposterMaterial.ts"
            );
            class l extends o.ImposterMaterial {
              constructor(f) {
                super(f), this.shaderID = "sphereimposter", this.setValues(f);
              }
              clone(f = new l()) {
                return super.clone.call(this, f), f;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/materials/SphereImposterOutlineMaterial.ts": (
          /*!**************************************************************!*\
            !*** ./src/WebGL/materials/SphereImposterOutlineMaterial.ts ***!
            \**************************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              SphereImposterOutlineMaterial: () => (
                /* binding */
                u
              )
              /* harmony export */
            });
            var o = n(
              /*! ../../colors */
              "./src/colors.ts"
            ), l = n(
              /*! ./ImposterMaterial */
              "./src/WebGL/materials/ImposterMaterial.ts"
            );
            class u extends l.ImposterMaterial {
              constructor(h) {
                super(h), h = h || {}, this.shaderID = "sphereimposteroutline", this.outlineColor = h.color || new o.Color(0, 0, 0), this.outlineWidth = h.width || 0.1, this.outlinePushback = h.pushback || 1, this.setValues(h);
              }
              clone(h = new u()) {
                return super.clone.call(this, h), h.outlineColor = this.outlineColor, h.outlineWidth = this.outlineWidth, h.outlinePushback = this.outlinePushback, h;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/materials/SpriteMaterial.ts": (
          /*!***********************************************!*\
            !*** ./src/WebGL/materials/SpriteMaterial.ts ***!
            \***********************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              SpriteMaterial: () => (
                /* binding */
                p
              )
              /* harmony export */
            });
            var o = n(
              /*! ../constants/SpriteAlignment */
              "./src/WebGL/constants/SpriteAlignment.ts"
            ), l = n(
              /*! ../core/Texture */
              "./src/WebGL/core/Texture.ts"
            ), u = n(
              /*! ../../colors */
              "./src/colors.ts"
            ), f = n(
              /*! ../math */
              "./src/WebGL/math/index.ts"
            ), h = n(
              /*! ./Material */
              "./src/WebGL/materials/Material.ts"
            );
            class p extends h.Material {
              constructor(g) {
                super(), this.color = new u.Color(16777215), this.map = new l.Texture(), this.useScreenCoordinates = !0, this.fog = !1, this.uvOffset = new f.Vector2(0, 0), this.uvScale = new f.Vector2(1, 1), this.depthTest = !this.useScreenCoordinates, this.sizeAttenuation = !this.useScreenCoordinates, this.screenOffset = this.screenOffset, this.scaleByViewPort = !this.sizeAttenuation, this.alignment = o.SpriteAlignment.center.clone(), this.setValues(g), g = g || {}, g.depthTest === void 0 && (this.depthTest = !this.useScreenCoordinates), g.sizeAttenuation === void 0 && (this.sizeAttenuation = !this.useScreenCoordinates), g.scaleByViewPort === void 0 && (this.scaleByViewPort = !this.sizeAttenuation);
              }
              clone(g = new p()) {
                return super.clone.call(this, g), g.color.copy(this.color), g.map = this.map, g.useScreenCoordinates = this.useScreenCoordinates, g.screenOffset = this.screenOffset, g.sizeAttenuation = this.sizeAttenuation, g.scaleByViewport = this.scaleByViewPort, g.alignment.copy(this.alignment), g.uvOffset.copy(this.uvOffset), g;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/materials/StickImposterMaterial.ts": (
          /*!******************************************************!*\
            !*** ./src/WebGL/materials/StickImposterMaterial.ts ***!
            \******************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              StickImposterMaterial: () => (
                /* binding */
                l
              )
              /* harmony export */
            });
            var o = n(
              /*! ./ImposterMaterial */
              "./src/WebGL/materials/ImposterMaterial.ts"
            );
            class l extends o.ImposterMaterial {
              constructor(f) {
                super(f), this.shaderID = "stickimposter", this.setValues(f);
              }
              clone(f = new l()) {
                return super.clone.call(this, f), f;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/materials/StickImposterOutlineMaterial.ts": (
          /*!*************************************************************!*\
            !*** ./src/WebGL/materials/StickImposterOutlineMaterial.ts ***!
            \*************************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              StickImposterOutlineMaterial: () => (
                /* binding */
                u
              )
              /* harmony export */
            });
            var o = n(
              /*! ../../colors */
              "./src/colors.ts"
            ), l = n(
              /*! ./ImposterMaterial */
              "./src/WebGL/materials/ImposterMaterial.ts"
            );
            class u extends l.ImposterMaterial {
              constructor(h = {}) {
                super(h), this.shaderID = "stickimposteroutline", this.outlineColor = new o.Color(0, 0, 0), this.outlineWidth = 0.1, this.outlinePushback = 1, h.color && (this.outlineColor = h.color), h.width && (this.outlineWidth = h.width), h.pushback && (this.outlinePushback = h.pushback), this.setValues(h);
              }
              clone(h = new u()) {
                return super.clone.call(this, h), h.outlineColor = this.outlineColor, h.outlineWidth = this.outlineWidth, h.outlinePushback = this.outlinePushback, h;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/materials/VolumetricMaterial.ts": (
          /*!***************************************************!*\
            !*** ./src/WebGL/materials/VolumetricMaterial.ts ***!
            \***************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              VolumetricMaterial: () => (
                /* binding */
                f
              )
              /* harmony export */
            });
            var o = n(
              /*! ../constants/Sides */
              "./src/WebGL/constants/Sides.ts"
            ), l = n(
              /*! ../../colors */
              "./src/colors.ts"
            ), u = n(
              /*! ./Material */
              "./src/WebGL/materials/Material.ts"
            );
            class f extends u.Material {
              constructor(p) {
                super(), this.transparent = !1, this.volumetric = !0, this.color = new l.Color(16777215), this.transferfn = null, this.map = void 0, this.extent = [], this.maxdepth = 100, this.unit = 0, this.texmatrix = null, this.transfermin = -1, this.transfermax = 1, this.subsamples = 5, this.shaderID = "volumetric", this.side = o.FrontSide, this.setValues(p);
              }
              clone(p = new f()) {
                return super.clone.call(this, p), p.transparent = this.transparent, p.volumetric = this.volumetric, p.color = this.color, p.transferfn = this.transferfn, p.map = this.map, p.extent = this.extent, p.maxdepth = this.maxdepth, p.unit = this.unit, p.texmatrix = this.texmatrix, p.transfermin = this.transfermin, p.transfermax = this.transfermax, p.subsamples = this.subsamples, p.shaderID = this.shaderID, p.side = this.side, p;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/materials/index.ts": (
          /*!**************************************!*\
            !*** ./src/WebGL/materials/index.ts ***!
            \**************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              ImposterMaterial: () => (
                /* reexport safe */
                o.ImposterMaterial
              ),
              /* harmony export */
              InstancedMaterial: () => (
                /* reexport safe */
                l.InstancedMaterial
              ),
              /* harmony export */
              LineBasicMaterial: () => (
                /* reexport safe */
                u.LineBasicMaterial
              ),
              /* harmony export */
              Material: () => (
                /* reexport safe */
                f.Material
              ),
              /* harmony export */
              MaterialIdCount: () => (
                /* reexport safe */
                f.MaterialIdCount
              ),
              /* harmony export */
              MeshDoubleLambertMaterial: () => (
                /* reexport safe */
                h.MeshDoubleLambertMaterial
              ),
              /* harmony export */
              MeshLambertMaterial: () => (
                /* reexport safe */
                p.MeshLambertMaterial
              ),
              /* harmony export */
              MeshOutlineMaterial: () => (
                /* reexport safe */
                v.MeshOutlineMaterial
              ),
              /* harmony export */
              SphereImposterMaterial: () => (
                /* reexport safe */
                g.SphereImposterMaterial
              ),
              /* harmony export */
              SphereImposterOutlineMaterial: () => (
                /* reexport safe */
                w.SphereImposterOutlineMaterial
              ),
              /* harmony export */
              SpriteMaterial: () => (
                /* reexport safe */
                E.SpriteMaterial
              ),
              /* harmony export */
              StickImposterMaterial: () => (
                /* reexport safe */
                T.StickImposterMaterial
              ),
              /* harmony export */
              StickImposterOutlineMaterial: () => (
                /* reexport safe */
                R.StickImposterOutlineMaterial
              ),
              /* harmony export */
              VolumetricMaterial: () => (
                /* reexport safe */
                _.VolumetricMaterial
              )
              /* harmony export */
            });
            var o = n(
              /*! ./ImposterMaterial */
              "./src/WebGL/materials/ImposterMaterial.ts"
            ), l = n(
              /*! ./InstancedMaterial */
              "./src/WebGL/materials/InstancedMaterial.ts"
            ), u = n(
              /*! ./LineBasicMaterial */
              "./src/WebGL/materials/LineBasicMaterial.ts"
            ), f = n(
              /*! ./Material */
              "./src/WebGL/materials/Material.ts"
            ), h = n(
              /*! ./MeshDoubleLambertMaterial */
              "./src/WebGL/materials/MeshDoubleLambertMaterial.ts"
            ), p = n(
              /*! ./MeshLambertMaterial */
              "./src/WebGL/materials/MeshLambertMaterial.ts"
            ), v = n(
              /*! ./MeshOutlineMaterial */
              "./src/WebGL/materials/MeshOutlineMaterial.ts"
            ), g = n(
              /*! ./SphereImposterMaterial */
              "./src/WebGL/materials/SphereImposterMaterial.ts"
            ), w = n(
              /*! ./SphereImposterOutlineMaterial */
              "./src/WebGL/materials/SphereImposterOutlineMaterial.ts"
            ), E = n(
              /*! ./SpriteMaterial */
              "./src/WebGL/materials/SpriteMaterial.ts"
            ), T = n(
              /*! ./StickImposterMaterial */
              "./src/WebGL/materials/StickImposterMaterial.ts"
            ), R = n(
              /*! ./StickImposterOutlineMaterial */
              "./src/WebGL/materials/StickImposterOutlineMaterial.ts"
            ), _ = n(
              /*! ./VolumetricMaterial */
              "./src/WebGL/materials/VolumetricMaterial.ts"
            );
          }
        ),
        /***/
        "./src/WebGL/math/Quaternion.ts": (
          /*!**************************************!*\
            !*** ./src/WebGL/math/Quaternion.ts ***!
            \**************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              Quaternion: () => (
                /* binding */
                o
              )
              /* harmony export */
            });
            class o {
              constructor(u, f, h, p) {
                this.x = u || 0, this.y = f || 0, this.z = h || 0, this.w = p !== void 0 ? p : 1;
              }
              set(u, f, h, p) {
                return this.x = u, this.y = f, this.z = h, this.w = p, this;
              }
              copy(u) {
                return this.x = u.x, this.y = u.y, this.z = u.z, this.w = u.w, this;
              }
              conjugate() {
                return this.x *= -1, this.y *= -1, this.z *= -1, this;
              }
              inverse() {
                return this.conjugate().normalize();
              }
              length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
              }
              lengthxyz() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
              }
              normalize() {
                let u = this.length();
                return u === 0 ? (this.x = 0, this.y = 0, this.z = 0, this.w = 1) : (u = 1 / u, this.x *= u, this.y *= u, this.z *= u, this.w *= u), this;
              }
              multiply(u) {
                return this.multiplyQuaternions(this, u);
              }
              multiplyScalar(u) {
                return this.x *= u, this.y *= u, this.z *= u, this.w *= u, this;
              }
              multiplyQuaternions(u, f) {
                const h = u.x, p = u.y, v = u.z, g = u.w, w = f.x, E = f.y, T = f.z, R = f.w;
                return this.x = h * R + g * w + p * T - v * E, this.y = p * R + g * E + v * w - h * T, this.z = v * R + g * T + h * E - p * w, this.w = g * R - h * w - p * E - v * T, this;
              }
              sub(u) {
                return this.x -= u.x, this.y -= u.y, this.z -= u.z, this.w -= u.w, this;
              }
              clone() {
                return new o(this.x, this.y, this.z, this.w);
              }
              setFromEuler(u) {
                const f = Math.cos(u.x / 2), h = Math.cos(u.y / 2), p = Math.cos(u.z / 2), v = Math.sin(u.x / 2), g = Math.sin(u.y / 2), w = Math.sin(u.z / 2);
                return this.x = v * h * p + f * g * w, this.y = f * g * p - v * h * w, this.z = f * h * w + v * g * p, this.w = f * h * p - v * g * w, this;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/math/Vector2.ts": (
          /*!***********************************!*\
            !*** ./src/WebGL/math/Vector2.ts ***!
            \***********************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              Vector2: () => (
                /* binding */
                o
              )
              /* harmony export */
            });
            class o {
              constructor(u, f) {
                this.x = u || 0, this.y = f || 0;
              }
              set(u, f) {
                return this.x = u, this.y = f, this;
              }
              subVectors(u, f) {
                return this.x = u.x - f.x, this.y = u.y - f.y, this;
              }
              copy(u) {
                return this.x = u.x, this.y = u.y, this;
              }
              clone() {
                return new o(this.x, this.y);
              }
            }
          }
        ),
        /***/
        "./src/WebGL/math/index.ts": (
          /*!*********************************!*\
            !*** ./src/WebGL/math/index.ts ***!
            \*********************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              Matrix3: () => (
                /* reexport safe */
                p.Matrix3
              ),
              /* harmony export */
              Matrix4: () => (
                /* reexport safe */
                p.Matrix4
              ),
              /* harmony export */
              Quaternion: () => (
                /* reexport safe */
                o.Quaternion
              ),
              /* harmony export */
              Ray: () => (
                /* reexport safe */
                p.Ray
              ),
              /* harmony export */
              Vector2: () => (
                /* reexport safe */
                l.Vector2
              ),
              /* harmony export */
              Vector3: () => (
                /* reexport safe */
                p.Vector3
              ),
              /* harmony export */
              clamp: () => (
                /* reexport safe */
                u.clamp
              ),
              /* harmony export */
              conversionMatrix3: () => (
                /* reexport safe */
                f.conversionMatrix3
              ),
              /* harmony export */
              degToRad: () => (
                /* reexport safe */
                h.degToRad
              )
              /* harmony export */
            });
            var o = n(
              /*! ./Quaternion */
              "./src/WebGL/math/Quaternion.ts"
            ), l = n(
              /*! ./Vector2 */
              "./src/WebGL/math/Vector2.ts"
            ), u = n(
              /*! ./utils/clamp */
              "./src/WebGL/math/utils/clamp.ts"
            ), f = n(
              /*! ./utils/conversionMatrix3 */
              "./src/WebGL/math/utils/conversionMatrix3.ts"
            ), h = n(
              /*! ./utils/degToRad */
              "./src/WebGL/math/utils/degToRad.ts"
            ), p = n(
              /*! ./math */
              "./src/WebGL/math/math.ts"
            );
          }
        ),
        /***/
        "./src/WebGL/math/math.ts": (
          /*!********************************!*\
            !*** ./src/WebGL/math/math.ts ***!
            \********************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              Matrix3: () => (
                /* binding */
                E
              ),
              /* harmony export */
              Matrix4: () => (
                /* binding */
                g
              ),
              /* harmony export */
              Ray: () => (
                /* binding */
                T
              ),
              /* harmony export */
              Vector3: () => (
                /* binding */
                w
              )
              /* harmony export */
            });
            var o = n(
              /*! ./utils/degToRad */
              "./src/WebGL/math/utils/degToRad.ts"
            ), l = n(
              /*! ./utils/clamp */
              "./src/WebGL/math/utils/clamp.ts"
            ), u, f, h, p, v;
            class g {
              constructor(_ = 1, b = 0, M = 0, A = 0, $ = 0, S = 1, C = 0, D = 0, O = 0, N = 0, j = 1, L = 0, z = 0, G = 0, B = 0, F = 1) {
                typeof _ < "u" && typeof _ != "number" ? this.elements = new Float32Array(_) : (this.elements = new Float32Array(16), this.elements[0] = _, this.elements[4] = b, this.elements[8] = M, this.elements[12] = A, this.elements[1] = $, this.elements[5] = S, this.elements[9] = C, this.elements[13] = D, this.elements[2] = O, this.elements[6] = N, this.elements[10] = j, this.elements[14] = L, this.elements[3] = z, this.elements[7] = G, this.elements[11] = B, this.elements[15] = F);
              }
              // eslint-disable-next-line no-unused-vars, class-methods-use-this
              makeScale(_, b, M) {
                throw new Error("Method not implemented.");
              }
              set(_, b, M, A, $, S, C, D, O, N, j, L, z, G, B, F) {
                const H = this.elements;
                return H[0] = _, H[4] = b, H[8] = M, H[12] = A, H[1] = $, H[5] = S, H[9] = C, H[13] = D, H[2] = O, H[6] = N, H[10] = j, H[14] = L, H[3] = z, H[7] = G, H[11] = B, H[15] = F, this;
              }
              identity() {
                return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
              }
              copy(_) {
                const b = _.elements;
                return this.set(b[0], b[4], b[8], b[12], b[1], b[5], b[9], b[13], b[2], b[6], b[10], b[14], b[3], b[7], b[11], b[15]), this;
              }
              matrix3FromTopLeft() {
                const _ = this.elements;
                return new E(_[0], _[4], _[8], _[1], _[5], _[9], _[2], _[6], _[10]);
              }
              setRotationFromEuler(_, b) {
                const M = this.elements, { x: A, y: $, z: S } = _, C = Math.cos(A), D = Math.sin(A), O = Math.cos($), N = Math.sin($), j = Math.cos(S), L = Math.sin(S);
                if (b === void 0 || b === "XYZ") {
                  const z = C * j, G = C * L, B = D * j, F = D * L;
                  M[0] = O * j, M[4] = -O * L, M[8] = N, M[1] = G + B * N, M[5] = z - F * N, M[9] = -D * O, M[2] = F - z * N, M[6] = B + G * N, M[10] = C * O;
                } else
                  console.error(`Error with matrix4 setRotationFromEuler. Order: ${b}`);
                return this;
              }
              setRotationFromQuaternion(_) {
                const b = this.elements, { x: M, y: A, z: $, w: S } = _, C = M + M, D = A + A, O = $ + $, N = M * C, j = M * D, L = M * O, z = A * D, G = A * O, B = $ * O, F = S * C, H = S * D, W = S * O;
                return b[0] = 1 - (z + B), b[4] = j - W, b[8] = L + H, b[1] = j + W, b[5] = 1 - (N + B), b[9] = G - F, b[2] = L - H, b[6] = G + F, b[10] = 1 - (N + z), this;
              }
              multiplyMatrices(_, b) {
                const M = _.elements, A = b.elements, $ = this.elements, S = M[0], C = M[4], D = M[8], O = M[12], N = M[1], j = M[5], L = M[9], z = M[13], G = M[2], B = M[6], F = M[10], H = M[14], W = M[3], V = M[7], X = M[11], Z = M[15], Q = A[0], q = A[4], J = A[8], ie = A[12], ne = A[1], ge = A[5], ye = A[9], xe = A[13], we = A[2], de = A[6], Te = A[10], Ce = A[14], ee = A[3], Ae = A[7], be = A[11], Fe = A[15];
                return $[0] = S * Q + C * ne + D * we + O * ee, $[4] = S * q + C * ge + D * de + O * Ae, $[8] = S * J + C * ye + D * Te + O * be, $[12] = S * ie + C * xe + D * Ce + O * Fe, $[1] = N * Q + j * ne + L * we + z * ee, $[5] = N * q + j * ge + L * de + z * Ae, $[9] = N * J + j * ye + L * Te + z * be, $[13] = N * ie + j * xe + L * Ce + z * Fe, $[2] = G * Q + B * ne + F * we + H * ee, $[6] = G * q + B * ge + F * de + H * Ae, $[10] = G * J + B * ye + F * Te + H * be, $[14] = G * ie + B * xe + F * Ce + H * Fe, $[3] = W * Q + V * ne + X * we + Z * ee, $[7] = W * q + V * ge + X * de + Z * Ae, $[11] = W * J + V * ye + X * Te + Z * be, $[15] = W * ie + V * xe + X * Ce + Z * Fe, this;
              }
              multiplyScalar(_) {
                const b = this.elements;
                return b[0] *= _, b[4] *= _, b[8] *= _, b[12] *= _, b[1] *= _, b[5] *= _, b[9] *= _, b[13] *= _, b[2] *= _, b[6] *= _, b[10] *= _, b[14] *= _, b[3] *= _, b[7] *= _, b[11] *= _, b[15] *= _, this;
              }
              makeTranslation(_, b, M) {
                return this.set(1, 0, 0, _, 0, 1, 0, b, 0, 0, 1, M, 0, 0, 0, 1), this;
              }
              // snap values close to integers to their integer value
              // useful and identifying identity matrices
              snap(_) {
                const b = Math.pow(10, 4), M = this.elements;
                for (let A = 0; A < 16; A++) {
                  const $ = Math.round(M[A]);
                  $ === Math.round(M[A] * b) / b && (M[A] = $);
                }
                return this;
              }
              transpose() {
                const _ = this.elements;
                let b;
                return b = _[1], _[1] = _[4], _[4] = b, b = _[2], _[2] = _[8], _[8] = b, b = _[6], _[6] = _[9], _[9] = b, b = _[3], _[3] = _[12], _[12] = b, b = _[7], _[7] = _[13], _[13] = b, b = _[11], _[11] = _[14], _[14] = b, this;
              }
              setPosition(_) {
                const b = this.elements;
                return b[12] = _.x, b[13] = _.y, b[14] = _.z, this;
              }
              translate(_) {
                const b = this.elements;
                return b[12] += _.x, b[13] += _.y, b[14] += _.z, this;
              }
              getInverse(_, b) {
                const M = this.elements, A = _.elements, $ = A[0], S = A[4], C = A[8], D = A[12], O = A[1], N = A[5], j = A[9], L = A[13], z = A[2], G = A[6], B = A[10], F = A[14], H = A[3], W = A[7], V = A[11], X = A[15];
                M[0] = j * F * W - L * B * W + L * G * V - N * F * V - j * G * X + N * B * X, M[4] = D * B * W - C * F * W - D * G * V + S * F * V + C * G * X - S * B * X, M[8] = C * L * W - D * j * W + D * N * V - S * L * V - C * N * X + S * j * X, M[12] = D * j * G - C * L * G - D * N * B + S * L * B + C * N * F - S * j * F, M[1] = L * B * H - j * F * H - L * z * V + O * F * V + j * z * X - O * B * X, M[5] = C * F * H - D * B * H + D * z * V - $ * F * V - C * z * X + $ * B * X, M[9] = D * j * H - C * L * H - D * O * V + $ * L * V + C * O * X - $ * j * X, M[13] = C * L * z - D * j * z + D * O * B - $ * L * B - C * O * F + $ * j * F, M[2] = N * F * H - L * G * H + L * z * W - O * F * W - N * z * X + O * G * X, M[6] = D * G * H - S * F * H - D * z * W + $ * F * W + S * z * X - $ * G * X, M[10] = S * L * H - D * N * H + D * O * W - $ * L * W - S * O * X + $ * N * X, M[14] = D * N * z - S * L * z - D * O * G + $ * L * G + S * O * F - $ * N * F, M[3] = j * G * H - N * B * H - j * z * W + O * B * W + N * z * V - O * G * V, M[7] = S * B * H - C * G * H + C * z * W - $ * B * W - S * z * V + $ * G * V, M[11] = C * N * H - S * j * H - C * O * W + $ * j * W + S * O * V - $ * N * V, M[15] = S * j * z - C * N * z + C * O * G - $ * j * G - S * O * B + $ * N * B;
                const Z = $ * M[0] + O * M[4] + z * M[8] + H * M[12];
                if (Z === 0) {
                  const Q = "Matrix4.getInverse(): can't invert matrix, determinant is 0";
                  if (b)
                    throw new Error(Q);
                  return console.warn(Q), this.identity(), this;
                }
                return this.multiplyScalar(1 / Z), this;
              }
              isReflected() {
                const _ = this.elements, b = _[0], M = _[4], A = _[8], $ = _[1], S = _[5], C = _[9], D = _[2], O = _[6], N = _[10];
                return b * S * N + // +aei
                $ * O * A + // +bfg
                D * M * C - // +cdh
                D * S * A - // -ceg
                $ * M * N - // -bdi
                b * O * C < 0;
              }
              scale(_) {
                const b = this.elements, { x: M } = _, { y: A } = _, { z: $ } = _;
                return b[0] *= M, b[4] *= A, b[8] *= $, b[1] *= M, b[5] *= A, b[9] *= $, b[2] *= M, b[6] *= A, b[10] *= $, b[3] *= M, b[7] *= A, b[11] *= $, this;
              }
              getMaxScaleOnAxis() {
                const _ = this.elements, b = _[0] * _[0] + _[1] * _[1] + _[2] * _[2], M = _[4] * _[4] + _[5] * _[5] + _[6] * _[6], A = _[8] * _[8] + _[9] * _[9] + _[10] * _[10];
                return Math.sqrt(Math.max(b, Math.max(M, A)));
              }
              makeFrustum(_, b, M, A, $, S) {
                const C = this.elements, D = 2 * $ / (b - _), O = 2 * $ / (A - M), N = (b + _) / (b - _), j = (A + M) / (A - M), L = -(S + $) / (S - $), z = -2 * S * $ / (S - $);
                return C[0] = D, C[4] = 0, C[8] = N, C[12] = 0, C[1] = 0, C[5] = O, C[9] = j, C[13] = 0, C[2] = 0, C[6] = 0, C[10] = L, C[14] = z, C[3] = 0, C[7] = 0, C[11] = -1, C[15] = 0, this;
              }
              makePerspective(_, b, M, A) {
                const $ = M * Math.tan((0, o.degToRad)(_ * 0.5)), S = -$, C = S * b, D = $ * b;
                return this.makeFrustum(C, D, S, $, M, A);
              }
              makeOrthographic(_, b, M, A, $, S) {
                const C = this.elements, D = 1 / (b - _), O = 1 / (M - A), N = 1 / (S - $), j = (b + _) * D, L = (M + A) * O, z = (S + $) * N;
                return C[0] = 2 * D, C[4] = 0, C[8] = 0, C[12] = -j, C[1] = 0, C[5] = 2 * O, C[9] = 0, C[13] = -L, C[2] = 0, C[6] = 0, C[10] = -2 * N, C[14] = -z, C[3] = 0, C[7] = 0, C[11] = 0, C[15] = 1, this;
              }
              isEqual(_) {
                const b = _.elements, M = this.elements;
                return M[0] === b[0] && M[4] === b[4] && M[8] === b[8] && M[12] === b[12] && M[1] === b[1] && M[5] === b[5] && M[9] === b[9] && M[13] === b[13] && M[2] === b[2] && M[6] === b[6] && M[10] === b[10] && M[14] === b[14] && M[3] === b[3] && M[7] === b[7] && M[11] === b[11] && M[15] === b[15];
              }
              clone() {
                const _ = this.elements;
                return new g(_[0], _[4], _[8], _[12], _[1], _[5], _[9], _[13], _[2], _[6], _[10], _[14], _[3], _[7], _[11], _[15]);
              }
              isIdentity() {
                const _ = this.elements;
                return _[0] === 1 && _[4] === 0 && _[8] === 0 && _[12] === 0 && _[1] === 0 && _[5] === 1 && _[9] === 0 && _[13] === 0 && _[2] === 0 && _[6] === 0 && _[10] === 1 && _[14] === 0 && _[3] === 0 && _[7] === 0 && _[11] === 0 && _[15] === 1;
              }
              // return true if elements are with digits of identity
              isNearlyIdentity(_) {
                return this.clone().snap(_).isIdentity();
              }
              getScale(_) {
                const b = this.elements;
                return _ = _ || new w(), h.set(b[0], b[1], b[2]), p.set(b[4], b[5], b[6]), v.set(b[8], b[9], b[10]), _.x = h.length(), _.y = p.length(), _.z = v.length(), _;
              }
              lookAt(_, b, M) {
                const A = this.elements;
                return v.subVectors(_, b).normalize(), v.length() === 0 && (v.z = 1), h.crossVectors(M, v).normalize(), h.length() === 0 && (v.x += 1e-4, h.crossVectors(M, v).normalize()), p.crossVectors(v, h), A[0] = h.x, A[4] = p.x, A[8] = v.x, A[1] = h.y, A[5] = p.y, A[9] = v.y, A[2] = h.z, A[6] = p.z, A[10] = v.z, this;
              }
              compose(_, b, M) {
                const A = this.elements;
                return u.identity(), u.setRotationFromQuaternion(b), f.makeScale(M.x, M.y, M.z), this.multiplyMatrices(u, f), A[12] = _.x, A[13] = _.y, A[14] = _.z, this;
              }
            }
            u = new g(), f = new g();
            class w {
              constructor(_, b, M) {
                this.x = _ || 0, this.y = b || 0, this.z = M || 0, this.atomid = void 0;
              }
              set(_, b, M) {
                return this.x = _, this.y = b, this.z = M, this;
              }
              copy(_) {
                return this.x = _.x, this.y = _.y, this.z = _.z, this;
              }
              add(_) {
                return this.x += _.x, this.y += _.y, this.z += _.z, this;
              }
              addVectors(_, b) {
                return this.x = _.x + b.x, this.y = _.y + b.y, this.z = _.z + b.z, this;
              }
              multiplyVectors(_, b) {
                return this.x = _.x * b.x, this.y = _.y * b.y, this.z = _.z * b.z, this;
              }
              sub(_) {
                return this.x -= _.x, this.y -= _.y, this.z -= _.z, this;
              }
              subVectors(_, b) {
                return this.x = _.x - b.x, this.y = _.y - b.y, this.z = _.z - b.z, this;
              }
              multiplyScalar(_) {
                return this.x *= _, this.y *= _, this.z *= _, this;
              }
              divideScalar(_) {
                return _ !== 0 ? (this.x /= _, this.y /= _, this.z /= _) : (this.x = 0, this.y = 0, this.z = 0), this;
              }
              // accumulate maximum
              max(_) {
                return this.x = Math.max(this.x, _.x), this.y = Math.max(this.y, _.y), this.z = Math.max(this.z, _.z), this;
              }
              // accumulate min
              min(_) {
                return this.x = Math.min(this.x, _.x), this.y = Math.min(this.y, _.y), this.z = Math.min(this.z, _.z), this;
              }
              distanceTo(_) {
                return Math.sqrt(this.distanceToSquared(_));
              }
              distanceToSquared(_) {
                const b = this.x - _.x, M = this.y - _.y, A = this.z - _.z;
                return b * b + M * M + A * A;
              }
              applyMatrix3(_) {
                const { x: b } = this, { y: M } = this, { z: A } = this, $ = _.elements;
                return this.x = $[0] * b + $[3] * M + $[6] * A, this.y = $[1] * b + $[4] * M + $[7] * A, this.z = $[2] * b + $[5] * M + $[8] * A, this;
              }
              applyMatrix4(_) {
                const { x: b } = this, { y: M } = this, { z: A } = this, $ = _.elements;
                return this.x = $[0] * b + $[4] * M + $[8] * A + $[12], this.y = $[1] * b + $[5] * M + $[9] * A + $[13], this.z = $[2] * b + $[6] * M + $[10] * A + $[14], this;
              }
              applyProjection(_) {
                const { x: b } = this, { y: M } = this, { z: A } = this, $ = _.elements, S = $[3] * b + $[7] * M + $[11] * A + $[15];
                return this.x = ($[0] * b + $[4] * M + $[8] * A + $[12]) / S, this.y = ($[1] * b + $[5] * M + $[9] * A + $[13]) / S, this.z = ($[2] * b + $[6] * M + $[10] * A + $[14]) / S, this;
              }
              applyQuaternion(_) {
                const { x: b } = this, { y: M } = this, { z: A } = this, $ = _.x, S = _.y, C = _.z, D = _.w, O = {};
                O.x = 2 * (M * C - A * S), O.y = 2 * (A * $ - b * C), O.z = 2 * (b * S - M * $);
                const N = {};
                return N.x = O.y * C - O.z * S, N.y = O.z * $ - O.x * C, N.z = O.x * S - O.y * $, this.x = b + D * O.x + N.x, this.y = M + D * O.y + N.y, this.z = A + D * O.z + N.z, this;
              }
              negate() {
                return this.multiplyScalar(-1);
              }
              dot(_) {
                return this.x * _.x + this.y * _.y + this.z * _.z;
              }
              length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
              }
              lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z;
              }
              normalize() {
                return this.divideScalar(this.length());
              }
              cross(_) {
                const { x: b } = this, { y: M } = this, { z: A } = this;
                return this.x = M * _.z - A * _.y, this.y = A * _.x - b * _.z, this.z = b * _.y - M * _.x, this;
              }
              crossVectors(_, b) {
                return this.x = _.y * b.z - _.z * b.y, this.y = _.z * b.x - _.x * b.z, this.z = _.x * b.y - _.y * b.x, this;
              }
              equals(_) {
                return this.x == _.x && this.y == _.y && this.z == _.z;
              }
              getPositionFromMatrix(_) {
                return this.x = _.elements[12], this.y = _.elements[13], this.z = _.elements[14], this;
              }
              setEulerFromRotationMatrix(_, b) {
                const M = _.elements, A = M[0], $ = M[4], S = M[8], C = M[5], D = M[9], O = M[6], N = M[10];
                return b === void 0 || b === "XYZ" ? (this.y = Math.asin((0, l.clamp)(S, -1, 1)), Math.abs(S) < 0.99999 ? (this.x = Math.atan2(-D, N), this.z = Math.atan2(-$, A)) : (this.x = Math.atan2(O, C), this.z = 0)) : console.error(`Error with vector's setEulerFromRotationMatrix: Unknown order: ${b}`), this;
              }
              rotateAboutVector(_, b) {
                _.normalize();
                const M = Math.cos(b), A = Math.sin(b), $ = this.clone().multiplyScalar(M), S = _.clone().cross(this).multiplyScalar(A), C = _.clone().multiplyScalar(_.clone().dot(this)).multiplyScalar(1 - M), D = $.add(S).add(C);
                return this.x = D.x, this.y = D.y, this.z = D.z, this;
              }
              setFromMatrixPosition(_) {
                const b = _.elements;
                return this.x = b[12], this.y = b[13], this.z = b[14], this;
              }
              // unproject is defined after Matrix4
              transformDirection(_) {
                const { x: b } = this, { y: M } = this, { z: A } = this, $ = _.elements;
                return this.x = $[0] * b + $[4] * M + $[8] * A, this.y = $[1] * b + $[5] * M + $[9] * A, this.z = $[2] * b + $[6] * M + $[10] * A, this.normalize();
              }
              clone() {
                return new w(this.x, this.y, this.z);
              }
              unproject(_) {
                const b = u;
                return b.multiplyMatrices(_.matrixWorld, b.getInverse(_.projectionMatrix)), this.applyMatrix4(b);
              }
            }
            h = new w(), p = new w(), v = new w();
            class E {
              constructor(_ = 1, b = 0, M = 0, A = 0, $ = 1, S = 0, C = 0, D = 0, O = 1) {
                this.elements = new Float32Array(9), this.set(_, b, M, A, $, S, C, D, O);
              }
              set(_, b, M, A, $, S, C, D, O) {
                const N = this.elements;
                return N[0] = _, N[3] = b, N[6] = M, N[1] = A, N[4] = $, N[7] = S, N[2] = C, N[5] = D, N[8] = O, this;
              }
              identity() {
                return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
              }
              copy(_) {
                const b = _.elements;
                this.set(b[0], b[3], b[6], b[1], b[4], b[7], b[2], b[5], b[8]);
              }
              multiplyScalar(_) {
                const b = this.elements;
                return b[0] *= _, b[3] *= _, b[6] *= _, b[1] *= _, b[4] *= _, b[7] *= _, b[2] *= _, b[5] *= _, b[8] *= _, this;
              }
              getInverse3(_) {
                const b = _.elements, M = this.elements;
                M[0] = b[4] * b[8] - b[5] * b[7], M[3] = b[6] * b[5] - b[3] * b[8], M[6] = b[3] * b[7] - b[6] * b[4], M[1] = b[7] * b[2] - b[1] * b[8], M[4] = b[0] * b[8] - b[6] * b[2], M[7] = b[1] * b[6] - b[0] * b[7], M[2] = b[1] * b[5] - b[2] * b[4], M[5] = b[2] * b[3] - b[0] * b[5], M[8] = b[0] * b[4] - b[1] * b[3];
                const A = b[0] * M[0] + b[3] * M[1] + b[6] * M[2];
                return this.multiplyScalar(1 / A), this;
              }
              getInverse(_, b) {
                const M = _.elements, A = this.elements;
                A[0] = M[10] * M[5] - M[6] * M[9], A[1] = -M[10] * M[1] + M[2] * M[9], A[2] = M[6] * M[1] - M[2] * M[5], A[3] = -M[10] * M[4] + M[6] * M[8], A[4] = M[10] * M[0] - M[2] * M[8], A[5] = -M[6] * M[0] + M[2] * M[4], A[6] = M[9] * M[4] - M[5] * M[8], A[7] = -M[9] * M[0] + M[1] * M[8], A[8] = M[5] * M[0] - M[1] * M[4];
                const $ = M[0] * A[0] + M[1] * A[3] + M[2] * A[6];
                if ($ === 0) {
                  const S = "Matrix3.getInverse(): can't invert matrix, determinant is 0";
                  if (b)
                    throw new Error(S);
                  return console.warn(S), this.identity(), this;
                }
                return this.multiplyScalar(1 / $), this;
              }
              // https://en.wikipedia.org/wiki/Determinant
              getDeterminant() {
                const _ = this.elements;
                return _[0] * _[4] * _[8] + // +aei
                _[1] * _[5] * _[6] + // +bfg
                _[2] * _[3] * _[7] - // +cdh
                _[2] * _[4] * _[6] - // -ceg
                _[1] * _[3] * _[8] - // -bdi
                _[0] * _[5] * _[7];
              }
              transpose() {
                let _;
                const b = this.elements;
                return _ = b[1], b[1] = b[3], b[3] = _, _ = b[2], b[2] = b[6], b[6] = _, _ = b[5], b[5] = b[7], b[7] = _, this;
              }
              clone() {
                const _ = this.elements;
                return new E(_[0], _[3], _[6], _[1], _[4], _[7], _[2], _[5], _[8]);
              }
              getMatrix4() {
                const _ = this.elements;
                return new g(_[0], _[3], _[6], 0, _[1], _[4], _[7], 0, _[2], _[5], _[8], 0);
              }
            }
            class T {
              constructor(_, b) {
                this.origin = _ !== void 0 ? _ : new w(), this.direction = b !== void 0 ? b : new w();
              }
              set(_, b) {
                return this.origin.copy(_), this.direction.copy(b), this;
              }
              copy(_) {
                return this.origin.copy(_.origin), this.direction.copy(_.direction), this;
              }
              at(_, b) {
                return (b || new w()).copy(this.direction).multiplyScalar(_).add(this.origin);
              }
              recast(_) {
                const b = h;
                return this.origin.copy(this.at(_, b)), this;
              }
              closestPointToPoint(_, b) {
                const M = b || new w();
                M.subVectors(_, this.origin);
                const A = M.dot(this.direction);
                return M.copy(this.direction).multiplyScalar(A).add(this.origin);
              }
              distanceToPoint(_) {
                const b = h, M = b.subVectors(_, this.origin).dot(this.direction);
                return b.copy(this.direction).multiplyScalar(M).add(this.origin), b.distanceTo(_);
              }
              // eslint-disable-next-line class-methods-use-this
              isIntersectionCylinder() {
              }
              isIntersectionSphere(_) {
                return this.distanceToPoint(_.center) <= _.radius;
              }
              isIntersectionPlane(_) {
                return _.normal.dot(this.direction) !== 0 || _.distanceToPoint(this.origin) === 0;
              }
              distanceToPlane(_) {
                const b = _.normal.dot(this.direction);
                return b === 0 ? _.distanceToPoint(this.origin) === 0 ? 0 : void 0 : -(this.origin.dot(_.normal) + _.constant) / b;
              }
              intersectPlane(_, b) {
                const M = this.distanceToPlane(_);
                if (M !== void 0)
                  return this.at(M, b);
              }
              applyMatrix4(_) {
                return this.direction.add(this.origin).applyMatrix4(_), this.origin.applyMatrix4(_), this.direction.sub(this.origin), this;
              }
              clone() {
                return new T().copy(this);
              }
            }
          }
        ),
        /***/
        "./src/WebGL/math/utils/clamp.ts": (
          /*!***************************************!*\
            !*** ./src/WebGL/math/utils/clamp.ts ***!
            \***************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              clamp: () => (
                /* binding */
                o
              )
              /* harmony export */
            });
            function o(l, u, f) {
              return Math.min(Math.max(l, u), f);
            }
          }
        ),
        /***/
        "./src/WebGL/math/utils/conversionMatrix3.ts": (
          /*!***************************************************!*\
            !*** ./src/WebGL/math/utils/conversionMatrix3.ts ***!
            \***************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              conversionMatrix3: () => (
                /* binding */
                l
              )
              /* harmony export */
            });
            var o = n(
              /*! ../math */
              "./src/WebGL/math/math.ts"
            );
            function l(u, f, h, p, v, g) {
              p = p * Math.PI / 180, v = v * Math.PI / 180, g = g * Math.PI / 180;
              const w = (b) => b * b, E = Math.cos(p), T = Math.cos(v), R = Math.cos(g), _ = Math.sin(g);
              return new o.Matrix3(u, f * R, h * T, 0, f * _, h * (E - T * R) / _, 0, 0, h * Math.sqrt(1 - w(E) - w(T) - w(R) + 2 * E * T * R) / _);
            }
          }
        ),
        /***/
        "./src/WebGL/math/utils/degToRad.ts": (
          /*!******************************************!*\
            !*** ./src/WebGL/math/utils/degToRad.ts ***!
            \******************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              degToRad: () => (
                /* binding */
                l
              )
              /* harmony export */
            });
            const o = Math.PI / 180;
            function l(u) {
              return u * o;
            }
          }
        ),
        /***/
        "./src/WebGL/objects/Line.ts": (
          /*!***********************************!*\
            !*** ./src/WebGL/objects/Line.ts ***!
            \***********************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              Line: () => (
                /* binding */
                f
              ),
              /* harmony export */
              LineStyle: () => (
                /* binding */
                u
              )
              /* harmony export */
            });
            var o = n(
              /*! ../materials */
              "./src/WebGL/materials/index.ts"
            ), l = n(
              /*! ../core */
              "./src/WebGL/core/index.ts"
            ), u;
            (function(h) {
              h[h.LineStrip = 0] = "LineStrip", h[h.LinePieces = 1] = "LinePieces";
            })(u || (u = {}));
            class f extends l.Object3D {
              constructor(p, v = new o.LineBasicMaterial({
                color: Math.random() * 16777215
              }), g = u.LineStrip) {
                super(), this.geometry = p, this.material = v, this.type = g;
              }
              clone(p = new f(this.geometry, this.material, this.type)) {
                return super.clone.call(this, p), p;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/objects/Mesh.ts": (
          /*!***********************************!*\
            !*** ./src/WebGL/objects/Mesh.ts ***!
            \***********************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              Mesh: () => (
                /* binding */
                l
              )
              /* harmony export */
            });
            var o = n(
              /*! ../core */
              "./src/WebGL/core/index.ts"
            );
            class l extends o.Object3D {
              constructor(f, h) {
                super(), this.geometry = f, this.material = h;
              }
              clone(f) {
                return f === void 0 && (f = new l(this.geometry, this.material)), super.clone.call(this, f), f;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/objects/Sprite.ts": (
          /*!*************************************!*\
            !*** ./src/WebGL/objects/Sprite.ts ***!
            \*************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              Sprite: () => (
                /* binding */
                u
              )
              /* harmony export */
            });
            var o = n(
              /*! ../materials */
              "./src/WebGL/materials/index.ts"
            ), l = n(
              /*! ../core */
              "./src/WebGL/core/index.ts"
            );
            class u extends l.Object3D {
              constructor(h = new o.SpriteMaterial()) {
                super(), this.material = h, this.rotation3d = this.rotation, this.rotation = 0;
              }
              updateMatrix() {
                this.matrix.setPosition(this.position), this.rotation3d.set(0, 0, this.rotation), this.matrix.setRotationFromEuler(this.rotation3d), (this.scale.x !== 1 || this.scale.y !== 1) && this.matrix.scale(this.scale), this.matrixWorldNeedsUpdate = !0;
              }
              clone(h = new u(this.material)) {
                return l.Object3D.prototype.clone.call(this, h), h;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/objects/index.ts": (
          /*!************************************!*\
            !*** ./src/WebGL/objects/index.ts ***!
            \************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              Line: () => (
                /* reexport safe */
                o.Line
              ),
              /* harmony export */
              LineStyle: () => (
                /* reexport safe */
                o.LineStyle
              ),
              /* harmony export */
              Mesh: () => (
                /* reexport safe */
                l.Mesh
              ),
              /* harmony export */
              Sprite: () => (
                /* reexport safe */
                u.Sprite
              )
              /* harmony export */
            });
            var o = n(
              /*! ./Line */
              "./src/WebGL/objects/Line.ts"
            ), l = n(
              /*! ./Mesh */
              "./src/WebGL/objects/Mesh.ts"
            ), u = n(
              /*! ./Sprite */
              "./src/WebGL/objects/Sprite.ts"
            );
          }
        ),
        /***/
        "./src/WebGL/shaders/ShaderType.ts": (
          /*!*****************************************!*\
            !*** ./src/WebGL/shaders/ShaderType.ts ***!
            \*****************************************/
          /***/
          (t, e, n) => {
            n.r(e);
          }
        ),
        /***/
        "./src/WebGL/shaders/index.ts": (
          /*!************************************!*\
            !*** ./src/WebGL/shaders/index.ts ***!
            \************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              ShaderLib: () => (
                /* reexport safe */
                o.ShaderLib
              ),
              /* harmony export */
              ShaderUtils: () => (
                /* reexport safe */
                l.ShaderUtils
              ),
              /* harmony export */
              basic: () => (
                /* reexport safe */
                o.basic
              ),
              /* harmony export */
              clone: () => (
                /* reexport safe */
                l.clone
              ),
              /* harmony export */
              instanced: () => (
                /* reexport safe */
                o.instanced
              ),
              /* harmony export */
              lambert: () => (
                /* reexport safe */
                o.lambert
              ),
              /* harmony export */
              lambertdouble: () => (
                /* reexport safe */
                o.lambertdouble
              ),
              /* harmony export */
              outline: () => (
                /* reexport safe */
                o.outline
              ),
              /* harmony export */
              screen: () => (
                /* reexport safe */
                o.screen
              ),
              /* harmony export */
              screenaa: () => (
                /* reexport safe */
                o.screenaa
              ),
              /* harmony export */
              sphereimposter: () => (
                /* reexport safe */
                o.sphereimposter
              ),
              /* harmony export */
              sphereimposteroutline: () => (
                /* reexport safe */
                o.sphereimposteroutline
              ),
              /* harmony export */
              sprite: () => (
                /* reexport safe */
                o.sprite
              ),
              /* harmony export */
              stickimposter: () => (
                /* reexport safe */
                o.stickimposter
              ),
              /* harmony export */
              stickimposteroutline: () => (
                /* reexport safe */
                o.stickimposteroutline
              ),
              /* harmony export */
              volumetric: () => (
                /* reexport safe */
                o.volumetric
              )
              /* harmony export */
            });
            var o = n(
              /*! ./lib */
              "./src/WebGL/shaders/lib/index.ts"
            ), l = n(
              /*! ./utils */
              "./src/WebGL/shaders/utils/index.ts"
            );
            n(
              /*! ./ShaderType */
              "./src/WebGL/shaders/ShaderType.ts"
            );
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/basic/index.ts": (
          /*!**********************************************!*\
            !*** ./src/WebGL/shaders/lib/basic/index.ts ***!
            \**********************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              basic: () => (
                /* binding */
                f
              )
              /* harmony export */
            });
            var o = n(
              /*! ./uniforms */
              "./src/WebGL/shaders/lib/basic/uniforms.ts"
            ), l = n(
              /*! ./basic.frag */
              "./src/WebGL/shaders/lib/basic/basic.frag"
            ), u = n(
              /*! ./basic.vert */
              "./src/WebGL/shaders/lib/basic/basic.vert"
            );
            const f = {
              vertexShader: u.default.replace("#define GLSLIFY 1", ""),
              fragmentShader: l.default.replace("#define GLSLIFY 1", ""),
              uniforms: o.uniforms
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/basic/uniforms.ts": (
          /*!*************************************************!*\
            !*** ./src/WebGL/shaders/lib/basic/uniforms.ts ***!
            \*************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              uniforms: () => (
                /* binding */
                l
              )
              /* harmony export */
            });
            var o = n(
              /*! ../../../../colors */
              "./src/colors.ts"
            );
            const l = {
              opacity: { type: "f", value: 1 },
              fogColor: { type: "c", value: new o.Color(1, 1, 1) },
              fogNear: { type: "f", value: 1 },
              fogFar: { type: "f", value: 2e3 }
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/index.ts": (
          /*!****************************************!*\
            !*** ./src/WebGL/shaders/lib/index.ts ***!
            \****************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              ShaderLib: () => (
                /* binding */
                b
              ),
              /* harmony export */
              basic: () => (
                /* reexport safe */
                o.basic
              ),
              /* harmony export */
              instanced: () => (
                /* reexport safe */
                l.instanced
              ),
              /* harmony export */
              lambert: () => (
                /* reexport safe */
                u.lambert
              ),
              /* harmony export */
              lambertdouble: () => (
                /* reexport safe */
                f.lambertdouble
              ),
              /* harmony export */
              outline: () => (
                /* reexport safe */
                h.outline
              ),
              /* harmony export */
              screen: () => (
                /* reexport safe */
                p.screen
              ),
              /* harmony export */
              screenaa: () => (
                /* reexport safe */
                v.screenaa
              ),
              /* harmony export */
              sphereimposter: () => (
                /* reexport safe */
                g.sphereimposter
              ),
              /* harmony export */
              sphereimposteroutline: () => (
                /* reexport safe */
                w.sphereimposteroutline
              ),
              /* harmony export */
              sprite: () => (
                /* reexport safe */
                E.sprite
              ),
              /* harmony export */
              stickimposter: () => (
                /* reexport safe */
                T.stickimposter
              ),
              /* harmony export */
              stickimposteroutline: () => (
                /* reexport safe */
                R.stickimposteroutline
              ),
              /* harmony export */
              volumetric: () => (
                /* reexport safe */
                _.volumetric
              )
              /* harmony export */
            });
            var o = n(
              /*! ./basic */
              "./src/WebGL/shaders/lib/basic/index.ts"
            ), l = n(
              /*! ./instanced */
              "./src/WebGL/shaders/lib/instanced/index.ts"
            ), u = n(
              /*! ./lambert */
              "./src/WebGL/shaders/lib/lambert/index.ts"
            ), f = n(
              /*! ./lambertdouble */
              "./src/WebGL/shaders/lib/lambertdouble/index.ts"
            ), h = n(
              /*! ./outline */
              "./src/WebGL/shaders/lib/outline/index.ts"
            ), p = n(
              /*! ./screen */
              "./src/WebGL/shaders/lib/screen/index.ts"
            ), v = n(
              /*! ./screenaa */
              "./src/WebGL/shaders/lib/screenaa/index.ts"
            ), g = n(
              /*! ./sphereimposter */
              "./src/WebGL/shaders/lib/sphereimposter/index.ts"
            ), w = n(
              /*! ./sphereimposteroutline */
              "./src/WebGL/shaders/lib/sphereimposteroutline/index.ts"
            ), E = n(
              /*! ./sprite */
              "./src/WebGL/shaders/lib/sprite/index.ts"
            ), T = n(
              /*! ./stickimposter */
              "./src/WebGL/shaders/lib/stickimposter/index.ts"
            ), R = n(
              /*! ./stickimposteroutline */
              "./src/WebGL/shaders/lib/stickimposteroutline/index.ts"
            ), _ = n(
              /*! ./volumetric */
              "./src/WebGL/shaders/lib/volumetric/index.ts"
            );
            const b = {
              basic: o.basic,
              instanced: l.instanced,
              lambert: u.lambert,
              lambertdouble: f.lambertdouble,
              outline: h.outline,
              screen: p.screen,
              screenaa: v.screenaa,
              sphereimposter: g.sphereimposter,
              sphereimposteroutline: w.sphereimposteroutline,
              sprite: E.sprite,
              stickimposter: T.stickimposter,
              stickimposteroutline: R.stickimposteroutline,
              volumetric: _.volumetric
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/instanced/index.ts": (
          /*!**************************************************!*\
            !*** ./src/WebGL/shaders/lib/instanced/index.ts ***!
            \**************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              instanced: () => (
                /* binding */
                f
              )
              /* harmony export */
            });
            var o = n(
              /*! ./uniforms */
              "./src/WebGL/shaders/lib/instanced/uniforms.ts"
            ), l = n(
              /*! ./instanced.frag */
              "./src/WebGL/shaders/lib/instanced/instanced.frag"
            ), u = n(
              /*! ./instanced.vert */
              "./src/WebGL/shaders/lib/instanced/instanced.vert"
            );
            const f = {
              fragmentShader: l.default.replace("#define GLSLIFY 1", ""),
              vertexShader: u.default.replace("#define GLSLIFY 1", ""),
              uniforms: o.uniforms
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/instanced/uniforms.ts": (
          /*!*****************************************************!*\
            !*** ./src/WebGL/shaders/lib/instanced/uniforms.ts ***!
            \*****************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              uniforms: () => (
                /* binding */
                l
              )
              /* harmony export */
            });
            var o = n(
              /*! ../../../../colors */
              "./src/colors.ts"
            );
            const l = {
              opacity: { type: "f", value: 1 },
              fogColor: { type: "c", value: new o.Color(1, 1, 1) },
              fogNear: { type: "f", value: 1 },
              fogFar: { type: "f", value: 2e3 },
              directionalLightColor: { type: "fv", value: [] },
              directionalLightDirection: { type: "fv", value: [] }
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/lambert/index.ts": (
          /*!************************************************!*\
            !*** ./src/WebGL/shaders/lib/lambert/index.ts ***!
            \************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              lambert: () => (
                /* binding */
                f
              )
              /* harmony export */
            });
            var o = n(
              /*! ./uniforms */
              "./src/WebGL/shaders/lib/lambert/uniforms.ts"
            ), l = n(
              /*! ./lambert.frag */
              "./src/WebGL/shaders/lib/lambert/lambert.frag"
            ), u = n(
              /*! ./lambert.vert */
              "./src/WebGL/shaders/lib/lambert/lambert.vert"
            );
            const f = {
              fragmentShader: l.default.replace("#define GLSLIFY 1", ""),
              vertexShader: u.default.replace("#define GLSLIFY 1", ""),
              uniforms: o.uniforms
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/lambert/uniforms.ts": (
          /*!***************************************************!*\
            !*** ./src/WebGL/shaders/lib/lambert/uniforms.ts ***!
            \***************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              uniforms: () => (
                /* binding */
                l
              )
              /* harmony export */
            });
            var o = n(
              /*! ../../../../colors */
              "./src/colors.ts"
            );
            const l = {
              opacity: { type: "f", value: 1 },
              fogColor: { type: "c", value: new o.Color(1, 1, 1) },
              fogNear: { type: "f", value: 1 },
              fogFar: { type: "f", value: 2e3 },
              directionalLightColor: { type: "fv", value: [] },
              directionalLightDirection: { type: "fv", value: [] }
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/lambertdouble/index.ts": (
          /*!******************************************************!*\
            !*** ./src/WebGL/shaders/lib/lambertdouble/index.ts ***!
            \******************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              lambertdouble: () => (
                /* binding */
                f
              )
              /* harmony export */
            });
            var o = n(
              /*! ./uniforms */
              "./src/WebGL/shaders/lib/lambertdouble/uniforms.ts"
            ), l = n(
              /*! ./lambertdouble.frag */
              "./src/WebGL/shaders/lib/lambertdouble/lambertdouble.frag"
            ), u = n(
              /*! ./lambertdouble.vert */
              "./src/WebGL/shaders/lib/lambertdouble/lambertdouble.vert"
            );
            const f = {
              fragmentShader: l.default.replace("#define GLSLIFY 1", ""),
              vertexShader: u.default.replace("#define GLSLIFY 1", ""),
              uniforms: o.uniforms
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/lambertdouble/uniforms.ts": (
          /*!*********************************************************!*\
            !*** ./src/WebGL/shaders/lib/lambertdouble/uniforms.ts ***!
            \*********************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              uniforms: () => (
                /* binding */
                l
              )
              /* harmony export */
            });
            var o = n(
              /*! ../../../../colors */
              "./src/colors.ts"
            );
            const l = {
              opacity: { type: "f", value: 1 },
              fogColor: { type: "c", value: new o.Color(1, 1, 1) },
              fogNear: { type: "f", value: 1 },
              fogFar: { type: "f", value: 2e3 },
              directionalLightColor: { type: "fv", value: [] },
              directionalLightDirection: { type: "fv", value: [] }
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/outline/index.ts": (
          /*!************************************************!*\
            !*** ./src/WebGL/shaders/lib/outline/index.ts ***!
            \************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              outline: () => (
                /* binding */
                f
              )
              /* harmony export */
            });
            var o = n(
              /*! ./uniforms */
              "./src/WebGL/shaders/lib/outline/uniforms.ts"
            ), l = n(
              /*! ./outline.frag */
              "./src/WebGL/shaders/lib/outline/outline.frag"
            ), u = n(
              /*! ./outline.vert */
              "./src/WebGL/shaders/lib/outline/outline.vert"
            );
            const f = {
              fragmentShader: l.default.replace("#define GLSLIFY 1", ""),
              vertexShader: u.default.replace("#define GLSLIFY 1", ""),
              uniforms: o.uniforms
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/outline/uniforms.ts": (
          /*!***************************************************!*\
            !*** ./src/WebGL/shaders/lib/outline/uniforms.ts ***!
            \***************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              uniforms: () => (
                /* binding */
                l
              )
              /* harmony export */
            });
            var o = n(
              /*! ../../../../colors */
              "./src/colors.ts"
            );
            const l = {
              opacity: { type: "f", value: 1 },
              outlineColor: { type: "c", value: new o.Color(0, 0, 0) },
              fogColor: { type: "c", value: new o.Color(1, 1, 1) },
              fogNear: { type: "f", value: 1 },
              fogFar: { type: "f", value: 2e3 },
              outlineWidth: { type: "f", value: 0.1 },
              outlinePushback: { type: "f", value: 1 }
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/screen/index.ts": (
          /*!***********************************************!*\
            !*** ./src/WebGL/shaders/lib/screen/index.ts ***!
            \***********************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              screen: () => (
                /* binding */
                f
              )
              /* harmony export */
            });
            var o = n(
              /*! ./uniforms */
              "./src/WebGL/shaders/lib/screen/uniforms.ts"
            ), l = n(
              /*! ./screen.frag */
              "./src/WebGL/shaders/lib/screen/screen.frag"
            ), u = n(
              /*! ./screen.vert */
              "./src/WebGL/shaders/lib/screen/screen.vert"
            );
            const f = {
              fragmentShader: l.default.replace("#define GLSLIFY 1", ""),
              vertexShader: u.default.replace("#define GLSLIFY 1", ""),
              uniforms: o.uniforms
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/screen/uniforms.ts": (
          /*!**************************************************!*\
            !*** ./src/WebGL/shaders/lib/screen/uniforms.ts ***!
            \**************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              uniforms: () => (
                /* binding */
                o
              )
              /* harmony export */
            });
            const o = {};
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/screenaa/index.ts": (
          /*!*************************************************!*\
            !*** ./src/WebGL/shaders/lib/screenaa/index.ts ***!
            \*************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              screenaa: () => (
                /* binding */
                f
              )
              /* harmony export */
            });
            var o = n(
              /*! ./uniforms */
              "./src/WebGL/shaders/lib/screenaa/uniforms.ts"
            ), l = n(
              /*! ./screenaa.frag */
              "./src/WebGL/shaders/lib/screenaa/screenaa.frag"
            ), u = n(
              /*! ./screenaa.vert */
              "./src/WebGL/shaders/lib/screenaa/screenaa.vert"
            );
            const f = {
              fragmentShader: l.default.replace("#define GLSLIFY 1", ""),
              vertexShader: u.default.replace("#define GLSLIFY 1", ""),
              uniforms: o.uniforms
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/screenaa/uniforms.ts": (
          /*!****************************************************!*\
            !*** ./src/WebGL/shaders/lib/screenaa/uniforms.ts ***!
            \****************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              uniforms: () => (
                /* binding */
                o
              )
              /* harmony export */
            });
            const o = {};
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/sphereimposter/index.ts": (
          /*!*******************************************************!*\
            !*** ./src/WebGL/shaders/lib/sphereimposter/index.ts ***!
            \*******************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              sphereimposter: () => (
                /* binding */
                f
              )
              /* harmony export */
            });
            var o = n(
              /*! ./uniforms */
              "./src/WebGL/shaders/lib/sphereimposter/uniforms.ts"
            ), l = n(
              /*! ./sphereimposter.frag */
              "./src/WebGL/shaders/lib/sphereimposter/sphereimposter.frag"
            ), u = n(
              /*! ./sphereimposter.vert */
              "./src/WebGL/shaders/lib/sphereimposter/sphereimposter.vert"
            );
            const f = {
              vertexShader: u.default.replace("#define GLSLIFY 1", ""),
              fragmentShader: l.default.replace("#define GLSLIFY 1", ""),
              uniforms: o.uniforms
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/sphereimposter/uniforms.ts": (
          /*!**********************************************************!*\
            !*** ./src/WebGL/shaders/lib/sphereimposter/uniforms.ts ***!
            \**********************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              uniforms: () => (
                /* binding */
                l
              )
              /* harmony export */
            });
            var o = n(
              /*! ../../../../colors */
              "./src/colors.ts"
            );
            const l = {
              opacity: { type: "f", value: 1 },
              fogColor: { type: "c", value: new o.Color(1, 1, 1) },
              fogNear: { type: "f", value: 1 },
              fogFar: { type: "f", value: 2e3 },
              directionalLightColor: { type: "fv", value: [] },
              directionalLightDirection: { type: "fv", value: [] }
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/sphereimposteroutline/index.ts": (
          /*!**************************************************************!*\
            !*** ./src/WebGL/shaders/lib/sphereimposteroutline/index.ts ***!
            \**************************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              sphereimposteroutline: () => (
                /* binding */
                f
              )
              /* harmony export */
            });
            var o = n(
              /*! ./uniforms */
              "./src/WebGL/shaders/lib/sphereimposteroutline/uniforms.ts"
            ), l = n(
              /*! ./sphereimposteroutline.frag */
              "./src/WebGL/shaders/lib/sphereimposteroutline/sphereimposteroutline.frag"
            ), u = n(
              /*! ./sphereimposteroutline.vert */
              "./src/WebGL/shaders/lib/sphereimposteroutline/sphereimposteroutline.vert"
            );
            const f = {
              fragmentShader: l.default.replace("#define GLSLIFY 1", ""),
              vertexShader: u.default.replace("#define GLSLIFY 1", ""),
              uniforms: o.uniforms
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/sphereimposteroutline/uniforms.ts": (
          /*!*****************************************************************!*\
            !*** ./src/WebGL/shaders/lib/sphereimposteroutline/uniforms.ts ***!
            \*****************************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              uniforms: () => (
                /* binding */
                l
              )
              /* harmony export */
            });
            var o = n(
              /*! ../../../../colors */
              "./src/colors.ts"
            );
            const l = {
              opacity: { type: "f", value: 1 },
              outlineColor: { type: "c", value: new o.Color(0, 0, 0) },
              fogColor: { type: "c", value: new o.Color(1, 1, 1) },
              fogNear: { type: "f", value: 1 },
              fogFar: { type: "f", value: 2e3 },
              outlineWidth: { type: "f", value: 0.1 },
              outlinePushback: { type: "f", value: 1 }
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/sprite/index.ts": (
          /*!***********************************************!*\
            !*** ./src/WebGL/shaders/lib/sprite/index.ts ***!
            \***********************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              sprite: () => (
                /* binding */
                f
              )
              /* harmony export */
            });
            var o = n(
              /*! ./uniforms */
              "./src/WebGL/shaders/lib/sprite/uniforms.ts"
            ), l = n(
              /*! ./sprite.frag */
              "./src/WebGL/shaders/lib/sprite/sprite.frag"
            ), u = n(
              /*! ./sprite.vert */
              "./src/WebGL/shaders/lib/sprite/sprite.vert"
            );
            const f = {
              fragmentShader: l.default.replace("#define GLSLIFY 1", ""),
              vertexShader: u.default.replace("#define GLSLIFY 1", ""),
              uniforms: o.uniforms
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/sprite/uniforms.ts": (
          /*!**************************************************!*\
            !*** ./src/WebGL/shaders/lib/sprite/uniforms.ts ***!
            \**************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              uniforms: () => (
                /* binding */
                o
              )
              /* harmony export */
            });
            const o = {};
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/stickimposter/index.ts": (
          /*!******************************************************!*\
            !*** ./src/WebGL/shaders/lib/stickimposter/index.ts ***!
            \******************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              stickimposter: () => (
                /* binding */
                h
              )
              /* harmony export */
            });
            var o = n(
              /*! ./uniforms */
              "./src/WebGL/shaders/lib/stickimposter/uniforms.ts"
            ), l = n(
              /*! ../../utils/stickimposterFragmentShader.partial.frag */
              "./src/WebGL/shaders/utils/stickimposterFragmentShader.partial.frag"
            ), u = n(
              /*! ./stickimposter.partial.frag */
              "./src/WebGL/shaders/lib/stickimposter/stickimposter.partial.frag"
            ), f = n(
              /*! ./stickimposter.vert */
              "./src/WebGL/shaders/lib/stickimposter/stickimposter.vert"
            );
            const h = {
              fragmentShader: [l.default, u.default].join(`
`).replace("#define GLSLIFY 1", ""),
              vertexShader: f.default.replace("#define GLSLIFY 1", ""),
              uniforms: o.uniforms
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/stickimposter/uniforms.ts": (
          /*!*********************************************************!*\
            !*** ./src/WebGL/shaders/lib/stickimposter/uniforms.ts ***!
            \*********************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              uniforms: () => (
                /* binding */
                l
              )
              /* harmony export */
            });
            var o = n(
              /*! ../../../../colors */
              "./src/colors.ts"
            );
            const l = {
              opacity: { type: "f", value: 1 },
              fogColor: { type: "c", value: new o.Color(1, 1, 1) },
              fogNear: { type: "f", value: 1 },
              fogFar: { type: "f", value: 2e3 },
              directionalLightColor: { type: "fv", value: [] },
              directionalLightDirection: { type: "fv", value: [] }
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/stickimposteroutline/index.ts": (
          /*!*************************************************************!*\
            !*** ./src/WebGL/shaders/lib/stickimposteroutline/index.ts ***!
            \*************************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              stickimposteroutline: () => (
                /* binding */
                f
              )
              /* harmony export */
            });
            var o = n(
              /*! ./uniforms */
              "./src/WebGL/shaders/lib/stickimposteroutline/uniforms.ts"
            ), l = n(
              /*! ../../utils/stickimposterFragmentShader.partial.frag */
              "./src/WebGL/shaders/utils/stickimposterFragmentShader.partial.frag"
            ), u = n(
              /*! ./stickimposteroutline.vert */
              "./src/WebGL/shaders/lib/stickimposteroutline/stickimposteroutline.vert"
            );
            const f = {
              fragmentShader: (l.default + "gl_FragColor = vec4(color,1.0);}").replace("#define GLSLIFY 1", ""),
              vertexShader: u.default.replace("#define GLSLIFY 1", ""),
              uniforms: o.uniforms
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/stickimposteroutline/uniforms.ts": (
          /*!****************************************************************!*\
            !*** ./src/WebGL/shaders/lib/stickimposteroutline/uniforms.ts ***!
            \****************************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              uniforms: () => (
                /* binding */
                l
              )
              /* harmony export */
            });
            var o = n(
              /*! ../../../../colors */
              "./src/colors.ts"
            );
            const l = {
              opacity: { type: "f", value: 1 },
              fogColor: { type: "c", value: new o.Color(1, 1, 1) },
              fogNear: { type: "f", value: 1 },
              fogFar: { type: "f", value: 2e3 },
              outlineColor: { type: "c", value: new o.Color(0, 0, 0) },
              outlineWidth: { type: "f", value: 0.1 },
              outlinePushback: { type: "f", value: 1 }
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/volumetric/index.ts": (
          /*!***************************************************!*\
            !*** ./src/WebGL/shaders/lib/volumetric/index.ts ***!
            \***************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              volumetric: () => (
                /* binding */
                f
              )
              /* harmony export */
            });
            var o = n(
              /*! ./uniforms */
              "./src/WebGL/shaders/lib/volumetric/uniforms.ts"
            ), l = n(
              /*! ./volumetric.frag */
              "./src/WebGL/shaders/lib/volumetric/volumetric.frag"
            ), u = n(
              /*! ./volumetric.vert */
              "./src/WebGL/shaders/lib/volumetric/volumetric.vert"
            );
            const f = {
              fragmentShader: l.default.replace("#define GLSLIFY 1", ""),
              vertexShader: u.default.replace("#define GLSLIFY 1", ""),
              uniforms: o.uniforms
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/lib/volumetric/uniforms.ts": (
          /*!******************************************************!*\
            !*** ./src/WebGL/shaders/lib/volumetric/uniforms.ts ***!
            \******************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              uniforms: () => (
                /* binding */
                l
              )
              /* harmony export */
            });
            var o = n(
              /*! ../../../../colors */
              "./src/colors.ts"
            );
            const l = {
              opacity: { type: "f", value: 1 },
              fogColor: { type: "c", value: new o.Color(1, 1, 1) },
              fogNear: { type: "f", value: 1 },
              fogFar: { type: "f", value: 2e3 },
              data: { type: "i", value: 3 },
              colormap: { type: "i", value: 4 },
              depthmap: { type: "i", value: 5 },
              step: { type: "f", value: 1 },
              maxdepth: { type: "f", value: 100 },
              subsamples: { type: "f", value: 5 },
              textmat: { type: "mat4", value: [] },
              projinv: { type: "mat4", value: [] },
              transfermin: { type: "f", value: -0.2 },
              transfermax: { type: "f", value: 0.2 }
            };
          }
        ),
        /***/
        "./src/WebGL/shaders/utils/clone.ts": (
          /*!******************************************!*\
            !*** ./src/WebGL/shaders/utils/clone.ts ***!
            \******************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              clone: () => (
                /* binding */
                l
              )
              /* harmony export */
            });
            var o = n(
              /*! ../../../colors */
              "./src/colors.ts"
            );
            function l(u) {
              let f = {};
              for (const p in u) {
                f[p] = {}, f[p].type = u[p].type;
                var h = u[p].value;
                h instanceof o.Color ? f[p].value = h.clone() : typeof h == "number" ? f[p].value = h : h instanceof Array ? f[p].value = [] : console.error("Error copying shader uniforms from ShaderLib: unknown type for uniform");
              }
              return f;
            }
          }
        ),
        /***/
        "./src/WebGL/shaders/utils/index.ts": (
          /*!******************************************!*\
            !*** ./src/WebGL/shaders/utils/index.ts ***!
            \******************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              ShaderUtils: () => (
                /* binding */
                u
              ),
              /* harmony export */
              clone: () => (
                /* reexport safe */
                o.clone
              )
              /* harmony export */
            });
            var o = n(
              /*! ./clone */
              "./src/WebGL/shaders/utils/clone.ts"
            ), l = n(
              /*! ./stickimposterFragmentShader.partial.frag */
              "./src/WebGL/shaders/utils/stickimposterFragmentShader.partial.frag"
            );
            const u = {
              clone: o.clone,
              stickimposterFragmentShader: l.default
            };
          }
        ),
        /***/
        "./src/WebGL/shapes/Cylinder.ts": (
          /*!**************************************!*\
            !*** ./src/WebGL/shapes/Cylinder.ts ***!
            \**************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              Cylinder: () => (
                /* binding */
                u
              )
              /* harmony export */
            });
            var o = n(
              /*! ../math */
              "./src/WebGL/math/index.ts"
            );
            let l = new o.Vector3();
            class u {
              constructor(h = new o.Vector3(), p = new o.Vector3(), v = 0) {
                this.c1 = h, this.c2 = p, this.radius = v, this.direction = new o.Vector3().subVectors(this.c2, this.c1).normalize();
              }
              copy(h) {
                return this.c1.copy(h.c1), this.c2.copy(h.c2), this.direction.copy(h.direction), this.radius = h.radius, this;
              }
              lengthSq() {
                return l.subVectors(this.c2, this.c1).lengthSq();
              }
              applyMatrix4(h) {
                return this.direction.add(this.c1).applyMatrix4(h), this.c1.applyMatrix4(h), this.c2.applyMatrix4(h), this.direction.sub(this.c1).normalize(), this.radius = this.radius * h.getMaxScaleOnAxis(), this;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/shapes/Sphere.ts": (
          /*!************************************!*\
            !*** ./src/WebGL/shapes/Sphere.ts ***!
            \************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              Sphere: () => (
                /* binding */
                l
              )
              /* harmony export */
            });
            var o = n(
              /*! ../math */
              "./src/WebGL/math/index.ts"
            );
            class l {
              constructor(f = { x: 0, y: 0, z: 0 }, h = 0) {
                this.center = new o.Vector3(f.x, f.y, f.z), this.radius = h;
              }
              set(f, h) {
                return this.center.copy(f), this.radius = h, this;
              }
              copy(f) {
                return this.center.copy(f.center), this.radius = f.radius, this;
              }
              applyMatrix4(f) {
                return this.center.applyMatrix4(f), this.radius = this.radius * f.getMaxScaleOnAxis(), this;
              }
              translate(f) {
                return this.center.add(f), this;
              }
              equals(f) {
                return f.center.equals(this.center) && f.radius === this.radius;
              }
              clone() {
                return new l().copy(this);
              }
            }
          }
        ),
        /***/
        "./src/WebGL/shapes/Triangle.ts": (
          /*!**************************************!*\
            !*** ./src/WebGL/shapes/Triangle.ts ***!
            \**************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              Triangle: () => (
                /* binding */
                u
              )
              /* harmony export */
            });
            var o = n(
              /*! ../math */
              "./src/WebGL/math/index.ts"
            );
            const l = new o.Vector3();
            class u {
              constructor(h = new o.Vector3(), p = new o.Vector3(), v = new o.Vector3()) {
                this.a = h, this.b = p, this.c = v;
              }
              copy(h) {
                return this.a.copy(h.a), this.b.copy(h.b), this.c.copy(h.c), this;
              }
              applyMatrix4(h) {
                return this.a.applyMatrix4(h), this.b.applyMatrix4(h), this.c.applyMatrix4(h), this;
              }
              getNormal() {
                var h = this.a.clone();
                return h.sub(this.b), l.subVectors(this.c, this.b), h.cross(l), h.normalize(), h;
              }
            }
          }
        ),
        /***/
        "./src/WebGL/shapes/index.ts": (
          /*!***********************************!*\
            !*** ./src/WebGL/shapes/index.ts ***!
            \***********************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              Cylinder: () => (
                /* reexport safe */
                l.Cylinder
              ),
              /* harmony export */
              Sphere: () => (
                /* reexport safe */
                o.Sphere
              ),
              /* harmony export */
              Triangle: () => (
                /* reexport safe */
                u.Triangle
              )
              /* harmony export */
            });
            var o = n(
              /*! ./Sphere */
              "./src/WebGL/shapes/Sphere.ts"
            ), l = n(
              /*! ./Cylinder */
              "./src/WebGL/shapes/Cylinder.ts"
            ), u = n(
              /*! ./Triangle */
              "./src/WebGL/shapes/Triangle.ts"
            );
          }
        ),
        /***/
        "./src/autoload.ts": (
          /*!*************************!*\
            !*** ./src/autoload.ts ***!
            \*************************/
          /***/
          (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
              /* harmony export */
              autoinit: () => (
                /* binding */
                autoinit
              ),
              /* harmony export */
              autoload: () => (
                /* binding */
                autoload
              ),
              /* harmony export */
              processing_autoinit: () => (
                /* binding */
                processing_autoinit
              ),
              /* harmony export */
              viewers: () => (
                /* binding */
                viewers
              )
              /* harmony export */
            });
            var _GLViewer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
              /*! ./GLViewer */
              "./src/GLViewer.ts"
            ), _ProteinSurface4__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
              /*! ./ProteinSurface4 */
              "./src/ProteinSurface4.ts"
            ), _utilities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
              /*! ./utilities */
              "./src/utilities.ts"
            ), _colors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
              /*! ./colors */
              "./src/colors.ts"
            ), autoinit = !1, processing_autoinit = !1, viewers = {};
            function autoload(viewer, callback) {
              var i, dataname, type;
              if (document.querySelector(".viewer_3Dmoljs") != null && (autoinit = !0), autoinit) {
                processing_autoinit = !0, viewer = viewer ?? null;
                var nviewers = 0;
                document.querySelectorAll(".viewer_3Dmoljs").forEach((viewerdiv) => {
                  var datauri = [], datatypes = [], uri = "";
                  viewerdiv.style.position == "static" && (viewerdiv.style.position = "relative");
                  var UI = null;
                  if (type = null, viewerdiv.dataset.pdb)
                    datauri.push("https://files.rcsb.org/view/" + viewerdiv.dataset.pdb + ".pdb"), datatypes.push("pdb");
                  else if (viewerdiv.dataset.cid)
                    datatypes.push("sdf"), datauri.push("https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/" + viewerdiv.dataset.cid + "/SDF?record_type=3d");
                  else if (viewerdiv.dataset.href || viewerdiv.dataset.url) {
                    viewerdiv.dataset.href ? uri = viewerdiv.dataset.href : uri = viewerdiv.dataset.url, datauri.push(uri), type = uri.substring(uri.lastIndexOf(".") + 1), datatypes.push(type);
                    var molName = uri.substring(uri.lastIndexOf("/") + 1, uri.lastIndexOf("."));
                    molName == "/" && (molName = uri.substring(uri.lastIndexOf("/") + 1)), viewerdiv.dataset[datatypes[datatypes.length - 1]] = molName;
                  }
                  var divdata = viewerdiv.dataset;
                  for (i in divdata)
                    i.substring(0, 3) === "pdb" && i !== "pdb" ? (datauri.push("https://files.rcsb.org/view/" + divdata[i] + ".pdb"), datatypes.push("pdb")) : i.substring(0, 4) === "href" && i !== "href" ? (uri = divdata[i], datauri.push(uri), datatypes.push(uri.substring(uri.lastIndexOf(".") + 1))) : i.substring(0, 3) === "cid" && i !== "cid" && (datauri.push("https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/" + divdata[i] + "/SDF?record_type=3d"), datatypes.push("sdf"));
                  var options = {};
                  viewerdiv.dataset.options && (options = (0, _utilities__WEBPACK_IMPORTED_MODULE_2__.specStringToObject)(viewerdiv.dataset.options));
                  var bgcolor = _colors__WEBPACK_IMPORTED_MODULE_3__.CC.color(viewerdiv.dataset.backgroundcolor), bgalpha = viewerdiv.dataset.backgroundalpha;
                  bgalpha = bgalpha == null ? 1 : parseFloat(bgalpha);
                  var style = { line: {} };
                  viewerdiv.dataset.style && (style = (0, _utilities__WEBPACK_IMPORTED_MODULE_2__.specStringToObject)(viewerdiv.dataset.style));
                  var select = {};
                  viewerdiv.dataset.select && (select = (0, _utilities__WEBPACK_IMPORTED_MODULE_2__.specStringToObject)(viewerdiv.dataset.select));
                  var selectstylelist = [], surfaces = [], labels = [], zoomto = {}, spin = null, d = viewerdiv.dataset, stylere = /style(.+)/, surfre = /surface(.*)/, reslabre = /labelres(.*)/, keys = [];
                  for (dataname in d)
                    Object.prototype.hasOwnProperty.call(d, dataname) && keys.push(dataname);
                  for (keys.sort(), i = 0; i < keys.length; i++) {
                    dataname = keys[i];
                    var m = stylere.exec(dataname), selname, newsel, styleobj;
                    m && (selname = "select" + m[1], newsel = (0, _utilities__WEBPACK_IMPORTED_MODULE_2__.specStringToObject)(d[selname]), styleobj = (0, _utilities__WEBPACK_IMPORTED_MODULE_2__.specStringToObject)(d[dataname]), selectstylelist.push([newsel, styleobj])), m = surfre.exec(dataname), m && (selname = "select" + m[1], newsel = (0, _utilities__WEBPACK_IMPORTED_MODULE_2__.specStringToObject)(d[selname]), styleobj = (0, _utilities__WEBPACK_IMPORTED_MODULE_2__.specStringToObject)(d[dataname]), surfaces.push([newsel, styleobj])), m = reslabre.exec(dataname), m && (selname = "select" + m[1], newsel = (0, _utilities__WEBPACK_IMPORTED_MODULE_2__.specStringToObject)(d[selname]), styleobj = (0, _utilities__WEBPACK_IMPORTED_MODULE_2__.specStringToObject)(d[dataname]), labels.push([newsel, styleobj])), dataname == "zoomto" && (zoomto = (0, _utilities__WEBPACK_IMPORTED_MODULE_2__.specStringToObject)(d[dataname])), dataname == "spin" && (spin = (0, _utilities__WEBPACK_IMPORTED_MODULE_2__.specStringToObject)(d[dataname]));
                  }
                  var applyStyles = function(t) {
                    for (t.setStyle(select, style), UI && UI.createSelectionAndStyle(select, style), i = 0; i < selectstylelist.length; i++) {
                      let e = selectstylelist[i][0] || {}, n = selectstylelist[i][1] || { line: {} };
                      t.setStyle(e, n), UI && UI.createSelectionAndStyle(select, style);
                    }
                    for (i = 0; i < surfaces.length; i++) {
                      let e = surfaces[i][0] || {}, n = surfaces[i][1] || {};
                      UI ? t.addSurface(_ProteinSurface4__WEBPACK_IMPORTED_MODULE_1__.SurfaceType.VDW, n, e, e).then((o) => {
                        UI.loadSurface("VDW", e, n, o);
                      }) : t.addSurface(_ProteinSurface4__WEBPACK_IMPORTED_MODULE_1__.SurfaceType.VDW, n, e, e);
                    }
                    for (i = 0; i < labels.length; i++) {
                      let e = labels[i][0] || {}, n = labels[i][1] || {};
                      t.addResLabels(e, n);
                    }
                    t.render(), t.zoomTo(zoomto), spin && t.spin(spin.axis, spin.speed);
                  }, glviewer = viewer;
                  try {
                    var config = (0, _utilities__WEBPACK_IMPORTED_MODULE_2__.specStringToObject)(viewerdiv.dataset.config) || {};
                    config.backgroundColor === void 0 && (config.backgroundColor = bgcolor), config.backgroundAlpha === void 0 && (config.backgroundAlpha = bgalpha), glviewer == null ? glviewer = viewers[viewerdiv.id || nviewers++] = (0, _GLViewer__WEBPACK_IMPORTED_MODULE_0__.createViewer)(viewerdiv, config) : (glviewer.setBackgroundColor(bgcolor, bgalpha), glviewer.setConfig(config), UI && UI.initiateUI()), viewerdiv.dataset.ui && $3Dmol.StateManager && (UI = new $3Dmol.StateManager(glviewer));
                  } catch (t) {
                    console.log(t), viewerdiv.textContent = "WebGL appears to be disabled.";
                  }
                  if (datauri.length != 0) {
                    let i = 0;
                    var process = function(moldata) {
                      uri = datauri[i];
                      var type = viewerdiv.dataset.type || viewerdiv.dataset.datatype || datatypes[i];
                      if (glviewer.addModel(moldata, type, options), UI) {
                        var modelName = viewerdiv.dataset[datatypes[i]];
                        UI.setModelTitle(modelName);
                      }
                      if (i += 1, i < datauri.length)
                        (0, _utilities__WEBPACK_IMPORTED_MODULE_2__.get)(datauri[i]).then(process);
                      else {
                        if (applyStyles(glviewer), viewerdiv.dataset.callback) {
                          var runres = eval(viewerdiv.dataset.callback);
                          typeof runres == "function" && runres(glviewer);
                        }
                        processing_autoinit = !1, callback && callback(glviewer);
                      }
                    };
                    (0, _utilities__WEBPACK_IMPORTED_MODULE_2__.get)(datauri[0]).then(process);
                  } else {
                    if (viewerdiv.dataset.element) {
                      var moldataid = "#" + viewerdiv.dataset.element, molelem = document.querySelector(moldataid), moldata = molelem ? molelem.textContent : "";
                      type = viewerdiv.dataset.type || viewerdiv.dataset.datatype, glviewer.addModel(moldata, type, options);
                    }
                    if (applyStyles(glviewer), viewerdiv.dataset.callback) {
                      var runres = eval(viewerdiv.dataset.callback);
                      typeof runres == "function" && runres(glviewer);
                    }
                    processing_autoinit = !1, callback && callback(glviewer);
                  }
                });
              }
            }
            document.onreadystatechange = () => {
              document.readyState === "complete" && autoload();
            };
          }
        ),
        /***/
        "./src/colors.ts": (
          /*!***********************!*\
            !*** ./src/colors.ts ***!
            \***********************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              CC: () => (
                /* binding */
                l
              ),
              /* harmony export */
              Color: () => (
                /* binding */
                o
              ),
              /* harmony export */
              builtinColorSchemes: () => (
                /* binding */
                w
              ),
              /* harmony export */
              chains: () => (
                /* binding */
                g
              ),
              /* harmony export */
              elementColors: () => (
                /* binding */
                p
              ),
              /* harmony export */
              htmlColors: () => (
                /* binding */
                u
              ),
              /* harmony export */
              residues: () => (
                /* binding */
                v
              ),
              /* harmony export */
              ssColors: () => (
                /* binding */
                f
              )
              /* harmony export */
            });
            class o {
              constructor(T, R, _) {
                return this.r = 0, this.g = 0, this.b = 0, arguments.length > 1 && typeof T == "number" ? (this.r = T || 0, this.g = R || 0, this.b = _ || 0, this) : this.set(T || 0);
              }
              set(T) {
                return T instanceof o ? T.clone() : (typeof T == "number" ? this.setHex(T) : typeof T == "object" && (this.r = (T == null ? void 0 : T.r) || 0, this.g = (T == null ? void 0 : T.g) || 0, this.b = (T == null ? void 0 : T.b) || 0), this);
              }
              setHex(T) {
                return T = Math.floor(T), this.r = (T >> 16 & 255) / 255, this.g = (T >> 8 & 255) / 255, this.b = (T & 255) / 255, this;
              }
              getHex() {
                var T = Math.round(this.r * 255), R = Math.round(this.g * 255), _ = Math.round(this.b * 255);
                return T << 16 | R << 8 | _;
              }
              clone() {
                return new o(this.r, this.g, this.b);
              }
              copy(T) {
                return this.r = T.r, this.g = T.g, this.b = T.b, this;
              }
              //return object that represents color components from 0 to 255
              scaled() {
                var T = {};
                return T.r = Math.round(this.r * 255), T.g = Math.round(this.g * 255), T.b = Math.round(this.b * 255), T.a = 1, T;
              }
            }
            class l {
              static color(T) {
                if (!T)
                  return l.cache[0];
                if (T instanceof o)
                  return T;
                if (typeof T == "number" && typeof l.cache[T] < "u")
                  return l.cache[T];
                if (T && Array.isArray(T))
                  return T.map(l.color);
                let R = l.getHex(T), _ = new o(R);
                return l.cache[R] = _, _;
              }
              static getHex(T) {
                var R;
                if (Array.isArray(T))
                  return T.map(l.getHex);
                if (typeof T == "string") {
                  let _ = T;
                  if (!isNaN(parseInt(_)))
                    return parseInt(_);
                  if (_ = _.trim(), _.length == 4 && _[0] == "#" && (_ = "#" + _[1] + _[1] + _[2] + _[2] + _[3] + _[3]), _.length == 7 && _[0] == "#")
                    return parseInt(_.substring(1), 16);
                  let b = l.rgbRegEx.exec(_);
                  if (b) {
                    b[1] != "" && console.log("WARNING: Opacity value in rgba ignored.  Specify separately as opacity attribute.");
                    let M = 0;
                    for (let A = 2; A < 5; A++) {
                      M *= 256;
                      let $ = b[A].endsWith("%") ? 255 * parseFloat(b[A]) / 100 : parseFloat(b[A]);
                      M += Math.round($);
                    }
                    return M;
                  }
                  return ((R = window == null ? void 0 : window.$3Dmol) === null || R === void 0 ? void 0 : R.htmlColors[T.toLowerCase()]) || 0;
                }
                return T;
              }
            }
            l.rgbRegEx = /rgb(a?)\(\s*([^ ,\)\t]+)\s*,\s*([^ ,\)\t]+)\s*,\s*([^ ,\)\t]+)/i, l.cache = { 0: new o(0) };
            const u = {
              aliceblue: 15792383,
              antiquewhite: 16444375,
              aqua: 65535,
              aquamarine: 8388564,
              azure: 15794175,
              beige: 16119260,
              bisque: 16770244,
              black: 0,
              blanchedalmond: 16772045,
              blue: 255,
              blueviolet: 9055202,
              brown: 10824234,
              burlywood: 14596231,
              cadetblue: 6266528,
              chartreuse: 8388352,
              chocolate: 13789470,
              coral: 16744272,
              cornflowerblue: 6591981,
              cornsilk: 16775388,
              crimson: 14423100,
              cyan: 65535,
              darkblue: 139,
              darkcyan: 35723,
              darkgoldenrod: 12092939,
              darkgray: 11119017,
              darkgrey: 11119017,
              darkgreen: 25600,
              darkkhaki: 12433259,
              darkmagenta: 9109643,
              darkolivegreen: 5597999,
              darkorange: 16747520,
              darkorchid: 10040012,
              darkred: 9109504,
              darksalmon: 15308410,
              darkseagreen: 9419919,
              darkslateblue: 4734347,
              darkslategray: 3100495,
              darkslategrey: 3100495,
              darkturquoise: 52945,
              darkviolet: 9699539,
              deeppink: 16716947,
              deepskyblue: 49151,
              dimgray: 6908265,
              dimgrey: 6908265,
              dodgerblue: 2003199,
              firebrick: 11674146,
              floralwhite: 16775920,
              forestgreen: 2263842,
              fuchsia: 16711935,
              gainsboro: 14474460,
              ghostwhite: 16316671,
              gold: 16766720,
              goldenrod: 14329120,
              gray: 8421504,
              grey: 8421504,
              green: 32768,
              greenyellow: 11403055,
              honeydew: 15794160,
              hotpink: 16738740,
              indianred: 13458524,
              indigo: 4915330,
              ivory: 16777200,
              khaki: 15787660,
              lavender: 15132410,
              lavenderblush: 16773365,
              lawngreen: 8190976,
              lemonchiffon: 16775885,
              lightblue: 11393254,
              lightcoral: 15761536,
              lightcyan: 14745599,
              lightgoldenrodyellow: 16448210,
              lightgray: 13882323,
              lightgrey: 13882323,
              lightgreen: 9498256,
              lightpink: 16758465,
              lightsalmon: 16752762,
              lightseagreen: 2142890,
              lightskyblue: 8900346,
              lightslategray: 7833753,
              lightslategrey: 7833753,
              lightsteelblue: 11584734,
              lightyellow: 16777184,
              lime: 65280,
              limegreen: 3329330,
              linen: 16445670,
              magenta: 16711935,
              maroon: 8388608,
              mediumaquamarine: 6737322,
              mediumblue: 205,
              mediumorchid: 12211667,
              mediumpurple: 9662683,
              mediumseagreen: 3978097,
              mediumslateblue: 8087790,
              mediumspringgreen: 64154,
              mediumturquoise: 4772300,
              mediumvioletred: 13047173,
              midnightblue: 1644912,
              mintcream: 16121850,
              mistyrose: 16770273,
              moccasin: 16770229,
              navajowhite: 16768685,
              navy: 128,
              oldlace: 16643558,
              olive: 8421376,
              olivedrab: 7048739,
              orange: 16753920,
              orangered: 16729344,
              orchid: 14315734,
              palegoldenrod: 15657130,
              palegreen: 10025880,
              paleturquoise: 11529966,
              palevioletred: 14381203,
              papayawhip: 16773077,
              peachpuff: 16767673,
              peru: 13468991,
              pink: 16761035,
              plum: 14524637,
              powderblue: 11591910,
              purple: 8388736,
              rebeccapurple: 6697881,
              red: 16711680,
              rosybrown: 12357519,
              royalblue: 4286945,
              saddlebrown: 9127187,
              salmon: 16416882,
              sandybrown: 16032864,
              seagreen: 3050327,
              seashell: 16774638,
              sienna: 10506797,
              silver: 12632256,
              skyblue: 8900331,
              slateblue: 6970061,
              slategray: 7372944,
              slategrey: 7372944,
              snow: 16775930,
              springgreen: 65407,
              steelblue: 4620980,
              tan: 13808780,
              teal: 32896,
              thistle: 14204888,
              tomato: 16737095,
              turquoise: 4251856,
              violet: 15631086,
              wheat: 16113331,
              white: 16777215,
              whitesmoke: 16119285,
              yellow: 16776960,
              yellowgreen: 10145074
            }, f = {
              //names are in helix-sheet-coil order
              pyMol: { h: 16711680, s: 16776960, c: 65280 },
              Jmol: { h: 16711808, s: 16762880, c: 16777215 }
            }, h = {
              H: 16777215,
              He: 16761035,
              HE: 16761035,
              Li: 11674146,
              LI: 11674146,
              B: 65280,
              C: 13158600,
              N: 9408511,
              O: 15728640,
              F: 14329120,
              Na: 255,
              NA: 255,
              Mg: 2263842,
              MG: 2263842,
              Al: 8421520,
              AL: 8421520,
              Si: 14329120,
              SI: 14329120,
              P: 16753920,
              S: 16762930,
              Cl: 65280,
              CL: 65280,
              Ca: 8421520,
              CA: 8421520,
              Ti: 8421520,
              TI: 8421520,
              Cr: 8421520,
              CR: 8421520,
              Mn: 8421520,
              MN: 8421520,
              Fe: 16753920,
              FE: 16753920,
              Ni: 10824234,
              NI: 10824234,
              Cu: 10824234,
              CU: 10824234,
              Zn: 10824234,
              ZN: 10824234,
              Br: 10824234,
              BR: 10824234,
              Ag: 8421520,
              AG: 8421520,
              I: 10494192,
              Ba: 16753920,
              BA: 16753920,
              Au: 14329120,
              AU: 14329120
            }, p = {
              defaultColor: 16716947,
              /** Jmol-like element colors*/
              Jmol: {
                H: 16777215,
                He: 14286847,
                HE: 14286847,
                Li: 13402367,
                LI: 13402367,
                Be: 12779264,
                BE: 12779264,
                B: 16758197,
                C: 9474192,
                N: 3166456,
                O: 16715021,
                F: 9494608,
                Ne: 11789301,
                NE: 11789301,
                Na: 11230450,
                NA: 11230450,
                Mg: 9109248,
                MG: 9109248,
                Al: 12560038,
                AL: 12560038,
                Si: 1578e4,
                SI: 1578e4,
                P: 16744448,
                S: 16777008,
                Cl: 2093087,
                CL: 2093087,
                Ar: 8442339,
                AR: 8442339,
                K: 9388244,
                Ca: 4062976,
                CA: 4062976,
                Sc: 15132390,
                SC: 15132390,
                Ti: 12567239,
                TI: 12567239,
                V: 10921643,
                Cr: 9083335,
                CR: 9083335,
                Mn: 10255047,
                MN: 10255047,
                Fe: 14706227,
                FE: 14706227,
                Co: 15765664,
                CO: 15765664,
                Ni: 5296208,
                NI: 5296208,
                Cu: 13140019,
                CU: 13140019,
                Zn: 8224944,
                ZN: 8224944,
                Ga: 12750735,
                GA: 12750735,
                Ge: 6721423,
                GE: 6721423,
                As: 12419299,
                AS: 12419299,
                Se: 16752896,
                SE: 16752896,
                Br: 10889513,
                BR: 10889513,
                Kr: 6076625,
                KR: 6076625,
                Rb: 7351984,
                RB: 7351984,
                Sr: 65280,
                SR: 65280,
                Y: 9764863,
                Zr: 9756896,
                ZR: 9756896,
                Nb: 7586505,
                NB: 7586505,
                Mo: 5551541,
                MO: 5551541,
                Tc: 3907230,
                TC: 3907230,
                Ru: 2396047,
                RU: 2396047,
                Rh: 687500,
                RH: 687500,
                Pd: 27013,
                PD: 27013,
                Ag: 12632256,
                AG: 12632256,
                Cd: 16767375,
                CD: 16767375,
                In: 10909043,
                IN: 10909043,
                Sn: 6717568,
                SN: 6717568,
                Sb: 10380213,
                SB: 10380213,
                Te: 13924864,
                TE: 13924864,
                I: 9699476,
                Xe: 4366e3,
                XE: 4366e3,
                Cs: 5707663,
                CS: 5707663,
                Ba: 51456,
                BA: 51456,
                La: 7394559,
                LA: 7394559,
                Ce: 16777159,
                CE: 16777159,
                Pr: 14286791,
                PR: 14286791,
                Nd: 13107143,
                ND: 13107143,
                Pm: 10747847,
                PM: 10747847,
                Sm: 9437127,
                SM: 9437127,
                Eu: 6422471,
                EU: 6422471,
                Gd: 4587463,
                GD: 4587463,
                Tb: 3211207,
                TB: 3211207,
                Dy: 2097095,
                DY: 2097095,
                Ho: 65436,
                HO: 65436,
                Er: 58997,
                ER: 58997,
                Tm: 54354,
                TM: 54354,
                Yb: 48952,
                YB: 48952,
                Lu: 43812,
                LU: 43812,
                Hf: 5096191,
                HF: 5096191,
                Ta: 5089023,
                TA: 5089023,
                W: 2200790,
                Re: 2522539,
                RE: 2522539,
                Os: 2516630,
                OS: 2516630,
                Ir: 1528967,
                IR: 1528967,
                Pt: 13684960,
                PT: 13684960,
                Au: 16765219,
                AU: 16765219,
                Hg: 12105936,
                HG: 12105936,
                Tl: 10900557,
                TL: 10900557,
                Pb: 5724513,
                PB: 5724513,
                Bi: 10375093,
                BI: 10375093,
                Po: 11230208,
                PO: 11230208,
                At: 7688005,
                AT: 7688005,
                Rn: 4358806,
                RN: 4358806,
                Fr: 4325478,
                FR: 4325478,
                Ra: 32e3,
                RA: 32e3,
                Ac: 7384058,
                AC: 7384058,
                Th: 47871,
                TH: 47871,
                Pa: 41471,
                PA: 41471,
                U: 36863,
                Np: 33023,
                NP: 33023,
                Pu: 27647,
                PU: 27647,
                Am: 5528818,
                AM: 5528818,
                Cm: 7888099,
                CM: 7888099,
                Bk: 9064419,
                BK: 9064419,
                Cf: 10565332,
                CF: 10565332,
                Es: 11739092,
                ES: 11739092,
                Fm: 11739066,
                FM: 11739066,
                Md: 11734438,
                MD: 11734438,
                No: 12389767,
                NO: 12389767,
                Lr: 13041766,
                LR: 13041766,
                Rf: 13369433,
                RF: 13369433,
                Db: 13697103,
                DB: 13697103,
                Sg: 14221381,
                SG: 14221381,
                Bh: 14680120,
                BH: 14680120,
                Hs: 15073326,
                HS: 15073326,
                Mt: 15400998,
                MT: 15400998
              },
              /** rasmol-like element colors */
              rasmol: h,
              defaultColors: Object.assign({}, h),
              greenCarbon: Object.assign(Object.assign({}, h), { C: 65280 }),
              cyanCarbon: Object.assign(Object.assign({}, h), { C: 65535 }),
              magentaCarbon: Object.assign(Object.assign({}, h), { C: 16711935 }),
              yellowCarbon: Object.assign(Object.assign({}, h), { C: 16776960 }),
              whiteCarbon: Object.assign(Object.assign({}, h), { C: 16777215 }),
              orangeCarbon: Object.assign(Object.assign({}, h), { C: 16753920 }),
              purpleCarbon: Object.assign(Object.assign({}, h), { C: 8388736 }),
              blueCarbon: Object.assign(Object.assign({}, h), { C: 255 })
            }, v = {
              /** @property standard amino acid color scheme*/
              amino: {
                ALA: 13158600,
                ARG: 1334015,
                ASN: 56540,
                ASP: 15075850,
                CYS: 15132160,
                GLN: 56540,
                GLU: 15075850,
                GLY: 15461355,
                HIS: 8553170,
                ILE: 1016335,
                LEU: 1016335,
                LYS: 1334015,
                MET: 15132160,
                PHE: 3289770,
                PRO: 14456450,
                SER: 16422400,
                THR: 16422400,
                TRP: 11819700,
                TYR: 3289770,
                VAL: 1016335,
                ASX: 16738740,
                GLX: 16738740
              },
              /** @property shapely amino acid color scheme*/
              shapely: {
                ALA: 9240460,
                ARG: 124,
                ASN: 16743536,
                ASP: 10485826,
                CYS: 16777072,
                GLN: 16731212,
                GLU: 6684672,
                GLY: 16777215,
                HIS: 7368959,
                ILE: 19456,
                LEU: 4546117,
                LYS: 4671416,
                MET: 12099650,
                PHE: 5459026,
                PRO: 5395026,
                SER: 16740418,
                THR: 12078080,
                TRP: 5195264,
                TYR: 9203788,
                VAL: 16747775,
                ASX: 16711935,
                GLX: 16711935
              },
              /** @property nucleic acid color scheme*/
              nucleic: {
                A: 10526975,
                G: 16740464,
                I: 8454143,
                C: 16747595,
                T: 10551200,
                U: 16744576
              }
            }, g = {
              /** @property chain based standard color scheme */
              atom: {
                A: 12636415,
                B: 11599792,
                C: 16761032,
                D: 16777088,
                E: 16761087,
                F: 11596016,
                G: 16765040,
                H: 15761536,
                I: 16113331,
                J: 49151,
                K: 13458524,
                L: 6737322,
                M: 10145074,
                N: 15631086,
                O: 52945,
                P: 65407,
                Q: 3978097,
                R: 139,
                S: 12433259,
                T: 25600,
                U: 8388608,
                V: 8421376,
                W: 8388736,
                X: 32896,
                Y: 12092939,
                Z: 11674146
              },
              /** @property hetatm color scheme */
              hetatm: {
                A: 9478351,
                B: 8441752,
                C: 13602992,
                D: 13619056,
                E: 13603023,
                F: 8437952,
                G: 13607008,
                H: 12603504,
                I: 12955267,
                J: 42959,
                K: 11881548,
                L: 5682578,
                M: 9090346,
                N: 12481214,
                O: 46753,
                P: 53103,
                Q: 3447649,
                R: 187,
                S: 10854235,
                T: 37888,
                U: 11534336,
                V: 11579392,
                W: 11534512,
                X: 45232,
                Y: 15250963,
                Z: 12726834
              }
            }, w = {
              /** secondary structure pymol */
              ssPyMol: { prop: "ss", map: f.pyMol },
              ssJmol: { prop: "ss", map: f.Jmol },
              Jmol: { prop: "elem", map: p.Jmol },
              amino: { prop: "resn", map: v.amino },
              shapely: { prop: "resn", map: v.shapely },
              nucleic: { prop: "resn", map: v.nucleic },
              chain: { prop: "chain", map: g.atom },
              rasmol: { prop: "elem", map: p.rasmol },
              default: { prop: "elem", map: p.defaultColors },
              greenCarbon: { prop: "elem", map: p.greenCarbon },
              chainHetatm: { prop: "chain", map: g.hetatm },
              cyanCarbon: { prop: "elem", map: p.cyanCarbon },
              magentaCarbon: { prop: "elem", map: p.magentaCarbon },
              purpleCarbon: { prop: "elem", map: p.purpleCarbon },
              whiteCarbon: { prop: "elem", map: p.whiteCarbon },
              orangeCarbon: { prop: "elem", map: p.orangeCarbon },
              yellowCarbon: { prop: "elem", map: p.yellowCarbon },
              blueCarbon: { prop: "elem", map: p.blueCarbon }
            };
          }
        ),
        /***/
        "./src/glcartoon.ts": (
          /*!**************************!*\
            !*** ./src/glcartoon.ts ***!
            \**************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              drawCartoon: () => (
                /* binding */
                G
              ),
              /* harmony export */
              subdivide_spline: () => (
                /* binding */
                g
              )
              /* harmony export */
            });
            var o = n(
              /*! ./WebGL/math */
              "./src/WebGL/math/index.ts"
            ), l = n(
              /*! ./WebGL/shapes */
              "./src/WebGL/shapes/index.ts"
            ), u = n(
              /*! ./WebGL */
              "./src/WebGL/index.ts"
            ), f = n(
              /*! ./Gradient */
              "./src/Gradient.ts"
            ), h = n(
              /*! ./colors */
              "./src/colors.ts"
            ), p = n(
              /*! ./GLDraw */
              "./src/GLDraw.ts"
            ), v = n(
              /*! ./utilities */
              "./src/utilities.ts"
            );
            function g(B, F) {
              var H = [], W = B;
              W = [], W.push(B[0]);
              var V, X, Z, Q, q, J, ie, ne, ge;
              for (V = 1, X = B.length - 1; V < X; V++)
                if (q = B[V], J = B[V + 1], q.smoothen) {
                  var ye = new o.Vector3((q.x + J.x) / 2, (q.y + J.y) / 2, (q.z + J.z) / 2);
                  ye.atom = q.atom, W.push(ye);
                } else
                  W.push(q);
              for (W.push(B[B.length - 1]), V = -1, Z = W.length; V <= Z - 3; V++)
                if (Q = W[V === -1 ? 0 : V], q = W[V + 1], J = W[V + 2], ie = W[V === Z - 3 ? Z - 1 : V + 3], ne = new o.Vector3().subVectors(J, Q).multiplyScalar(0.5), ge = new o.Vector3().subVectors(ie, q).multiplyScalar(0.5), !J.skip)
                  for (var xe = 0; xe < F; xe++) {
                    var we = 1 / F * xe, de = q.x + we * ne.x + we * we * (-3 * q.x + 3 * J.x - 2 * ne.x - ge.x) + we * we * we * (2 * q.x - 2 * J.x + ne.x + ge.x), Te = q.y + we * ne.y + we * we * (-3 * q.y + 3 * J.y - 2 * ne.y - ge.y) + we * we * we * (2 * q.y - 2 * J.y + ne.y + ge.y), Ce = q.z + we * ne.z + we * we * (-3 * q.z + 3 * J.z - 2 * ne.z - ge.z) + we * we * we * (2 * q.z - 2 * J.z + ne.z + ge.z), ee = new o.Vector3(de, Te, Ce);
                    xe < F / 2 ? ee.atom = q.atom : ee.atom = J.atom, H.push(ee);
                  }
              return H.push(W[W.length - 1]), H;
            }
            const w = 0.5, E = 1.3, T = 0.8, R = 0.4, _ = 0.4;
            function b(B, F, H, W) {
              for (var V, X, Z, Q, q = 0, J = F.length; q < J; q++) {
                Q = Math.round(q * (W.length - 1) / J), Z = h.CC.color(W[Q]);
                var ie = B.updateGeoGroup(2), ne = ie.vertexArray, ge = ie.colorArray, ye = ie.faceArray;
                V = ie.vertices, X = V * 3, ne[X] = F[q].x, ne[X + 1] = F[q].y, ne[X + 2] = F[q].z, ne[X + 3] = H[q].x, ne[X + 4] = H[q].y, ne[X + 5] = H[q].z;
                for (var xe = 0; xe < 6; ++xe)
                  ge[X + 3 * xe] = Z.r, ge[X + 1 + 3 * xe] = Z.g, ge[X + 2 + 3 * xe] = Z.b;
                if (q > 0) {
                  var we = [V, V + 1, V - 1, V - 2], de = ie.faceidx;
                  ye[de] = we[0], ye[de + 1] = we[1], ye[de + 2] = we[3], ye[de + 3] = we[1], ye[de + 4] = we[2], ye[de + 5] = we[3], ie.faceidx += 6;
                }
                ie.vertices += 2;
              }
            }
            function M(B, F, H, W, V, X, Z) {
              var Q, q, J, ie;
              if (J = F.length, J < 2 || F[0].length < 2)
                return;
              for (Q = 0; Q < J; Q++)
                F[Q] = g(F[Q], W);
              if (ie = F[0].length, !V)
                return b(B, F[0], F[J - 1], H);
              var ne, ge, ye, xe, we, de, Te = [], Ce = [], ee = [];
              for (q = 0; q < J; q++)
                Te.push(0.25 + 1.5 * Math.sqrt((J - 1) * q - Math.pow(q, 2)) / (J - 1)), Ce.push(0.5), ee.push(2 * (Math.pow(q / J, 2) - q / J) + 0.6);
              var Ae = [];
              for (q = 0; q < J * 2 - 1; q++)
                Ae[q] = [q, q + 1, q + 1 - 2 * J, q - 2 * J];
              Ae[J * 2 - 1] = [
                q,
                q + 1 - 2 * J,
                q + 1 - 4 * J,
                q - 2 * J
              ];
              var be, Fe, et, Ye, De, Ue, Qe, ue, te, Be;
              let Je = B.updateGeoGroup();
              for (Q = 0; Q < ie; Q++) {
                let ae = B.groups, se = !1;
                Je = B.updateGeoGroup(2 * J), ae != B.groups && Q > 0 && (Q = Q - 1, se = !0), Ue = Math.round(Q * (H.length - 1) / ie), De = h.CC.color(H[Ue]), we = ye, de = xe, ye = [], xe = [], ne = [], F[0][Q].atom !== void 0 && (Ye = F[0][Q].atom, Z === "oval" ? ge = Te : Z === "rectangle" ? ge = Ce : Z === "parabola" && (ge = ee)), ge || (ge = Ce);
                var ft, lt;
                for (q = 0; q < J; q++)
                  Q < ie - 1 ? ft = F[q][Q + 1].clone().sub(F[q][Q]) : ft = F[q][Q - 1].clone().sub(F[q][Q]).negate(), q < J - 1 ? lt = F[q + 1][Q].clone().sub(F[q][Q]) : lt = F[q - 1][Q].clone().sub(F[q][Q]).negate(), ne[q] = lt.cross(ft).normalize().multiplyScalar(V * ge[q]);
                for (q = 0; q < J; q++)
                  ye[q] = F[q][Q].clone().add(ne[q].clone().negate());
                for (q = 0; q < J; q++)
                  xe[q] = F[q][Q].clone().add(ne[q]);
                for (Qe = Je.vertexArray, ue = Je.colorArray, te = Je.faceArray, be = Je.vertices, Fe = be * 3, q = 0; q < J; q++)
                  Qe[Fe + 3 * q + 0] = ye[q].x, Qe[Fe + 3 * q + 1] = ye[q].y, Qe[Fe + 3 * q + 2] = ye[q].z;
                for (q = 0; q < J; q++)
                  Qe[Fe + 3 * q + 0 + 3 * J] = xe[J - 1 - q].x, Qe[Fe + 3 * q + 1 + 3 * J] = xe[J - 1 - q].y, Qe[Fe + 3 * q + 2 + 3 * J] = xe[J - 1 - q].z;
                for (q = 0; q < 2 * J; ++q)
                  ue[Fe + 3 * q + 0] = De.r, ue[Fe + 3 * q + 1] = De.g, ue[Fe + 3 * q + 2] = De.b;
                if (Q > 0 && !se) {
                  for (q = 0; q < J * 2; q++)
                    Be = [
                      be + Ae[q][0],
                      be + Ae[q][1],
                      be + Ae[q][2],
                      be + Ae[q][3]
                    ], et = Je.faceidx, te[et] = Be[0], te[et + 1] = Be[1], te[et + 2] = Be[3], te[et + 3] = Be[1], te[et + 4] = Be[2], te[et + 5] = Be[3], Je.faceidx += 6;
                  if (Ye.clickable || Ye.hoverable) {
                    var he = [];
                    he.push(new l.Triangle(we[0], ye[0], ye[J - 1])), he.push(new l.Triangle(we[0], ye[J - 1], we[J - 1])), he.push(new l.Triangle(we[J - 1], ye[J - 1], xe[J - 1])), he.push(new l.Triangle(we[J - 1], xe[J - 1], de[J - 1])), he.push(new l.Triangle(xe[0], de[0], de[J - 1])), he.push(new l.Triangle(xe[J - 1], xe[0], de[J - 1])), he.push(new l.Triangle(ye[0], we[0], de[0])), he.push(new l.Triangle(xe[0], ye[0], de[0]));
                    for (q in he)
                      Ye.intersectionShape.triangle.push(he[q]);
                  }
                }
                Je.vertices += 2 * J;
              }
              for (Qe = Je.vertexArray, ue = Je.colorArray, te = Je.faceArray, be = Je.vertices, Fe = be * 3, et = Je.faceidx, Q = 0; Q < J - 1; Q++)
                Be = [Q, Q + 1, 2 * J - 2 - Q, 2 * J - 1 - Q], et = Je.faceidx, te[et] = Be[0], te[et + 1] = Be[1], te[et + 2] = Be[3], te[et + 3] = Be[1], te[et + 4] = Be[2], te[et + 5] = Be[3], Je.faceidx += 6;
              for (Q = 0; Q < J - 1; Q++)
                Be = [
                  be - 1 - Q,
                  be - 2 - Q,
                  be - 2 * J + Q + 1,
                  be - 2 * J + Q
                ], et = Je.faceidx, te[et] = Be[0], te[et + 1] = Be[1], te[et + 2] = Be[3], te[et + 3] = Be[1], te[et + 4] = Be[2], te[et + 5] = Be[3], Je.faceidx += 6;
            }
            function A(B, F, H, W, V, X) {
              if (!(F.length < 2)) {
                var Z, Q;
                if (Z = F[0], Q = F[F.length - 1], Z = g(Z, W), Q = g(Q, W), !V)
                  return b(B, Z, Q, H);
                var q = [], J, ie, ne, ge, ye, xe = [
                  [0, 2, -6, -8],
                  [-4, -2, 6, 4],
                  [7, -1, -5, 3],
                  [-3, 5, 1, -7]
                ], we, de, Te, Ce, ee, Ae, be, Fe, et, Ye, De, Ue, Qe, ue, te, Be, Je;
                for (Fe = 0, et = Z.length; Fe < et; Fe++) {
                  if (ee = Math.round(Fe * (H.length - 1) / et), Ce = h.CC.color(H[ee]), q.push(ie = Z[Fe]), q.push(ie), q.push(ne = Q[Fe]), q.push(ne), Fe < et - 1) {
                    var ft = Z[Fe + 1].clone().sub(Z[Fe]), lt = Q[Fe].clone().sub(Z[Fe]);
                    J = lt.cross(ft).normalize().multiplyScalar(V);
                  }
                  for (q.push(ge = Z[Fe].clone().add(J)), q.push(ge), q.push(ye = Q[Fe].clone().add(J)), q.push(ye), ie.atom !== void 0 && (Ae = ie.atom), ue = B.updateGeoGroup(8), te = ue.vertexArray, Be = ue.colorArray, Je = ue.faceArray, we = ue.vertices, de = we * 3, te[de] = ie.x, te[de + 1] = ie.y, te[de + 2] = ie.z, te[de + 3] = ie.x, te[de + 4] = ie.y, te[de + 5] = ie.z, te[de + 6] = ne.x, te[de + 7] = ne.y, te[de + 8] = ne.z, te[de + 9] = ne.x, te[de + 10] = ne.y, te[de + 11] = ne.z, te[de + 12] = ge.x, te[de + 13] = ge.y, te[de + 14] = ge.z, te[de + 15] = ge.x, te[de + 16] = ge.y, te[de + 17] = ge.z, te[de + 18] = ye.x, te[de + 19] = ye.y, te[de + 20] = ye.z, te[de + 21] = ye.x, te[de + 22] = ye.y, te[de + 23] = ye.z, Ye = 0; Ye < 8; ++Ye)
                    Be[de + 3 * Ye] = Ce.r, Be[de + 1 + 3 * Ye] = Ce.g, Be[de + 2 + 3 * Ye] = Ce.b;
                  if (Fe > 0) {
                    var he = be !== void 0 && Ae !== void 0 && be.serial !== Ae.serial;
                    for (Ye = 0; Ye < 4; Ye++) {
                      var ae = [
                        we + xe[Ye][0],
                        we + xe[Ye][1],
                        we + xe[Ye][2],
                        we + xe[Ye][3]
                      ];
                      if (Te = ue.faceidx, Je[Te] = ae[0], Je[Te + 1] = ae[1], Je[Te + 2] = ae[3], Je[Te + 3] = ae[1], Je[Te + 4] = ae[2], Je[Te + 5] = ae[3], ue.faceidx += 6, Ae.clickable || be.clickable || Ae.hoverable || be.hoverable) {
                        var se = q[ae[3]].clone(), Re = q[ae[0]].clone(), Oe = q[ae[2]].clone(), We = q[ae[1]].clone();
                        if (se.atom = q[ae[3]].atom || null, Oe.atom = q[ae[2]].atom || null, Re.atom = q[ae[0]].atom || null, We.atom = q[ae[1]].atom || null, he) {
                          var Ct = se.clone().add(Re).multiplyScalar(0.5), le = Oe.clone().add(We).multiplyScalar(0.5), ke = se.clone().add(We).multiplyScalar(0.5);
                          Ye % 2 === 0 ? ((be.clickable || be.hoverable) && (De = new l.Triangle(Ct, ke, se), Ue = new l.Triangle(le, Oe, ke), Qe = new l.Triangle(ke, Oe, se), be.intersectionShape.triangle.push(De), be.intersectionShape.triangle.push(Ue), be.intersectionShape.triangle.push(Qe)), (Ae.clickable || Ae.hoverable) && (De = new l.Triangle(Re, We, ke), Ue = new l.Triangle(We, le, ke), Qe = new l.Triangle(Re, ke, Ct), Ae.intersectionShape.triangle.push(De), Ae.intersectionShape.triangle.push(Ue), Ae.intersectionShape.triangle.push(Qe))) : ((Ae.clickable || Ae.hoverable) && (De = new l.Triangle(Ct, ke, se), Ue = new l.Triangle(le, Oe, ke), Qe = new l.Triangle(ke, Oe, se), Ae.intersectionShape.triangle.push(De), Ae.intersectionShape.triangle.push(Ue), Ae.intersectionShape.triangle.push(Qe)), (be.clickable || be.hoverable) && (De = new l.Triangle(Re, We, ke), Ue = new l.Triangle(We, le, ke), Qe = new l.Triangle(Re, ke, Ct), be.intersectionShape.triangle.push(De), be.intersectionShape.triangle.push(Ue), be.intersectionShape.triangle.push(Qe)));
                        } else
                          (Ae.clickable || Ae.hoverable) && (De = new l.Triangle(Re, We, se), Ue = new l.Triangle(We, Oe, se), Ae.intersectionShape.triangle.push(De), Ae.intersectionShape.triangle.push(Ue));
                      }
                    }
                  }
                  ue.vertices += 8, be = Ae;
                }
                var Ke = q.length - 8;
                for (ue = B.updateGeoGroup(8), te = ue.vertexArray, Be = ue.colorArray, Je = ue.faceArray, we = ue.vertices, de = we * 3, Te = ue.faceidx, Fe = 0; Fe < 4; Fe++) {
                  q.push(q[Fe * 2]), q.push(q[Ke + Fe * 2]);
                  var me = q[Fe * 2], Ee = q[Ke + Fe * 2];
                  te[de + 6 * Fe] = me.x, te[de + 1 + 6 * Fe] = me.y, te[de + 2 + 6 * Fe] = me.z, te[de + 3 + 6 * Fe] = Ee.x, te[de + 4 + 6 * Fe] = Ee.y, te[de + 5 + 6 * Fe] = Ee.z, Be[de + 6 * Fe] = Ce.r, Be[de + 1 + 6 * Fe] = Ce.g, Be[de + 2 + 6 * Fe] = Ce.b, Be[de + 3 + 6 * Fe] = Ce.r, Be[de + 4 + 6 * Fe] = Ce.g, Be[de + 5 + 6 * Fe] = Ce.b;
                }
                Ke += 8, De = [we, we + 2, we + 6, we + 4], Ue = [we + 1, we + 5, we + 7, we + 3], Je[Te] = De[0], Je[Te + 1] = De[1], Je[Te + 2] = De[3], Je[Te + 3] = De[1], Je[Te + 4] = De[2], Je[Te + 5] = De[3], Je[Te + 6] = Ue[0], Je[Te + 7] = Ue[1], Je[Te + 8] = Ue[3], Je[Te + 9] = Ue[1], Je[Te + 10] = Ue[2], Je[Te + 11] = Ue[3], ue.faceidx += 12, ue.vertices += 8;
              }
            }
            function $(B, F, H, W, V, X, Z) {
              (!Z || Z === "default") && (Z = "rectangle"), Z === "edged" ? A(B, F, H, W, V) : (Z === "rectangle" || Z === "oval" || Z === "parabola") && M(B, F, H, W, V, X, Z);
            }
            function S(B) {
              return B && B.elem === "C" && B.atom === "CA";
            }
            function C(B, F) {
              if (B && F && B.chain === F.chain) {
                if (!B.hetflag && !F.hetflag && B.reschain === F.reschain && (B.resi === F.resi || B.resi === F.resi - 1))
                  return !0;
                if (B.resi < F.resi) {
                  var H = B.x - F.x, W = B.y - F.y, V = B.z - F.z, X = H * H + W * W + V * V;
                  if (B.atom == "CA" && F.atom == "CA" && X < 16 || (B.atom == "P" || F.atom == "P") && X < 64)
                    return !0;
                }
              }
              return !1;
            }
            function D(B, F, H, W, V) {
              if (!(F == null || F.vertices == 0)) {
                V && (F.initTypedArrays(), F.setUpNormals());
                var X = new u.MeshDoubleLambertMaterial();
                X.vertexColors = u.Coloring.FaceColors, typeof H == "number" && H >= 0 && H < 1 && (X.transparent = !0, X.opacity = H), X.outline = W;
                var Z = new u.Mesh(F, X);
                B.add(Z);
              }
            }
            function O(B, F, H, W, V, X, Z, Q, q) {
              var J, ie, ne, ge, ye, xe;
              if (!(!W || !V || !Z)) {
                var we = V.sub(W);
                we.normalize();
                var de = Q[q];
                for (ie = q + 1; ie < Q.length && (de = Q[ie], de.atom != Z.atom); ie++)
                  ;
                if (de = de ? new o.Vector3(de.x, de.y, de.z) : new o.Vector3(0, 0, 0), de.sub(W), Z.ss === "arrow start") {
                  var Te = de.clone().multiplyScalar(0.3).cross(V);
                  W.add(Te);
                  var Ce = de.clone().cross(we).normalize();
                  we.rotateAboutVector(Ce, 0.43);
                }
                for (Z.style.cartoon.ribbon ? J = Z.style.cartoon.thickness || R : Z.style.cartoon.width ? J = Z.style.cartoon.width : Z.ss === "c" ? Z.atom === "P" ? J = T : J = w : Z.ss === "arrow start" ? (J = E, ye = !0) : Z.ss === "arrow end" || Z.ss === "h" && Z.style.cartoon.tubes || Z.ss === "tube start" ? J = w : J = E, X != null && we.dot(X) < 0 && we.negate(), we.multiplyScalar(J), ie = 0; ie < F; ie++)
                  ne = -1 + ie * 2 / (F - 1), ge = new o.Vector3(W.x + ne * we.x, W.y + ne * we.y, W.z + ne * we.z), ge.atom = Z, Z.ss === "s" && (ge.smoothen = !0), B[ie].push(ge);
                if (ye)
                  for (we.multiplyScalar(2), ie = 0; ie < F; ie++)
                    ne = -1 + ie * 2 / (F - 1), ge = new o.Vector3(W.x + ne * we.x, W.y + ne * we.y, W.z + ne * we.z), ge.atom = Z, ge.smoothen = !1, ge.skip = !0, B[ie].push(ge);
                return xe = Z.style.cartoon.style || "default", B.style ? B.style != xe && (console.log("Warning: a cartoon chain's strand-style is ambiguous"), B.style = "default") : B.style = xe, (Z.ss === "arrow start" || Z.ss === "arrow end") && (Z.ss = "s"), ye;
              }
            }
            const N = {
              C: !0,
              CA: !0,
              O: !0,
              P: !0,
              OP2: !0,
              O2P: !0,
              "O5'": !0,
              "O3'": !0,
              "C5'": !0,
              "C2'": !0,
              "O5*": !0,
              "O3*": !0,
              "C5*": !0,
              "C2*": !0,
              N1: !0,
              N3: !0
            }, j = { DA: !0, DG: !0, A: !0, G: !0 }, L = { DT: !0, DC: !0, U: !0, C: !0, T: !0 }, z = { DA: !0, DG: !0, A: !0, G: !0, DT: !0, DC: !0, U: !0, C: !0, T: !0 };
            function G(B, F, H, W = 10) {
              let V = W, X = W;
              var Z, Q, q, J, ie, ne, ge, ye, xe, we, de, Te, Ce, ee, Ae, be, Fe, et, Ye = new u.Geometry(!0), De = new u.Geometry(!0), Ue = [], Qe = [], ue = 1, te = !1, Be = {};
              for (var Je in f.Gradient.builtinGradients)
                f.Gradient.builtinGradients.hasOwnProperty(Je) && (Be[Je] = new f.Gradient.builtinGradients[Je](H[1], H[0]));
              var ft = function(ce, _e) {
                return H && _e.color === "spectrum" ? _e.colorscheme in Be ? Be[_e.colorscheme].valueToHex(ce.resi) : Be.sinebow.valueToHex(ce.resi) : (0, v.getColorFromStyle)(ce, _e).getHex();
              };
              for (ye = 0; ye < V; ye++)
                Qe[ye] = [];
              var lt = !1, he = !1, ae = [];
              for (ye in F) {
                if (J = F[ye], J.elem === "C" && J.atom === "CA") {
                  var se = C(q, J);
                  se && J.ss === "s" ? lt = !0 : lt && (q && Q && q.style.cartoon.arrows && Q.style.cartoon.arrows && (q.ss = "arrow end", Q.ss = "arrow start"), lt = !1), se && (q.ss === "h" || q.ss == "tube start") && q.style.cartoon.tubes ? !he && q.ss != "tube start" && J.style.cartoon.tubes && (J.ss = "tube start", he = !0) : he && (q.ss === "tube start" ? q.ss = "tube end" : Q && Q.style.cartoon.tubes && (Q.ss = "tube end"), he = !1), Q = q, q = J;
                }
                J && J.atom in N && ae.push(J);
              }
              he && q.style.cartoon.tubes && (q.ss = "tube end", he = !1);
              var Re = function(ce) {
                Qe[0].length > 0 && $(De, Qe, Ue, X, ge, ue, Qe.style);
                var _e = [], Ht = null;
                if (ce) {
                  for (ye = 0; ye < V; ye++)
                    _e[ye] = Qe[ye][Qe[ye].length - 1];
                  Ht = Ue[Ue.length - 1];
                }
                for (Qe = [], ye = 0; ye < V; ye++)
                  Qe[ye] = [];
                if (Ue = [], ce) {
                  for (ye = 0; ye < V; ye++)
                    Qe[ye].push(_e[ye]);
                  Ue.push(Ht);
                }
                D(B, De, ue, te, !0), D(B, Ye, ue, te, !1), De = new u.Geometry(!0), Ye = new u.Geometry(!0);
              };
              q = void 0;
              for (var Oe = 0; Oe < ae.length; Oe++) {
                J = ae[Oe];
                var We = J.resn.trim(), Ct = We in z;
                if (ue = 1, Z = J.style.cartoon, q && q.style.cartoon && (ue = q.style.cartoon.opacity), q && q.style.cartoon && q.style.cartoon.outline && (te = q.style.cartoon.outline), q && q.style.cartoon && (!J.style.cartoon || q.style.cartoon.opacity != J.style.cartoon.opacity) && Re(q.chain == J.chain), Z.style === "trace") {
                  if (!J.hetflag && (J.elem === "C" && J.atom === "CA" || Ct && J.atom === "P" || J.atom === "BB")) {
                    if (ne = ft(J, Z), (0, v.isNumeric)(Z.thickness) ? ge = Z.thickness : ge = R, C(q, J))
                      if (ne == ie) {
                        var le = h.CC.color(ne);
                        p.GLDraw.drawCylinder(Ye, q, J, ge, le, 2, 2);
                      } else {
                        var ke = new o.Vector3().addVectors(q, J).multiplyScalar(0.5), Ke = h.CC.color(ie), me = h.CC.color(ne);
                        p.GLDraw.drawCylinder(Ye, q, ke, ge, Ke, 2, 0), p.GLDraw.drawCylinder(Ye, ke, J, ge, me, 0, 2);
                      }
                    if ((J.clickable === !0 || J.hoverable) && J.intersectionShape !== void 0) {
                      var Ee = new o.Vector3(J.x, J.y, J.z);
                      J.intersectionShape.sphere.push(new l.Sphere(Ee, ge));
                    }
                    q = J, ie = ne;
                  }
                } else {
                  if (S(J) || Ct && (J.atom === "P" || J.atom.indexOf("O5") == 0)) {
                    if (et)
                      if (J.ss === "tube end")
                        et = !1, Fe = new o.Vector3(J.x, J.y, J.z), p.GLDraw.drawCylinder(Ye, be, Fe, 2, h.CC.color(ie), 1, 1), J.ss = "h";
                      else if (q.chain != J.chain || q.ss === "tube end")
                        et = !1, q.ss = "h", Fe = new o.Vector3(q.x, q.y, q.z), p.GLDraw.drawCylinder(Ye, be, Fe, 2, h.CC.color(ie), 1, 1);
                      else
                        continue;
                    if (q && (!C(q, J) || q.ss === "tube start")) {
                      for (q.ss === "tube start" && (et = !0, be = new o.Vector3(q.x, q.y, q.z), q.ss = "h"), Ae && (Te ? ee = new o.Vector3().addVectors(q, Te).multiplyScalar(0.5) : ee = new o.Vector3(q.x, q.y, q.z), p.GLDraw.drawCylinder(Ye, ee, Ae, _, h.CC.color(Ae.color), 0, 2), O(Qe, V, !0, Te, Ce, de, q, ae, Oe), Ue.push(ne), ee = null, Ae = null), Qe[0].length > 0 && $(De, Qe, Ue, X, ge, ue, Qe.style), Qe = [], ye = 0; ye < V; ye++)
                        Qe[ye] = [];
                      Ue = [];
                    }
                    if (q === void 0 || q.rescode != J.rescode || q.resi != J.resi) {
                      if (Ae && q != null) {
                        ee = new o.Vector3().addVectors(q, J).multiplyScalar(0.5);
                        var tt = ee.clone().sub(Ae).multiplyScalar(0.02);
                        ee.add(tt), p.GLDraw.drawCylinder(Ye, ee, Ae, _, h.CC.color(Ae.color), 0, 2), ee = null, Ae = null;
                      }
                      ne = ft(J, Z), Ue.push(ne), (0, v.isNumeric)(Z.thickness) ? ge = Z.thickness : ge = R, q = J, xe = new o.Vector3(q.x, q.y, q.z), xe.resi = q.resi, ie = ne;
                    }
                    (J.clickable === !0 || J.hoverable === !0) && (J.intersectionShape === void 0 || J.intersectionShape.triangle === void 0) && (J.intersectionShape = {
                      sphere: null,
                      cylinder: [],
                      line: [],
                      triangle: []
                    });
                  } else
                    q != null && (S(q) && J.atom === "O" || Ct && q.atom === "P" && (J.atom === "OP2" || J.atom === "O2P") || Ct && q.atom.indexOf("O5") == 0 && J.atom.indexOf("C5") == 0) ? (we = new o.Vector3(J.x, J.y, J.z), we.resi = J.resi, (J.atom === "OP2" || J.atom === "O2P") && (Ce = new o.Vector3(J.x, J.y, J.z))) : Ct && J.atom.indexOf("O3") == 0 ? Te = new o.Vector3(J.x, J.y, J.z) : (J.atom === "N1" && We in j || J.atom === "N3" && We in L) && (Ae = new o.Vector3(J.x, J.y, J.z), Ae.color = (0, v.getColorFromStyle)(J, Z).getHex());
                  we && xe && we.resi === xe.resi && (O(Qe, V, !0, xe, we, de, q, ae, Oe), de = we, xe = null, we = null, Ue.push(ne));
                }
              }
              Ae && (Te ? ee = new o.Vector3().addVectors(q, Te).multiplyScalar(0.5) : ee = new o.Vector3(q.x, q.y, q.z), p.GLDraw.drawCylinder(Ye, ee, Ae, _, h.CC.color(Ae.color), 0, 2), O(Qe, V, !0, Te, Ce, de, q, ae, Oe), Ue.push(ne)), Re(!1);
            }
          }
        ),
        /***/
        "./src/index.ts": (
          /*!**********************!*\
            !*** ./src/index.ts ***!
            \**********************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              CAP: () => (
                /* reexport safe */
                _.CAP
              ),
              /* harmony export */
              CC: () => (
                /* reexport safe */
                l.CC
              ),
              /* harmony export */
              Color: () => (
                /* reexport safe */
                l.Color
              ),
              /* harmony export */
              CustomLinear: () => (
                /* reexport safe */
                o.CustomLinear
              ),
              /* harmony export */
              Cylinder: () => (
                /* reexport safe */
                v.Cylinder
              ),
              /* harmony export */
              GLDraw: () => (
                /* reexport safe */
                _.GLDraw
              ),
              /* harmony export */
              GLModel: () => (
                /* reexport safe */
                M.GLModel
              ),
              /* harmony export */
              GLShape: () => (
                /* reexport safe */
                R.GLShape
              ),
              /* harmony export */
              GLViewer: () => (
                /* reexport safe */
                A.GLViewer
              ),
              /* harmony export */
              GLVolumetricRender: () => (
                /* reexport safe */
                T.GLVolumetricRender
              ),
              /* harmony export */
              Gradient: () => (
                /* reexport safe */
                o.Gradient
              ),
              /* harmony export */
              GradientType: () => (
                /* reexport safe */
                o.GradientType
              ),
              /* harmony export */
              Label: () => (
                /* reexport safe */
                u.Label
              ),
              /* harmony export */
              LabelCount: () => (
                /* reexport safe */
                u.LabelCount
              ),
              /* harmony export */
              MarchingCube: () => (
                /* reexport safe */
                w.MarchingCube
              ),
              /* harmony export */
              MarchingCubeInitializer: () => (
                /* reexport safe */
                w.MarchingCubeInitializer
              ),
              /* harmony export */
              Matrix3: () => (
                /* reexport safe */
                p.Matrix3
              ),
              /* harmony export */
              Matrix4: () => (
                /* reexport safe */
                p.Matrix4
              ),
              /* harmony export */
              Parsers: () => (
                /* reexport safe */
                h.Parsers
              ),
              /* harmony export */
              PausableTimer: () => (
                /* reexport safe */
                g.PausableTimer
              ),
              /* harmony export */
              PointGrid: () => (
                /* reexport safe */
                w.PointGrid
              ),
              /* harmony export */
              ProteinSurface: () => (
                /* reexport safe */
                w.ProteinSurface
              ),
              /* harmony export */
              Quaternion: () => (
                /* reexport safe */
                p.Quaternion
              ),
              /* harmony export */
              ROYGB: () => (
                /* reexport safe */
                o.ROYGB
              ),
              /* harmony export */
              RWB: () => (
                /* reexport safe */
                o.RWB
              ),
              /* harmony export */
              Ray: () => (
                /* reexport safe */
                p.Ray
              ),
              /* harmony export */
              Sinebow: () => (
                /* reexport safe */
                o.Sinebow
              ),
              /* harmony export */
              Sphere: () => (
                /* reexport safe */
                v.Sphere
              ),
              /* harmony export */
              SurfaceType: () => (
                /* reexport safe */
                w.SurfaceType
              ),
              /* harmony export */
              Triangle: () => (
                /* reexport safe */
                v.Triangle
              ),
              /* harmony export */
              Vector2: () => (
                /* reexport safe */
                p.Vector2
              ),
              /* harmony export */
              Vector3: () => (
                /* reexport safe */
                p.Vector3
              ),
              /* harmony export */
              VolumeData: () => (
                /* reexport safe */
                E.VolumeData
              ),
              /* harmony export */
              adjustVolumeStyle: () => (
                /* reexport safe */
                g.adjustVolumeStyle
              ),
              /* harmony export */
              applyPartialCharges: () => (
                /* reexport safe */
                f.applyPartialCharges
              ),
              /* harmony export */
              autoinit: () => (
                /* reexport safe */
                $.autoinit
              ),
              /* harmony export */
              autoload: () => (
                /* reexport safe */
                $.autoload
              ),
              /* harmony export */
              base64ToArray: () => (
                /* reexport safe */
                g.base64ToArray
              ),
              /* harmony export */
              bondLength: () => (
                /* reexport safe */
                h.bondLength
              ),
              /* harmony export */
              builtinColorSchemes: () => (
                /* reexport safe */
                l.builtinColorSchemes
              ),
              /* harmony export */
              builtinGradients: () => (
                /* reexport safe */
                o.builtinGradients
              ),
              /* harmony export */
              chains: () => (
                /* reexport safe */
                l.chains
              ),
              /* harmony export */
              clamp: () => (
                /* reexport safe */
                p.clamp
              ),
              /* harmony export */
              conversionMatrix3: () => (
                /* reexport safe */
                p.conversionMatrix3
              ),
              /* harmony export */
              createStereoViewer: () => (
                /* reexport safe */
                A.createStereoViewer
              ),
              /* harmony export */
              createViewer: () => (
                /* reexport safe */
                A.createViewer
              ),
              /* harmony export */
              createViewerGrid: () => (
                /* reexport safe */
                A.createViewerGrid
              ),
              /* harmony export */
              deepCopy: () => (
                /* reexport safe */
                g.deepCopy
              ),
              /* harmony export */
              degToRad: () => (
                /* reexport safe */
                p.degToRad
              ),
              /* harmony export */
              download: () => (
                /* reexport safe */
                g.download
              ),
              /* harmony export */
              drawCartoon: () => (
                /* reexport safe */
                b.drawCartoon
              ),
              /* harmony export */
              elementColors: () => (
                /* reexport safe */
                l.elementColors
              ),
              /* harmony export */
              extend: () => (
                /* reexport safe */
                g.extend
              ),
              /* harmony export */
              get: () => (
                /* reexport safe */
                g.get
              ),
              /* harmony export */
              getAtomProperty: () => (
                /* reexport safe */
                g.getAtomProperty
              ),
              /* harmony export */
              getColorFromStyle: () => (
                /* reexport safe */
                g.getColorFromStyle
              ),
              /* harmony export */
              getElement: () => (
                /* reexport safe */
                g.getElement
              ),
              /* harmony export */
              getExtent: () => (
                /* reexport safe */
                g.getExtent
              ),
              /* harmony export */
              getGradient: () => (
                /* reexport safe */
                o.getGradient
              ),
              /* harmony export */
              getPropertyRange: () => (
                /* reexport safe */
                g.getPropertyRange
              ),
              /* harmony export */
              getbin: () => (
                /* reexport safe */
                g.getbin
              ),
              /* harmony export */
              htmlColors: () => (
                /* reexport safe */
                l.htmlColors
              ),
              /* harmony export */
              isEmptyObject: () => (
                /* reexport safe */
                g.isEmptyObject
              ),
              /* harmony export */
              isNumeric: () => (
                /* reexport safe */
                g.isNumeric
              ),
              /* harmony export */
              makeFunction: () => (
                /* reexport safe */
                g.makeFunction
              ),
              /* harmony export */
              mergeGeos: () => (
                /* reexport safe */
                g.mergeGeos
              ),
              /* harmony export */
              normalizeValue: () => (
                /* reexport safe */
                o.normalizeValue
              ),
              /* harmony export */
              partialCharges: () => (
                /* reexport safe */
                f.partialCharges
              ),
              /* harmony export */
              processing_autoinit: () => (
                /* reexport safe */
                $.processing_autoinit
              ),
              /* harmony export */
              residues: () => (
                /* reexport safe */
                l.residues
              ),
              /* harmony export */
              setBondLength: () => (
                /* reexport safe */
                h.setBondLength
              ),
              /* harmony export */
              setSyncSurface: () => (
                /* reexport safe */
                w.setSyncSurface
              ),
              /* harmony export */
              specStringToObject: () => (
                /* reexport safe */
                g.specStringToObject
              ),
              /* harmony export */
              splitMesh: () => (
                /* reexport safe */
                R.splitMesh
              ),
              /* harmony export */
              ssColors: () => (
                /* reexport safe */
                l.ssColors
              ),
              /* harmony export */
              subdivide_spline: () => (
                /* reexport safe */
                b.subdivide_spline
              ),
              /* harmony export */
              syncSurface: () => (
                /* reexport safe */
                w.syncSurface
              ),
              /* harmony export */
              viewers: () => (
                /* reexport safe */
                $.viewers
              )
              /* harmony export */
            });
            var o = n(
              /*! ./Gradient */
              "./src/Gradient.ts"
            ), l = n(
              /*! ./colors */
              "./src/colors.ts"
            ), u = n(
              /*! ./Label */
              "./src/Label.ts"
            ), f = n(
              /*! ./partialCharges */
              "./src/partialCharges.ts"
            ), h = n(
              /*! ./parsers */
              "./src/parsers/index.ts"
            ), p = n(
              /*! ./WebGL/math */
              "./src/WebGL/math/index.ts"
            ), v = n(
              /*! ./WebGL/shapes */
              "./src/WebGL/shapes/index.ts"
            ), g = n(
              /*! ./utilities */
              "./src/utilities.ts"
            ), w = n(
              /*! ./ProteinSurface4 */
              "./src/ProteinSurface4.ts"
            ), E = n(
              /*! ./VolumeData */
              "./src/VolumeData.ts"
            ), T = n(
              /*! ./VolumetricRender */
              "./src/VolumetricRender.ts"
            ), R = n(
              /*! ./GLShape */
              "./src/GLShape.ts"
            ), _ = n(
              /*! ./GLDraw */
              "./src/GLDraw.ts"
            ), b = n(
              /*! ./glcartoon */
              "./src/glcartoon.ts"
            ), M = n(
              /*! ./GLModel */
              "./src/GLModel.ts"
            ), A = n(
              /*! ./GLViewer */
              "./src/GLViewer.ts"
            ), $ = n(
              /*! ./autoload */
              "./src/autoload.ts"
            );
            n(
              /*! ./specs */
              "./src/specs.ts"
            ), window && (window.$3Dmol = e);
          }
        ),
        /***/
        "./src/parsers/CDJSON.ts": (
          /*!*******************************!*\
            !*** ./src/parsers/CDJSON.ts ***!
            \*******************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              CDJSON: () => (
                /* binding */
                o
              )
              /* harmony export */
            });
            function o(l, u) {
              var f = [[]];
              typeof l == "string" && (l = JSON.parse(l));
              for (var h = l.m, p = h[0].a, v = h[0].b, g = h[0].s, w = u !== void 0 && u.parseStyle !== void 0 ? u.parseStyle : g !== void 0, E = f[f.length - 1].length, T = 0; T < p.length; T++) {
                var R = p[T], _ = {};
                _.id = R.i, _.x = R.x, _.y = R.y, _.z = R.z || 0, _.bonds = [], _.bondOrder = [];
                var b = R.l || "C";
                _.elem = b[0].toUpperCase() + b.substring(1).toLowerCase(), _.serial = f[f.length - 1].length, w && (_.style = g[R.s || 0]), f[f.length - 1].push(_);
              }
              for (let M = 0; M < v.length; M++) {
                let A = v[M], $ = A.b + E, S = A.e + E, C = A.o || 1, D = f[f.length - 1][$], O = f[f.length - 1][S];
                D.bonds.push(S), D.bondOrder.push(C), O.bonds.push($), O.bondOrder.push(C);
              }
              return f;
            }
          }
        ),
        /***/
        "./src/parsers/CIF.ts": (
          /*!****************************!*\
            !*** ./src/parsers/CIF.ts ***!
            \****************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              CIF: () => (
                /* binding */
                h
              )
              /* harmony export */
            });
            var o = n(
              /*! ./utils/computeSecondaryStructure */
              "./src/parsers/utils/computeSecondaryStructure.ts"
            ), l = n(
              /*! ./utils/processSymmetries */
              "./src/parsers/utils/processSymmetries.ts"
            ), u = n(
              /*! ../WebGL */
              "./src/WebGL/index.ts"
            ), f = n(
              /*! ./utils/assignPDBBonds */
              "./src/parsers/utils/assignPDBBonds.ts"
            );
            function h(p, v = {}) {
              var g = [], w = !v.doAssembly, E = g.modelData = [], T = v.assignBonds === void 0 ? !0 : v.assignBonds, R = function(ae, se, Re, Oe) {
                return new u.Vector3(se, Re, Oe).applyMatrix3(ae);
              };
              function _(ae, se) {
                for (var Re = [], Oe = 0, We = 0; We < ae.length; ) {
                  for (; ae.substring(We, We + se.length) !== se && We < ae.length; )
                    if (ae[We] === "'") {
                      for (We++; We < ae.length && ae[We] !== "'"; )
                        We++;
                      for (; ae.substring(We, We + se.length) !== se && We < ae.length; )
                        We++;
                    } else if (ae[We] === '"') {
                      for (We++; We < ae.length && ae[We] !== '"'; )
                        We++;
                      We++;
                    } else
                      We++;
                  Re.push(ae.substring(Oe, We)), Oe = We = We + se.length;
                }
                return Re;
              }
              var b = p.split(/\r?\n|\r/), M = [], A = !1;
              for (let ae = 0; ae < b.length; ae++) {
                var $ = b[ae].split("#")[0];
                if (A ? $[0] === ";" && (A = !1) : $[0] === ";" && (A = !0), A || $ !== "") {
                  if (!A && ($ = $.trim(), $[0] === "_")) {
                    var S = $.split(/\s/)[0].indexOf(".");
                    if (S > -1) {
                      let se = $.split("");
                      se[S] = "_", $ = se.join(""), $ = $.substring(0, S) + "_" + $.substring(S + 1);
                    }
                  }
                  M.push($);
                }
              }
              for (var C = 0; C < M.length; ) {
                for (; !M[C].startsWith("data_") || M[C] === "data_global"; )
                  C++;
                C++;
                for (var D = {}; C < M.length && !M[C].startsWith("data_"); )
                  if (M[C][0] === void 0)
                    C++;
                  else if (M[C][0] === "_") {
                    var O = M[C].split(/\s/)[0].toLowerCase(), N = D[O] = D[O] || [], j = M[C].substring(M[C].indexOf(O) + O.length);
                    if (j === "")
                      if (C++, M[C][0] === ";") {
                        var L = M[C].substring(1);
                        for (C++; M[C] !== ";"; )
                          L = L + `
` + M[C], C++;
                        N.push(L);
                      } else
                        N.push(M[C]);
                    else
                      N.push(j.trim());
                    C++;
                  } else if (M[C].substring(0, 5) === "loop_") {
                    C++;
                    for (var z = []; M[C] === "" || M[C][0] === "_"; ) {
                      if (M[C] !== "") {
                        let ae = M[C].split(/\s/)[0].toLowerCase(), se = D[ae] = D[ae] || [];
                        z.push(se);
                      }
                      C++;
                    }
                    for (var G = 0; C < M.length && M[C][0] !== "_" && !M[C].startsWith("loop_") && !M[C].startsWith("data_"); ) {
                      let ae = _(M[C], " ");
                      for (var B = 0; B < ae.length; B++)
                        ae[B] !== "" && (z[G].push(ae[B]), G = (G + 1) % z.length);
                      C++;
                    }
                  } else
                    C++;
                E.push({ symmetries: [] }), g.push([]);
                var F = D._atom_site_id !== void 0 ? D._atom_site_id.length : D._atom_site_label.length, H;
                if (D._cell_length_a !== void 0) {
                  var W = parseFloat(D._cell_length_a), V = parseFloat(D._cell_length_b), X = parseFloat(D._cell_length_c), Z = parseFloat(D._cell_angle_alpha) || 90, Q = parseFloat(D._cell_angle_beta) || 90, q = parseFloat(D._cell_angle_gamma) || 90;
                  H = (0, u.conversionMatrix3)(W, V, X, Z, Q, q), E[E.length - 1].cryst = {
                    a: W,
                    b: V,
                    c: X,
                    alpha: Z,
                    beta: Q,
                    gamma: q
                  };
                }
                for (var J = 0; J < F; J++)
                  if (!(D._atom_site_group_pdb !== void 0 && D._atom_site_group_pdb[J] === "TER")) {
                    var ie = {};
                    if (D._atom_site_cartn_x !== void 0)
                      ie.x = parseFloat(D._atom_site_cartn_x[J]), ie.y = parseFloat(D._atom_site_cartn_y[J]), ie.z = parseFloat(D._atom_site_cartn_z[J]);
                    else {
                      var ne = R(H, parseFloat(D._atom_site_fract_x[J]), parseFloat(D._atom_site_fract_y[J]), parseFloat(D._atom_site_fract_z[J]));
                      ie.x = ne.x, ie.y = ne.y, ie.z = ne.z;
                    }
                    ie.chain = D._atom_site_auth_asym_id ? D._atom_site_auth_asym_id[J] : D._atom_site_label_asym_id ? D._atom_site_label_asym_id[J] : void 0, ie.resi = D._atom_site_auth_seq_id ? parseInt(D._atom_site_auth_seq_id[J]) : D._atom_site_label_seq_id ? D._atom_site_label_seq_id[J] : void 0, ie.resn = D._atom_site_auth_comp_id ? D._atom_site_auth_comp_id[J].trim() : D._atom_site_label_comp_id ? D._atom_site_label_comp_id[J].trim() : void 0, ie.atom = D._atom_site_auth_atom_id ? D._atom_site_auth_atom_id[J].replace(/"/gm, "") : D._atom_site_label_atom_id ? D._atom_site_label_atom_id[J].replace(/"/gm, "") : void 0, ie.hetflag = !D._atom_site_group_pdb || D._atom_site_group_pdb[J] === "HETA" || D._atom_site_group_pdb[J] === "HETATM";
                    var ge = "X";
                    D._atom_site_type_symbol ? ge = D._atom_site_type_symbol[J].replace(/\(?\+?\d+.*/, "") : D._atom_site_label && (ge = D._atom_site_label[J].split("_")[0].replace(/\(?\d+.*/, "")), ie.elem = ge[0].toUpperCase() + ge.substring(1, 2).toLowerCase(), ie.bonds = [], ie.ss = "c", ie.serial = J, ie.bondOrder = [], ie.properties = {}, g[g.length - 1].push(ie);
                  }
                if (D._pdbx_struct_oper_list_id !== void 0 && !w)
                  for (let ae = 0; ae < D._pdbx_struct_oper_list_id.length; ae++) {
                    var ye = parseFloat(D["_pdbx_struct_oper_list_matrix[1][1]"][ae]), xe = parseFloat(D["_pdbx_struct_oper_list_matrix[1][2]"][ae]), we = parseFloat(D["_pdbx_struct_oper_list_matrix[1][3]"][ae]), de = parseFloat(D["_pdbx_struct_oper_list_vector[1]"][ae]), Te = parseFloat(D["_pdbx_struct_oper_list_matrix[2][1]"][ae]), Ce = parseFloat(D["_pdbx_struct_oper_list_matrix[2][2]"][ae]), ee = parseFloat(D["_pdbx_struct_oper_list_matrix[2][3]"][ae]), Ae = parseFloat(D["_pdbx_struct_oper_list_vector[2]"][ae]), be = parseFloat(D["_pdbx_struct_oper_list_matrix[3][1]"][ae]), Fe = parseFloat(D["_pdbx_struct_oper_list_matrix[3][2]"][ae]), et = parseFloat(D["_pdbx_struct_oper_list_matrix[3][3]"][ae]), Ye = parseFloat(D["_pdbx_struct_oper_list_vector[3]"][ae]), De = new u.Matrix4(ye, xe, we, de, Te, Ce, ee, Ae, be, Fe, et, Ye);
                    E[E.length - 1].symmetries.push(De);
                  }
                var Ue = function(ae) {
                  var se = ae.match("-");
                  ae = ae.replace(/[-xyz]/g, "");
                  var Re = ae.split("/"), Oe, We;
                  return Re[1] === void 0 ? We = 1 : We = parseInt(Re[1]), Re[0] === "" ? Oe = 1 : Oe = parseInt(Re[0]), Oe / We * (se ? -1 : 1);
                };
                if (D._symmetry_equiv_pos_as_xyz !== void 0 && !w)
                  for (var Qe = 0; Qe < D._symmetry_equiv_pos_as_xyz.length; Qe++) {
                    var ue = D._symmetry_equiv_pos_as_xyz[Qe].replace(/["' ]/g, ""), te = ue.split(",").map(function(se) {
                      return se.replace(/-/g, "+-");
                    });
                    let ae = new u.Matrix4(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1);
                    for (let se = 0; se < 3; se++) {
                      var Be = te[se].split("+");
                      for (let Re = 0; Re < Be.length; Re++) {
                        var Je = Be[Re];
                        if (Je !== "") {
                          var ft = Ue(Je);
                          Je.match("x") ? ae.elements[se + 0] = ft : Je.match("y") ? ae.elements[se + 4] = ft : Je.match("z") ? ae.elements[se + 8] = ft : ae.elements[se + 12] = ft;
                        }
                      }
                    }
                    var lt = H.getMatrix4(), he = new u.Matrix4().getInverse(lt, !0);
                    ae = new u.Matrix4().multiplyMatrices(ae, he), ae = new u.Matrix4().multiplyMatrices(lt, ae), E[E.length - 1].symmetries.push(ae);
                  }
              }
              for (let ae = 0; ae < g.length; ae++)
                T && !(v.duplicateAssemblyAtoms && !v.dontConnectDuplicatedAtoms) && (0, f.assignPDBBonds)(g[ae], v), (0, o.computeSecondaryStructure)(g[ae], v.hbondCutoff), (0, l.processSymmetries)(E[ae].symmetries, g[ae], v, E[ae].cryst), v.duplicateAssemblyAtoms && !v.dontConnectDuplicatedAtoms && T && (0, f.assignPDBBonds)(g[ae], v);
              return g;
            }
          }
        ),
        /***/
        "./src/parsers/CUBE.ts": (
          /*!*****************************!*\
            !*** ./src/parsers/CUBE.ts ***!
            \*****************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              CUBE: () => (
                /* binding */
                f
              )
              /* harmony export */
            });
            var o = n(
              /*! ../WebGL */
              "./src/WebGL/index.ts"
            ), l = n(
              /*! ./utils/assignBonds */
              "./src/parsers/utils/assignBonds.ts"
            ), u = n(
              /*! ./utils/anumToSymbol */
              "./src/parsers/utils/anumToSymbol.ts"
            );
            function f(h, p) {
              p = p || {};
              var v = [[]], g = h.split(/\r?\n/), w = p.assignBonds === void 0 ? !0 : p.assignBonds;
              if (g.length < 6)
                return v;
              var E = g[2].replace(/^\s+/, "").replace(/\s+/g, " ").split(" "), T = Math.abs(parseFloat(E[0]));
              let R = {};
              var _ = R.origin = new o.Vector3(parseFloat(E[1]), parseFloat(E[2]), parseFloat(E[3]));
              E = g[3].replace(/^\s+/, "").replace(/\s+/g, " ").split(" "), E = g[3].replace(/^\s+/, "").replace(/\s+/g, " ").split(" ");
              var b = E[0] > 0 ? 0.529177 : 1;
              _.multiplyScalar(b);
              var M = Math.abs(E[0]), A = new o.Vector3(parseFloat(E[1]), parseFloat(E[2]), parseFloat(E[3])).multiplyScalar(b);
              E = g[4].replace(/^\s+/, "").replace(/\s+/g, " ").split(" ");
              var $ = Math.abs(E[0]), S = new o.Vector3(parseFloat(E[1]), parseFloat(E[2]), parseFloat(E[3])).multiplyScalar(b);
              E = g[5].replace(/^\s+/, "").replace(/\s+/g, " ").split(" ");
              var C = Math.abs(E[0]), D = new o.Vector3(parseFloat(E[1]), parseFloat(E[2]), parseFloat(E[3])).multiplyScalar(b);
              if (R.size = { x: M, y: $, z: C }, R.unit = new o.Vector3(A.x, S.y, D.z), A.y != 0 || A.z != 0 || S.x != 0 || S.z != 0 || D.x != 0 || D.y != 0) {
                R.matrix4 = new o.Matrix4(A.x, S.x, D.x, 0, A.y, S.y, D.y, 0, A.z, S.z, D.z, 0, 0, 0, 0, 1);
                let B = new o.Matrix4().makeTranslation(_.x, _.y, _.z);
                R.matrix4 = R.matrix4.multiplyMatrices(B, R.matrix4), R.matrix = R.matrix4.matrix3FromTopLeft(), R.origin = new o.Vector3(0, 0, 0), R.unit = new o.Vector3(1, 1, 1);
              }
              v.modelData = [{ cryst: R }], g = g.splice(6, T);
              for (var O = v[v.length - 1].length, N = O + g.length, j = O; j < N; ++j) {
                var L = {};
                L.serial = j;
                var z = g[j - O], G = z.replace(/^\s+/, "").replace(/\s+/g, " ").split(" ");
                L.elem = u.anumToSymbol[G[0]], L.x = parseFloat(G[2]) * b, L.y = parseFloat(G[3]) * b, L.z = parseFloat(G[4]) * b, L.hetflag = !0, L.bonds = [], L.bondOrder = [], L.properties = {}, v[v.length - 1].push(L);
              }
              if (w)
                for (let B = 0; B < v.length; B++)
                  (0, l.assignBonds)(v[B], p);
              return v;
            }
          }
        ),
        /***/
        "./src/parsers/GRO.ts": (
          /*!****************************!*\
            !*** ./src/parsers/GRO.ts ***!
            \****************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              GRO: () => (
                /* binding */
                u
              )
              /* harmony export */
            });
            var o = n(
              /*! ./utils/assignPDBBonds */
              "./src/parsers/utils/assignPDBBonds.ts"
            ), l = n(
              /*! ./utils/atomNameToElem */
              "./src/parsers/utils/atomNameToElem.ts"
            );
            function u(f, h) {
              for (var p = [], v = f.split(/\r?\n|\r/); v.length > 0 && !(v.length < 3); ) {
                var g = parseInt(v[1]);
                if (isNaN(g) || g <= 0 || v.length < g + 3)
                  break;
                var w = [];
                p.push(w);
                for (var E = 2, T = w.length, R = T + g, _ = T; _ < R; _++) {
                  var b = v[E++], M = {};
                  M.serial = _, M.atom = b.slice(10, 15).trim(), M.elem = (0, l.atomNameToElem)(M.atom, !0), M.x = 10 * parseFloat(b.slice(20, 28)), M.y = 10 * parseFloat(b.slice(28, 36)), M.z = 10 * parseFloat(b.slice(36, 44)), M.resi = parseInt(b.slice(0, 5)), M.resn = b.slice(5, 10).trim(), M.bonds = [], M.bondOrder = [], M.properties = {}, b.length > 44 && (M.dx = 10 * parseFloat(b.slice(44, 52)), M.dy = 10 * parseFloat(b.slice(52, 60)), M.dz = 10 * parseFloat(b.slice(60, 68))), w[_] = M;
                }
                if (v.length <= E + 3) {
                  var A = v[E++], $ = A.trim().split(/\s+/);
                  if ($.length == 3) {
                    for (var S = 0; S < 3; S++)
                      $[S] = parseFloat($[S]) * 10;
                    p.box = $;
                  }
                }
                v.splice(0, ++E);
              }
              for (let C = 0; C < p.length; C++)
                (0, o.assignPDBBonds)(p[C], h);
              return p;
            }
          }
        ),
        /***/
        "./src/parsers/LAMMPSTRJ.ts": (
          /*!**********************************!*\
            !*** ./src/parsers/LAMMPSTRJ.ts ***!
            \**********************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              LAMMPSTRJ: () => (
                /* binding */
                l
              )
              /* harmony export */
            });
            var o = n(
              /*! ./utils/assignBonds */
              "./src/parsers/utils/assignBonds.ts"
            );
            function l(u, f) {
              for (var h = [], p = {
                id: "serial",
                type: "atom",
                element: "elem",
                q: "charge",
                radius: "radius",
                x: "x",
                xu: "x",
                xs: "x",
                xsu: "x",
                y: "y",
                yu: "y",
                ys: "y",
                ysu: "y",
                z: "z",
                zu: "z",
                zs: "z",
                zsu: "z"
              }, v = u.split(/\r?\n|\r/), g = 0, w = 0, E = 0; E < v.length - 9; ) {
                for (var T = E; T < v.length; T++)
                  if (v[T].match(/ITEM: NUMBER OF ATOMS/) && (w = parseInt(v[T + 1])), v[T].match(/ITEM: ATOMS/)) {
                    g = T + 1;
                    break;
                  }
                var R = v[g - 1].replace("ITEM: ATOMS ", "").split(" ");
                h.push([]);
                for (let C = g; C < g + w; C++) {
                  for (var _ = {}, b = {}, M = v[C].split(" "), A = 0; A < M.length; A++) {
                    var $ = p[R[A]];
                    $ != null && ($ == "serial" ? _[$] = parseInt(M[A]) : $ == "x" || $ == "y" || $ === "z" ? _[$] = parseFloat(M[A]) : $ == "charge" || $ == "radius" ? b[$] = parseFloat(M[A]) : _[$] = M[A]), _.properties = b, _.bonds = [], _.bondOrder = [];
                  }
                  h[h.length - 1][C - g] = _;
                }
                E = g + w - 1;
              }
              if (f.assignBonds)
                for (var S = 0; S < h.length; S++)
                  (0, o.assignBonds)(h[S], f);
              return h;
            }
          }
        ),
        /***/
        "./src/parsers/MMTF.ts": (
          /*!*****************************!*\
            !*** ./src/parsers/MMTF.ts ***!
            \*****************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              MMTFparser: () => (
                /* binding */
                w
              )
              /* harmony export */
            });
            var o = n(
              /*! ../utilities */
              "./src/utilities.ts"
            ), l = n(
              /*! ../WebGL */
              "./src/WebGL/index.ts"
            ), u = n(
              /*! ./utils/computeSecondaryStructure */
              "./src/parsers/utils/computeSecondaryStructure.ts"
            ), f = n(
              /*! ./utils/processSymmetries */
              "./src/parsers/utils/processSymmetries.ts"
            ), h = n(
              /*! ./src/vendor/mmtf.js */
              "./src/vendor/mmtf.js"
            ), p = function(E) {
              return String.fromCharCode.apply(null, E).replace(/\0/g, "");
            }, v = function(E) {
              return E == 0 || E == 2 || E == 4 ? "h" : E == 3 ? "s" : "c";
            };
            let g = /* @__PURE__ */ new Set([
              "D-SACCHARIDE",
              "D-SACCHARIDE 1,4 AND 1,4 LINKING",
              "D-SACCHARIDE 1,4 AND 1,6 LINKING",
              "L-SACCHARIDE",
              "L-SACCHARIDE 1,4 AND 1,4 LINKING",
              "L-SACCHARIDE 1,4 AND 1,6 LINKING",
              "NON-POLYMER",
              "OTHER",
              "PEPTIDE-LIKE",
              "SACCHARIDE"
            ]);
            function w(E, T) {
              var R = !T.keepH, _ = T.altLoc ? T.altLoc : "A", b = !!T.noSecondaryStructure, M = !T.noComputeSecondaryStructure, A = !T.doAssembly, $ = T.assemblyIndex ? T.assemblyIndex : 0;
              typeof E == "string" ? E = (0, o.base64ToArray)(E) : E = new Uint8Array(E);
              var S = h.decode(E), C = [[]], D = C.modelData = [], O = 0, N = 0, j = 0, L = S.secStructList, z = S.bFactorList, G = S.altLocList, B = S.occupancyList, F = S.bondAtomList, H = S.bondOrderList, W = S.numModels;
              if (W == 0)
                return C;
              T.multimodel || (W = 1);
              var V, X, Z, Q, q, J, ie = [];
              if (!A && S.bioAssemblyList && S.bioAssemblyList.length > 0) {
                var ne = S.bioAssemblyList[$].transformList;
                for (V = 0, J = ne.length; V < J; V++) {
                  var ge = new l.Matrix4(ne[V].matrix);
                  ge.transpose(), ie.push(ge);
                }
              }
              var ye = null;
              if (S.unitCell) {
                var xe = S.unitCell;
                ye = { a: xe[0], b: xe[1], c: xe[2], alpha: xe[3], beta: xe[4], gamma: xe[5] };
              }
              let we = [];
              S.entityList.forEach((Ne) => {
                Ne.chainIndexList.forEach((pe) => {
                  we[pe] = Ne.type == "polymer";
                });
              });
              var de = 0;
              for (q = 0; q < W; q++) {
                var Te = S.chainsPerModel[q], Ce = C[C.length - 1], ee = [];
                for (D.push({ symmetries: ie, cryst: ye }), V = 0; V < Te; ++V) {
                  var Ae = S.groupsPerChain[O], be = p(S.chainIdList.subarray(O * 4, O * 4 + 4));
                  S.chainNameList && (be = p(S.chainNameList.subarray(O * 4, O * 4 + 4)));
                  var Fe = N, et = "";
                  for (X = 0; X < Ae; ++X) {
                    var Ye = S.groupList[S.groupTypeList[N]], De = Ye.atomNameList.length, Ue = 0, Qe = !1, ue = !1;
                    if (L) {
                      Ue = L[N];
                      var te = v(Ue);
                      (N == 0 || te != et) && (Qe = !0), et = te;
                      var Be = N + 1;
                      (Be >= L.length || v(L[Be] != te)) && (ue = !0);
                    }
                    var Je = S.groupIdList[N], ft = Ye.groupName;
                    let Ne = Ye.chemCompType;
                    var lt = j;
                    let pe = g.has(Ne) || !we[O];
                    for (Z = 0; Z < De; ++Z) {
                      var he = Ye.elementList[Z];
                      if (R && he == "H") {
                        j += 1;
                        continue;
                      }
                      var ae = "";
                      z && (ae = z[j]);
                      var se = "";
                      G && G[j] && (se = String.fromCharCode(G[j]));
                      var Re = "";
                      if (B && (Re = B[j]), se != "" && se != _ && _ != "*") {
                        j += 1;
                        continue;
                      }
                      var Oe = S.atomIdList[j], We = Ye.atomNameList[Z], Ct = 0;
                      Ye.atomChargeList && (Ct = Ye.atomChargeList[Z]);
                      var le = S.xCoordList[j], ke = S.yCoordList[j], Ke = S.zCoordList[j];
                      ee[j] = Ce.length, Ce.push({
                        resn: ft,
                        x: le,
                        y: ke,
                        z: Ke,
                        elem: he,
                        hetflag: pe,
                        chain: be,
                        resi: Je,
                        icode: se,
                        rescode: Je + (se != " " ? "^" + se : ""),
                        // resi
                        // and
                        // icode
                        serial: Oe,
                        altLoc: se,
                        index: j,
                        atom: We,
                        bonds: [],
                        ss: v(Ue),
                        ssbegin: Qe,
                        ssend: ue,
                        bondOrder: [],
                        properties: { charge: Ct, occupancy: Re },
                        b: ae
                      }), j += 1;
                    }
                    var me = Ye.bondAtomList;
                    for (Z = 0, Q = Ye.bondOrderList.length; Z < Q; ++Z) {
                      var Ee = lt + me[Z * 2], tt = lt + me[Z * 2 + 1], ce = Ye.bondOrderList[Z], _e = ee[Ee], Ht = ee[tt], K = Ce[_e], Ve = Ce[Ht];
                      K && Ve && (K.bonds.push(Ht), K.bondOrder.push(ce), Ve.bonds.push(_e), Ve.bondOrder.push(ce));
                    }
                    N += 1;
                  }
                  for (N = Fe, X = 0; X < Ae; ++X)
                    N += 1;
                  O += 1;
                }
                if (F)
                  for (let Ne = de, pe = F.length; Ne < pe; Ne += 2) {
                    let Le = F[Ne], bt = F[Ne + 1], yi = H ? H[Ne / 2] : 1;
                    if (Le >= j) {
                      de = Ne;
                      break;
                    }
                    let _n = ee[Le], Do = ee[bt], ms = Ce[_n], Bp = Ce[Do];
                    ms && Bp && (ms.bonds.push(Do), ms.bondOrder.push(yi), Bp.bonds.push(_n), Bp.bondOrder.push(yi));
                  }
                T.multimodel && (T.onemol || C.push([]));
              }
              if (!A)
                for (let Ne = 0; Ne < C.length; Ne++)
                  (0, f.processSymmetries)(D[Ne].symmetries, C[Ne], T, D[Ne].cryst);
              return M && !b && (0, u.computeSecondaryStructure)(C, T.hbondCutoff), C;
            }
          }
        ),
        /***/
        "./src/parsers/MOL2.ts": (
          /*!*****************************!*\
            !*** ./src/parsers/MOL2.ts ***!
            \*****************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              MOL2: () => (
                /* binding */
                l
              )
              /* harmony export */
            });
            let o = {
              "C.1": "C",
              C1: "C",
              "C.2": "C",
              C2: "C",
              "C.3": "C",
              C3: "C",
              "C.ar": "C",
              Car: "C",
              "C.cat": "C",
              Ccat: "C",
              "H.spc": "H",
              Hspc: "H",
              "H.t3p": "H",
              Ht3p: "H",
              "N.1": "N",
              N1: "N",
              "N.2": "N",
              N2: "N",
              "N.3": "N",
              N3: "N",
              "N.4": "N",
              N4: "N",
              "N.am": "N",
              Nam: "N",
              "N.ar": "N",
              Nar: "N",
              "N.p13": "N",
              Np13: "N",
              "O.2": "O",
              O2: "O",
              "O.3": "O",
              O3: "O",
              "O.co2": "O",
              Oco2: "O",
              "O.spc": "O",
              Ospc: "O",
              "O.t3p": "O",
              Ot3p: "O",
              "P.3": "P",
              P3: "P",
              "S.2": "S",
              S2: "S",
              "S.3": "S",
              S3: "S",
              "S.o": "S",
              So: "S",
              "S.o2": "S",
              So2: "S"
            };
            function l(u, f) {
              var h = [[]], p = !1;
              typeof f.keepH < "u" && (p = !f.keepH);
              var v = u.search(/@<TRIPOS>MOLECULE/), g = u.search(/@<TRIPOS>ATOM/);
              if (v == -1 || g == -1)
                return h;
              for (var w = u.substring(v).split(/\r?\n|\r/); w.length > 0; ) {
                var E = [], T = w[2].replace(/^\s+/, "").replace(/\s+/g, " ").split(" "), R = parseInt(T[0]), _ = 0;
                T.length > 1 && (_ = parseInt(T[1]));
                var b = 4, M;
                for (M = 3; M < w.length; M++)
                  if (w[M] == "@<TRIPOS>ATOM") {
                    b = M + 1;
                    break;
                  }
                var A = h[h.length - 1].length, $ = A + R, S;
                for (M = A; M < $; M++) {
                  S = w[b++], T = S.replace(/^\s+/, "").replace(/\s+/g, " ").split(" ");
                  var C = {}, D = T[5];
                  if (o[D] !== void 0 ? D = o[D] : (D = D.split(".")[0], D = D[0].toUpperCase() + D.substring(1).toLowerCase()), C.atom = T[1], C.elem = D, !(C.elem == "H" && p)) {
                    var O = h[h.length - 1].length, N = parseInt(T[0]);
                    C.serial = N, C.x = parseFloat(T[2]), C.y = parseFloat(T[3]), C.z = parseFloat(T[4]), C.atom = T[5];
                    var j = parseFloat(T[8]);
                    C.index = O, C.bonds = [], C.bondOrder = [], C.properties = {
                      charge: j,
                      partialCharge: j
                    }, E[N] = O, h[h.length - 1].push(C);
                  }
                }
                for (var L = !1; b < w.length; )
                  if (w[b++] == "@<TRIPOS>BOND") {
                    L = !0;
                    break;
                  }
                if (L && _)
                  for (M = 0; M < _; M++) {
                    S = w[b++], T = S.replace(/^\s+/, "").replace(/\s+/g, " ").split(" ");
                    var z = parseInt(T[1]), G = h[h.length - 1][E[z]], B = parseInt(T[2]), F = h[h.length - 1][E[B]], H = parseInt(T[3]);
                    isNaN(H) && (H = 1), G !== void 0 && F !== void 0 && (G.bonds.push(E[B]), G.bondOrder.push(H), F.bonds.push(E[z]), F.bondOrder.push(H));
                  }
                if (f.multimodel) {
                  f.onemol || h.push([]), w.splice(0, b), u = w.join(`
`);
                  continue;
                } else
                  break;
              }
              return h;
            }
          }
        ),
        /***/
        "./src/parsers/PDB.ts": (
          /*!****************************!*\
            !*** ./src/parsers/PDB.ts ***!
            \****************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              PDB: () => (
                /* binding */
                l
              )
              /* harmony export */
            });
            var o = n(
              /*! ./utils/getSinglePDB */
              "./src/parsers/utils/getSinglePDB.ts"
            );
            function l(u, f) {
              f = f || {};
              var h = [], p = {};
              h.modelData = [];
              for (var v = u.split(/\r?\n|\r/); v.length > 0; ) {
                var g = (0, o.getSinglePDB)(v, f, p), w = g[0], E = g[1];
                if (v = g[2], w.length != 0) {
                  if (f.multimodel && f.onemol && h.length > 0)
                    for (var T = h[0].length, R = 0; R < w.length; R++) {
                      var _ = w[R];
                      _.index = R;
                      for (var b = 0; b < _.bonds.length; b++)
                        _.bonds[b] += T;
                      h[0].push(_);
                    }
                  else
                    h.modelData.push(E), h.push(w);
                  if (!f.multimodel)
                    break;
                }
              }
              return h;
            }
          }
        ),
        /***/
        "./src/parsers/PQR.ts": (
          /*!****************************!*\
            !*** ./src/parsers/PQR.ts ***!
            \****************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              PQR: () => (
                /* binding */
                u
              )
              /* harmony export */
            });
            var o = n(
              /*! ./utils/assignPDBBonds */
              "./src/parsers/utils/assignPDBBonds.ts"
            ), l = n(
              /*! ./utils/computeSecondaryStructure */
              "./src/parsers/utils/computeSecondaryStructure.ts"
            );
            function u(f, h) {
              var p = [[]], v = !h.noSecondaryStructure;
              p.modelData = [{ symmetries: [] }];
              var g = [], w = f.split(/\r?\n|\r/), E;
              for (let L = 0; L < w.length; L++) {
                E = w[L].replace(/^\s*/, "");
                var T = E.substring(0, 6);
                if (T.indexOf("END") == 0)
                  if (h.multimodel) {
                    h.onemol || p.push([]);
                    continue;
                  } else
                    break;
                else if (T == "ATOM  " || T == "HETATM") {
                  var R;
                  let z = parseInt(E.substring(6, 11)), G = E.substring(12, 16).replace(/ /g, ""), B = E.substring(17, 20).trim(), F = E.substring(21, 22), H = parseInt(E.substring(22, 26));
                  var _ = E.substring(30).trim().split(/\s+/), b = parseFloat(_[0]), M = parseFloat(_[1]), A = parseFloat(_[2]), $ = parseFloat(_[3]), S = parseFloat(_[4]), C = G[0];
                  G.length > 1 && G[1].toUpperCase() != G[1] && (C = G.substring(0, 2)), E[0] == "H" ? R = !0 : R = !1, g[z] = p[p.length - 1].length, p[p.length - 1].push({
                    resn: B,
                    x: b,
                    y: M,
                    z: A,
                    elem: C,
                    hetflag: R,
                    chain: F,
                    resi: H,
                    serial: z,
                    atom: G,
                    bonds: [],
                    ss: "c",
                    bondOrder: [],
                    properties: {
                      charge: $,
                      partialCharge: $,
                      radius: S
                    },
                    pdbline: E
                  });
                } else if (T == "CONECT") {
                  var D = parseInt(E.substring(6, 11)), O = p[p.length - 1][g[D]];
                  for (let z = 0; z < 4; z++) {
                    var N = parseInt(E.substring([11, 16, 21, 26][z], [11, 16, 21, 26][z] + 5)), j = p[p.length - 1][g[N]];
                    O !== void 0 && j !== void 0 && (O.bonds.push(g[N]), O.bondOrder.push(1));
                  }
                }
              }
              for (let L = 0; L < p.length; L++)
                (0, o.assignPDBBonds)(p[L], h), v && (0, l.computeSecondaryStructure)(p[L], h.hbondCutoff);
              return p;
            }
          }
        ),
        /***/
        "./src/parsers/PRMTOP.ts": (
          /*!*******************************!*\
            !*** ./src/parsers/PRMTOP.ts ***!
            \*******************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              PRMTOP: () => (
                /* binding */
                o
              )
              /* harmony export */
            });
            function o(l) {
              var u = [], f, h = 0, p = l.split(/\r?\n|\r/);
              if (p.length > 0 && p[0].includes("VERSION")) {
                var v = p.filter(function(b) {
                  return b.includes("POINTERS") || b.includes("ATOM_NAME") || b.includes("CHARGE") || b.includes("RADII") || b.includes("BONDS_INC_HYDROGEN") || b.includes("BONDS_WITHOUT_HYDROGEN");
                }), g = R("POINTERS");
                if (g == -1)
                  return [];
                var w = _(g), E = parseInt(p[g + 1].slice(0, w[1]));
                if (isNaN(E) || E <= 0)
                  return [];
                if (g = R("ATOM_NAME"), g == -1)
                  return [];
                w = _(g);
                var T = w[0];
                for (let b = 0; b < E / w[0]; b++) {
                  b == parseInt(E / w[0]) && (T = E % w[0]);
                  for (let M = 0; M < T; M++) {
                    let A = {}, $ = { charge: "", radii: "" };
                    A.serial = h, A.x = 0, A.y = 0, A.z = 0, A.atom = p[g + 1].slice(w[1] * M, w[1] * (M + 1)), A.elem = p[g + 1].slice(w[1] * M, w[1] * M + 1), A.properties = $, A.bonds = [], A.bondOrder = [], u.push(A), h++;
                  }
                  g++;
                }
                if (g = R("CHARGE"), g != -1) {
                  w = _(g), h = 0, T = w[0];
                  for (let b = 0; b < E / w[0]; b++) {
                    b == parseInt(E / w[0]) && (T = E % w[0]);
                    for (let M = 0; M < T; M++)
                      u[h].properties.charge = parseFloat(p[g + 1].slice(w[1] * M, w[1] * (M + 1))), h++;
                    g++;
                  }
                }
                if (g = R("RADII"), g != -1) {
                  w = _(g), h = 0, T = w[0];
                  for (let b = 0; b < E / w[0]; b++) {
                    b == parseInt(E / w[0]) && (T = E % w[0]);
                    for (let M = 0; M < T; M++)
                      u[h].properties.radii = parseFloat(p[g + 1].slice(w[1] * M, w[1] * (M + 1))), h++;
                    g++;
                  }
                }
                if (g = R("BONDS_WITHOUT_HYDROGEN"), g != -1)
                  for (w = _(g), h = 0, T = w[0], g = g + 1; !p[g].match(/^%FLAG/); ) {
                    p[g + 1].match(/^%FLAG/) && (T = E % w[0]);
                    for (let b = 0; b < T; b++)
                      h % 3 == 0 ? f = parseInt(p[g].slice(w[1] * b, w[1] * (b + 1)) / 3) : h % 3 == 1 && u[f].bonds.push(parseInt(p[g].slice(w[1] * b, w[1] * (b + 1)) / 3)), h++;
                    g++;
                  }
                if (g = R("BONDS_INC_HYDROGEN"), g != -1)
                  for (w = _(g), h = 0, T = w[0], g = g + 1; !p[g].match(/^%FLAG/); ) {
                    p[g + 1].match(/^%FLAG/) && (T = E % w[0]);
                    for (let b = 0; b < T; b++)
                      h % 3 == 0 ? f = parseInt(p[g].slice(w[1] * b, w[1] * (b + 1)) / 3) : h % 3 == 1 && u[f].bonds.push(parseInt(p[g].slice(w[1] * b, w[1] * (b + 1)) / 3)), h++;
                    g++;
                  }
              } else
                return [];
              function R(b) {
                var M = p.indexOf(v.filter(function(A) {
                  return A.includes(b);
                })[0]);
                if (Number.isInteger(M) && M > 0) {
                  for (; !p[M].includes("FORMAT"); )
                    M++;
                  return M;
                } else
                  return -1;
              }
              function _(b) {
                var M = p[b].match(/\((\d*)\S*/), A = p[b].match(/[a-zA-Z](\d*)\)\s*/);
                return A == null && (A = p[b].match(/[a-zA-Z](\d*)\.\d*\)\s*/)), [M[1], A[1]];
              }
              return [u];
            }
          }
        ),
        /***/
        "./src/parsers/SDF.ts": (
          /*!****************************!*\
            !*** ./src/parsers/SDF.ts ***!
            \****************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              SDF: () => (
                /* binding */
                u
              )
              /* harmony export */
            });
            var o = function(f, h) {
              var p = [[]], v = !1;
              for (typeof h.keepH < "u" && (v = !h.keepH); f.length > 0 && !(f.length < 4); ) {
                var g = parseInt(f[3].substring(0, 3));
                if (isNaN(g) || g <= 0)
                  break;
                var w = parseInt(f[3].substring(3, 6)), E = 4;
                if (f.length < 4 + g + w)
                  break;
                var T = [], R = p[p.length - 1].length, _ = R + g, b, M;
                for (b = R; b < _; b++, E++) {
                  M = f[E];
                  var A = {}, $ = M.substring(31, 34).replace(/ /g, "");
                  A.atom = A.elem = $[0].toUpperCase() + $.substring(1).toLowerCase(), (A.elem !== "H" || !v) && (A.serial = b, T[b] = p[p.length - 1].length, A.x = parseFloat(M.substring(0, 10)), A.y = parseFloat(M.substring(10, 20)), A.z = parseFloat(M.substring(20, 30)), A.hetflag = !0, A.bonds = [], A.bondOrder = [], A.properties = {}, A.index = p[p.length - 1].length, p[p.length - 1].push(A));
                }
                for (b = 0; b < w; b++, E++) {
                  M = f[E];
                  var S = T[parseInt(M.substring(0, 3)) - 1 + R], C = T[parseInt(M.substring(3, 6)) - 1 + R], D = parseFloat(M.substring(6));
                  typeof S < "u" && typeof C < "u" && (p[p.length - 1][S].bonds.push(C), p[p.length - 1][S].bondOrder.push(D), p[p.length - 1][C].bonds.push(S), p[p.length - 1][C].bondOrder.push(D));
                }
                if (h.multimodel) {
                  for (h.onemol || p.push([]); f[E] !== "$$$$" && E < f.length; )
                    E++;
                  f.splice(0, ++E);
                } else
                  break;
              }
              return p;
            }, l = function(f, h) {
              var p = [[]], v = !1;
              for (typeof h.keepH < "u" && (v = !h.keepH); f.length > 0 && !(f.length < 8 || !f[4].startsWith("M  V30 BEGIN CTAB") || !f[5].startsWith("M  V30 COUNTS") || f[5].length < 14); ) {
                var g = f[5].substring(13).match(/\S+/g);
                if (g.length < 2)
                  break;
                var w = parseInt(g[0]);
                if (isNaN(w) || w <= 0)
                  break;
                var E = parseInt(g[1]), T = 7;
                if (f.length < 8 + w + E)
                  break;
                var R = [], _ = p[p.length - 1].length, b = _ + w, M, A;
                for (M = _; M < b; M++, T++) {
                  A = f[T];
                  var $ = A.substring(6).match(/\S+/g);
                  if ($.length > 4) {
                    var S = {}, C = $[1].replace(/ /g, "");
                    S.atom = S.elem = C[0].toUpperCase() + C.substring(1).toLowerCase(), (S.elem !== "H" || !v) && (S.serial = M, R[M] = p[p.length - 1].length, S.x = parseFloat($[2]), S.y = parseFloat($[3]), S.z = parseFloat($[4]), S.hetflag = !0, S.bonds = [], S.bondOrder = [], S.properties = {}, S.index = p[p.length - 1].length, p[p.length - 1].push(S));
                  }
                }
                if (f[T] === "M  V30 END ATOM")
                  T++;
                else
                  break;
                if (E !== 0 && f[T] === "M  V30 BEGIN BOND")
                  T++;
                else
                  break;
                for (M = 0; M < E; M++, T++) {
                  A = f[T];
                  var D = A.substring(6).match(/\S+/g);
                  if (D.length > 3) {
                    var O = R[parseInt(D[2]) - 1 + _], N = R[parseInt(D[3]) - 1 + _], j = parseFloat(D[1]);
                    typeof O < "u" && typeof N < "u" && (p[p.length - 1][O].bonds.push(N), p[p.length - 1][O].bondOrder.push(j), p[p.length - 1][N].bonds.push(O), p[p.length - 1][N].bondOrder.push(j));
                  }
                }
                if (h.multimodel) {
                  for (h.onemol || p.push([]); f[T] !== "$$$$" && T < f.length; )
                    T++;
                  f.splice(0, ++T);
                } else
                  break;
              }
              return p;
            };
            function u(f, h) {
              var p = "V2000", v = f.split(/\r?\n|\r/);
              return v.length > 3 && v[3].length > 38 && (p = v[3].substring(34, 39)), p === "V2000" ? o(v, h) : p === "V3000" ? l(v, h) : [[""]];
            }
          }
        ),
        /***/
        "./src/parsers/VASP.ts": (
          /*!*****************************!*\
            !*** ./src/parsers/VASP.ts ***!
            \*****************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              VASP: () => (
                /* binding */
                l
              )
              /* harmony export */
            });
            var o = n(
              /*! ../WebGL */
              "./src/WebGL/index.ts"
            );
            function l(u) {
              var f = [[]], h = {}, p = u.replace(/^\s+/, "").split(/\r?\n/);
              if (p.length < 3)
                return f;
              if (p[1].match(/\d+/))
                h.length = parseFloat(p[1]);
              else
                return console.log("Warning: second line of the vasp structure file must be a number"), f;
              if (h.length < 0)
                return console.log("Warning: Vasp implementation for negative lattice lengths is not yet available"), f;
              h.xVec = new Float32Array(p[2].replace(/^\s+/, "").split(/\s+/)), h.yVec = new Float32Array(p[3].replace(/^\s+/, "").split(/\s+/)), h.zVec = new Float32Array(p[4].replace(/^\s+/, "").split(/\s+/));
              var v = new o.Matrix3(h.xVec[0], h.xVec[1], h.xVec[2], h.yVec[0], h.yVec[1], h.yVec[2], h.zVec[0], h.zVec[1], h.zVec[2]);
              v.multiplyScalar(h.length), f.modelData = [{ symmetries: [], cryst: { matrix: v } }];
              var g = p[5].replace(/\s+/, "").replace(/\s+$/, "").split(/\s+/), w = new Int16Array(p[6].replace(/^\s+/, "").split(/\s+/)), E = p[7].replace(/\s+/, "");
              if (E.match(/C/))
                E = "cartesian";
              else if (E.match(/D/))
                E = "direct";
              else
                return console.log("Warning: Unknown vasp mode in POSCAR file: mode must be either C(artesian) or D(irect)"), f;
              if (g.length != w.length)
                return console.log("Warning: declaration of atomary species wrong:"), console.log(g), console.log(w), f;
              p.splice(0, 8);
              for (var T = 0, R = 0, _ = g.length; R < _; R++) {
                for (var b = g[R], M = 0, A = w[R]; M < A; M++) {
                  var $ = new Float32Array(p[T + M].replace(/^\s+/, "").split(/\s+/)), S = {};
                  S.elem = b, E == "cartesian" ? (S.x = h.length * $[0], S.y = h.length * $[1], S.z = h.length * $[2]) : (S.x = h.length * ($[0] * h.xVec[0] + $[1] * h.yVec[0] + $[2] * h.zVec[0]), S.y = h.length * ($[0] * h.xVec[1] + $[1] * h.yVec[1] + $[2] * h.zVec[1]), S.z = h.length * ($[0] * h.xVec[2] + $[1] * h.yVec[2] + $[2] * h.zVec[2])), S.bonds = [], f[0].push(S);
                }
                T += w[R];
              }
              return f;
            }
          }
        ),
        /***/
        "./src/parsers/XYZ.ts": (
          /*!****************************!*\
            !*** ./src/parsers/XYZ.ts ***!
            \****************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              XYZ: () => (
                /* binding */
                u
              )
              /* harmony export */
            });
            var o = n(
              /*! ../WebGL */
              "./src/WebGL/index.ts"
            ), l = n(
              /*! ./utils/assignBonds */
              "./src/parsers/utils/assignBonds.ts"
            );
            function u(f, h) {
              h = h || {};
              for (var p = [[]], v = h.assignBonds === void 0 ? !0 : h.assignBonds, g = f.split(/\r?\n|\r/); g.length > 0 && !(g.length < 3); ) {
                var w = parseInt(g[0]);
                if (isNaN(w) || w <= 0 || g.length < w + 2)
                  break;
                var E = /Lattice\s*=\s*["\{\}]([^"\{\}]+)["\{\}]\s*/gi, T = E.exec(g[1]);
                if (T != null && T.length > 1) {
                  var R = new Float32Array(T[1].split(/\s+/)), _ = new o.Matrix3(R[0], R[3], R[6], R[1], R[4], R[7], R[2], R[5], R[8]);
                  p.modelData = [{ cryst: { matrix: _ } }];
                }
                for (var b = 2, M = p[p.length - 1].length, A = M + w, $ = M; $ < A; $++) {
                  var S = g[b++], C = S.replace(/^\s+/, "").replace(/\s+/g, " ").split(" "), D = {};
                  D.serial = $;
                  var O = C[0];
                  D.atom = D.elem = O[0].toUpperCase() + O.substring(1, 2).toLowerCase(), D.x = parseFloat(C[1]), D.y = parseFloat(C[2]), D.z = parseFloat(C[3]), D.hetflag = !0, D.bonds = [], D.bondOrder = [], D.properties = {}, p[p.length - 1][$] = D, C.length >= 7 && (D.dx = parseFloat(C[4]), D.dy = parseFloat(C[5]), D.dz = parseFloat(C[6]));
                }
                if (h.multimodel)
                  p.push([]), g.splice(0, b);
                else
                  break;
              }
              if (v)
                for (let j = 0; j < p.length; j++)
                  (0, l.assignBonds)(p[j], h);
              if (h.onemol) {
                var N = p;
                p = [], p.push(N[0]);
                for (let j = 1; j < N.length; j++) {
                  let L = p[0].length;
                  for (let z = 0; z < N[j].length; z++) {
                    let G = N[j][z];
                    for (let B = 0; B < G.bonds.length; B++)
                      G.bonds[B] = G.bonds[B] + L;
                    G.index = p[0].length, G.serial = p[0].length, p[0].push(G);
                  }
                }
              }
              return p;
            }
          }
        ),
        /***/
        "./src/parsers/index.ts": (
          /*!******************************!*\
            !*** ./src/parsers/index.ts ***!
            \******************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              Parsers: () => (
                /* binding */
                M
              ),
              /* harmony export */
              bondLength: () => (
                /* reexport safe */
                b.bondLength
              ),
              /* harmony export */
              setBondLength: () => (
                /* reexport safe */
                b.setBondLength
              )
              /* harmony export */
            });
            var o = n(
              /*! ./VASP */
              "./src/parsers/VASP.ts"
            ), l = n(
              /*! ./CUBE */
              "./src/parsers/CUBE.ts"
            ), u = n(
              /*! ./XYZ */
              "./src/parsers/XYZ.ts"
            ), f = n(
              /*! ./SDF */
              "./src/parsers/SDF.ts"
            ), h = n(
              /*! ./CDJSON */
              "./src/parsers/CDJSON.ts"
            ), p = n(
              /*! ./CIF */
              "./src/parsers/CIF.ts"
            ), v = n(
              /*! ./MOL2 */
              "./src/parsers/MOL2.ts"
            ), g = n(
              /*! ./PDB */
              "./src/parsers/PDB.ts"
            ), w = n(
              /*! ./PQR */
              "./src/parsers/PQR.ts"
            ), E = n(
              /*! ./MMTF */
              "./src/parsers/MMTF.ts"
            ), T = n(
              /*! ./PRMTOP */
              "./src/parsers/PRMTOP.ts"
            ), R = n(
              /*! ./GRO */
              "./src/parsers/GRO.ts"
            ), _ = n(
              /*! ./LAMMPSTRJ */
              "./src/parsers/LAMMPSTRJ.ts"
            ), b = n(
              /*! ./utils/bondLength */
              "./src/parsers/utils/bondLength.ts"
            );
            const M = {
              vasp: o.VASP,
              VASP: o.VASP,
              cube: l.CUBE,
              CUBE: l.CUBE,
              xyz: u.XYZ,
              XYZ: u.XYZ,
              sdf: f.SDF,
              SDF: f.SDF,
              json: h.CDJSON,
              cdjson: h.CDJSON,
              CDJSON: h.CDJSON,
              mcif: p.CIF,
              cif: p.CIF,
              CIF: p.CIF,
              mol2: v.MOL2,
              MOL2: v.MOL2,
              pdb: g.PDB,
              PDB: g.PDB,
              pdbqt: g.PDB,
              PDBQT: g.PDB,
              pqr: w.PQR,
              PQR: w.PQR,
              mmtf: E.MMTFparser,
              MMTF: E.MMTFparser,
              prmtop: T.PRMTOP,
              PRMTOP: T.PRMTOP,
              gro: R.GRO,
              GRO: R.GRO,
              lammpstrj: _.LAMMPSTRJ,
              LAMMPSTRJ: _.LAMMPSTRJ
            };
          }
        ),
        /***/
        "./src/parsers/utils/anumToSymbol.ts": (
          /*!*******************************************!*\
            !*** ./src/parsers/utils/anumToSymbol.ts ***!
            \*******************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              anumToSymbol: () => (
                /* binding */
                o
              )
              /* harmony export */
            });
            const o = {
              1: "H",
              2: "He",
              3: "Li",
              4: "Be",
              5: "B",
              6: "C",
              7: "N",
              8: "O",
              9: "F",
              10: "Ne",
              11: "Na",
              12: "Mg",
              13: "Al",
              14: "Si",
              15: "P",
              16: "S",
              17: "Cl",
              18: "Ar",
              19: "K",
              20: "Ca",
              21: "Sc",
              22: "Ti",
              23: "V",
              24: "Cr",
              25: "Mn",
              26: "Fe",
              27: "Co",
              28: "Ni",
              29: "Cu",
              30: "Zn",
              31: "Ga",
              32: "Ge",
              33: "As",
              34: "Se",
              35: "Br",
              36: "Kr",
              37: "Rb",
              38: "Sr",
              39: "Y",
              40: "Zr",
              41: "Nb",
              42: "Mo",
              43: "Tc",
              44: "Ru",
              45: "Rh",
              46: "Pd",
              47: "Ag",
              48: "Cd",
              49: "In",
              50: "Sn",
              51: "Sb",
              52: "Te",
              53: "I",
              54: "Xe",
              55: "Cs",
              56: "Ba",
              71: "Lu",
              72: "Hf",
              73: "Ta",
              74: "W",
              75: "Re",
              76: "Os",
              77: "Ir",
              78: "Pt",
              79: "Au",
              80: "Hg",
              81: "Tl",
              82: "Pb",
              83: "Bi",
              84: "Po",
              85: "At",
              86: "Rn",
              87: "Fr",
              88: "Ra",
              104: "Rf",
              105: "Db",
              106: "Sg",
              107: "Bh",
              108: "Hs",
              109: "Mt",
              110: "Ds",
              111: "Rg",
              112: "Cn",
              113: "Nh",
              114: "Fl",
              115: "Mc",
              116: "Lv",
              117: "Ts",
              118: "Og",
              57: "La",
              58: "Ce",
              59: "Pr",
              60: "Nd",
              61: "Pm",
              62: "Sm",
              63: "Eu",
              64: "Gd",
              65: "Tb",
              66: "Dy",
              67: "Ho",
              68: "Er",
              69: "Tm",
              70: "Yb",
              89: "Ac",
              90: "Th",
              91: "Pa",
              92: "U",
              93: "Np",
              94: "Pu",
              95: "Am",
              96: "Cm",
              97: "Bk",
              98: "Cf",
              99: "Es",
              100: "Fm",
              101: "Md",
              102: "No"
            };
          }
        ),
        /***/
        "./src/parsers/utils/areConnected.ts": (
          /*!*******************************************!*\
            !*** ./src/parsers/utils/areConnected.ts ***!
            \*******************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              areConnected: () => (
                /* binding */
                u
              )
              /* harmony export */
            });
            var o = n(
              /*! ./bondLength */
              "./src/parsers/utils/bondLength.ts"
            );
            const l = /* @__PURE__ */ new Set(["Na", "K", "Ca", "Mg", "Mn", "Sr"]);
            function u(f, h, p) {
              if (p && p.unboundCations && (l.has(f.elem) || l.has(h.elem)))
                return !1;
              let v = (0, o.bondLength)(f.elem) + (0, o.bondLength)(h.elem);
              v += 0.25, v *= v;
              let g = f.x - h.x;
              if (g *= g, g > v)
                return !1;
              let w = f.y - h.y;
              if (w *= w, w > v)
                return !1;
              let E = f.z - h.z;
              if (E *= E, E > v)
                return !1;
              const T = g + w + E;
              return !(isNaN(T) || T < 0.5 || T > v || f.altLoc !== h.altLoc && f.altLoc !== " " && h.altLoc !== " ");
            }
          }
        ),
        /***/
        "./src/parsers/utils/assignBackboneHBonds.ts": (
          /*!***************************************************!*\
            !*** ./src/parsers/utils/assignBackboneHBonds.ts ***!
            \***************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              assignBackboneHBonds: () => (
                /* binding */
                o
              )
              /* harmony export */
            });
            function o(l, u) {
              const f = u || 3.2, h = f * f, p = [];
              for (let v = 0, g = l.length; v < g; v++) {
                l[v].index = v;
                const w = l[v];
                !w.hetflag && (w.atom === "N" || w.atom === "O") && (p.push(w), w.hbondOther = null, w.hbondDistanceSq = Number.POSITIVE_INFINITY);
              }
              p.sort(function(v, g) {
                return v.z - g.z;
              });
              for (let v = 0, g = p.length; v < g; v++) {
                const w = p[v];
                for (let E = v + 1; E < g; E++) {
                  const T = p[E], R = T.z - w.z;
                  if (R > f)
                    break;
                  if (T.atom == w.atom)
                    continue;
                  const _ = Math.abs(T.y - w.y);
                  if (_ > f)
                    continue;
                  const b = Math.abs(T.x - w.x);
                  if (b > f)
                    continue;
                  const M = b * b + _ * _ + R * R;
                  M > h || T.chain == w.chain && Math.abs(T.resi - w.resi) < 4 || (M < w.hbondDistanceSq && (w.hbondOther = T, w.hbondDistanceSq = M), M < T.hbondDistanceSq && (T.hbondOther = w, T.hbondDistanceSq = M));
                }
              }
            }
          }
        ),
        /***/
        "./src/parsers/utils/assignBonds.ts": (
          /*!******************************************!*\
            !*** ./src/parsers/utils/assignBonds.ts ***!
            \******************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              assignBonds: () => (
                /* binding */
                f
              )
              /* harmony export */
            });
            var o = n(
              /*! ./areConnected */
              "./src/parsers/utils/areConnected.ts"
            );
            const l = [
              { x: 0, y: 0, z: 1 },
              { x: 0, y: 1, z: -1 },
              { x: 0, y: 1, z: 0 },
              { x: 0, y: 1, z: 1 },
              { x: 1, y: -1, z: -1 },
              { x: 1, y: -1, z: 0 },
              { x: 1, y: -1, z: 1 },
              { x: 1, y: 0, z: -1 },
              { x: 1, y: 0, z: 0 },
              { x: 1, y: 0, z: 1 },
              { x: 1, y: 1, z: -1 },
              { x: 1, y: 1, z: 0 },
              { x: 1, y: 1, z: 1 }
            ], u = 4.95;
            function f(h, p) {
              for (let w = 0, E = h.length; w < E; w++)
                h[w].index || (h[w].index = w);
              const v = {
                x: {
                  y: {
                    z: []
                  }
                }
              };
              for (let w = 0; w < h.length; w++) {
                const E = h[w], T = Math.floor(E.x / u), R = Math.floor(E.y / u), _ = Math.floor(E.z / u);
                v[T] || (v[T] = {}), v[T][R] || (v[T][R] = {}), v[T][R][_] || (v[T][R][_] = []), v[T][R][_].push(E);
              }
              function g(w, E) {
                for (let T = 0; T < w.length; T++) {
                  const R = w[T];
                  for (let _ = 0; _ < E.length; _++) {
                    const b = E[_];
                    if ((0, o.areConnected)(R, b, p)) {
                      const M = R.bonds.indexOf(b.index), A = b.bonds.indexOf(R.index);
                      M === -1 && A === -1 ? (R.bonds.push(b.index), R.bondOrder.push(1), b.bonds.push(R.index), b.bondOrder.push(1)) : M === -1 ? (R.bonds.push(b.index), R.bondOrder.push(b.bondOrder[A])) : A === -1 && (b.bonds.push(R.index), b.bondOrder.push(R.bondOrder[M]));
                    }
                  }
                }
              }
              for (let w in v) {
                const E = parseInt(w);
                for (let T in v[E]) {
                  const R = parseInt(T);
                  for (let _ in v[E][R]) {
                    const b = parseInt(_), M = v[E][R][b];
                    for (let A = 0; A < M.length; A++) {
                      const $ = M[A];
                      for (let S = A + 1; S < M.length; S++) {
                        const C = M[S];
                        (0, o.areConnected)($, C, p) && $.bonds.indexOf(C.index) == -1 && ($.bonds.push(C.index), $.bondOrder.push(1), C.bonds.push($.index), C.bondOrder.push(1));
                      }
                    }
                    for (let A = 0; A < l.length; A++) {
                      const $ = l[A];
                      if (!v[E + $.x] || !v[E + $.x][R + $.y] || !v[E + $.x][R + $.y][b + $.z])
                        continue;
                      const S = v[E + $.x][R + $.y][b + $.z];
                      g(M, S);
                    }
                  }
                }
              }
            }
          }
        ),
        /***/
        "./src/parsers/utils/assignPDBBonds.ts": (
          /*!*********************************************!*\
            !*** ./src/parsers/utils/assignPDBBonds.ts ***!
            \*********************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              assignPDBBonds: () => (
                /* binding */
                f
              )
              /* harmony export */
            });
            var o = n(
              /*! ./areConnected */
              "./src/parsers/utils/areConnected.ts"
            ), l = n(
              /*! ./assignBonds */
              "./src/parsers/utils/assignBonds.ts"
            ), u = n(
              /*! ./standardResidues */
              "./src/parsers/utils/standardResidues.ts"
            );
            function f(h, p) {
              const v = [], g = [];
              for (let R = 0, _ = h.length; R < _; R++) {
                const b = h[R];
                b.index = R, b.hetflag || !u.standardResidues.has(b.resn) ? g.push(b) : v.push(b);
              }
              (0, l.assignBonds)(g, p), v.sort(function(R, _) {
                return R.chain !== _.chain ? R.chain < _.chain ? -1 : 1 : R.resi - _.resi;
              });
              let w = -1, E = -1, T;
              for (let R = 0, _ = v.length; R < _; R++) {
                const b = v[R];
                b.resi !== w && (w = b.resi, T || E++, T = !1), b.reschain = E;
                for (let M = R + 1; M < v.length; M++) {
                  const A = v[M];
                  if (A.chain !== b.chain || A.resi - b.resi > 1)
                    break;
                  (0, o.areConnected)(b, A, p) && (b.bonds.indexOf(A.index) === -1 && (b.bonds.push(A.index), b.bondOrder.push(1), A.bonds.push(b.index), A.bondOrder.push(1)), b.resi !== A.resi && (T = !0));
                }
              }
            }
          }
        ),
        /***/
        "./src/parsers/utils/atomNameToElem.ts": (
          /*!*********************************************!*\
            !*** ./src/parsers/utils/atomNameToElem.ts ***!
            \*********************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              atomNameToElem: () => (
                /* binding */
                l
              )
              /* harmony export */
            });
            var o = n(
              /*! ./bondLength */
              "./src/parsers/utils/bondLength.ts"
            );
            function l(u, f) {
              let h = u.replace(/ /g, "");
              return h.length > 0 && h[0] === "H" && h !== "Hg" && h !== "He" && h !== "Hf" && h !== "Hs" && h !== "Ho" && (h = "H"), h.length > 1 && (h = h[0].toUpperCase() + h.substring(1).toLowerCase(), o.bondTable[h] === void 0 ? h = h[0] : f && (h === "Ca" || h === "Cd") && (h = "C")), h;
            }
          }
        ),
        /***/
        "./src/parsers/utils/bondLength.ts": (
          /*!*****************************************!*\
            !*** ./src/parsers/utils/bondLength.ts ***!
            \*****************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              bondLength: () => (
                /* binding */
                l
              ),
              /* harmony export */
              bondTable: () => (
                /* binding */
                o
              ),
              /* harmony export */
              setBondLength: () => (
                /* binding */
                u
              )
              /* harmony export */
            });
            let o = {
              H: 0.37,
              He: 0.32,
              Li: 1.34,
              Be: 0.9,
              B: 0.82,
              C: 0.77,
              N: 0.75,
              O: 0.73,
              F: 0.71,
              Ne: 0.69,
              Na: 1.54,
              Mg: 1.3,
              Al: 1.18,
              Si: 1.11,
              P: 1.06,
              S: 1.02,
              Cl: 0.99,
              Ar: 0.97,
              K: 1.96,
              Ca: 1.74,
              Sc: 1.44,
              Ti: 1.56,
              V: 1.25,
              /* Cr */
              Mn: 1.39,
              Fe: 1.25,
              Co: 1.26,
              Ni: 1.21,
              Cu: 1.38,
              Zn: 1.31,
              Ga: 1.26,
              Ge: 1.22,
              /* As */
              Se: 1.16,
              Br: 1.14,
              Kr: 1.1,
              Rb: 2.11,
              Sr: 1.92,
              Y: 1.62,
              Zr: 1.48,
              Nb: 1.37,
              Mo: 1.45,
              Tc: 1.56,
              Ru: 1.26,
              Rh: 1.35,
              Pd: 1.31,
              Ag: 1.53,
              Cd: 1.48,
              In: 1.44,
              Sn: 1.41,
              Sb: 1.38,
              Te: 1.35,
              I: 1.33,
              Xe: 1.3,
              Cs: 2.25,
              Ba: 1.98,
              Lu: 1.6,
              Hf: 1.5,
              Ta: 1.38,
              W: 1.46,
              Re: 1.59,
              Os: 1.44,
              Ir: 1.37,
              Pt: 1.28,
              Au: 1.44,
              Hg: 1.49,
              Tl: 1.48,
              Pb: 1.47,
              Bi: 1.46,
              /* Po */
              /* At */
              Rn: 1.45
              // None of the bottom row or any of the Lanthanides have bond lengths
            };
            function l(f) {
              return o[f] || 1.6;
            }
            function u(f, h) {
              h < 0 && (h = 0), o[f] = h;
            }
          }
        ),
        /***/
        "./src/parsers/utils/computeSecondaryStructure.ts": (
          /*!********************************************************!*\
            !*** ./src/parsers/utils/computeSecondaryStructure.ts ***!
            \********************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              computeSecondaryStructure: () => (
                /* binding */
                l
              )
              /* harmony export */
            });
            var o = n(
              /*! ./assignBackboneHBonds */
              "./src/parsers/utils/assignBackboneHBonds.ts"
            );
            function l(u, f) {
              (0, o.assignBackboneHBonds)(u, f);
              const h = {};
              let p, v, g, w, E, T;
              for (p = 0, v = u.length; p < v; p++)
                if (E = u[p], h[E.chain] === void 0 && (h[E.chain] = []), isFinite(E.hbondDistanceSq)) {
                  const R = E.hbondOther;
                  h[R.chain] === void 0 && (h[R.chain] = []), Math.abs(R.resi - E.resi) === 4 && (h[E.chain][E.resi] = "h");
                }
              for (g in h)
                for (w = 1; w < h[g].length - 1; w++) {
                  const R = h[g][w - 1], _ = h[g][w + 1];
                  T = h[g][w], R == "h" && R == _ && T != R && (h[g][w] = R);
                }
              for (p = 0, v = u.length; p < v; p++)
                E = u[p], isFinite(E.hbondDistanceSq) && h[E.chain][E.resi] != "h" && E.ss !== "h" && (h[E.chain][E.resi] = "maybesheet");
              for (let R = 0, _ = u.length; R < _; R++)
                if (E = u[R], isFinite(E.hbondDistanceSq) && h[E.chain][E.resi] == "maybesheet") {
                  let b = E.hbondOther, M = h[b.chain][b.resi];
                  (M == "maybesheet" || M == "s") && (h[E.chain][E.resi] = "s", h[b.chain][b.resi] = "s");
                }
              for (let R in h) {
                for (let _ = 1; _ < h[R].length - 1; _++) {
                  const b = h[R][_ - 1], M = h[R][_ + 1];
                  T = h[R][_], b == "s" && b == M && T != b && (h[R][_] = b);
                }
                for (let _ = 0; _ < h[R].length; _++) {
                  const b = h[R][_];
                  (b == "h" || b == "s") && h[R][_ - 1] != b && h[R][_ + 1] != b && delete h[R][_];
                }
              }
              for (p = 0, v = u.length; p < v; p++)
                E = u[p], T = h[E.chain][E.resi], delete E.hbondOther, delete E.hbondDistanceSq, !(T === void 0 || T === "maybesheet") && (E.ss = T, h[E.chain][E.resi - 1] != T && (E.ssbegin = !0), h[E.chain][E.resi + 1] != T && (E.ssend = !0));
            }
          }
        ),
        /***/
        "./src/parsers/utils/getSinglePDB.ts": (
          /*!*******************************************!*\
            !*** ./src/parsers/utils/getSinglePDB.ts ***!
            \*******************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              getSinglePDB: () => (
                /* binding */
                w
              )
              /* harmony export */
            });
            var o = n(
              /*! ../../WebGL */
              "./src/WebGL/index.ts"
            ), l = n(
              /*! ./atomNameToElem */
              "./src/parsers/utils/atomNameToElem.ts"
            ), u = n(
              /*! ./bondLength */
              "./src/parsers/utils/bondLength.ts"
            ), f = n(
              /*! ./computeSecondaryStructure */
              "./src/parsers/utils/computeSecondaryStructure.ts"
            ), h = n(
              /*! ./isEmpty */
              "./src/parsers/utils/isEmpty.ts"
            ), p = n(
              /*! ./processSymmetries */
              "./src/parsers/utils/processSymmetries.ts"
            ), v = n(
              /*! ./assignPDBBonds */
              "./src/parsers/utils/assignPDBBonds.ts"
            ), g = n(
              /*! ./validateBonds */
              "./src/parsers/utils/validateBonds.ts"
            );
            function w(E, T, R) {
              const _ = [], b = T.assignBonds === void 0 ? !0 : T.assignBonds, M = !T.keepH, A = !!T.noSecondaryStructure, $ = !T.noComputeSecondaryStructure, S = !T.doAssembly, C = T.altLoc ? T.altLoc : "A", D = { symmetries: [], cryst: void 0 };
              let O, N = [];
              const j = [];
              let L;
              const z = {};
              for (let G = 0; G < E.length; G++) {
                L = E[G].replace(/^\s*/, "");
                const B = L.substring(0, 6);
                let F, H, W;
                if (B.indexOf("END") === 0) {
                  if (N = E.slice(G + 1), B === "END")
                    for (const V in R)
                      R.hasOwnProperty(V) && delete R[V];
                  break;
                } else if (B === "ATOM  " || B === "HETATM") {
                  let V, X, Z, Q, q, J, ie, ne, ge, ye, xe, we;
                  if (xe = L.substring(16, 17), xe !== " " && xe !== C && C !== "*" || (ye = parseInt(L.substring(6, 11)), O = L.substring(12, 16).replace(/ /g, ""), V = L.substring(17, 20).replace(/ /g, ""), X = L.substring(21, 22), Z = parseInt(L.substring(22, 26)), Q = L.substring(26, 27), q = parseFloat(L.substring(30, 38)), J = parseFloat(L.substring(38, 46)), ie = parseFloat(L.substring(46, 54)), we = parseFloat(L.substring(60, 68)), ge = L.substring(76, 78).replace(/ /g, ""), ge === "" || u.bondTable[ge] === void 0 ? ge = (0, l.atomNameToElem)(L.substring(12, 14), L[0] == "A") : ge = ge[0].toUpperCase() + ge.substring(1).toLowerCase(), ge === "H" && M))
                    continue;
                  B[0] == "H" ? ne = !0 : ne = !1, j[ye] = _.length, _.push({
                    resn: V,
                    x: q,
                    y: J,
                    z: ie,
                    elem: ge,
                    hetflag: ne,
                    altLoc: xe,
                    chain: X,
                    resi: Z,
                    icode: Q,
                    rescode: Z + (Q !== " " ? "^" + Q : ""),
                    // resi
                    // and
                    // icode
                    serial: ye,
                    atom: O,
                    bonds: [],
                    ss: "c",
                    bondOrder: [],
                    properties: {},
                    b: we,
                    pdbline: L
                  });
                } else if (B === "SHEET ") {
                  F = L.substring(21, 22), H = parseInt(L.substring(22, 26)), W = parseInt(L.substring(33, 37)), F in R || (R[F] = {}), R[F][H] = "s1";
                  for (let V = H + 1; V < W; V++)
                    R[F][V] = "s";
                  R[F][W] = "s2";
                } else if (B === "CONECT") {
                  const V = parseInt(L.substring(6, 11)), X = j[V], Z = _[X], Q = [11, 16, 21, 26];
                  for (let q = 0; q < 4; q++) {
                    const J = parseInt(L.substring(Q[q], Q[q] + 5)), ie = j[J];
                    let ne = X + ":" + ie;
                    const ge = _[ie];
                    if (Z !== void 0 && ge !== void 0)
                      if (!z[ne])
                        z[ne] = 1, (Z.bonds.length == 0 || Z.bonds[Z.bonds.length - 1] !== ie) && (Z.bonds.push(ie), Z.bondOrder.push(1));
                      else {
                        z[ne] += 1;
                        for (let ye = 0; ye < Z.bonds.length; ye++)
                          if (Z.bonds[ye] == ie) {
                            const xe = z[ne];
                            xe >= 4 ? Z.bondOrder[ye] = 1 : Z.bondOrder[ye] = xe;
                          }
                      }
                  }
                } else if (B === "HELIX ") {
                  F = L.substring(19, 20), H = parseInt(L.substring(21, 25)), W = parseInt(L.substring(33, 37)), F in R || (R[F] = {}), R[F][H] = "h1";
                  for (let V = H + 1; V < W; V++)
                    R[F][V] = "h";
                  R[F][W] = "h2";
                } else if (!S && B === "REMARK" && L.substring(13, 18) === "BIOMT") {
                  let V, X = new o.Matrix4();
                  for (V = 1; V <= 3; V++)
                    if (L = E[G].replace(/^\s*/, ""), parseInt(L.substring(18, 19)) == V)
                      X.elements[V - 1] = parseFloat(L.substring(23, 33)), X.elements[V - 1 + 4] = parseFloat(L.substring(33, 43)), X.elements[V - 1 + 8] = parseFloat(L.substring(43, 53)), X.elements[V - 1 + 12] = parseFloat(L.substring(53)), G++;
                    else
                      for (; L.substring(13, 18) === "BIOMT"; )
                        G++, L = E[G].replace(/^\s*/, "");
                  X.elements[3] = 0, X.elements[7] = 0, X.elements[11] = 0, X.elements[15] = 1, D.symmetries.push(X), G--;
                } else if (B === "CRYST1") {
                  let V, X, Z, Q, q, J;
                  V = parseFloat(L.substring(7, 15)), X = parseFloat(L.substring(16, 24)), Z = parseFloat(L.substring(25, 33)), Q = parseFloat(L.substring(34, 40)), q = parseFloat(L.substring(41, 47)), J = parseFloat(L.substring(48, 54)), D.cryst = {
                    a: V,
                    b: X,
                    c: Z,
                    alpha: Q,
                    beta: q,
                    gamma: J
                  };
                } else if (B === "ANISOU") {
                  const V = parseInt(L.substring(6, 11)), X = j[V], Z = _[X];
                  if (Z) {
                    const Q = L.substring(30).trim().split(/\s+/), q = {
                      u11: parseInt(Q[0]),
                      u22: parseInt(Q[1]),
                      u33: parseInt(Q[2]),
                      u12: parseInt(Q[3]),
                      u13: parseInt(Q[4]),
                      u23: parseInt(Q[5])
                    };
                    Z.uMat = q;
                  }
                }
              }
              if ((0, g.validateBonds)(_, j), b && (0, v.assignPDBBonds)(_, T), S || (0, p.processSymmetries)(D.symmetries, _, T, D.cryst), $ && !A && (0, f.computeSecondaryStructure)(_, T.hbondCutoff), !(0, h.isEmpty)(R))
                for (let G = 0; G < _.length; G++) {
                  const B = _[G];
                  if (B !== void 0 && B.chain in R && B.resi in R[B.chain]) {
                    const F = R[B.chain][B.resi];
                    B.ss = F[0], F.length > 1 && (F[1] == "1" ? B.ssbegin = !0 : F[1] == "2" && (B.ssend = !0));
                  }
                }
              return [_, D, N];
            }
          }
        ),
        /***/
        "./src/parsers/utils/isEmpty.ts": (
          /*!**************************************!*\
            !*** ./src/parsers/utils/isEmpty.ts ***!
            \**************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              isEmpty: () => (
                /* binding */
                o
              )
              /* harmony export */
            });
            function o(l) {
              for (const u in l)
                return !1;
              return !0;
            }
          }
        ),
        /***/
        "./src/parsers/utils/processSymmetries.ts": (
          /*!************************************************!*\
            !*** ./src/parsers/utils/processSymmetries.ts ***!
            \************************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              processSymmetries: () => (
                /* binding */
                l
              )
              /* harmony export */
            });
            var o = n(
              /*! ../../WebGL */
              "./src/WebGL/index.ts"
            );
            function l(u, f, h, p) {
              const v = !h.duplicateAssemblyAtoms, g = f.length;
              let w = g, E = -1, T = null, R = null;
              (h.normalizeAssembly || h.wrapAtoms) && p && (T = (0, o.conversionMatrix3)(p.a, p.b, p.c, p.alpha, p.beta, p.gamma), R = new o.Matrix3(), R.getInverse3(T));
              let _ = function(A) {
                let $ = A.clone().applyMatrix3(R);
                const S = [$.x, $.y, $.z], C = [0, 0, 0];
                for (let O = 0; O < 3; O++) {
                  for (; S[O] < -1e-3; )
                    S[O] += 1, C[O] += 1;
                  for (; S[O] > 1.001; )
                    S[O] -= 1, C[O] -= 1;
                }
                const D = new o.Vector3(C[0], C[1], C[2]);
                return D.applyMatrix3(T), D;
              };
              if (h.normalizeAssembly && p)
                for (let A = 0; A < u.length; A++) {
                  const $ = new o.Vector3(0, 0, 0);
                  for (let C = 0; C < g; C++) {
                    const D = new o.Vector3(f[C].x, f[C].y, f[C].z);
                    D.applyMatrix4(u[A]), $.add(D);
                  }
                  $.divideScalar(g);
                  const S = _($);
                  u[A].isNearlyIdentity() && S.lengthSq() > 1e-3 && (E = A), u[A].translate(S);
                }
              if (v) {
                if (u.length > 1)
                  for (let A = 0; A < f.length; A++) {
                    var b = [];
                    for (let $ = 0; $ < u.length; $++)
                      if (!u[$].isNearlyIdentity()) {
                        var M = new o.Vector3();
                        M.set(f[A].x, f[A].y, f[A].z), M.applyMatrix4(u[$]), b.push(M);
                      }
                    f[A].symmetries = b;
                  }
              } else {
                for (let A = 0; A < g; A++)
                  f[A].sym = -1;
                for (let A = 0; A < u.length; A++)
                  if (!u[A].isNearlyIdentity() && E != A) {
                    let $ = new o.Vector3();
                    for (let S = 0; S < g; S++) {
                      const C = [];
                      for (let O = 0; O < f[S].bonds.length; O++)
                        C.push(f[S].bonds[O] + w);
                      if ($.set(f[S].x, f[S].y, f[S].z), $.applyMatrix4(u[A]), h.wrapAtoms && p) {
                        let O = _($);
                        $.add(O);
                      }
                      const D = {};
                      for (const O in f[S])
                        D[O] = f[S][O];
                      D.x = $.x, D.y = $.y, D.z = $.z, D.bonds = C, D.sym = A, D.index = f.length, f.push(D);
                    }
                    w = f.length;
                  } else
                    for (let $ = 0; $ < g; $++)
                      f[$].sym = A;
                if (h.wrapAtoms && p) {
                  let A = new o.Vector3();
                  for (let $ = 0; $ < g; $++) {
                    A.set(f[$].x, f[$].y, f[$].z);
                    let S = _(A);
                    A.add(S), f[$].x = A.x, f[$].y = A.y, f[$].z = A.z;
                  }
                }
                if (E >= 0) {
                  const A = new o.Vector3();
                  for (let $ = 0; $ < g; $++)
                    A.set(f[$].x, f[$].y, f[$].z), A.applyMatrix4(u[E]), f[$].x = A.x, f[$].y = A.y, f[$].z = A.z;
                }
                u.length = 0;
              }
            }
          }
        ),
        /***/
        "./src/parsers/utils/standardResidues.ts": (
          /*!***********************************************!*\
            !*** ./src/parsers/utils/standardResidues.ts ***!
            \***********************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              standardResidues: () => (
                /* binding */
                o
              )
              /* harmony export */
            });
            const o = /* @__PURE__ */ new Set([
              "ABU",
              "ACD",
              "ALA",
              "ALB",
              "ALI",
              "ARG",
              "AR0",
              "ASN",
              "ASP",
              "ASX",
              "BAS",
              "CYS",
              "CYH",
              "CYX",
              "CSS",
              "CSH",
              "GLN",
              "GLU",
              "GLX",
              "GLY",
              "HIS",
              "HIE",
              "HID",
              "HIP",
              "HYP",
              "ILE",
              "ILU",
              "LEU",
              "LYS",
              "MET",
              "PCA",
              "PGA",
              "PHE",
              "PR0",
              "PRO",
              "PRZ",
              "SER",
              "THR",
              "TRP",
              "TYR",
              "VAL",
              "A",
              "1MA",
              "C",
              "5MC",
              "OMC",
              "G",
              "1MG",
              "2MG",
              "M2G",
              "7MG",
              "OMG",
              "YG",
              "I",
              "T",
              "U",
              "+U",
              "H2U",
              "5MU",
              "PSU",
              "ACE",
              "F0R",
              "H2O",
              "HOH",
              "WAT"
            ]);
          }
        ),
        /***/
        "./src/parsers/utils/validateBonds.ts": (
          /*!********************************************!*\
            !*** ./src/parsers/utils/validateBonds.ts ***!
            \********************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              validateBonds: () => (
                /* binding */
                o
              )
              /* harmony export */
            });
            function o(l, u) {
              for (let f = 0, h = l.length; f < h; f++) {
                const p = l[f];
                for (let v = 0; v < p.bonds.length; v++) {
                  const g = p.bonds[v], w = l[g], E = u[p.serial];
                  w && E && w.bonds.indexOf(E) < 0 && (w.bonds.push(E), w.bondOrder.push(p.bondOrder[v]));
                }
              }
            }
          }
        ),
        /***/
        "./src/partialCharges.ts": (
          /*!*******************************!*\
            !*** ./src/partialCharges.ts ***!
            \*******************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              applyPartialCharges: () => (
                /* binding */
                l
              ),
              /* harmony export */
              partialCharges: () => (
                /* binding */
                o
              )
              /* harmony export */
            });
            const o = {
              "ALA:N": -0.15,
              "ALA:CA": 0.1,
              "ALA:CB": 0,
              "ALA:C": 0.6,
              "ALA:O": -0.55,
              "ARG:N": -0.15,
              "ARG:CA": 0.1,
              "ARG:CB": 0,
              "ARG:CG": 0,
              "ARG:CD": 0.1,
              "ARG:NE": -0.1,
              "ARG:CZ": 0.5,
              "ARG:NH1": 0.25,
              "ARG:NH2": 0.25,
              "ARG:C": 0.6,
              "ARG:O": -0.55,
              "ASN:N": -0.15,
              "ASN:CA": 0.1,
              "ASN:CB": 0,
              "ASN:CG": 0.55,
              "ASN:OD1": -0.55,
              "ASN:ND2": 0,
              "ASN:C": 0.6,
              "ASN:O": -0.55,
              "ASP:N": -0.15,
              "ASP:CA": 0.1,
              "ASP:CB": 0,
              "ASP:CG": 0.14,
              "ASP:OD1": -0.57,
              "ASP:OD2": -0.57,
              "ASP:C": 0.6,
              "ASP:O": -0.55,
              "CYS:N": -0.15,
              "CYS:CA": 0.1,
              "CYS:CB": 0.19,
              "CYS:SG": -0.19,
              "CYS:C": 0.6,
              "CYS:O": -0.55,
              "GLN:N": -0.15,
              "GLN:CA": 0.1,
              "GLN:CB": 0,
              "GLN:CG": 0,
              "GLN:CD": 0.55,
              "GLN:OE1": -0.55,
              "GLN:NE2": 0,
              "GLN:C": 0.6,
              "GLN:O": -0.55,
              "GLU:N": -0.15,
              "GLU:CA": 0.1,
              "GLU:CB": 0,
              "GLU:CG": 0,
              "GLU:CD": 0.14,
              "GLU:OE1": -0.57,
              "GLU:OE2": -0.57,
              "GLU:C": 0.6,
              "GLU:O": -0.55,
              "GLY:N": -0.15,
              "GLY:CA": 0.1,
              "GLY:C": 0.6,
              "GLY:O": -0.55,
              "HIS:N": -0.15,
              "HIS:CA": 0.1,
              "HIS:CB": 0,
              "HIS:CG": 0.1,
              "HIS:ND1": -0.1,
              "HIS:CD2": 0.1,
              "HIS:NE2": -0.4,
              "HIS:CE1": 0.3,
              "HIS:C": 0.6,
              "HIS:O": -0.55,
              "ILE:N": -0.15,
              "ILE:CA": 0.1,
              "ILE:CB": 0,
              "ILE:CG2": 0,
              "ILE:CG1": 0,
              "ILE:CD": 0,
              "ILE:C": 0.6,
              "ILE:O": -0.55,
              "LEU:N": -0.15,
              "LEU:CA": 0.1,
              "LEU:CB": 0,
              "LEU:CG": 0,
              "LEU:CD1": 0,
              "LEU:CD2": 0,
              "LEU:C": 0.6,
              "LEU:O": -0.55,
              "LYS:N": -0.15,
              "LYS:CA": 0.1,
              "LYS:CB": 0,
              "LYS:CG": 0,
              "LYS:CD": 0,
              "LYS:CE": 0.25,
              "LYS:NZ": 0.75,
              "LYS:C": 0.6,
              "LYS:O": -0.55,
              "MET:N": -0.15,
              "MET:CA": 0.1,
              "MET:CB": 0,
              "MET:CG": 0.06,
              "MET:SD": -0.12,
              "MET:CE": 0.06,
              "MET:C": 0.6,
              "MET:O": -0.55,
              "PHE:N": -0.15,
              "PHE:CA": 0.1,
              "PHE:CB": 0,
              "PHE:CG": 0,
              "PHE:CD1": 0,
              "PHE:CD2": 0,
              "PHE:CE1": 0,
              "PHE:CE2": 0,
              "PHE:CZ": 0,
              "PHE:C": 0.6,
              "PHE:O": -0.55,
              "PRO:N": -0.25,
              "PRO:CD": 0.1,
              "PRO:CA": 0.1,
              "PRO:CB": 0,
              "PRO:CG": 0,
              "PRO:C": 0.6,
              "PRO:O": -0.55,
              "SER:N": -0.15,
              "SER:CA": 0.1,
              "SER:CB": 0.25,
              "SER:OG": -0.25,
              "SER:C": 0.6,
              "SER:O": -0.55,
              "THR:N": -0.15,
              "THR:CA": 0.1,
              "THR:CB": 0.25,
              "THR:OG1": -0.25,
              "THR:CG2": 0,
              "THR:C": 0.6,
              "THR:O": -0.55,
              "TRP:N": -0.15,
              "TRP:CA": 0.1,
              "TRP:CB": 0,
              "TRP:CG": -0.03,
              "TRP:CD2": 0.1,
              "TRP:CE2": -0.04,
              "TRP:CE3": -0.03,
              "TRP:CD1": 0.06,
              "TRP:NE1": -0.06,
              "TRP:CZ2": 0,
              "TRP:CZ3": 0,
              "TRP:CH2": 0,
              "TRP:C": 0.6,
              "TRP:O": -0.55,
              "TYR:N": -0.15,
              "TYR:CA": 0.1,
              "TYR:CB": 0,
              "TYR:CG": 0,
              "TYR:CD1": 0,
              "TYR:CE1": 0,
              "TYR:CD2": 0,
              "TYR:CE2": 0,
              "TYR:CZ": 0.25,
              "TYR:OH": -0.25,
              "TYR:C": 0.6,
              "TYR:O": -0.55,
              "VAL:N": -0.15,
              "VAL:CA": 0.1,
              "VAL:CB": 0,
              "VAL:CG1": 0,
              "VAL:CG2": 0,
              "VAL:C": 0.6,
              "VAL:O": -0.55
            };
            function l(u, f) {
              if ((!f || typeof u.partialCharge > "u") && u.resn && u.atom) {
                var h = u.resn + ":" + u.atom;
                u.properties.partialCharge = o[h];
              }
            }
          }
        ),
        /***/
        "./src/specs.ts": (
          /*!**********************!*\
            !*** ./src/specs.ts ***!
            \**********************/
          /***/
          (t, e, n) => {
            n.r(e);
          }
        ),
        /***/
        "./src/utilities.ts": (
          /*!**************************!*\
            !*** ./src/utilities.ts ***!
            \**************************/
          /***/
          (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
            __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
              /* harmony export */
              PausableTimer: () => (
                /* binding */
                PausableTimer
              ),
              /* harmony export */
              adjustVolumeStyle: () => (
                /* binding */
                adjustVolumeStyle
              ),
              /* harmony export */
              base64ToArray: () => (
                /* binding */
                base64ToArray
              ),
              /* harmony export */
              deepCopy: () => (
                /* binding */
                deepCopy
              ),
              /* harmony export */
              download: () => (
                /* binding */
                download
              ),
              /* harmony export */
              extend: () => (
                /* binding */
                extend
              ),
              /* harmony export */
              get: () => (
                /* binding */
                get
              ),
              /* harmony export */
              getAtomProperty: () => (
                /* binding */
                getAtomProperty
              ),
              /* harmony export */
              getColorFromStyle: () => (
                /* binding */
                getColorFromStyle
              ),
              /* harmony export */
              getElement: () => (
                /* binding */
                getElement
              ),
              /* harmony export */
              getExtent: () => (
                /* binding */
                getExtent
              ),
              /* harmony export */
              getPropertyRange: () => (
                /* binding */
                getPropertyRange
              ),
              /* harmony export */
              getbin: () => (
                /* binding */
                getbin
              ),
              /* harmony export */
              isEmptyObject: () => (
                /* binding */
                isEmptyObject
              ),
              /* harmony export */
              isNumeric: () => (
                /* binding */
                isNumeric
              ),
              /* harmony export */
              makeFunction: () => (
                /* binding */
                makeFunction
              ),
              /* harmony export */
              mergeGeos: () => (
                /* binding */
                mergeGeos
              ),
              /* harmony export */
              specStringToObject: () => (
                /* binding */
                specStringToObject
              )
              /* harmony export */
            });
            var _Gradient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
              /*! ./Gradient */
              "./src/Gradient.ts"
            ), _VolumeData__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
              /*! ./VolumeData */
              "./src/VolumeData.ts"
            ), _colors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
              /*! ./colors */
              "./src/colors.ts"
            );
            function extend(t, e) {
              for (var n in e)
                e.hasOwnProperty(n) && e[n] !== void 0 && (t[n] = e[n]);
              return t;
            }
            function deepCopy(t) {
              let e, n, o;
              if (t == null)
                return {};
              if (typeof t != "object" || t === null)
                return t;
              e = Array.isArray(t) ? [] : {};
              for (o in t)
                n = t[o], e[o] = deepCopy(n);
              return e;
            }
            function isNumeric(t) {
              var e = typeof t;
              return (e === "number" || e === "string") && !isNaN(t - parseFloat(t));
            }
            function isEmptyObject(t) {
              var e;
              for (e in t)
                return !1;
              return !0;
            }
            function makeFunction(callback) {
              return callback && typeof callback == "string" && (callback = eval("(" + callback + ")")), callback && typeof callback != "function" ? null : callback;
            }
            function adjustVolumeStyle(t) {
              t && (t.volformat && !(t.voldata instanceof _VolumeData__WEBPACK_IMPORTED_MODULE_1__.VolumeData) && (t.voldata = new _VolumeData__WEBPACK_IMPORTED_MODULE_1__.VolumeData(t.voldata, t.volformat)), t.volscheme && (t.volscheme = _Gradient__WEBPACK_IMPORTED_MODULE_0__.Gradient.getGradient(t.volscheme)));
            }
            function getExtent(t, e) {
              var n, o, l, u, f, h, p, v, g, w, E = !e;
              if (n = o = l = 9999, u = f = h = -9999, p = v = g = w = 0, t.length === 0)
                return [[0, 0, 0], [0, 0, 0], [0, 0, 0]];
              for (var T = 0; T < t.length; T++) {
                var R = t[T];
                if (!(typeof R > "u" || !isFinite(R.x) || !isFinite(R.y) || !isFinite(R.z)) && (w++, p += R.x, v += R.y, g += R.z, n = n < R.x ? n : R.x, o = o < R.y ? o : R.y, l = l < R.z ? l : R.z, u = u > R.x ? u : R.x, f = f > R.y ? f : R.y, h = h > R.z ? h : R.z, R.symmetries && E))
                  for (var _ = 0; _ < R.symmetries.length; _++)
                    w++, p += R.symmetries[_].x, v += R.symmetries[_].y, g += R.symmetries[_].z, n = n < R.symmetries[_].x ? n : R.symmetries[_].x, o = o < R.symmetries[_].y ? o : R.symmetries[_].y, l = l < R.symmetries[_].z ? l : R.symmetries[_].z, u = u > R.symmetries[_].x ? u : R.symmetries[_].x, f = f > R.symmetries[_].y ? f : R.symmetries[_].y, h = h > R.symmetries[_].z ? h : R.symmetries[_].z;
              }
              return [
                [n, o, l],
                [u, f, h],
                [p / w, v / w, g / w]
              ];
            }
            function getPropertyRange(t, e) {
              for (var n = Number.POSITIVE_INFINITY, o = Number.NEGATIVE_INFINITY, l = 0, u = t.length; l < u; l++) {
                var f = t[l], h = getAtomProperty(f, e);
                h != null && (h < n && (n = h), h > o && (o = h));
              }
              return !isFinite(n) && !isFinite(o) ? n = o = 0 : isFinite(n) ? isFinite(o) || (o = n) : n = o, [n, o];
            }
            class PausableTimer {
              constructor(e, n, o) {
                this.total_time_run = 0, this.fn = e, this.arg = o, this.countdown = n, this.start_time = (/* @__PURE__ */ new Date()).getTime(), this.ident = setTimeout(e, n, o);
              }
              cancel() {
                clearTimeout(this.ident);
              }
              pause() {
                clearTimeout(this.ident), this.total_time_run = (/* @__PURE__ */ new Date()).getTime() - this.start_time;
              }
              resume() {
                this.ident = setTimeout(this.fn, Math.max(0, this.countdown - this.total_time_run), this.arg);
              }
            }
            function base64ToArray(t) {
              for (var e = window.atob(t), n = e.length, o = new Uint8Array(n), l = 0; l < n; l++)
                o[l] = e.charCodeAt(l);
              return o;
            }
            function getAtomProperty(t, e) {
              var n = null;
              return t.properties && typeof t.properties[e] < "u" ? n = t.properties[e] : typeof t[e] < "u" && (n = t[e]), n;
            }
            function mergeGeos(t, e) {
              var n = e.geometry;
              n !== void 0 && t.geometryGroups.push(n.geometryGroups[0]);
            }
            function specStringToObject(t) {
              if (typeof t == "object" || typeof t > "u" || t == null)
                return t;
              try {
                return JSON.parse(t);
              } catch {
              }
              t = t.replace(/%7E/g, "~");
              var e = function(E) {
                return isNumeric(E) ? Math.floor(parseFloat(E)) == parseInt(E) || E.indexOf(".") >= 0 ? parseFloat(E) : parseInt(E) : E === "true" ? !0 : E === "false" ? !1 : E;
              }, n = {};
              if (t === "all")
                return n;
              for (var o = t.split(";"), l = 0; l < o.length; l++) {
                var u = o[l].split(":"), f = u[0], h = {}, p = u[1];
                if (p)
                  if (p = p.replace(/~/g, "="), p.indexOf("=") !== -1)
                    for (var v = p.split(","), g = 0; g < v.length; g++) {
                      var w = v[g].split("=", 2);
                      h[w[0]] = e(w[1]);
                    }
                  else
                    p.indexOf(",") !== -1 ? h = p.split(",") : h = e(p);
                n[f] = h;
              }
              return n;
            }
            function checkStatus(t) {
              if (!t.ok)
                throw new Error(`HTTP ${t.status} - ${t.statusText}`);
              return t;
            }
            function get(t, e) {
              var n = fetch(t).then(checkStatus).then((o) => o.text());
              return e ? n.then(e) : n;
            }
            function getbin(t, e, n, o) {
              var l;
              return n == "POST" ? l = fetch(t, { method: "POST", body: o }).then((u) => checkStatus(u)).then((u) => u.arrayBuffer()) : l = fetch(t).then((u) => checkStatus(u)).then((u) => u.arrayBuffer()), e ? l.then(e) : l;
            }
            function download(t, e, n, o) {
              var l = "", u = "", f = "", h = "", p = null, v = e.addModel();
              if (t.indexOf(":") < 0 && (t.length == 4 ? t = "pdb:" + t : isNaN(t) ? t = "url:" + t : t = "cid:" + t), t.substring(0, 5) === "mmtf:")
                u = n && n.pdbUri ? n.pdbUri : "https://mmtf.rcsb.org/v1.0/full/", t = t.substring(5).toUpperCase(), h = u + t, n && typeof n.noComputeSecondaryStructure > "u" && (n.noComputeSecondaryStructure = !0), p = new Promise(function(w) {
                  getbin(h).then(function(E) {
                    v.addMolData(E, "mmtf", n), e.zoomTo(), e.render(), w(v);
                  }, function() {
                    console.log("fetch of " + h + " failed.");
                  });
                });
              else {
                if (t.substring(0, 4) === "pdb:") {
                  if (l = "mmtf", n && n.format && (l = n.format), n && typeof n.noComputeSecondaryStructure > "u" && (n.noComputeSecondaryStructure = !0), t = t.substring(4).toUpperCase(), !t.match(/^[1-9][A-Za-z0-9]{3}$/)) {
                    alert("Wrong PDB ID");
                    return;
                  }
                  l == "mmtf" ? (f = n && n.mmtfUri ? n.mmtfUri : "https://mmtf.rcsb.org/v1.0/full/", h = f + t.toUpperCase()) : (u = n && n.pdbUri ? n.pdbUri : "https://files.rcsb.org/view/", h = u + t + "." + l);
                } else if (t.substring(0, 4) == "cid:") {
                  if (l = "sdf", t = t.substring(4), !t.match(/^[0-9]+$/)) {
                    alert("Wrong Compound ID");
                    return;
                  }
                  h = "https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/cid/" + t + "/SDF?record_type=3d";
                } else
                  t.substring(0, 4) == "url:" && (h = t.substring(4), l = h);
                var g = function(w) {
                  v.addMolData(w, l, n), e.zoomTo(), e.render();
                };
                p = new Promise(function(w) {
                  l == "mmtf" ? getbin(h).then(function(E) {
                    g(E), w(v);
                  }).catch(function() {
                    u = n && n.pdbUri ? n.pdbUri : "https://files.rcsb.org/view/", h = u + t + ".pdb", l = "pdb", console.log("falling back to pdb format"), get(h).then(function(E) {
                      g(E), w(v);
                    }).catch(function(E) {
                      g(""), w(v), console.log("fetch of " + h + " failed: " + E.statusText);
                    });
                  }) : get(h).then(function(E) {
                    g(E), w(v);
                  }).catch(function(E) {
                    g(""), w(v), console.log("fetch of " + h + " failed: " + E.statusText);
                  });
                });
              }
              return o ? (p.then(function(w) {
                o(w);
              }), v) : p;
            }
            function getColorFromStyle(t, e) {
              let n = e.colorscheme;
              if (typeof _colors__WEBPACK_IMPORTED_MODULE_2__.builtinColorSchemes[n] < "u")
                n = _colors__WEBPACK_IMPORTED_MODULE_2__.builtinColorSchemes[n];
              else if (typeof n == "string" && n.endsWith("Carbon")) {
                let u = n.substring(0, n.lastIndexOf("Carbon")).toLowerCase();
                if (typeof _colors__WEBPACK_IMPORTED_MODULE_2__.htmlColors[u] < "u") {
                  let f = Object.assign({}, _colors__WEBPACK_IMPORTED_MODULE_2__.elementColors.defaultColors);
                  f.C = _colors__WEBPACK_IMPORTED_MODULE_2__.htmlColors[u], _colors__WEBPACK_IMPORTED_MODULE_2__.builtinColorSchemes[n] = { prop: "elem", map: f }, n = _colors__WEBPACK_IMPORTED_MODULE_2__.builtinColorSchemes[n];
                }
              }
              let o = t.color;
              if (typeof e.color < "u" && e.color != "spectrum" && (o = e.color), typeof n < "u") {
                let u, f;
                if (typeof _colors__WEBPACK_IMPORTED_MODULE_2__.elementColors[n] < "u")
                  n = _colors__WEBPACK_IMPORTED_MODULE_2__.elementColors[n], typeof n[t[n.prop]] < "u" && (o = n.map[t[n.prop]]);
                else if (typeof n[t[n.prop]] < "u")
                  o = n.map[t[n.prop]];
                else if (typeof n.prop < "u" && typeof n.gradient < "u") {
                  u = n.prop;
                  var l = n.gradient;
                  typeof _Gradient__WEBPACK_IMPORTED_MODULE_0__.builtinGradients[l] < "u" && (l = new _Gradient__WEBPACK_IMPORTED_MODULE_0__.builtinGradients[l](n.min, n.max, n.mid ? n.mid : n.colors));
                  let h = l.range() || [-1, 1];
                  f = getAtomProperty(t, u), f != null && (o = l.valueToHex(f, h));
                } else
                  typeof n.prop < "u" && typeof n.map < "u" ? (u = n.prop, f = getAtomProperty(t, u), typeof n.map[f] < "u" && (o = n.map[f])) : typeof e.colorscheme[t.elem] < "u" ? o = e.colorscheme[t.elem] : console.log("Could not interpret colorscheme " + n);
              } else
                typeof e.colorfunc < "u" && (o = e.colorfunc(t));
              return _colors__WEBPACK_IMPORTED_MODULE_2__.CC.color(o);
            }
            function getElement(t) {
              let e = t;
              return typeof t == "string" ? e = document.querySelector("#" + t) : typeof t == "object" && t.get && (e = t.get(0)), e;
            }
          }
        ),
        /***/
        "./node_modules/upng-js/UPNG.js": (
          /*!**************************************!*\
            !*** ./node_modules/upng-js/UPNG.js ***!
            \**************************************/
          /***/
          (t, e, n) => {
            (function() {
              var o = {}, l;
              t.exports = o, l = n(
                /*! pako */
                "./node_modules/upng-js/node_modules/pako/index.js"
              ), function(u, f) {
                u.toRGBA8 = function(h) {
                  var p = h.width, v = h.height;
                  if (h.tabs.acTL == null)
                    return [u.toRGBA8.decodeImage(h.data, p, v, h).buffer];
                  var g = [];
                  h.frames[0].data == null && (h.frames[0].data = h.data);
                  for (var w, E = new Uint8Array(p * v * 4), T = 0; T < h.frames.length; T++) {
                    var R = h.frames[T], _ = R.rect.x, b = R.rect.y, M = R.rect.width, A = R.rect.height, $ = u.toRGBA8.decodeImage(R.data, M, A, h);
                    if (T == 0 ? w = $ : R.blend == 0 ? u._copyTile($, M, A, w, p, v, _, b, 0) : R.blend == 1 && u._copyTile($, M, A, w, p, v, _, b, 1), g.push(w.buffer), w = w.slice(0), R.dispose != 0) {
                      if (R.dispose == 1)
                        u._copyTile(E, M, A, w, p, v, _, b, 0);
                      else if (R.dispose == 2) {
                        for (var S = T - 1; h.frames[S].dispose == 2; )
                          S--;
                        w = new Uint8Array(g[S]).slice(0);
                      }
                    }
                  }
                  return g;
                }, u.toRGBA8.decodeImage = function(h, p, v, g) {
                  var w = p * v, E = u.decode._getBPP(g), T = Math.ceil(p * E / 8), R = new Uint8Array(w * 4), _ = new Uint32Array(R.buffer), b = g.ctype, M = g.depth, A = u._bin.readUshort;
                  if (b == 6) {
                    var $ = w << 2;
                    if (M == 8)
                      for (var S = 0; S < $; S++)
                        R[S] = h[S];
                    if (M == 16)
                      for (var S = 0; S < $; S++)
                        R[S] = h[S << 1];
                  } else if (b == 2) {
                    var C = g.tabs.tRNS, D = -1, O = -1, N = -1;
                    if (C && (D = C[0], O = C[1], N = C[2]), M == 8)
                      for (var S = 0; S < w; S++) {
                        var j = S << 2, L = S * 3;
                        R[j] = h[L], R[j + 1] = h[L + 1], R[j + 2] = h[L + 2], R[j + 3] = 255, D != -1 && h[L] == D && h[L + 1] == O && h[L + 2] == N && (R[j + 3] = 0);
                      }
                    if (M == 16)
                      for (var S = 0; S < w; S++) {
                        var j = S << 2, L = S * 6;
                        R[j] = h[L], R[j + 1] = h[L + 2], R[j + 2] = h[L + 4], R[j + 3] = 255, D != -1 && A(h, L) == D && A(h, L + 2) == O && A(h, L + 4) == N && (R[j + 3] = 0);
                      }
                  } else if (b == 3) {
                    var z = g.tabs.PLTE, G = g.tabs.tRNS, B = G ? G.length : 0;
                    if (M == 1)
                      for (var F = 0; F < v; F++)
                        for (var H = F * T, W = F * p, S = 0; S < p; S++) {
                          var j = W + S << 2, V = h[H + (S >> 3)] >> 7 - ((S & 7) << 0) & 1, X = 3 * V;
                          R[j] = z[X], R[j + 1] = z[X + 1], R[j + 2] = z[X + 2], R[j + 3] = V < B ? G[V] : 255;
                        }
                    if (M == 2)
                      for (var F = 0; F < v; F++)
                        for (var H = F * T, W = F * p, S = 0; S < p; S++) {
                          var j = W + S << 2, V = h[H + (S >> 2)] >> 6 - ((S & 3) << 1) & 3, X = 3 * V;
                          R[j] = z[X], R[j + 1] = z[X + 1], R[j + 2] = z[X + 2], R[j + 3] = V < B ? G[V] : 255;
                        }
                    if (M == 4)
                      for (var F = 0; F < v; F++)
                        for (var H = F * T, W = F * p, S = 0; S < p; S++) {
                          var j = W + S << 2, V = h[H + (S >> 1)] >> 4 - ((S & 1) << 2) & 15, X = 3 * V;
                          R[j] = z[X], R[j + 1] = z[X + 1], R[j + 2] = z[X + 2], R[j + 3] = V < B ? G[V] : 255;
                        }
                    if (M == 8)
                      for (var S = 0; S < w; S++) {
                        var j = S << 2, V = h[S], X = 3 * V;
                        R[j] = z[X], R[j + 1] = z[X + 1], R[j + 2] = z[X + 2], R[j + 3] = V < B ? G[V] : 255;
                      }
                  } else if (b == 4) {
                    if (M == 8)
                      for (var S = 0; S < w; S++) {
                        var j = S << 2, Z = S << 1, Q = h[Z];
                        R[j] = Q, R[j + 1] = Q, R[j + 2] = Q, R[j + 3] = h[Z + 1];
                      }
                    if (M == 16)
                      for (var S = 0; S < w; S++) {
                        var j = S << 2, Z = S << 2, Q = h[Z];
                        R[j] = Q, R[j + 1] = Q, R[j + 2] = Q, R[j + 3] = h[Z + 2];
                      }
                  } else if (b == 0) {
                    var D = g.tabs.tRNS ? g.tabs.tRNS : -1;
                    if (M == 1)
                      for (var S = 0; S < w; S++) {
                        var Q = 255 * (h[S >> 3] >> 7 - (S & 7) & 1), q = Q == D * 255 ? 0 : 255;
                        _[S] = q << 24 | Q << 16 | Q << 8 | Q;
                      }
                    if (M == 2)
                      for (var S = 0; S < w; S++) {
                        var Q = 85 * (h[S >> 2] >> 6 - ((S & 3) << 1) & 3), q = Q == D * 85 ? 0 : 255;
                        _[S] = q << 24 | Q << 16 | Q << 8 | Q;
                      }
                    if (M == 4)
                      for (var S = 0; S < w; S++) {
                        var Q = 17 * (h[S >> 1] >> 4 - ((S & 1) << 2) & 15), q = Q == D * 17 ? 0 : 255;
                        _[S] = q << 24 | Q << 16 | Q << 8 | Q;
                      }
                    if (M == 8)
                      for (var S = 0; S < w; S++) {
                        var Q = h[S], q = Q == D ? 0 : 255;
                        _[S] = q << 24 | Q << 16 | Q << 8 | Q;
                      }
                    if (M == 16)
                      for (var S = 0; S < w; S++) {
                        var Q = h[S << 1], q = A(h, S << 1) == D ? 0 : 255;
                        _[S] = q << 24 | Q << 16 | Q << 8 | Q;
                      }
                  }
                  return R;
                }, u.decode = function(h) {
                  for (var p = new Uint8Array(h), v = 8, g = u._bin, w = g.readUshort, E = g.readUint, T = { tabs: {}, frames: [] }, R = new Uint8Array(p.length), _ = 0, b, M = 0, A = [137, 80, 78, 71, 13, 10, 26, 10], $ = 0; $ < 8; $++)
                    if (p[$] != A[$])
                      throw "The input is not a PNG file!";
                  for (; v < p.length; ) {
                    var S = g.readUint(p, v);
                    v += 4;
                    var C = g.readASCII(p, v, 4);
                    if (v += 4, C == "IHDR")
                      u.decode._IHDR(p, v, T);
                    else if (C == "IDAT") {
                      for (var $ = 0; $ < S; $++)
                        R[_ + $] = p[v + $];
                      _ += S;
                    } else if (C == "acTL")
                      T.tabs[C] = { num_frames: E(p, v), num_plays: E(p, v + 4) }, b = new Uint8Array(p.length);
                    else if (C == "fcTL") {
                      if (M != 0) {
                        var D = T.frames[T.frames.length - 1];
                        D.data = u.decode._decompress(T, b.slice(0, M), D.rect.width, D.rect.height), M = 0;
                      }
                      var O = { x: E(p, v + 12), y: E(p, v + 16), width: E(p, v + 4), height: E(p, v + 8) }, N = w(p, v + 22);
                      N = w(p, v + 20) / (N == 0 ? 100 : N);
                      var j = { rect: O, delay: Math.round(N * 1e3), dispose: p[v + 24], blend: p[v + 25] };
                      T.frames.push(j);
                    } else if (C == "fdAT") {
                      for (var $ = 0; $ < S - 4; $++)
                        b[M + $] = p[v + $ + 4];
                      M += S - 4;
                    } else if (C == "pHYs")
                      T.tabs[C] = [g.readUint(p, v), g.readUint(p, v + 4), p[v + 8]];
                    else if (C == "cHRM") {
                      T.tabs[C] = [];
                      for (var $ = 0; $ < 8; $++)
                        T.tabs[C].push(g.readUint(p, v + $ * 4));
                    } else if (C == "tEXt") {
                      T.tabs[C] == null && (T.tabs[C] = {});
                      var L = g.nextZero(p, v), z = g.readASCII(p, v, L - v), G = g.readASCII(p, L + 1, v + S - L - 1);
                      T.tabs[C][z] = G;
                    } else if (C == "iTXt") {
                      T.tabs[C] == null && (T.tabs[C] = {});
                      var L = 0, B = v;
                      L = g.nextZero(p, B);
                      var z = g.readASCII(p, B, L - B);
                      B = L + 1, p[B], p[B + 1], B += 2, L = g.nextZero(p, B), g.readASCII(p, B, L - B), B = L + 1, L = g.nextZero(p, B), g.readUTF8(p, B, L - B), B = L + 1;
                      var G = g.readUTF8(p, B, S - (B - v));
                      T.tabs[C][z] = G;
                    } else if (C == "PLTE")
                      T.tabs[C] = g.readBytes(p, v, S);
                    else if (C == "hIST") {
                      var F = T.tabs.PLTE.length / 3;
                      T.tabs[C] = [];
                      for (var $ = 0; $ < F; $++)
                        T.tabs[C].push(w(p, v + $ * 2));
                    } else if (C == "tRNS")
                      T.ctype == 3 ? T.tabs[C] = g.readBytes(p, v, S) : T.ctype == 0 ? T.tabs[C] = w(p, v) : T.ctype == 2 && (T.tabs[C] = [w(p, v), w(p, v + 2), w(p, v + 4)]);
                    else if (C == "gAMA")
                      T.tabs[C] = g.readUint(p, v) / 1e5;
                    else if (C == "sRGB")
                      T.tabs[C] = p[v];
                    else if (C == "bKGD")
                      T.ctype == 0 || T.ctype == 4 ? T.tabs[C] = [w(p, v)] : T.ctype == 2 || T.ctype == 6 ? T.tabs[C] = [w(p, v), w(p, v + 2), w(p, v + 4)] : T.ctype == 3 && (T.tabs[C] = p[v]);
                    else if (C == "IEND") {
                      if (M != 0) {
                        var D = T.frames[T.frames.length - 1];
                        D.data = u.decode._decompress(T, b.slice(0, M), D.rect.width, D.rect.height), M = 0;
                      }
                      T.data = u.decode._decompress(T, R, T.width, T.height);
                      break;
                    }
                    v += S, g.readUint(p, v), v += 4;
                  }
                  return delete T.compress, delete T.interlace, delete T.filter, T;
                }, u.decode._decompress = function(h, p, v, g) {
                  return h.compress == 0 && (p = u.decode._inflate(p)), h.interlace == 0 ? p = u.decode._filterZero(p, h, 0, v, g) : h.interlace == 1 && (p = u.decode._readInterlace(p, h)), p;
                }, u.decode._inflate = function(h) {
                  return f.inflate(h);
                }, u.decode._readInterlace = function(h, p) {
                  for (var v = p.width, g = p.height, w = u.decode._getBPP(p), E = w >> 3, T = Math.ceil(v * w / 8), R = new Uint8Array(g * T), _ = 0, b = [0, 0, 4, 0, 2, 0, 1], M = [0, 4, 0, 2, 0, 1, 0], A = [8, 8, 8, 4, 4, 2, 2], $ = [8, 8, 4, 4, 2, 2, 1], S = 0; S < 7; ) {
                    for (var C = A[S], D = $[S], O = 0, N = 0, j = b[S]; j < g; )
                      j += C, N++;
                    for (var L = M[S]; L < v; )
                      L += D, O++;
                    var z = Math.ceil(O * w / 8);
                    u.decode._filterZero(h, p, _, O, N);
                    for (var G = 0, B = b[S]; B < g; ) {
                      for (var F = M[S], H = _ + G * z << 3; F < v; ) {
                        if (w == 1) {
                          var W = h[H >> 3];
                          W = W >> 7 - (H & 7) & 1, R[B * T + (F >> 3)] |= W << 7 - ((F & 3) << 0);
                        }
                        if (w == 2) {
                          var W = h[H >> 3];
                          W = W >> 6 - (H & 7) & 3, R[B * T + (F >> 2)] |= W << 6 - ((F & 3) << 1);
                        }
                        if (w == 4) {
                          var W = h[H >> 3];
                          W = W >> 4 - (H & 7) & 15, R[B * T + (F >> 1)] |= W << 4 - ((F & 1) << 2);
                        }
                        if (w >= 8)
                          for (var V = B * T + F * E, X = 0; X < E; X++)
                            R[V + X] = h[(H >> 3) + X];
                        H += w, F += D;
                      }
                      G++, B += C;
                    }
                    O * N != 0 && (_ += N * (1 + z)), S = S + 1;
                  }
                  return R;
                }, u.decode._getBPP = function(h) {
                  var p = [1, null, 3, 1, 2, null, 4][h.ctype];
                  return p * h.depth;
                }, u.decode._filterZero = function(h, p, v, g, w) {
                  var E = u.decode._getBPP(p), T = Math.ceil(g * E / 8), R = u.decode._paeth;
                  E = Math.ceil(E / 8);
                  for (var _ = 0; _ < w; _++) {
                    var b = v + _ * T, M = b + _ + 1, A = h[M - 1];
                    if (A == 0)
                      for (var $ = 0; $ < T; $++)
                        h[b + $] = h[M + $];
                    else if (A == 1) {
                      for (var $ = 0; $ < E; $++)
                        h[b + $] = h[M + $];
                      for (var $ = E; $ < T; $++)
                        h[b + $] = h[M + $] + h[b + $ - E] & 255;
                    } else if (_ == 0) {
                      for (var $ = 0; $ < E; $++)
                        h[b + $] = h[M + $];
                      if (A == 2)
                        for (var $ = E; $ < T; $++)
                          h[b + $] = h[M + $] & 255;
                      if (A == 3)
                        for (var $ = E; $ < T; $++)
                          h[b + $] = h[M + $] + (h[b + $ - E] >> 1) & 255;
                      if (A == 4)
                        for (var $ = E; $ < T; $++)
                          h[b + $] = h[M + $] + R(h[b + $ - E], 0, 0) & 255;
                    } else {
                      if (A == 2)
                        for (var $ = 0; $ < T; $++)
                          h[b + $] = h[M + $] + h[b + $ - T] & 255;
                      if (A == 3) {
                        for (var $ = 0; $ < E; $++)
                          h[b + $] = h[M + $] + (h[b + $ - T] >> 1) & 255;
                        for (var $ = E; $ < T; $++)
                          h[b + $] = h[M + $] + (h[b + $ - T] + h[b + $ - E] >> 1) & 255;
                      }
                      if (A == 4) {
                        for (var $ = 0; $ < E; $++)
                          h[b + $] = h[M + $] + R(0, h[b + $ - T], 0) & 255;
                        for (var $ = E; $ < T; $++)
                          h[b + $] = h[M + $] + R(h[b + $ - E], h[b + $ - T], h[b + $ - E - T]) & 255;
                      }
                    }
                  }
                  return h;
                }, u.decode._paeth = function(h, p, v) {
                  var g = h + p - v, w = Math.abs(g - h), E = Math.abs(g - p), T = Math.abs(g - v);
                  return w <= E && w <= T ? h : E <= T ? p : v;
                }, u.decode._IHDR = function(h, p, v) {
                  var g = u._bin;
                  v.width = g.readUint(h, p), p += 4, v.height = g.readUint(h, p), p += 4, v.depth = h[p], p++, v.ctype = h[p], p++, v.compress = h[p], p++, v.filter = h[p], p++, v.interlace = h[p], p++;
                }, u._bin = {
                  nextZero: function(h, p) {
                    for (; h[p] != 0; )
                      p++;
                    return p;
                  },
                  readUshort: function(h, p) {
                    return h[p] << 8 | h[p + 1];
                  },
                  writeUshort: function(h, p, v) {
                    h[p] = v >> 8 & 255, h[p + 1] = v & 255;
                  },
                  readUint: function(h, p) {
                    return h[p] * 16777216 + (h[p + 1] << 16 | h[p + 2] << 8 | h[p + 3]);
                  },
                  writeUint: function(h, p, v) {
                    h[p] = v >> 24 & 255, h[p + 1] = v >> 16 & 255, h[p + 2] = v >> 8 & 255, h[p + 3] = v & 255;
                  },
                  readASCII: function(h, p, v) {
                    for (var g = "", w = 0; w < v; w++)
                      g += String.fromCharCode(h[p + w]);
                    return g;
                  },
                  writeASCII: function(h, p, v) {
                    for (var g = 0; g < v.length; g++)
                      h[p + g] = v.charCodeAt(g);
                  },
                  readBytes: function(h, p, v) {
                    for (var g = [], w = 0; w < v; w++)
                      g.push(h[p + w]);
                    return g;
                  },
                  pad: function(h) {
                    return h.length < 2 ? "0" + h : h;
                  },
                  readUTF8: function(h, p, v) {
                    for (var g = "", w, E = 0; E < v; E++)
                      g += "%" + u._bin.pad(h[p + E].toString(16));
                    try {
                      w = decodeURIComponent(g);
                    } catch {
                      return u._bin.readASCII(h, p, v);
                    }
                    return w;
                  }
                }, u._copyTile = function(h, p, v, g, w, E, T, R, _) {
                  for (var b = Math.min(p, w), M = Math.min(v, E), A = 0, $ = 0, S = 0; S < M; S++)
                    for (var C = 0; C < b; C++)
                      if (T >= 0 && R >= 0 ? (A = S * p + C << 2, $ = (R + S) * w + T + C << 2) : (A = (-R + S) * p - T + C << 2, $ = S * w + C << 2), _ == 0)
                        g[$] = h[A], g[$ + 1] = h[A + 1], g[$ + 2] = h[A + 2], g[$ + 3] = h[A + 3];
                      else if (_ == 1) {
                        var D = h[A + 3] * 0.00392156862745098, O = h[A] * D, N = h[A + 1] * D, j = h[A + 2] * D, L = g[$ + 3] * (1 / 255), z = g[$] * L, G = g[$ + 1] * L, B = g[$ + 2] * L, F = 1 - D, H = D + L * F, W = H == 0 ? 0 : 1 / H;
                        g[$ + 3] = 255 * H, g[$ + 0] = (O + z * F) * W, g[$ + 1] = (N + G * F) * W, g[$ + 2] = (j + B * F) * W;
                      } else if (_ == 2) {
                        var D = h[A + 3], O = h[A], N = h[A + 1], j = h[A + 2], L = g[$ + 3], z = g[$], G = g[$ + 1], B = g[$ + 2];
                        D == L && O == z && N == G && j == B ? (g[$] = 0, g[$ + 1] = 0, g[$ + 2] = 0, g[$ + 3] = 0) : (g[$] = O, g[$ + 1] = N, g[$ + 2] = j, g[$ + 3] = D);
                      } else if (_ == 3) {
                        var D = h[A + 3], O = h[A], N = h[A + 1], j = h[A + 2], L = g[$ + 3], z = g[$], G = g[$ + 1], B = g[$ + 2];
                        if (D == L && O == z && N == G && j == B)
                          continue;
                        if (D < 220 && L > 20)
                          return !1;
                      }
                  return !0;
                }, u.encode = function(h, p, v, g, w, E) {
                  g == null && (g = 0), E == null && (E = !1);
                  for (var T = new Uint8Array(h[0].byteLength * h.length + 100), R = [137, 80, 78, 71, 13, 10, 26, 10], _ = 0; _ < 8; _++)
                    T[_] = R[_];
                  var b = 8, M = u._bin, A = u.crc.crc, $ = M.writeUint, S = M.writeUshort, C = M.writeASCII, D = u.encode.compressPNG(h, p, v, g, E);
                  $(T, b, 13), b += 4, C(T, b, "IHDR"), b += 4, $(T, b, p), b += 4, $(T, b, v), b += 4, T[b] = D.depth, b++, T[b] = D.ctype, b++, T[b] = 0, b++, T[b] = 0, b++, T[b] = 0, b++, $(T, b, A(T, b - 17, 17)), b += 4, $(T, b, 1), b += 4, C(T, b, "sRGB"), b += 4, T[b] = 1, b++, $(T, b, A(T, b - 5, 5)), b += 4;
                  var O = h.length > 1;
                  if (O && ($(T, b, 8), b += 4, C(T, b, "acTL"), b += 4, $(T, b, h.length), b += 4, $(T, b, 0), b += 4, $(T, b, A(T, b - 12, 12)), b += 4), D.ctype == 3) {
                    var N = D.plte.length;
                    $(T, b, N * 3), b += 4, C(T, b, "PLTE"), b += 4;
                    for (var _ = 0; _ < N; _++) {
                      var j = _ * 3, L = D.plte[_], z = L & 255, G = L >> 8 & 255, B = L >> 16 & 255;
                      T[b + j + 0] = z, T[b + j + 1] = G, T[b + j + 2] = B;
                    }
                    if (b += N * 3, $(T, b, A(T, b - N * 3 - 4, N * 3 + 4)), b += 4, D.gotAlpha) {
                      $(T, b, N), b += 4, C(T, b, "tRNS"), b += 4;
                      for (var _ = 0; _ < N; _++)
                        T[b + _] = D.plte[_] >> 24 & 255;
                      b += N, $(T, b, A(T, b - N - 4, N + 4)), b += 4;
                    }
                  }
                  for (var F = 0, H = 0; H < D.frames.length; H++) {
                    var W = D.frames[H];
                    O && ($(T, b, 26), b += 4, C(T, b, "fcTL"), b += 4, $(T, b, F++), b += 4, $(T, b, W.rect.width), b += 4, $(T, b, W.rect.height), b += 4, $(T, b, W.rect.x), b += 4, $(T, b, W.rect.y), b += 4, S(T, b, w[H]), b += 2, S(T, b, 1e3), b += 2, T[b] = W.dispose, b++, T[b] = W.blend, b++, $(T, b, A(T, b - 30, 30)), b += 4);
                    var V = W.cimg, N = V.length;
                    $(T, b, N + (H == 0 ? 0 : 4)), b += 4;
                    var X = b;
                    C(T, b, H == 0 ? "IDAT" : "fdAT"), b += 4, H != 0 && ($(T, b, F++), b += 4);
                    for (var _ = 0; _ < N; _++)
                      T[b + _] = V[_];
                    b += N, $(T, b, A(T, X, b - X)), b += 4;
                  }
                  return $(T, b, 0), b += 4, C(T, b, "IEND"), b += 4, $(T, b, A(T, b - 4, 4)), b += 4, T.buffer.slice(0, b);
                }, u.encode.compressPNG = function(h, p, v, g, w) {
                  for (var E = u.encode.compress(h, p, v, g, !1, w), T = 0; T < h.length; T++) {
                    var R = E.frames[T];
                    R.rect.width;
                    var _ = R.rect.height, b = R.bpl, M = R.bpp, A = new Uint8Array(_ * b + _);
                    R.cimg = u.encode._filterZero(R.img, _, M, b, A);
                  }
                  return E;
                }, u.encode.compress = function(h, p, v, g, w, E) {
                  E == null && (E = !1);
                  for (var T = 6, R = 8, _ = 4, b = 255, M = 0; M < h.length; M++)
                    for (var A = new Uint8Array(h[M]), $ = A.length, S = 0; S < $; S += 4)
                      b &= A[S + 3];
                  var C = b != 255, D = {}, O = [];
                  if (h.length != 0 && (D[0] = 0, O.push(0), g != 0 && g--), g != 0) {
                    var N = u.quantize(h, g, w);
                    h = N.bufs;
                    for (var S = 0; S < N.plte.length; S++) {
                      var j = N.plte[S].est.rgba;
                      D[j] == null && (D[j] = O.length, O.push(j));
                    }
                  } else
                    for (var M = 0; M < h.length; M++)
                      for (var L = new Uint32Array(h[M]), $ = L.length, S = 0; S < $; S++) {
                        var j = L[S];
                        if ((S < p || j != L[S - 1] && j != L[S - p]) && D[j] == null && (D[j] = O.length, O.push(j), O.length >= 300))
                          break;
                      }
                  var z = C ? w : !1, G = O.length;
                  G <= 256 && E == !1 && (G <= 2 ? R = 1 : G <= 4 ? R = 2 : G <= 16 ? R = 4 : R = 8, w && (R = 8), C = !0);
                  for (var B = [], M = 0; M < h.length; M++) {
                    var F = new Uint8Array(h[M]), H = new Uint32Array(F.buffer), W = 0, V = 0, X = p, Z = v, Q = 0;
                    if (M != 0 && !z) {
                      for (var q = w || M == 1 || B[B.length - 2].dispose == 2 ? 1 : 2, J = 0, ie = 1e9, ne = 0; ne < q; ne++) {
                        for (var Ae = new Uint8Array(h[M - 1 - ne]), ge = new Uint32Array(h[M - 1 - ne]), ye = p, xe = v, we = -1, de = -1, Te = 0; Te < v; Te++)
                          for (var Ce = 0; Ce < p; Ce++) {
                            var S = Te * p + Ce;
                            H[S] != ge[S] && (Ce < ye && (ye = Ce), Ce > we && (we = Ce), Te < xe && (xe = Te), Te > de && (de = Te));
                          }
                        var ee = we == -1 ? 1 : (we - ye + 1) * (de - xe + 1);
                        ee < ie && (ie = ee, J = ne, we == -1 ? (W = V = 0, X = Z = 1) : (W = ye, V = xe, X = we - ye + 1, Z = de - xe + 1));
                      }
                      var Ae = new Uint8Array(h[M - 1 - J]);
                      J == 1 && (B[B.length - 1].dispose = 2);
                      var be = new Uint8Array(X * Z * 4);
                      new Uint32Array(be.buffer), u._copyTile(Ae, p, v, be, X, Z, -W, -V, 0), u._copyTile(F, p, v, be, X, Z, -W, -V, 3) ? (u._copyTile(F, p, v, be, X, Z, -W, -V, 2), Q = 1) : (u._copyTile(F, p, v, be, X, Z, -W, -V, 0), Q = 0), F = be, H = new Uint32Array(F.buffer);
                    }
                    var Fe = 4 * X;
                    if (G <= 256 && E == !1) {
                      Fe = Math.ceil(R * X / 8);
                      for (var be = new Uint8Array(Fe * Z), Te = 0; Te < Z; Te++) {
                        var S = Te * Fe, et = Te * X;
                        if (R == 8)
                          for (var Ce = 0; Ce < X; Ce++)
                            be[S + Ce] = D[H[et + Ce]];
                        else if (R == 4)
                          for (var Ce = 0; Ce < X; Ce++)
                            be[S + (Ce >> 1)] |= D[H[et + Ce]] << 4 - (Ce & 1) * 4;
                        else if (R == 2)
                          for (var Ce = 0; Ce < X; Ce++)
                            be[S + (Ce >> 2)] |= D[H[et + Ce]] << 6 - (Ce & 3) * 2;
                        else if (R == 1)
                          for (var Ce = 0; Ce < X; Ce++)
                            be[S + (Ce >> 3)] |= D[H[et + Ce]] << 7 - (Ce & 7) * 1;
                      }
                      F = be, T = 3, _ = 1;
                    } else if (C == !1 && h.length == 1) {
                      for (var be = new Uint8Array(X * Z * 3), Ye = X * Z, S = 0; S < Ye; S++) {
                        var De = S * 3, Ue = S * 4;
                        be[De] = F[Ue], be[De + 1] = F[Ue + 1], be[De + 2] = F[Ue + 2];
                      }
                      F = be, T = 2, _ = 3, Fe = 3 * X;
                    }
                    B.push({ rect: { x: W, y: V, width: X, height: Z }, img: F, bpl: Fe, bpp: _, blend: Q, dispose: z ? 1 : 0 });
                  }
                  return { ctype: T, depth: R, plte: O, gotAlpha: C, frames: B };
                }, u.encode._filterZero = function(h, p, v, g, w) {
                  for (var E = [], T = 0; T < 5; T++)
                    if (!(p * g > 5e5 && (T == 2 || T == 3 || T == 4))) {
                      for (var R = 0; R < p; R++)
                        u.encode._filterLine(w, h, R, g, v, T);
                      if (E.push(f.deflate(w)), v == 1)
                        break;
                    }
                  for (var _, b = 1e9, M = 0; M < E.length; M++)
                    E[M].length < b && (_ = M, b = E[M].length);
                  return E[_];
                }, u.encode._filterLine = function(h, p, v, g, w, E) {
                  var T = v * g, R = T + v, _ = u.decode._paeth;
                  if (h[R] = E, R++, E == 0)
                    for (var b = 0; b < g; b++)
                      h[R + b] = p[T + b];
                  else if (E == 1) {
                    for (var b = 0; b < w; b++)
                      h[R + b] = p[T + b];
                    for (var b = w; b < g; b++)
                      h[R + b] = p[T + b] - p[T + b - w] + 256 & 255;
                  } else if (v == 0) {
                    for (var b = 0; b < w; b++)
                      h[R + b] = p[T + b];
                    if (E == 2)
                      for (var b = w; b < g; b++)
                        h[R + b] = p[T + b];
                    if (E == 3)
                      for (var b = w; b < g; b++)
                        h[R + b] = p[T + b] - (p[T + b - w] >> 1) + 256 & 255;
                    if (E == 4)
                      for (var b = w; b < g; b++)
                        h[R + b] = p[T + b] - _(p[T + b - w], 0, 0) + 256 & 255;
                  } else {
                    if (E == 2)
                      for (var b = 0; b < g; b++)
                        h[R + b] = p[T + b] + 256 - p[T + b - g] & 255;
                    if (E == 3) {
                      for (var b = 0; b < w; b++)
                        h[R + b] = p[T + b] + 256 - (p[T + b - g] >> 1) & 255;
                      for (var b = w; b < g; b++)
                        h[R + b] = p[T + b] + 256 - (p[T + b - g] + p[T + b - w] >> 1) & 255;
                    }
                    if (E == 4) {
                      for (var b = 0; b < w; b++)
                        h[R + b] = p[T + b] + 256 - _(0, p[T + b - g], 0) & 255;
                      for (var b = w; b < g; b++)
                        h[R + b] = p[T + b] + 256 - _(p[T + b - w], p[T + b - g], p[T + b - w - g]) & 255;
                    }
                  }
                }, u.crc = {
                  table: function() {
                    for (var h = new Uint32Array(256), p = 0; p < 256; p++) {
                      for (var v = p, g = 0; g < 8; g++)
                        v & 1 ? v = 3988292384 ^ v >>> 1 : v = v >>> 1;
                      h[p] = v;
                    }
                    return h;
                  }(),
                  update: function(h, p, v, g) {
                    for (var w = 0; w < g; w++)
                      h = u.crc.table[(h ^ p[v + w]) & 255] ^ h >>> 8;
                    return h;
                  },
                  crc: function(h, p, v) {
                    return u.crc.update(4294967295, h, p, v) ^ 4294967295;
                  }
                }, u.quantize = function(h, p, v) {
                  for (var g = [], w = 0, E = 0; E < h.length; E++)
                    g.push(u.encode.alphaMul(new Uint8Array(h[E]), v)), w += h[E].byteLength;
                  for (var T = new Uint8Array(w), R = new Uint32Array(T.buffer), _ = 0, E = 0; E < g.length; E++) {
                    for (var b = g[E], M = b.length, A = 0; A < M; A++)
                      T[_ + A] = b[A];
                    _ += M;
                  }
                  var $ = { i0: 0, i1: T.length, bst: null, est: null, tdst: 0, left: null, right: null };
                  $.bst = u.quantize.stats(T, $.i0, $.i1), $.est = u.quantize.estats($.bst);
                  for (var S = [$]; S.length < p; ) {
                    for (var C = 0, D = 0, E = 0; E < S.length; E++)
                      S[E].est.L > C && (C = S[E].est.L, D = E);
                    if (C < 1e-3)
                      break;
                    var O = S[D], N = u.quantize.splitPixels(T, R, O.i0, O.i1, O.est.e, O.est.eMq255), j = { i0: O.i0, i1: N, bst: null, est: null, tdst: 0, left: null, right: null };
                    j.bst = u.quantize.stats(T, j.i0, j.i1), j.est = u.quantize.estats(j.bst);
                    var L = { i0: N, i1: O.i1, bst: null, est: null, tdst: 0, left: null, right: null };
                    L.bst = { R: [], m: [], N: O.bst.N - j.bst.N };
                    for (var E = 0; E < 16; E++)
                      L.bst.R[E] = O.bst.R[E] - j.bst.R[E];
                    for (var E = 0; E < 4; E++)
                      L.bst.m[E] = O.bst.m[E] - j.bst.m[E];
                    L.est = u.quantize.estats(L.bst), O.left = j, O.right = L, S[D] = j, S.push(L);
                  }
                  S.sort(function(q, J) {
                    return J.bst.N - q.bst.N;
                  });
                  for (var z = 0; z < g.length; z++) {
                    for (var G = u.quantize.planeDst, B = new Uint8Array(g[z].buffer), F = new Uint32Array(g[z].buffer), H = B.length, E = 0; E < H; E += 4) {
                      for (var W = B[E] * 0.00392156862745098, V = B[E + 1] * 0.00392156862745098, X = B[E + 2] * 0.00392156862745098, Z = B[E + 3] * 0.00392156862745098, Q = $; Q.left; )
                        Q = G(Q.est, W, V, X, Z) <= 0 ? Q.left : Q.right;
                      F[E >> 2] = Q.est.rgba;
                    }
                    g[z] = F.buffer;
                  }
                  return { bufs: g, plte: S };
                }, u.quantize.getNearest = function(h, p, v, g, w) {
                  if (h.left == null)
                    return h.tdst = u.quantize.dist(h.est.q, p, v, g, w), h;
                  var E = u.quantize.planeDst(h.est, p, v, g, w), T = h.left, R = h.right;
                  E > 0 && (T = h.right, R = h.left);
                  var _ = u.quantize.getNearest(T, p, v, g, w);
                  if (_.tdst <= E * E)
                    return _;
                  var b = u.quantize.getNearest(R, p, v, g, w);
                  return b.tdst < _.tdst ? b : _;
                }, u.quantize.planeDst = function(h, p, v, g, w) {
                  var E = h.e;
                  return E[0] * p + E[1] * v + E[2] * g + E[3] * w - h.eMq;
                }, u.quantize.dist = function(h, p, v, g, w) {
                  var E = p - h[0], T = v - h[1], R = g - h[2], _ = w - h[3];
                  return E * E + T * T + R * R + _ * _;
                }, u.quantize.splitPixels = function(h, p, v, g, w, E) {
                  var T = u.quantize.vecDot;
                  for (g -= 4; v < g; ) {
                    for (; T(h, v, w) <= E; )
                      v += 4;
                    for (; T(h, g, w) > E; )
                      g -= 4;
                    if (v >= g)
                      break;
                    var R = p[v >> 2];
                    p[v >> 2] = p[g >> 2], p[g >> 2] = R, v += 4, g -= 4;
                  }
                  for (; T(h, v, w) > E; )
                    v -= 4;
                  return v + 4;
                }, u.quantize.vecDot = function(h, p, v) {
                  return h[p] * v[0] + h[p + 1] * v[1] + h[p + 2] * v[2] + h[p + 3] * v[3];
                }, u.quantize.stats = function(h, p, v) {
                  for (var g = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], w = [0, 0, 0, 0], E = v - p >> 2, T = p; T < v; T += 4) {
                    var R = h[T] * 0.00392156862745098, _ = h[T + 1] * (1 / 255), b = h[T + 2] * (1 / 255), M = h[T + 3] * (1 / 255);
                    w[0] += R, w[1] += _, w[2] += b, w[3] += M, g[0] += R * R, g[1] += R * _, g[2] += R * b, g[3] += R * M, g[5] += _ * _, g[6] += _ * b, g[7] += _ * M, g[10] += b * b, g[11] += b * M, g[15] += M * M;
                  }
                  return g[4] = g[1], g[8] = g[2], g[12] = g[3], g[9] = g[6], g[13] = g[7], g[14] = g[11], { R: g, m: w, N: E };
                }, u.quantize.estats = function(h) {
                  var p = h.R, v = h.m, g = h.N, w = v[0], E = v[1], T = v[2], R = v[3], _ = g == 0 ? 0 : 1 / g, b = [
                    p[0] - w * w * _,
                    p[1] - w * E * _,
                    p[2] - w * T * _,
                    p[3] - w * R * _,
                    p[4] - E * w * _,
                    p[5] - E * E * _,
                    p[6] - E * T * _,
                    p[7] - E * R * _,
                    p[8] - T * w * _,
                    p[9] - T * E * _,
                    p[10] - T * T * _,
                    p[11] - T * R * _,
                    p[12] - R * w * _,
                    p[13] - R * E * _,
                    p[14] - R * T * _,
                    p[15] - R * R * _
                  ], M = b, A = u.M4, $ = [0.5, 0.5, 0.5, 0.5], S = 0, C = 0;
                  if (g != 0)
                    for (var D = 0; D < 10 && ($ = A.multVec(M, $), C = Math.sqrt(A.dot($, $)), $ = A.sml(1 / C, $), !(Math.abs(C - S) < 1e-9)); D++)
                      S = C;
                  var O = [w * _, E * _, T * _, R * _], N = A.dot(A.sml(255, O), $), j = O[3] < 1e-3 ? 0 : 1 / O[3];
                  return {
                    Cov: b,
                    q: O,
                    e: $,
                    L: S,
                    eMq255: N,
                    eMq: A.dot($, O),
                    rgba: (Math.round(255 * O[3]) << 24 | Math.round(255 * O[2] * j) << 16 | Math.round(255 * O[1] * j) << 8 | Math.round(255 * O[0] * j) << 0) >>> 0
                  };
                }, u.M4 = {
                  multVec: function(h, p) {
                    return [
                      h[0] * p[0] + h[1] * p[1] + h[2] * p[2] + h[3] * p[3],
                      h[4] * p[0] + h[5] * p[1] + h[6] * p[2] + h[7] * p[3],
                      h[8] * p[0] + h[9] * p[1] + h[10] * p[2] + h[11] * p[3],
                      h[12] * p[0] + h[13] * p[1] + h[14] * p[2] + h[15] * p[3]
                    ];
                  },
                  dot: function(h, p) {
                    return h[0] * p[0] + h[1] * p[1] + h[2] * p[2] + h[3] * p[3];
                  },
                  sml: function(h, p) {
                    return [h * p[0], h * p[1], h * p[2], h * p[3]];
                  }
                }, u.encode.alphaMul = function(h, p) {
                  for (var v = new Uint8Array(h.length), g = h.length >> 2, w = 0; w < g; w++) {
                    var E = w << 2, T = h[E + 3];
                    p && (T = T < 128 ? 0 : 255);
                    var R = T * (1 / 255);
                    v[E + 0] = h[E + 0] * R, v[E + 1] = h[E + 1] * R, v[E + 2] = h[E + 2] * R, v[E + 3] = T;
                  }
                  return v;
                };
              }(o, l);
            })();
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/index.js": (
          /*!*********************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/index.js ***!
            \*********************************************************/
          /***/
          (t, e, n) => {
            var o = n(
              /*! ./lib/utils/common */
              "./node_modules/upng-js/node_modules/pako/lib/utils/common.js"
            ).assign, l = n(
              /*! ./lib/deflate */
              "./node_modules/upng-js/node_modules/pako/lib/deflate.js"
            ), u = n(
              /*! ./lib/inflate */
              "./node_modules/upng-js/node_modules/pako/lib/inflate.js"
            ), f = n(
              /*! ./lib/zlib/constants */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/constants.js"
            ), h = {};
            o(h, l, u, f), t.exports = h;
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/lib/deflate.js": (
          /*!***************************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/lib/deflate.js ***!
            \***************************************************************/
          /***/
          (t, e, n) => {
            var o = n(
              /*! ./zlib/deflate */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/deflate.js"
            ), l = n(
              /*! ./utils/common */
              "./node_modules/upng-js/node_modules/pako/lib/utils/common.js"
            ), u = n(
              /*! ./utils/strings */
              "./node_modules/upng-js/node_modules/pako/lib/utils/strings.js"
            ), f = n(
              /*! ./zlib/messages */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/messages.js"
            ), h = n(
              /*! ./zlib/zstream */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/zstream.js"
            ), p = Object.prototype.toString, v = 0, g = 4, w = 0, E = 1, T = 2, R = -1, _ = 0, b = 8;
            function M(C) {
              if (!(this instanceof M))
                return new M(C);
              this.options = l.assign({
                level: R,
                method: b,
                chunkSize: 16384,
                windowBits: 15,
                memLevel: 8,
                strategy: _,
                to: ""
              }, C || {});
              var D = this.options;
              D.raw && D.windowBits > 0 ? D.windowBits = -D.windowBits : D.gzip && D.windowBits > 0 && D.windowBits < 16 && (D.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new h(), this.strm.avail_out = 0;
              var O = o.deflateInit2(
                this.strm,
                D.level,
                D.method,
                D.windowBits,
                D.memLevel,
                D.strategy
              );
              if (O !== w)
                throw new Error(f[O]);
              if (D.header && o.deflateSetHeader(this.strm, D.header), D.dictionary) {
                var N;
                if (typeof D.dictionary == "string" ? N = u.string2buf(D.dictionary) : p.call(D.dictionary) === "[object ArrayBuffer]" ? N = new Uint8Array(D.dictionary) : N = D.dictionary, O = o.deflateSetDictionary(this.strm, N), O !== w)
                  throw new Error(f[O]);
                this._dict_set = !0;
              }
            }
            M.prototype.push = function(C, D) {
              var O = this.strm, N = this.options.chunkSize, j, L;
              if (this.ended)
                return !1;
              L = D === ~~D ? D : D === !0 ? g : v, typeof C == "string" ? O.input = u.string2buf(C) : p.call(C) === "[object ArrayBuffer]" ? O.input = new Uint8Array(C) : O.input = C, O.next_in = 0, O.avail_in = O.input.length;
              do {
                if (O.avail_out === 0 && (O.output = new l.Buf8(N), O.next_out = 0, O.avail_out = N), j = o.deflate(O, L), j !== E && j !== w)
                  return this.onEnd(j), this.ended = !0, !1;
                (O.avail_out === 0 || O.avail_in === 0 && (L === g || L === T)) && (this.options.to === "string" ? this.onData(u.buf2binstring(l.shrinkBuf(O.output, O.next_out))) : this.onData(l.shrinkBuf(O.output, O.next_out)));
              } while ((O.avail_in > 0 || O.avail_out === 0) && j !== E);
              return L === g ? (j = o.deflateEnd(this.strm), this.onEnd(j), this.ended = !0, j === w) : (L === T && (this.onEnd(w), O.avail_out = 0), !0);
            }, M.prototype.onData = function(C) {
              this.chunks.push(C);
            }, M.prototype.onEnd = function(C) {
              C === w && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = l.flattenChunks(this.chunks)), this.chunks = [], this.err = C, this.msg = this.strm.msg;
            };
            function A(C, D) {
              var O = new M(D);
              if (O.push(C, !0), O.err)
                throw O.msg || f[O.err];
              return O.result;
            }
            function $(C, D) {
              return D = D || {}, D.raw = !0, A(C, D);
            }
            function S(C, D) {
              return D = D || {}, D.gzip = !0, A(C, D);
            }
            e.Deflate = M, e.deflate = A, e.deflateRaw = $, e.gzip = S;
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/lib/inflate.js": (
          /*!***************************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/lib/inflate.js ***!
            \***************************************************************/
          /***/
          (t, e, n) => {
            var o = n(
              /*! ./zlib/inflate */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/inflate.js"
            ), l = n(
              /*! ./utils/common */
              "./node_modules/upng-js/node_modules/pako/lib/utils/common.js"
            ), u = n(
              /*! ./utils/strings */
              "./node_modules/upng-js/node_modules/pako/lib/utils/strings.js"
            ), f = n(
              /*! ./zlib/constants */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/constants.js"
            ), h = n(
              /*! ./zlib/messages */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/messages.js"
            ), p = n(
              /*! ./zlib/zstream */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/zstream.js"
            ), v = n(
              /*! ./zlib/gzheader */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/gzheader.js"
            ), g = Object.prototype.toString;
            function w(R) {
              if (!(this instanceof w))
                return new w(R);
              this.options = l.assign({
                chunkSize: 16384,
                windowBits: 0,
                to: ""
              }, R || {});
              var _ = this.options;
              _.raw && _.windowBits >= 0 && _.windowBits < 16 && (_.windowBits = -_.windowBits, _.windowBits === 0 && (_.windowBits = -15)), _.windowBits >= 0 && _.windowBits < 16 && !(R && R.windowBits) && (_.windowBits += 32), _.windowBits > 15 && _.windowBits < 48 && (_.windowBits & 15 || (_.windowBits |= 15)), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new p(), this.strm.avail_out = 0;
              var b = o.inflateInit2(
                this.strm,
                _.windowBits
              );
              if (b !== f.Z_OK)
                throw new Error(h[b]);
              if (this.header = new v(), o.inflateGetHeader(this.strm, this.header), _.dictionary && (typeof _.dictionary == "string" ? _.dictionary = u.string2buf(_.dictionary) : g.call(_.dictionary) === "[object ArrayBuffer]" && (_.dictionary = new Uint8Array(_.dictionary)), _.raw && (b = o.inflateSetDictionary(this.strm, _.dictionary), b !== f.Z_OK)))
                throw new Error(h[b]);
            }
            w.prototype.push = function(R, _) {
              var b = this.strm, M = this.options.chunkSize, A = this.options.dictionary, $, S, C, D, O, N = !1;
              if (this.ended)
                return !1;
              S = _ === ~~_ ? _ : _ === !0 ? f.Z_FINISH : f.Z_NO_FLUSH, typeof R == "string" ? b.input = u.binstring2buf(R) : g.call(R) === "[object ArrayBuffer]" ? b.input = new Uint8Array(R) : b.input = R, b.next_in = 0, b.avail_in = b.input.length;
              do {
                if (b.avail_out === 0 && (b.output = new l.Buf8(M), b.next_out = 0, b.avail_out = M), $ = o.inflate(b, f.Z_NO_FLUSH), $ === f.Z_NEED_DICT && A && ($ = o.inflateSetDictionary(this.strm, A)), $ === f.Z_BUF_ERROR && N === !0 && ($ = f.Z_OK, N = !1), $ !== f.Z_STREAM_END && $ !== f.Z_OK)
                  return this.onEnd($), this.ended = !0, !1;
                b.next_out && (b.avail_out === 0 || $ === f.Z_STREAM_END || b.avail_in === 0 && (S === f.Z_FINISH || S === f.Z_SYNC_FLUSH)) && (this.options.to === "string" ? (C = u.utf8border(b.output, b.next_out), D = b.next_out - C, O = u.buf2string(b.output, C), b.next_out = D, b.avail_out = M - D, D && l.arraySet(b.output, b.output, C, D, 0), this.onData(O)) : this.onData(l.shrinkBuf(b.output, b.next_out))), b.avail_in === 0 && b.avail_out === 0 && (N = !0);
              } while ((b.avail_in > 0 || b.avail_out === 0) && $ !== f.Z_STREAM_END);
              return $ === f.Z_STREAM_END && (S = f.Z_FINISH), S === f.Z_FINISH ? ($ = o.inflateEnd(this.strm), this.onEnd($), this.ended = !0, $ === f.Z_OK) : (S === f.Z_SYNC_FLUSH && (this.onEnd(f.Z_OK), b.avail_out = 0), !0);
            }, w.prototype.onData = function(R) {
              this.chunks.push(R);
            }, w.prototype.onEnd = function(R) {
              R === f.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = l.flattenChunks(this.chunks)), this.chunks = [], this.err = R, this.msg = this.strm.msg;
            };
            function E(R, _) {
              var b = new w(_);
              if (b.push(R, !0), b.err)
                throw b.msg || h[b.err];
              return b.result;
            }
            function T(R, _) {
              return _ = _ || {}, _.raw = !0, E(R, _);
            }
            e.Inflate = w, e.inflate = E, e.inflateRaw = T, e.ungzip = E;
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/lib/utils/common.js": (
          /*!********************************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/lib/utils/common.js ***!
            \********************************************************************/
          /***/
          (t, e) => {
            var n = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
            function o(f, h) {
              return Object.prototype.hasOwnProperty.call(f, h);
            }
            e.assign = function(f) {
              for (var h = Array.prototype.slice.call(arguments, 1); h.length; ) {
                var p = h.shift();
                if (p) {
                  if (typeof p != "object")
                    throw new TypeError(p + "must be non-object");
                  for (var v in p)
                    o(p, v) && (f[v] = p[v]);
                }
              }
              return f;
            }, e.shrinkBuf = function(f, h) {
              return f.length === h ? f : f.subarray ? f.subarray(0, h) : (f.length = h, f);
            };
            var l = {
              arraySet: function(f, h, p, v, g) {
                if (h.subarray && f.subarray) {
                  f.set(h.subarray(p, p + v), g);
                  return;
                }
                for (var w = 0; w < v; w++)
                  f[g + w] = h[p + w];
              },
              // Join array of chunks to single array.
              flattenChunks: function(f) {
                var h, p, v, g, w, E;
                for (v = 0, h = 0, p = f.length; h < p; h++)
                  v += f[h].length;
                for (E = new Uint8Array(v), g = 0, h = 0, p = f.length; h < p; h++)
                  w = f[h], E.set(w, g), g += w.length;
                return E;
              }
            }, u = {
              arraySet: function(f, h, p, v, g) {
                for (var w = 0; w < v; w++)
                  f[g + w] = h[p + w];
              },
              // Join array of chunks to single array.
              flattenChunks: function(f) {
                return [].concat.apply([], f);
              }
            };
            e.setTyped = function(f) {
              f ? (e.Buf8 = Uint8Array, e.Buf16 = Uint16Array, e.Buf32 = Int32Array, e.assign(e, l)) : (e.Buf8 = Array, e.Buf16 = Array, e.Buf32 = Array, e.assign(e, u));
            }, e.setTyped(n);
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/lib/utils/strings.js": (
          /*!*********************************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/lib/utils/strings.js ***!
            \*********************************************************************/
          /***/
          (t, e, n) => {
            var o = n(
              /*! ./common */
              "./node_modules/upng-js/node_modules/pako/lib/utils/common.js"
            ), l = !0, u = !0;
            try {
              String.fromCharCode.apply(null, [0]);
            } catch {
              l = !1;
            }
            try {
              String.fromCharCode.apply(null, new Uint8Array(1));
            } catch {
              u = !1;
            }
            for (var f = new o.Buf8(256), h = 0; h < 256; h++)
              f[h] = h >= 252 ? 6 : h >= 248 ? 5 : h >= 240 ? 4 : h >= 224 ? 3 : h >= 192 ? 2 : 1;
            f[254] = f[254] = 1, e.string2buf = function(v) {
              var g, w, E, T, R, _ = v.length, b = 0;
              for (T = 0; T < _; T++)
                w = v.charCodeAt(T), (w & 64512) === 55296 && T + 1 < _ && (E = v.charCodeAt(T + 1), (E & 64512) === 56320 && (w = 65536 + (w - 55296 << 10) + (E - 56320), T++)), b += w < 128 ? 1 : w < 2048 ? 2 : w < 65536 ? 3 : 4;
              for (g = new o.Buf8(b), R = 0, T = 0; R < b; T++)
                w = v.charCodeAt(T), (w & 64512) === 55296 && T + 1 < _ && (E = v.charCodeAt(T + 1), (E & 64512) === 56320 && (w = 65536 + (w - 55296 << 10) + (E - 56320), T++)), w < 128 ? g[R++] = w : w < 2048 ? (g[R++] = 192 | w >>> 6, g[R++] = 128 | w & 63) : w < 65536 ? (g[R++] = 224 | w >>> 12, g[R++] = 128 | w >>> 6 & 63, g[R++] = 128 | w & 63) : (g[R++] = 240 | w >>> 18, g[R++] = 128 | w >>> 12 & 63, g[R++] = 128 | w >>> 6 & 63, g[R++] = 128 | w & 63);
              return g;
            };
            function p(v, g) {
              if (g < 65534 && (v.subarray && u || !v.subarray && l))
                return String.fromCharCode.apply(null, o.shrinkBuf(v, g));
              for (var w = "", E = 0; E < g; E++)
                w += String.fromCharCode(v[E]);
              return w;
            }
            e.buf2binstring = function(v) {
              return p(v, v.length);
            }, e.binstring2buf = function(v) {
              for (var g = new o.Buf8(v.length), w = 0, E = g.length; w < E; w++)
                g[w] = v.charCodeAt(w);
              return g;
            }, e.buf2string = function(v, g) {
              var w, E, T, R, _ = g || v.length, b = new Array(_ * 2);
              for (E = 0, w = 0; w < _; ) {
                if (T = v[w++], T < 128) {
                  b[E++] = T;
                  continue;
                }
                if (R = f[T], R > 4) {
                  b[E++] = 65533, w += R - 1;
                  continue;
                }
                for (T &= R === 2 ? 31 : R === 3 ? 15 : 7; R > 1 && w < _; )
                  T = T << 6 | v[w++] & 63, R--;
                if (R > 1) {
                  b[E++] = 65533;
                  continue;
                }
                T < 65536 ? b[E++] = T : (T -= 65536, b[E++] = 55296 | T >> 10 & 1023, b[E++] = 56320 | T & 1023);
              }
              return p(b, E);
            }, e.utf8border = function(v, g) {
              var w;
              for (g = g || v.length, g > v.length && (g = v.length), w = g - 1; w >= 0 && (v[w] & 192) === 128; )
                w--;
              return w < 0 || w === 0 ? g : w + f[v[w]] > g ? w : g;
            };
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/lib/zlib/adler32.js": (
          /*!********************************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/lib/zlib/adler32.js ***!
            \********************************************************************/
          /***/
          (t) => {
            function e(n, o, l, u) {
              for (var f = n & 65535 | 0, h = n >>> 16 & 65535 | 0, p = 0; l !== 0; ) {
                p = l > 2e3 ? 2e3 : l, l -= p;
                do
                  f = f + o[u++] | 0, h = h + f | 0;
                while (--p);
                f %= 65521, h %= 65521;
              }
              return f | h << 16 | 0;
            }
            t.exports = e;
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/lib/zlib/constants.js": (
          /*!**********************************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/lib/zlib/constants.js ***!
            \**********************************************************************/
          /***/
          (t) => {
            t.exports = {
              /* Allowed flush values; see deflate() and inflate() below for details */
              Z_NO_FLUSH: 0,
              Z_PARTIAL_FLUSH: 1,
              Z_SYNC_FLUSH: 2,
              Z_FULL_FLUSH: 3,
              Z_FINISH: 4,
              Z_BLOCK: 5,
              Z_TREES: 6,
              /* Return codes for the compression/decompression functions. Negative values
              * are errors, positive values are used for special but normal events.
              */
              Z_OK: 0,
              Z_STREAM_END: 1,
              Z_NEED_DICT: 2,
              Z_ERRNO: -1,
              Z_STREAM_ERROR: -2,
              Z_DATA_ERROR: -3,
              //Z_MEM_ERROR:     -4,
              Z_BUF_ERROR: -5,
              //Z_VERSION_ERROR: -6,
              /* compression levels */
              Z_NO_COMPRESSION: 0,
              Z_BEST_SPEED: 1,
              Z_BEST_COMPRESSION: 9,
              Z_DEFAULT_COMPRESSION: -1,
              Z_FILTERED: 1,
              Z_HUFFMAN_ONLY: 2,
              Z_RLE: 3,
              Z_FIXED: 4,
              Z_DEFAULT_STRATEGY: 0,
              /* Possible values of the data_type field (though see inflate()) */
              Z_BINARY: 0,
              Z_TEXT: 1,
              //Z_ASCII:                1, // = Z_TEXT (deprecated)
              Z_UNKNOWN: 2,
              /* The deflate compression method */
              Z_DEFLATED: 8
              //Z_NULL:                 null // Use -1 or null inline, depending on var type
            };
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/lib/zlib/crc32.js": (
          /*!******************************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/lib/zlib/crc32.js ***!
            \******************************************************************/
          /***/
          (t) => {
            function e() {
              for (var l, u = [], f = 0; f < 256; f++) {
                l = f;
                for (var h = 0; h < 8; h++)
                  l = l & 1 ? 3988292384 ^ l >>> 1 : l >>> 1;
                u[f] = l;
              }
              return u;
            }
            var n = e();
            function o(l, u, f, h) {
              var p = n, v = h + f;
              l ^= -1;
              for (var g = h; g < v; g++)
                l = l >>> 8 ^ p[(l ^ u[g]) & 255];
              return l ^ -1;
            }
            t.exports = o;
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/lib/zlib/deflate.js": (
          /*!********************************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/lib/zlib/deflate.js ***!
            \********************************************************************/
          /***/
          (t, e, n) => {
            var o = n(
              /*! ../utils/common */
              "./node_modules/upng-js/node_modules/pako/lib/utils/common.js"
            ), l = n(
              /*! ./trees */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/trees.js"
            ), u = n(
              /*! ./adler32 */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/adler32.js"
            ), f = n(
              /*! ./crc32 */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/crc32.js"
            ), h = n(
              /*! ./messages */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/messages.js"
            ), p = 0, v = 1, g = 3, w = 4, E = 5, T = 0, R = 1, _ = -2, b = -3, M = -5, A = -1, $ = 1, S = 2, C = 3, D = 4, O = 0, N = 2, j = 8, L = 9, z = 15, G = 8, B = 29, F = 256, H = F + 1 + B, W = 30, V = 19, X = 2 * H + 1, Z = 15, Q = 3, q = 258, J = q + Q + 1, ie = 32, ne = 42, ge = 69, ye = 73, xe = 91, we = 103, de = 113, Te = 666, Ce = 1, ee = 2, Ae = 3, be = 4, Fe = 3;
            function et(K, Ve) {
              return K.msg = h[Ve], Ve;
            }
            function Ye(K) {
              return (K << 1) - (K > 4 ? 9 : 0);
            }
            function De(K) {
              for (var Ve = K.length; --Ve >= 0; )
                K[Ve] = 0;
            }
            function Ue(K) {
              var Ve = K.state, Ne = Ve.pending;
              Ne > K.avail_out && (Ne = K.avail_out), Ne !== 0 && (o.arraySet(K.output, Ve.pending_buf, Ve.pending_out, Ne, K.next_out), K.next_out += Ne, Ve.pending_out += Ne, K.total_out += Ne, K.avail_out -= Ne, Ve.pending -= Ne, Ve.pending === 0 && (Ve.pending_out = 0));
            }
            function Qe(K, Ve) {
              l._tr_flush_block(K, K.block_start >= 0 ? K.block_start : -1, K.strstart - K.block_start, Ve), K.block_start = K.strstart, Ue(K.strm);
            }
            function ue(K, Ve) {
              K.pending_buf[K.pending++] = Ve;
            }
            function te(K, Ve) {
              K.pending_buf[K.pending++] = Ve >>> 8 & 255, K.pending_buf[K.pending++] = Ve & 255;
            }
            function Be(K, Ve, Ne, pe) {
              var Le = K.avail_in;
              return Le > pe && (Le = pe), Le === 0 ? 0 : (K.avail_in -= Le, o.arraySet(Ve, K.input, K.next_in, Le, Ne), K.state.wrap === 1 ? K.adler = u(K.adler, Ve, Le, Ne) : K.state.wrap === 2 && (K.adler = f(K.adler, Ve, Le, Ne)), K.next_in += Le, K.total_in += Le, Le);
            }
            function Je(K, Ve) {
              var Ne = K.max_chain_length, pe = K.strstart, Le, bt, yi = K.prev_length, _n = K.nice_match, Do = K.strstart > K.w_size - J ? K.strstart - (K.w_size - J) : 0, ms = K.window, Bp = K.w_mask, Sp = K.prev, Tp = K.strstart + q, Pp = ms[pe + yi - 1], Xe = ms[pe + yi];
              K.prev_length >= K.good_match && (Ne >>= 2), _n > K.lookahead && (_n = K.lookahead);
              do
                if (Le = Ve, !(ms[Le + yi] !== Xe || ms[Le + yi - 1] !== Pp || ms[Le] !== ms[pe] || ms[++Le] !== ms[pe + 1])) {
                  pe += 2, Le++;
                  do
                    ;
                  while (ms[++pe] === ms[++Le] && ms[++pe] === ms[++Le] && ms[++pe] === ms[++Le] && ms[++pe] === ms[++Le] && ms[++pe] === ms[++Le] && ms[++pe] === ms[++Le] && ms[++pe] === ms[++Le] && ms[++pe] === ms[++Le] && pe < Tp);
                  if (bt = q - (Tp - pe), pe = Tp - q, bt > yi) {
                    if (K.match_start = Ve, yi = bt, bt >= _n)
                      break;
                    Pp = ms[pe + yi - 1], Xe = ms[pe + yi];
                  }
                }
              while ((Ve = Sp[Ve & Bp]) > Do && --Ne !== 0);
              return yi <= K.lookahead ? yi : K.lookahead;
            }
            function ft(K) {
              var Ve = K.w_size, Ne, pe, Le, bt, yi;
              do {
                if (bt = K.window_size - K.lookahead - K.strstart, K.strstart >= Ve + (Ve - J)) {
                  o.arraySet(K.window, K.window, Ve, Ve, 0), K.match_start -= Ve, K.strstart -= Ve, K.block_start -= Ve, pe = K.hash_size, Ne = pe;
                  do
                    Le = K.head[--Ne], K.head[Ne] = Le >= Ve ? Le - Ve : 0;
                  while (--pe);
                  pe = Ve, Ne = pe;
                  do
                    Le = K.prev[--Ne], K.prev[Ne] = Le >= Ve ? Le - Ve : 0;
                  while (--pe);
                  bt += Ve;
                }
                if (K.strm.avail_in === 0)
                  break;
                if (pe = Be(K.strm, K.window, K.strstart + K.lookahead, bt), K.lookahead += pe, K.lookahead + K.insert >= Q)
                  for (yi = K.strstart - K.insert, K.ins_h = K.window[yi], K.ins_h = (K.ins_h << K.hash_shift ^ K.window[yi + 1]) & K.hash_mask; K.insert && (K.ins_h = (K.ins_h << K.hash_shift ^ K.window[yi + Q - 1]) & K.hash_mask, K.prev[yi & K.w_mask] = K.head[K.ins_h], K.head[K.ins_h] = yi, yi++, K.insert--, !(K.lookahead + K.insert < Q)); )
                    ;
              } while (K.lookahead < J && K.strm.avail_in !== 0);
            }
            function lt(K, Ve) {
              var Ne = 65535;
              for (Ne > K.pending_buf_size - 5 && (Ne = K.pending_buf_size - 5); ; ) {
                if (K.lookahead <= 1) {
                  if (ft(K), K.lookahead === 0 && Ve === p)
                    return Ce;
                  if (K.lookahead === 0)
                    break;
                }
                K.strstart += K.lookahead, K.lookahead = 0;
                var pe = K.block_start + Ne;
                if ((K.strstart === 0 || K.strstart >= pe) && (K.lookahead = K.strstart - pe, K.strstart = pe, Qe(K, !1), K.strm.avail_out === 0) || K.strstart - K.block_start >= K.w_size - J && (Qe(K, !1), K.strm.avail_out === 0))
                  return Ce;
              }
              return K.insert = 0, Ve === w ? (Qe(K, !0), K.strm.avail_out === 0 ? Ae : be) : (K.strstart > K.block_start && (Qe(K, !1), K.strm.avail_out), Ce);
            }
            function he(K, Ve) {
              for (var Ne, pe; ; ) {
                if (K.lookahead < J) {
                  if (ft(K), K.lookahead < J && Ve === p)
                    return Ce;
                  if (K.lookahead === 0)
                    break;
                }
                if (Ne = 0, K.lookahead >= Q && (K.ins_h = (K.ins_h << K.hash_shift ^ K.window[K.strstart + Q - 1]) & K.hash_mask, Ne = K.prev[K.strstart & K.w_mask] = K.head[K.ins_h], K.head[K.ins_h] = K.strstart), Ne !== 0 && K.strstart - Ne <= K.w_size - J && (K.match_length = Je(K, Ne)), K.match_length >= Q)
                  if (pe = l._tr_tally(K, K.strstart - K.match_start, K.match_length - Q), K.lookahead -= K.match_length, K.match_length <= K.max_lazy_match && K.lookahead >= Q) {
                    K.match_length--;
                    do
                      K.strstart++, K.ins_h = (K.ins_h << K.hash_shift ^ K.window[K.strstart + Q - 1]) & K.hash_mask, Ne = K.prev[K.strstart & K.w_mask] = K.head[K.ins_h], K.head[K.ins_h] = K.strstart;
                    while (--K.match_length !== 0);
                    K.strstart++;
                  } else
                    K.strstart += K.match_length, K.match_length = 0, K.ins_h = K.window[K.strstart], K.ins_h = (K.ins_h << K.hash_shift ^ K.window[K.strstart + 1]) & K.hash_mask;
                else
                  pe = l._tr_tally(K, 0, K.window[K.strstart]), K.lookahead--, K.strstart++;
                if (pe && (Qe(K, !1), K.strm.avail_out === 0))
                  return Ce;
              }
              return K.insert = K.strstart < Q - 1 ? K.strstart : Q - 1, Ve === w ? (Qe(K, !0), K.strm.avail_out === 0 ? Ae : be) : K.last_lit && (Qe(K, !1), K.strm.avail_out === 0) ? Ce : ee;
            }
            function ae(K, Ve) {
              for (var Ne, pe, Le; ; ) {
                if (K.lookahead < J) {
                  if (ft(K), K.lookahead < J && Ve === p)
                    return Ce;
                  if (K.lookahead === 0)
                    break;
                }
                if (Ne = 0, K.lookahead >= Q && (K.ins_h = (K.ins_h << K.hash_shift ^ K.window[K.strstart + Q - 1]) & K.hash_mask, Ne = K.prev[K.strstart & K.w_mask] = K.head[K.ins_h], K.head[K.ins_h] = K.strstart), K.prev_length = K.match_length, K.prev_match = K.match_start, K.match_length = Q - 1, Ne !== 0 && K.prev_length < K.max_lazy_match && K.strstart - Ne <= K.w_size - J && (K.match_length = Je(K, Ne), K.match_length <= 5 && (K.strategy === $ || K.match_length === Q && K.strstart - K.match_start > 4096) && (K.match_length = Q - 1)), K.prev_length >= Q && K.match_length <= K.prev_length) {
                  Le = K.strstart + K.lookahead - Q, pe = l._tr_tally(K, K.strstart - 1 - K.prev_match, K.prev_length - Q), K.lookahead -= K.prev_length - 1, K.prev_length -= 2;
                  do
                    ++K.strstart <= Le && (K.ins_h = (K.ins_h << K.hash_shift ^ K.window[K.strstart + Q - 1]) & K.hash_mask, Ne = K.prev[K.strstart & K.w_mask] = K.head[K.ins_h], K.head[K.ins_h] = K.strstart);
                  while (--K.prev_length !== 0);
                  if (K.match_available = 0, K.match_length = Q - 1, K.strstart++, pe && (Qe(K, !1), K.strm.avail_out === 0))
                    return Ce;
                } else if (K.match_available) {
                  if (pe = l._tr_tally(K, 0, K.window[K.strstart - 1]), pe && Qe(K, !1), K.strstart++, K.lookahead--, K.strm.avail_out === 0)
                    return Ce;
                } else
                  K.match_available = 1, K.strstart++, K.lookahead--;
              }
              return K.match_available && (pe = l._tr_tally(K, 0, K.window[K.strstart - 1]), K.match_available = 0), K.insert = K.strstart < Q - 1 ? K.strstart : Q - 1, Ve === w ? (Qe(K, !0), K.strm.avail_out === 0 ? Ae : be) : K.last_lit && (Qe(K, !1), K.strm.avail_out === 0) ? Ce : ee;
            }
            function se(K, Ve) {
              for (var Ne, pe, Le, bt, yi = K.window; ; ) {
                if (K.lookahead <= q) {
                  if (ft(K), K.lookahead <= q && Ve === p)
                    return Ce;
                  if (K.lookahead === 0)
                    break;
                }
                if (K.match_length = 0, K.lookahead >= Q && K.strstart > 0 && (Le = K.strstart - 1, pe = yi[Le], pe === yi[++Le] && pe === yi[++Le] && pe === yi[++Le])) {
                  bt = K.strstart + q;
                  do
                    ;
                  while (pe === yi[++Le] && pe === yi[++Le] && pe === yi[++Le] && pe === yi[++Le] && pe === yi[++Le] && pe === yi[++Le] && pe === yi[++Le] && pe === yi[++Le] && Le < bt);
                  K.match_length = q - (bt - Le), K.match_length > K.lookahead && (K.match_length = K.lookahead);
                }
                if (K.match_length >= Q ? (Ne = l._tr_tally(K, 1, K.match_length - Q), K.lookahead -= K.match_length, K.strstart += K.match_length, K.match_length = 0) : (Ne = l._tr_tally(K, 0, K.window[K.strstart]), K.lookahead--, K.strstart++), Ne && (Qe(K, !1), K.strm.avail_out === 0))
                  return Ce;
              }
              return K.insert = 0, Ve === w ? (Qe(K, !0), K.strm.avail_out === 0 ? Ae : be) : K.last_lit && (Qe(K, !1), K.strm.avail_out === 0) ? Ce : ee;
            }
            function Re(K, Ve) {
              for (var Ne; ; ) {
                if (K.lookahead === 0 && (ft(K), K.lookahead === 0)) {
                  if (Ve === p)
                    return Ce;
                  break;
                }
                if (K.match_length = 0, Ne = l._tr_tally(K, 0, K.window[K.strstart]), K.lookahead--, K.strstart++, Ne && (Qe(K, !1), K.strm.avail_out === 0))
                  return Ce;
              }
              return K.insert = 0, Ve === w ? (Qe(K, !0), K.strm.avail_out === 0 ? Ae : be) : K.last_lit && (Qe(K, !1), K.strm.avail_out === 0) ? Ce : ee;
            }
            function Oe(K, Ve, Ne, pe, Le) {
              this.good_length = K, this.max_lazy = Ve, this.nice_length = Ne, this.max_chain = pe, this.func = Le;
            }
            var We;
            We = [
              /*      good lazy nice chain */
              new Oe(0, 0, 0, 0, lt),
              /* 0 store only */
              new Oe(4, 4, 8, 4, he),
              /* 1 max speed, no lazy matches */
              new Oe(4, 5, 16, 8, he),
              /* 2 */
              new Oe(4, 6, 32, 32, he),
              /* 3 */
              new Oe(4, 4, 16, 16, ae),
              /* 4 lazy matches */
              new Oe(8, 16, 32, 32, ae),
              /* 5 */
              new Oe(8, 16, 128, 128, ae),
              /* 6 */
              new Oe(8, 32, 128, 256, ae),
              /* 7 */
              new Oe(32, 128, 258, 1024, ae),
              /* 8 */
              new Oe(32, 258, 258, 4096, ae)
              /* 9 max compression */
            ];
            function Ct(K) {
              K.window_size = 2 * K.w_size, De(K.head), K.max_lazy_match = We[K.level].max_lazy, K.good_match = We[K.level].good_length, K.nice_match = We[K.level].nice_length, K.max_chain_length = We[K.level].max_chain, K.strstart = 0, K.block_start = 0, K.lookahead = 0, K.insert = 0, K.match_length = K.prev_length = Q - 1, K.match_available = 0, K.ins_h = 0;
            }
            function le() {
              this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = j, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new o.Buf16(X * 2), this.dyn_dtree = new o.Buf16((2 * W + 1) * 2), this.bl_tree = new o.Buf16((2 * V + 1) * 2), De(this.dyn_ltree), De(this.dyn_dtree), De(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new o.Buf16(Z + 1), this.heap = new o.Buf16(2 * H + 1), De(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new o.Buf16(2 * H + 1), De(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
            }
            function ke(K) {
              var Ve;
              return !K || !K.state ? et(K, _) : (K.total_in = K.total_out = 0, K.data_type = N, Ve = K.state, Ve.pending = 0, Ve.pending_out = 0, Ve.wrap < 0 && (Ve.wrap = -Ve.wrap), Ve.status = Ve.wrap ? ne : de, K.adler = Ve.wrap === 2 ? 0 : 1, Ve.last_flush = p, l._tr_init(Ve), T);
            }
            function Ke(K) {
              var Ve = ke(K);
              return Ve === T && Ct(K.state), Ve;
            }
            function me(K, Ve) {
              return !K || !K.state || K.state.wrap !== 2 ? _ : (K.state.gzhead = Ve, T);
            }
            function Ee(K, Ve, Ne, pe, Le, bt) {
              if (!K)
                return _;
              var yi = 1;
              if (Ve === A && (Ve = 6), pe < 0 ? (yi = 0, pe = -pe) : pe > 15 && (yi = 2, pe -= 16), Le < 1 || Le > L || Ne !== j || pe < 8 || pe > 15 || Ve < 0 || Ve > 9 || bt < 0 || bt > D)
                return et(K, _);
              pe === 8 && (pe = 9);
              var _n = new le();
              return K.state = _n, _n.strm = K, _n.wrap = yi, _n.gzhead = null, _n.w_bits = pe, _n.w_size = 1 << _n.w_bits, _n.w_mask = _n.w_size - 1, _n.hash_bits = Le + 7, _n.hash_size = 1 << _n.hash_bits, _n.hash_mask = _n.hash_size - 1, _n.hash_shift = ~~((_n.hash_bits + Q - 1) / Q), _n.window = new o.Buf8(_n.w_size * 2), _n.head = new o.Buf16(_n.hash_size), _n.prev = new o.Buf16(_n.w_size), _n.lit_bufsize = 1 << Le + 6, _n.pending_buf_size = _n.lit_bufsize * 4, _n.pending_buf = new o.Buf8(_n.pending_buf_size), _n.d_buf = 1 * _n.lit_bufsize, _n.l_buf = 3 * _n.lit_bufsize, _n.level = Ve, _n.strategy = bt, _n.method = Ne, Ke(K);
            }
            function tt(K, Ve) {
              return Ee(K, Ve, j, z, G, O);
            }
            function ce(K, Ve) {
              var Ne, pe, Le, bt;
              if (!K || !K.state || Ve > E || Ve < 0)
                return K ? et(K, _) : _;
              if (pe = K.state, !K.output || !K.input && K.avail_in !== 0 || pe.status === Te && Ve !== w)
                return et(K, K.avail_out === 0 ? M : _);
              if (pe.strm = K, Ne = pe.last_flush, pe.last_flush = Ve, pe.status === ne)
                if (pe.wrap === 2)
                  K.adler = 0, ue(pe, 31), ue(pe, 139), ue(pe, 8), pe.gzhead ? (ue(
                    pe,
                    (pe.gzhead.text ? 1 : 0) + (pe.gzhead.hcrc ? 2 : 0) + (pe.gzhead.extra ? 4 : 0) + (pe.gzhead.name ? 8 : 0) + (pe.gzhead.comment ? 16 : 0)
                  ), ue(pe, pe.gzhead.time & 255), ue(pe, pe.gzhead.time >> 8 & 255), ue(pe, pe.gzhead.time >> 16 & 255), ue(pe, pe.gzhead.time >> 24 & 255), ue(pe, pe.level === 9 ? 2 : pe.strategy >= S || pe.level < 2 ? 4 : 0), ue(pe, pe.gzhead.os & 255), pe.gzhead.extra && pe.gzhead.extra.length && (ue(pe, pe.gzhead.extra.length & 255), ue(pe, pe.gzhead.extra.length >> 8 & 255)), pe.gzhead.hcrc && (K.adler = f(K.adler, pe.pending_buf, pe.pending, 0)), pe.gzindex = 0, pe.status = ge) : (ue(pe, 0), ue(pe, 0), ue(pe, 0), ue(pe, 0), ue(pe, 0), ue(pe, pe.level === 9 ? 2 : pe.strategy >= S || pe.level < 2 ? 4 : 0), ue(pe, Fe), pe.status = de);
                else {
                  var yi = j + (pe.w_bits - 8 << 4) << 8, _n = -1;
                  pe.strategy >= S || pe.level < 2 ? _n = 0 : pe.level < 6 ? _n = 1 : pe.level === 6 ? _n = 2 : _n = 3, yi |= _n << 6, pe.strstart !== 0 && (yi |= ie), yi += 31 - yi % 31, pe.status = de, te(pe, yi), pe.strstart !== 0 && (te(pe, K.adler >>> 16), te(pe, K.adler & 65535)), K.adler = 1;
                }
              if (pe.status === ge)
                if (pe.gzhead.extra) {
                  for (Le = pe.pending; pe.gzindex < (pe.gzhead.extra.length & 65535) && !(pe.pending === pe.pending_buf_size && (pe.gzhead.hcrc && pe.pending > Le && (K.adler = f(K.adler, pe.pending_buf, pe.pending - Le, Le)), Ue(K), Le = pe.pending, pe.pending === pe.pending_buf_size)); )
                    ue(pe, pe.gzhead.extra[pe.gzindex] & 255), pe.gzindex++;
                  pe.gzhead.hcrc && pe.pending > Le && (K.adler = f(K.adler, pe.pending_buf, pe.pending - Le, Le)), pe.gzindex === pe.gzhead.extra.length && (pe.gzindex = 0, pe.status = ye);
                } else
                  pe.status = ye;
              if (pe.status === ye)
                if (pe.gzhead.name) {
                  Le = pe.pending;
                  do {
                    if (pe.pending === pe.pending_buf_size && (pe.gzhead.hcrc && pe.pending > Le && (K.adler = f(K.adler, pe.pending_buf, pe.pending - Le, Le)), Ue(K), Le = pe.pending, pe.pending === pe.pending_buf_size)) {
                      bt = 1;
                      break;
                    }
                    pe.gzindex < pe.gzhead.name.length ? bt = pe.gzhead.name.charCodeAt(pe.gzindex++) & 255 : bt = 0, ue(pe, bt);
                  } while (bt !== 0);
                  pe.gzhead.hcrc && pe.pending > Le && (K.adler = f(K.adler, pe.pending_buf, pe.pending - Le, Le)), bt === 0 && (pe.gzindex = 0, pe.status = xe);
                } else
                  pe.status = xe;
              if (pe.status === xe)
                if (pe.gzhead.comment) {
                  Le = pe.pending;
                  do {
                    if (pe.pending === pe.pending_buf_size && (pe.gzhead.hcrc && pe.pending > Le && (K.adler = f(K.adler, pe.pending_buf, pe.pending - Le, Le)), Ue(K), Le = pe.pending, pe.pending === pe.pending_buf_size)) {
                      bt = 1;
                      break;
                    }
                    pe.gzindex < pe.gzhead.comment.length ? bt = pe.gzhead.comment.charCodeAt(pe.gzindex++) & 255 : bt = 0, ue(pe, bt);
                  } while (bt !== 0);
                  pe.gzhead.hcrc && pe.pending > Le && (K.adler = f(K.adler, pe.pending_buf, pe.pending - Le, Le)), bt === 0 && (pe.status = we);
                } else
                  pe.status = we;
              if (pe.status === we && (pe.gzhead.hcrc ? (pe.pending + 2 > pe.pending_buf_size && Ue(K), pe.pending + 2 <= pe.pending_buf_size && (ue(pe, K.adler & 255), ue(pe, K.adler >> 8 & 255), K.adler = 0, pe.status = de)) : pe.status = de), pe.pending !== 0) {
                if (Ue(K), K.avail_out === 0)
                  return pe.last_flush = -1, T;
              } else if (K.avail_in === 0 && Ye(Ve) <= Ye(Ne) && Ve !== w)
                return et(K, M);
              if (pe.status === Te && K.avail_in !== 0)
                return et(K, M);
              if (K.avail_in !== 0 || pe.lookahead !== 0 || Ve !== p && pe.status !== Te) {
                var Do = pe.strategy === S ? Re(pe, Ve) : pe.strategy === C ? se(pe, Ve) : We[pe.level].func(pe, Ve);
                if ((Do === Ae || Do === be) && (pe.status = Te), Do === Ce || Do === Ae)
                  return K.avail_out === 0 && (pe.last_flush = -1), T;
                if (Do === ee && (Ve === v ? l._tr_align(pe) : Ve !== E && (l._tr_stored_block(pe, 0, 0, !1), Ve === g && (De(pe.head), pe.lookahead === 0 && (pe.strstart = 0, pe.block_start = 0, pe.insert = 0))), Ue(K), K.avail_out === 0))
                  return pe.last_flush = -1, T;
              }
              return Ve !== w ? T : pe.wrap <= 0 ? R : (pe.wrap === 2 ? (ue(pe, K.adler & 255), ue(pe, K.adler >> 8 & 255), ue(pe, K.adler >> 16 & 255), ue(pe, K.adler >> 24 & 255), ue(pe, K.total_in & 255), ue(pe, K.total_in >> 8 & 255), ue(pe, K.total_in >> 16 & 255), ue(pe, K.total_in >> 24 & 255)) : (te(pe, K.adler >>> 16), te(pe, K.adler & 65535)), Ue(K), pe.wrap > 0 && (pe.wrap = -pe.wrap), pe.pending !== 0 ? T : R);
            }
            function _e(K) {
              var Ve;
              return !K || !K.state ? _ : (Ve = K.state.status, Ve !== ne && Ve !== ge && Ve !== ye && Ve !== xe && Ve !== we && Ve !== de && Ve !== Te ? et(K, _) : (K.state = null, Ve === de ? et(K, b) : T));
            }
            function Ht(K, Ve) {
              var Ne = Ve.length, pe, Le, bt, yi, _n, Do, ms, Bp;
              if (!K || !K.state || (pe = K.state, yi = pe.wrap, yi === 2 || yi === 1 && pe.status !== ne || pe.lookahead))
                return _;
              for (yi === 1 && (K.adler = u(K.adler, Ve, Ne, 0)), pe.wrap = 0, Ne >= pe.w_size && (yi === 0 && (De(pe.head), pe.strstart = 0, pe.block_start = 0, pe.insert = 0), Bp = new o.Buf8(pe.w_size), o.arraySet(Bp, Ve, Ne - pe.w_size, pe.w_size, 0), Ve = Bp, Ne = pe.w_size), _n = K.avail_in, Do = K.next_in, ms = K.input, K.avail_in = Ne, K.next_in = 0, K.input = Ve, ft(pe); pe.lookahead >= Q; ) {
                Le = pe.strstart, bt = pe.lookahead - (Q - 1);
                do
                  pe.ins_h = (pe.ins_h << pe.hash_shift ^ pe.window[Le + Q - 1]) & pe.hash_mask, pe.prev[Le & pe.w_mask] = pe.head[pe.ins_h], pe.head[pe.ins_h] = Le, Le++;
                while (--bt);
                pe.strstart = Le, pe.lookahead = Q - 1, ft(pe);
              }
              return pe.strstart += pe.lookahead, pe.block_start = pe.strstart, pe.insert = pe.lookahead, pe.lookahead = 0, pe.match_length = pe.prev_length = Q - 1, pe.match_available = 0, K.next_in = Do, K.input = ms, K.avail_in = _n, pe.wrap = yi, T;
            }
            e.deflateInit = tt, e.deflateInit2 = Ee, e.deflateReset = Ke, e.deflateResetKeep = ke, e.deflateSetHeader = me, e.deflate = ce, e.deflateEnd = _e, e.deflateSetDictionary = Ht, e.deflateInfo = "pako deflate (from Nodeca project)";
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/lib/zlib/gzheader.js": (
          /*!*********************************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/lib/zlib/gzheader.js ***!
            \*********************************************************************/
          /***/
          (t) => {
            function e() {
              this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
            }
            t.exports = e;
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/lib/zlib/inffast.js": (
          /*!********************************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/lib/zlib/inffast.js ***!
            \********************************************************************/
          /***/
          (t) => {
            var e = 30, n = 12;
            t.exports = function(o, l) {
              var u, f, h, p, v, g, w, E, T, R, _, b, M, A, $, S, C, D, O, N, j, L, z, G, B;
              u = o.state, f = o.next_in, G = o.input, h = f + (o.avail_in - 5), p = o.next_out, B = o.output, v = p - (l - o.avail_out), g = p + (o.avail_out - 257), w = u.dmax, E = u.wsize, T = u.whave, R = u.wnext, _ = u.window, b = u.hold, M = u.bits, A = u.lencode, $ = u.distcode, S = (1 << u.lenbits) - 1, C = (1 << u.distbits) - 1;
              e:
                do {
                  M < 15 && (b += G[f++] << M, M += 8, b += G[f++] << M, M += 8), D = A[b & S];
                  t:
                    for (; ; ) {
                      if (O = D >>> 24, b >>>= O, M -= O, O = D >>> 16 & 255, O === 0)
                        B[p++] = D & 65535;
                      else if (O & 16) {
                        N = D & 65535, O &= 15, O && (M < O && (b += G[f++] << M, M += 8), N += b & (1 << O) - 1, b >>>= O, M -= O), M < 15 && (b += G[f++] << M, M += 8, b += G[f++] << M, M += 8), D = $[b & C];
                        r:
                          for (; ; ) {
                            if (O = D >>> 24, b >>>= O, M -= O, O = D >>> 16 & 255, O & 16) {
                              if (j = D & 65535, O &= 15, M < O && (b += G[f++] << M, M += 8, M < O && (b += G[f++] << M, M += 8)), j += b & (1 << O) - 1, j > w) {
                                o.msg = "invalid distance too far back", u.mode = e;
                                break e;
                              }
                              if (b >>>= O, M -= O, O = p - v, j > O) {
                                if (O = j - O, O > T && u.sane) {
                                  o.msg = "invalid distance too far back", u.mode = e;
                                  break e;
                                }
                                if (L = 0, z = _, R === 0) {
                                  if (L += E - O, O < N) {
                                    N -= O;
                                    do
                                      B[p++] = _[L++];
                                    while (--O);
                                    L = p - j, z = B;
                                  }
                                } else if (R < O) {
                                  if (L += E + R - O, O -= R, O < N) {
                                    N -= O;
                                    do
                                      B[p++] = _[L++];
                                    while (--O);
                                    if (L = 0, R < N) {
                                      O = R, N -= O;
                                      do
                                        B[p++] = _[L++];
                                      while (--O);
                                      L = p - j, z = B;
                                    }
                                  }
                                } else if (L += R - O, O < N) {
                                  N -= O;
                                  do
                                    B[p++] = _[L++];
                                  while (--O);
                                  L = p - j, z = B;
                                }
                                for (; N > 2; )
                                  B[p++] = z[L++], B[p++] = z[L++], B[p++] = z[L++], N -= 3;
                                N && (B[p++] = z[L++], N > 1 && (B[p++] = z[L++]));
                              } else {
                                L = p - j;
                                do
                                  B[p++] = B[L++], B[p++] = B[L++], B[p++] = B[L++], N -= 3;
                                while (N > 2);
                                N && (B[p++] = B[L++], N > 1 && (B[p++] = B[L++]));
                              }
                            } else if (O & 64) {
                              o.msg = "invalid distance code", u.mode = e;
                              break e;
                            } else {
                              D = $[(D & 65535) + (b & (1 << O) - 1)];
                              continue r;
                            }
                            break;
                          }
                      } else if (O & 64)
                        if (O & 32) {
                          u.mode = n;
                          break e;
                        } else {
                          o.msg = "invalid literal/length code", u.mode = e;
                          break e;
                        }
                      else {
                        D = A[(D & 65535) + (b & (1 << O) - 1)];
                        continue t;
                      }
                      break;
                    }
                } while (f < h && p < g);
              N = M >> 3, f -= N, M -= N << 3, b &= (1 << M) - 1, o.next_in = f, o.next_out = p, o.avail_in = f < h ? 5 + (h - f) : 5 - (f - h), o.avail_out = p < g ? 257 + (g - p) : 257 - (p - g), u.hold = b, u.bits = M;
            };
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/lib/zlib/inflate.js": (
          /*!********************************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/lib/zlib/inflate.js ***!
            \********************************************************************/
          /***/
          (t, e, n) => {
            var o = n(
              /*! ../utils/common */
              "./node_modules/upng-js/node_modules/pako/lib/utils/common.js"
            ), l = n(
              /*! ./adler32 */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/adler32.js"
            ), u = n(
              /*! ./crc32 */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/crc32.js"
            ), f = n(
              /*! ./inffast */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/inffast.js"
            ), h = n(
              /*! ./inftrees */
              "./node_modules/upng-js/node_modules/pako/lib/zlib/inftrees.js"
            ), p = 0, v = 1, g = 2, w = 4, E = 5, T = 6, R = 0, _ = 1, b = 2, M = -2, A = -3, $ = -4, S = -5, C = 8, D = 1, O = 2, N = 3, j = 4, L = 5, z = 6, G = 7, B = 8, F = 9, H = 10, W = 11, V = 12, X = 13, Z = 14, Q = 15, q = 16, J = 17, ie = 18, ne = 19, ge = 20, ye = 21, xe = 22, we = 23, de = 24, Te = 25, Ce = 26, ee = 27, Ae = 28, be = 29, Fe = 30, et = 31, Ye = 32, De = 852, Ue = 592, Qe = 15, ue = Qe;
            function te(Ee) {
              return (Ee >>> 24 & 255) + (Ee >>> 8 & 65280) + ((Ee & 65280) << 8) + ((Ee & 255) << 24);
            }
            function Be() {
              this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new o.Buf16(320), this.work = new o.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
            }
            function Je(Ee) {
              var tt;
              return !Ee || !Ee.state ? M : (tt = Ee.state, Ee.total_in = Ee.total_out = tt.total = 0, Ee.msg = "", tt.wrap && (Ee.adler = tt.wrap & 1), tt.mode = D, tt.last = 0, tt.havedict = 0, tt.dmax = 32768, tt.head = null, tt.hold = 0, tt.bits = 0, tt.lencode = tt.lendyn = new o.Buf32(De), tt.distcode = tt.distdyn = new o.Buf32(Ue), tt.sane = 1, tt.back = -1, R);
            }
            function ft(Ee) {
              var tt;
              return !Ee || !Ee.state ? M : (tt = Ee.state, tt.wsize = 0, tt.whave = 0, tt.wnext = 0, Je(Ee));
            }
            function lt(Ee, tt) {
              var ce, _e;
              return !Ee || !Ee.state || (_e = Ee.state, tt < 0 ? (ce = 0, tt = -tt) : (ce = (tt >> 4) + 1, tt < 48 && (tt &= 15)), tt && (tt < 8 || tt > 15)) ? M : (_e.window !== null && _e.wbits !== tt && (_e.window = null), _e.wrap = ce, _e.wbits = tt, ft(Ee));
            }
            function he(Ee, tt) {
              var ce, _e;
              return Ee ? (_e = new Be(), Ee.state = _e, _e.window = null, ce = lt(Ee, tt), ce !== R && (Ee.state = null), ce) : M;
            }
            function ae(Ee) {
              return he(Ee, ue);
            }
            var se = !0, Re, Oe;
            function We(Ee) {
              if (se) {
                var tt;
                for (Re = new o.Buf32(512), Oe = new o.Buf32(32), tt = 0; tt < 144; )
                  Ee.lens[tt++] = 8;
                for (; tt < 256; )
                  Ee.lens[tt++] = 9;
                for (; tt < 280; )
                  Ee.lens[tt++] = 7;
                for (; tt < 288; )
                  Ee.lens[tt++] = 8;
                for (h(v, Ee.lens, 0, 288, Re, 0, Ee.work, { bits: 9 }), tt = 0; tt < 32; )
                  Ee.lens[tt++] = 5;
                h(g, Ee.lens, 0, 32, Oe, 0, Ee.work, { bits: 5 }), se = !1;
              }
              Ee.lencode = Re, Ee.lenbits = 9, Ee.distcode = Oe, Ee.distbits = 5;
            }
            function Ct(Ee, tt, ce, _e) {
              var Ht, K = Ee.state;
              return K.window === null && (K.wsize = 1 << K.wbits, K.wnext = 0, K.whave = 0, K.window = new o.Buf8(K.wsize)), _e >= K.wsize ? (o.arraySet(K.window, tt, ce - K.wsize, K.wsize, 0), K.wnext = 0, K.whave = K.wsize) : (Ht = K.wsize - K.wnext, Ht > _e && (Ht = _e), o.arraySet(K.window, tt, ce - _e, Ht, K.wnext), _e -= Ht, _e ? (o.arraySet(K.window, tt, ce - _e, _e, 0), K.wnext = _e, K.whave = K.wsize) : (K.wnext += Ht, K.wnext === K.wsize && (K.wnext = 0), K.whave < K.wsize && (K.whave += Ht))), 0;
            }
            function le(Ee, tt) {
              var ce, _e, Ht, K, Ve, Ne, pe, Le, bt, yi, _n, Do, ms, Bp, Sp = 0, Tp, Pp, Xe, Se, pr, mn, Si, Io, ve = new o.Buf8(4), He, nt, dr = (
                /* permutation of code lengths */
                [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
              );
              if (!Ee || !Ee.state || !Ee.output || !Ee.input && Ee.avail_in !== 0)
                return M;
              ce = Ee.state, ce.mode === V && (ce.mode = X), Ve = Ee.next_out, Ht = Ee.output, pe = Ee.avail_out, K = Ee.next_in, _e = Ee.input, Ne = Ee.avail_in, Le = ce.hold, bt = ce.bits, yi = Ne, _n = pe, Io = R;
              e:
                for (; ; )
                  switch (ce.mode) {
                    case D:
                      if (ce.wrap === 0) {
                        ce.mode = X;
                        break;
                      }
                      for (; bt < 16; ) {
                        if (Ne === 0)
                          break e;
                        Ne--, Le += _e[K++] << bt, bt += 8;
                      }
                      if (ce.wrap & 2 && Le === 35615) {
                        ce.check = 0, ve[0] = Le & 255, ve[1] = Le >>> 8 & 255, ce.check = u(ce.check, ve, 2, 0), Le = 0, bt = 0, ce.mode = O;
                        break;
                      }
                      if (ce.flags = 0, ce.head && (ce.head.done = !1), !(ce.wrap & 1) || /* check if zlib header allowed */
                      (((Le & 255) << 8) + (Le >> 8)) % 31) {
                        Ee.msg = "incorrect header check", ce.mode = Fe;
                        break;
                      }
                      if ((Le & 15) !== C) {
                        Ee.msg = "unknown compression method", ce.mode = Fe;
                        break;
                      }
                      if (Le >>>= 4, bt -= 4, Si = (Le & 15) + 8, ce.wbits === 0)
                        ce.wbits = Si;
                      else if (Si > ce.wbits) {
                        Ee.msg = "invalid window size", ce.mode = Fe;
                        break;
                      }
                      ce.dmax = 1 << Si, Ee.adler = ce.check = 1, ce.mode = Le & 512 ? H : V, Le = 0, bt = 0;
                      break;
                    case O:
                      for (; bt < 16; ) {
                        if (Ne === 0)
                          break e;
                        Ne--, Le += _e[K++] << bt, bt += 8;
                      }
                      if (ce.flags = Le, (ce.flags & 255) !== C) {
                        Ee.msg = "unknown compression method", ce.mode = Fe;
                        break;
                      }
                      if (ce.flags & 57344) {
                        Ee.msg = "unknown header flags set", ce.mode = Fe;
                        break;
                      }
                      ce.head && (ce.head.text = Le >> 8 & 1), ce.flags & 512 && (ve[0] = Le & 255, ve[1] = Le >>> 8 & 255, ce.check = u(ce.check, ve, 2, 0)), Le = 0, bt = 0, ce.mode = N;
                    case N:
                      for (; bt < 32; ) {
                        if (Ne === 0)
                          break e;
                        Ne--, Le += _e[K++] << bt, bt += 8;
                      }
                      ce.head && (ce.head.time = Le), ce.flags & 512 && (ve[0] = Le & 255, ve[1] = Le >>> 8 & 255, ve[2] = Le >>> 16 & 255, ve[3] = Le >>> 24 & 255, ce.check = u(ce.check, ve, 4, 0)), Le = 0, bt = 0, ce.mode = j;
                    case j:
                      for (; bt < 16; ) {
                        if (Ne === 0)
                          break e;
                        Ne--, Le += _e[K++] << bt, bt += 8;
                      }
                      ce.head && (ce.head.xflags = Le & 255, ce.head.os = Le >> 8), ce.flags & 512 && (ve[0] = Le & 255, ve[1] = Le >>> 8 & 255, ce.check = u(ce.check, ve, 2, 0)), Le = 0, bt = 0, ce.mode = L;
                    case L:
                      if (ce.flags & 1024) {
                        for (; bt < 16; ) {
                          if (Ne === 0)
                            break e;
                          Ne--, Le += _e[K++] << bt, bt += 8;
                        }
                        ce.length = Le, ce.head && (ce.head.extra_len = Le), ce.flags & 512 && (ve[0] = Le & 255, ve[1] = Le >>> 8 & 255, ce.check = u(ce.check, ve, 2, 0)), Le = 0, bt = 0;
                      } else
                        ce.head && (ce.head.extra = null);
                      ce.mode = z;
                    case z:
                      if (ce.flags & 1024 && (Do = ce.length, Do > Ne && (Do = Ne), Do && (ce.head && (Si = ce.head.extra_len - ce.length, ce.head.extra || (ce.head.extra = new Array(ce.head.extra_len)), o.arraySet(
                        ce.head.extra,
                        _e,
                        K,
                        // extra field is limited to 65536 bytes
                        // - no need for additional size check
                        Do,
                        /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                        Si
                      )), ce.flags & 512 && (ce.check = u(ce.check, _e, Do, K)), Ne -= Do, K += Do, ce.length -= Do), ce.length))
                        break e;
                      ce.length = 0, ce.mode = G;
                    case G:
                      if (ce.flags & 2048) {
                        if (Ne === 0)
                          break e;
                        Do = 0;
                        do
                          Si = _e[K + Do++], ce.head && Si && ce.length < 65536 && (ce.head.name += String.fromCharCode(Si));
                        while (Si && Do < Ne);
                        if (ce.flags & 512 && (ce.check = u(ce.check, _e, Do, K)), Ne -= Do, K += Do, Si)
                          break e;
                      } else
                        ce.head && (ce.head.name = null);
                      ce.length = 0, ce.mode = B;
                    case B:
                      if (ce.flags & 4096) {
                        if (Ne === 0)
                          break e;
                        Do = 0;
                        do
                          Si = _e[K + Do++], ce.head && Si && ce.length < 65536 && (ce.head.comment += String.fromCharCode(Si));
                        while (Si && Do < Ne);
                        if (ce.flags & 512 && (ce.check = u(ce.check, _e, Do, K)), Ne -= Do, K += Do, Si)
                          break e;
                      } else
                        ce.head && (ce.head.comment = null);
                      ce.mode = F;
                    case F:
                      if (ce.flags & 512) {
                        for (; bt < 16; ) {
                          if (Ne === 0)
                            break e;
                          Ne--, Le += _e[K++] << bt, bt += 8;
                        }
                        if (Le !== (ce.check & 65535)) {
                          Ee.msg = "header crc mismatch", ce.mode = Fe;
                          break;
                        }
                        Le = 0, bt = 0;
                      }
                      ce.head && (ce.head.hcrc = ce.flags >> 9 & 1, ce.head.done = !0), Ee.adler = ce.check = 0, ce.mode = V;
                      break;
                    case H:
                      for (; bt < 32; ) {
                        if (Ne === 0)
                          break e;
                        Ne--, Le += _e[K++] << bt, bt += 8;
                      }
                      Ee.adler = ce.check = te(Le), Le = 0, bt = 0, ce.mode = W;
                    case W:
                      if (ce.havedict === 0)
                        return Ee.next_out = Ve, Ee.avail_out = pe, Ee.next_in = K, Ee.avail_in = Ne, ce.hold = Le, ce.bits = bt, b;
                      Ee.adler = ce.check = 1, ce.mode = V;
                    case V:
                      if (tt === E || tt === T)
                        break e;
                    case X:
                      if (ce.last) {
                        Le >>>= bt & 7, bt -= bt & 7, ce.mode = ee;
                        break;
                      }
                      for (; bt < 3; ) {
                        if (Ne === 0)
                          break e;
                        Ne--, Le += _e[K++] << bt, bt += 8;
                      }
                      switch (ce.last = Le & 1, Le >>>= 1, bt -= 1, Le & 3) {
                        case 0:
                          ce.mode = Z;
                          break;
                        case 1:
                          if (We(ce), ce.mode = ge, tt === T) {
                            Le >>>= 2, bt -= 2;
                            break e;
                          }
                          break;
                        case 2:
                          ce.mode = J;
                          break;
                        case 3:
                          Ee.msg = "invalid block type", ce.mode = Fe;
                      }
                      Le >>>= 2, bt -= 2;
                      break;
                    case Z:
                      for (Le >>>= bt & 7, bt -= bt & 7; bt < 32; ) {
                        if (Ne === 0)
                          break e;
                        Ne--, Le += _e[K++] << bt, bt += 8;
                      }
                      if ((Le & 65535) !== (Le >>> 16 ^ 65535)) {
                        Ee.msg = "invalid stored block lengths", ce.mode = Fe;
                        break;
                      }
                      if (ce.length = Le & 65535, Le = 0, bt = 0, ce.mode = Q, tt === T)
                        break e;
                    case Q:
                      ce.mode = q;
                    case q:
                      if (Do = ce.length, Do) {
                        if (Do > Ne && (Do = Ne), Do > pe && (Do = pe), Do === 0)
                          break e;
                        o.arraySet(Ht, _e, K, Do, Ve), Ne -= Do, K += Do, pe -= Do, Ve += Do, ce.length -= Do;
                        break;
                      }
                      ce.mode = V;
                      break;
                    case J:
                      for (; bt < 14; ) {
                        if (Ne === 0)
                          break e;
                        Ne--, Le += _e[K++] << bt, bt += 8;
                      }
                      if (ce.nlen = (Le & 31) + 257, Le >>>= 5, bt -= 5, ce.ndist = (Le & 31) + 1, Le >>>= 5, bt -= 5, ce.ncode = (Le & 15) + 4, Le >>>= 4, bt -= 4, ce.nlen > 286 || ce.ndist > 30) {
                        Ee.msg = "too many length or distance symbols", ce.mode = Fe;
                        break;
                      }
                      ce.have = 0, ce.mode = ie;
                    case ie:
                      for (; ce.have < ce.ncode; ) {
                        for (; bt < 3; ) {
                          if (Ne === 0)
                            break e;
                          Ne--, Le += _e[K++] << bt, bt += 8;
                        }
                        ce.lens[dr[ce.have++]] = Le & 7, Le >>>= 3, bt -= 3;
                      }
                      for (; ce.have < 19; )
                        ce.lens[dr[ce.have++]] = 0;
                      if (ce.lencode = ce.lendyn, ce.lenbits = 7, He = { bits: ce.lenbits }, Io = h(p, ce.lens, 0, 19, ce.lencode, 0, ce.work, He), ce.lenbits = He.bits, Io) {
                        Ee.msg = "invalid code lengths set", ce.mode = Fe;
                        break;
                      }
                      ce.have = 0, ce.mode = ne;
                    case ne:
                      for (; ce.have < ce.nlen + ce.ndist; ) {
                        for (; Sp = ce.lencode[Le & (1 << ce.lenbits) - 1], Tp = Sp >>> 24, Pp = Sp >>> 16 & 255, Xe = Sp & 65535, !(Tp <= bt); ) {
                          if (Ne === 0)
                            break e;
                          Ne--, Le += _e[K++] << bt, bt += 8;
                        }
                        if (Xe < 16)
                          Le >>>= Tp, bt -= Tp, ce.lens[ce.have++] = Xe;
                        else {
                          if (Xe === 16) {
                            for (nt = Tp + 2; bt < nt; ) {
                              if (Ne === 0)
                                break e;
                              Ne--, Le += _e[K++] << bt, bt += 8;
                            }
                            if (Le >>>= Tp, bt -= Tp, ce.have === 0) {
                              Ee.msg = "invalid bit length repeat", ce.mode = Fe;
                              break;
                            }
                            Si = ce.lens[ce.have - 1], Do = 3 + (Le & 3), Le >>>= 2, bt -= 2;
                          } else if (Xe === 17) {
                            for (nt = Tp + 3; bt < nt; ) {
                              if (Ne === 0)
                                break e;
                              Ne--, Le += _e[K++] << bt, bt += 8;
                            }
                            Le >>>= Tp, bt -= Tp, Si = 0, Do = 3 + (Le & 7), Le >>>= 3, bt -= 3;
                          } else {
                            for (nt = Tp + 7; bt < nt; ) {
                              if (Ne === 0)
                                break e;
                              Ne--, Le += _e[K++] << bt, bt += 8;
                            }
                            Le >>>= Tp, bt -= Tp, Si = 0, Do = 11 + (Le & 127), Le >>>= 7, bt -= 7;
                          }
                          if (ce.have + Do > ce.nlen + ce.ndist) {
                            Ee.msg = "invalid bit length repeat", ce.mode = Fe;
                            break;
                          }
                          for (; Do--; )
                            ce.lens[ce.have++] = Si;
                        }
                      }
                      if (ce.mode === Fe)
                        break;
                      if (ce.lens[256] === 0) {
                        Ee.msg = "invalid code -- missing end-of-block", ce.mode = Fe;
                        break;
                      }
                      if (ce.lenbits = 9, He = { bits: ce.lenbits }, Io = h(v, ce.lens, 0, ce.nlen, ce.lencode, 0, ce.work, He), ce.lenbits = He.bits, Io) {
                        Ee.msg = "invalid literal/lengths set", ce.mode = Fe;
                        break;
                      }
                      if (ce.distbits = 6, ce.distcode = ce.distdyn, He = { bits: ce.distbits }, Io = h(g, ce.lens, ce.nlen, ce.ndist, ce.distcode, 0, ce.work, He), ce.distbits = He.bits, Io) {
                        Ee.msg = "invalid distances set", ce.mode = Fe;
                        break;
                      }
                      if (ce.mode = ge, tt === T)
                        break e;
                    case ge:
                      ce.mode = ye;
                    case ye:
                      if (Ne >= 6 && pe >= 258) {
                        Ee.next_out = Ve, Ee.avail_out = pe, Ee.next_in = K, Ee.avail_in = Ne, ce.hold = Le, ce.bits = bt, f(Ee, _n), Ve = Ee.next_out, Ht = Ee.output, pe = Ee.avail_out, K = Ee.next_in, _e = Ee.input, Ne = Ee.avail_in, Le = ce.hold, bt = ce.bits, ce.mode === V && (ce.back = -1);
                        break;
                      }
                      for (ce.back = 0; Sp = ce.lencode[Le & (1 << ce.lenbits) - 1], Tp = Sp >>> 24, Pp = Sp >>> 16 & 255, Xe = Sp & 65535, !(Tp <= bt); ) {
                        if (Ne === 0)
                          break e;
                        Ne--, Le += _e[K++] << bt, bt += 8;
                      }
                      if (Pp && !(Pp & 240)) {
                        for (Se = Tp, pr = Pp, mn = Xe; Sp = ce.lencode[mn + ((Le & (1 << Se + pr) - 1) >> Se)], Tp = Sp >>> 24, Pp = Sp >>> 16 & 255, Xe = Sp & 65535, !(Se + Tp <= bt); ) {
                          if (Ne === 0)
                            break e;
                          Ne--, Le += _e[K++] << bt, bt += 8;
                        }
                        Le >>>= Se, bt -= Se, ce.back += Se;
                      }
                      if (Le >>>= Tp, bt -= Tp, ce.back += Tp, ce.length = Xe, Pp === 0) {
                        ce.mode = Ce;
                        break;
                      }
                      if (Pp & 32) {
                        ce.back = -1, ce.mode = V;
                        break;
                      }
                      if (Pp & 64) {
                        Ee.msg = "invalid literal/length code", ce.mode = Fe;
                        break;
                      }
                      ce.extra = Pp & 15, ce.mode = xe;
                    case xe:
                      if (ce.extra) {
                        for (nt = ce.extra; bt < nt; ) {
                          if (Ne === 0)
                            break e;
                          Ne--, Le += _e[K++] << bt, bt += 8;
                        }
                        ce.length += Le & (1 << ce.extra) - 1, Le >>>= ce.extra, bt -= ce.extra, ce.back += ce.extra;
                      }
                      ce.was = ce.length, ce.mode = we;
                    case we:
                      for (; Sp = ce.distcode[Le & (1 << ce.distbits) - 1], Tp = Sp >>> 24, Pp = Sp >>> 16 & 255, Xe = Sp & 65535, !(Tp <= bt); ) {
                        if (Ne === 0)
                          break e;
                        Ne--, Le += _e[K++] << bt, bt += 8;
                      }
                      if (!(Pp & 240)) {
                        for (Se = Tp, pr = Pp, mn = Xe; Sp = ce.distcode[mn + ((Le & (1 << Se + pr) - 1) >> Se)], Tp = Sp >>> 24, Pp = Sp >>> 16 & 255, Xe = Sp & 65535, !(Se + Tp <= bt); ) {
                          if (Ne === 0)
                            break e;
                          Ne--, Le += _e[K++] << bt, bt += 8;
                        }
                        Le >>>= Se, bt -= Se, ce.back += Se;
                      }
                      if (Le >>>= Tp, bt -= Tp, ce.back += Tp, Pp & 64) {
                        Ee.msg = "invalid distance code", ce.mode = Fe;
                        break;
                      }
                      ce.offset = Xe, ce.extra = Pp & 15, ce.mode = de;
                    case de:
                      if (ce.extra) {
                        for (nt = ce.extra; bt < nt; ) {
                          if (Ne === 0)
                            break e;
                          Ne--, Le += _e[K++] << bt, bt += 8;
                        }
                        ce.offset += Le & (1 << ce.extra) - 1, Le >>>= ce.extra, bt -= ce.extra, ce.back += ce.extra;
                      }
                      if (ce.offset > ce.dmax) {
                        Ee.msg = "invalid distance too far back", ce.mode = Fe;
                        break;
                      }
                      ce.mode = Te;
                    case Te:
                      if (pe === 0)
                        break e;
                      if (Do = _n - pe, ce.offset > Do) {
                        if (Do = ce.offset - Do, Do > ce.whave && ce.sane) {
                          Ee.msg = "invalid distance too far back", ce.mode = Fe;
                          break;
                        }
                        Do > ce.wnext ? (Do -= ce.wnext, ms = ce.wsize - Do) : ms = ce.wnext - Do, Do > ce.length && (Do = ce.length), Bp = ce.window;
                      } else
                        Bp = Ht, ms = Ve - ce.offset, Do = ce.length;
                      Do > pe && (Do = pe), pe -= Do, ce.length -= Do;
                      do
                        Ht[Ve++] = Bp[ms++];
                      while (--Do);
                      ce.length === 0 && (ce.mode = ye);
                      break;
                    case Ce:
                      if (pe === 0)
                        break e;
                      Ht[Ve++] = ce.length, pe--, ce.mode = ye;
                      break;
                    case ee:
                      if (ce.wrap) {
                        for (; bt < 32; ) {
                          if (Ne === 0)
                            break e;
                          Ne--, Le |= _e[K++] << bt, bt += 8;
                        }
                        if (_n -= pe, Ee.total_out += _n, ce.total += _n, _n && (Ee.adler = ce.check = /*UPDATE(state.check, put - _out, _out);*/
                        ce.flags ? u(ce.check, Ht, _n, Ve - _n) : l(ce.check, Ht, _n, Ve - _n)), _n = pe, (ce.flags ? Le : te(Le)) !== ce.check) {
                          Ee.msg = "incorrect data check", ce.mode = Fe;
                          break;
                        }
                        Le = 0, bt = 0;
                      }
                      ce.mode = Ae;
                    case Ae:
                      if (ce.wrap && ce.flags) {
                        for (; bt < 32; ) {
                          if (Ne === 0)
                            break e;
                          Ne--, Le += _e[K++] << bt, bt += 8;
                        }
                        if (Le !== (ce.total & 4294967295)) {
                          Ee.msg = "incorrect length check", ce.mode = Fe;
                          break;
                        }
                        Le = 0, bt = 0;
                      }
                      ce.mode = be;
                    case be:
                      Io = _;
                      break e;
                    case Fe:
                      Io = A;
                      break e;
                    case et:
                      return $;
                    case Ye:
                    default:
                      return M;
                  }
              return Ee.next_out = Ve, Ee.avail_out = pe, Ee.next_in = K, Ee.avail_in = Ne, ce.hold = Le, ce.bits = bt, (ce.wsize || _n !== Ee.avail_out && ce.mode < Fe && (ce.mode < ee || tt !== w)) && Ct(Ee, Ee.output, Ee.next_out, _n - Ee.avail_out), yi -= Ee.avail_in, _n -= Ee.avail_out, Ee.total_in += yi, Ee.total_out += _n, ce.total += _n, ce.wrap && _n && (Ee.adler = ce.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
              ce.flags ? u(ce.check, Ht, _n, Ee.next_out - _n) : l(ce.check, Ht, _n, Ee.next_out - _n)), Ee.data_type = ce.bits + (ce.last ? 64 : 0) + (ce.mode === V ? 128 : 0) + (ce.mode === ge || ce.mode === Q ? 256 : 0), (yi === 0 && _n === 0 || tt === w) && Io === R && (Io = S), Io;
            }
            function ke(Ee) {
              if (!Ee || !Ee.state)
                return M;
              var tt = Ee.state;
              return tt.window && (tt.window = null), Ee.state = null, R;
            }
            function Ke(Ee, tt) {
              var ce;
              return !Ee || !Ee.state || (ce = Ee.state, !(ce.wrap & 2)) ? M : (ce.head = tt, tt.done = !1, R);
            }
            function me(Ee, tt) {
              var ce = tt.length, _e, Ht, K;
              return !Ee || !Ee.state || (_e = Ee.state, _e.wrap !== 0 && _e.mode !== W) ? M : _e.mode === W && (Ht = 1, Ht = l(Ht, tt, ce, 0), Ht !== _e.check) ? A : (K = Ct(Ee, tt, ce, ce), K ? (_e.mode = et, $) : (_e.havedict = 1, R));
            }
            e.inflateReset = ft, e.inflateReset2 = lt, e.inflateResetKeep = Je, e.inflateInit = ae, e.inflateInit2 = he, e.inflate = le, e.inflateEnd = ke, e.inflateGetHeader = Ke, e.inflateSetDictionary = me, e.inflateInfo = "pako inflate (from Nodeca project)";
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/lib/zlib/inftrees.js": (
          /*!*********************************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/lib/zlib/inftrees.js ***!
            \*********************************************************************/
          /***/
          (t, e, n) => {
            var o = n(
              /*! ../utils/common */
              "./node_modules/upng-js/node_modules/pako/lib/utils/common.js"
            ), l = 15, u = 852, f = 592, h = 0, p = 1, v = 2, g = [
              /* Length codes 257..285 base */
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              10,
              11,
              13,
              15,
              17,
              19,
              23,
              27,
              31,
              35,
              43,
              51,
              59,
              67,
              83,
              99,
              115,
              131,
              163,
              195,
              227,
              258,
              0,
              0
            ], w = [
              /* Length codes 257..285 extra */
              16,
              16,
              16,
              16,
              16,
              16,
              16,
              16,
              17,
              17,
              17,
              17,
              18,
              18,
              18,
              18,
              19,
              19,
              19,
              19,
              20,
              20,
              20,
              20,
              21,
              21,
              21,
              21,
              16,
              72,
              78
            ], E = [
              /* Distance codes 0..29 base */
              1,
              2,
              3,
              4,
              5,
              7,
              9,
              13,
              17,
              25,
              33,
              49,
              65,
              97,
              129,
              193,
              257,
              385,
              513,
              769,
              1025,
              1537,
              2049,
              3073,
              4097,
              6145,
              8193,
              12289,
              16385,
              24577,
              0,
              0
            ], T = [
              /* Distance codes 0..29 extra */
              16,
              16,
              16,
              16,
              17,
              17,
              18,
              18,
              19,
              19,
              20,
              20,
              21,
              21,
              22,
              22,
              23,
              23,
              24,
              24,
              25,
              25,
              26,
              26,
              27,
              27,
              28,
              28,
              29,
              29,
              64,
              64
            ];
            t.exports = function(R, _, b, M, A, $, S, C) {
              var D = C.bits, O = 0, N = 0, j = 0, L = 0, z = 0, G = 0, B = 0, F = 0, H = 0, W = 0, V, X, Z, Q, q, J = null, ie = 0, ne, ge = new o.Buf16(l + 1), ye = new o.Buf16(l + 1), xe = null, we = 0, de, Te, Ce;
              for (O = 0; O <= l; O++)
                ge[O] = 0;
              for (N = 0; N < M; N++)
                ge[_[b + N]]++;
              for (z = D, L = l; L >= 1 && ge[L] === 0; L--)
                ;
              if (z > L && (z = L), L === 0)
                return A[$++] = 20971520, A[$++] = 20971520, C.bits = 1, 0;
              for (j = 1; j < L && ge[j] === 0; j++)
                ;
              for (z < j && (z = j), F = 1, O = 1; O <= l; O++)
                if (F <<= 1, F -= ge[O], F < 0)
                  return -1;
              if (F > 0 && (R === h || L !== 1))
                return -1;
              for (ye[1] = 0, O = 1; O < l; O++)
                ye[O + 1] = ye[O] + ge[O];
              for (N = 0; N < M; N++)
                _[b + N] !== 0 && (S[ye[_[b + N]]++] = N);
              if (R === h ? (J = xe = S, ne = 19) : R === p ? (J = g, ie -= 257, xe = w, we -= 257, ne = 256) : (J = E, xe = T, ne = -1), W = 0, N = 0, O = j, q = $, G = z, B = 0, Z = -1, H = 1 << z, Q = H - 1, R === p && H > u || R === v && H > f)
                return 1;
              for (; ; ) {
                de = O - B, S[N] < ne ? (Te = 0, Ce = S[N]) : S[N] > ne ? (Te = xe[we + S[N]], Ce = J[ie + S[N]]) : (Te = 96, Ce = 0), V = 1 << O - B, X = 1 << G, j = X;
                do
                  X -= V, A[q + (W >> B) + X] = de << 24 | Te << 16 | Ce | 0;
                while (X !== 0);
                for (V = 1 << O - 1; W & V; )
                  V >>= 1;
                if (V !== 0 ? (W &= V - 1, W += V) : W = 0, N++, --ge[O] === 0) {
                  if (O === L)
                    break;
                  O = _[b + S[N]];
                }
                if (O > z && (W & Q) !== Z) {
                  for (B === 0 && (B = z), q += j, G = O - B, F = 1 << G; G + B < L && (F -= ge[G + B], !(F <= 0)); )
                    G++, F <<= 1;
                  if (H += 1 << G, R === p && H > u || R === v && H > f)
                    return 1;
                  Z = W & Q, A[Z] = z << 24 | G << 16 | q - $ | 0;
                }
              }
              return W !== 0 && (A[q + W] = O - B << 24 | 4194304 | 0), C.bits = z, 0;
            };
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/lib/zlib/messages.js": (
          /*!*********************************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/lib/zlib/messages.js ***!
            \*********************************************************************/
          /***/
          (t) => {
            t.exports = {
              2: "need dictionary",
              /* Z_NEED_DICT       2  */
              1: "stream end",
              /* Z_STREAM_END      1  */
              0: "",
              /* Z_OK              0  */
              "-1": "file error",
              /* Z_ERRNO         (-1) */
              "-2": "stream error",
              /* Z_STREAM_ERROR  (-2) */
              "-3": "data error",
              /* Z_DATA_ERROR    (-3) */
              "-4": "insufficient memory",
              /* Z_MEM_ERROR     (-4) */
              "-5": "buffer error",
              /* Z_BUF_ERROR     (-5) */
              "-6": "incompatible version"
              /* Z_VERSION_ERROR (-6) */
            };
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/lib/zlib/trees.js": (
          /*!******************************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/lib/zlib/trees.js ***!
            \******************************************************************/
          /***/
          (t, e, n) => {
            var o = n(
              /*! ../utils/common */
              "./node_modules/upng-js/node_modules/pako/lib/utils/common.js"
            ), l = 4, u = 0, f = 1, h = 2;
            function p(le) {
              for (var ke = le.length; --ke >= 0; )
                le[ke] = 0;
            }
            var v = 0, g = 1, w = 2, E = 3, T = 258, R = 29, _ = 256, b = _ + 1 + R, M = 30, A = 19, $ = 2 * b + 1, S = 15, C = 16, D = 7, O = 256, N = 16, j = 17, L = 18, z = (
              /* extra bits for each length code */
              [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
            ), G = (
              /* extra bits for each distance code */
              [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
            ), B = (
              /* extra bits for each bit length code */
              [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
            ), F = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], H = 512, W = new Array((b + 2) * 2);
            p(W);
            var V = new Array(M * 2);
            p(V);
            var X = new Array(H);
            p(X);
            var Z = new Array(T - E + 1);
            p(Z);
            var Q = new Array(R);
            p(Q);
            var q = new Array(M);
            p(q);
            function J(le, ke, Ke, me, Ee) {
              this.static_tree = le, this.extra_bits = ke, this.extra_base = Ke, this.elems = me, this.max_length = Ee, this.has_stree = le && le.length;
            }
            var ie, ne, ge;
            function ye(le, ke) {
              this.dyn_tree = le, this.max_code = 0, this.stat_desc = ke;
            }
            function xe(le) {
              return le < 256 ? X[le] : X[256 + (le >>> 7)];
            }
            function we(le, ke) {
              le.pending_buf[le.pending++] = ke & 255, le.pending_buf[le.pending++] = ke >>> 8 & 255;
            }
            function de(le, ke, Ke) {
              le.bi_valid > C - Ke ? (le.bi_buf |= ke << le.bi_valid & 65535, we(le, le.bi_buf), le.bi_buf = ke >> C - le.bi_valid, le.bi_valid += Ke - C) : (le.bi_buf |= ke << le.bi_valid & 65535, le.bi_valid += Ke);
            }
            function Te(le, ke, Ke) {
              de(
                le,
                Ke[ke * 2],
                Ke[ke * 2 + 1]
                /*.Len*/
              );
            }
            function Ce(le, ke) {
              var Ke = 0;
              do
                Ke |= le & 1, le >>>= 1, Ke <<= 1;
              while (--ke > 0);
              return Ke >>> 1;
            }
            function ee(le) {
              le.bi_valid === 16 ? (we(le, le.bi_buf), le.bi_buf = 0, le.bi_valid = 0) : le.bi_valid >= 8 && (le.pending_buf[le.pending++] = le.bi_buf & 255, le.bi_buf >>= 8, le.bi_valid -= 8);
            }
            function Ae(le, ke) {
              var Ke = ke.dyn_tree, me = ke.max_code, Ee = ke.stat_desc.static_tree, tt = ke.stat_desc.has_stree, ce = ke.stat_desc.extra_bits, _e = ke.stat_desc.extra_base, Ht = ke.stat_desc.max_length, K, Ve, Ne, pe, Le, bt, yi = 0;
              for (pe = 0; pe <= S; pe++)
                le.bl_count[pe] = 0;
              for (Ke[le.heap[le.heap_max] * 2 + 1] = 0, K = le.heap_max + 1; K < $; K++)
                Ve = le.heap[K], pe = Ke[Ke[Ve * 2 + 1] * 2 + 1] + 1, pe > Ht && (pe = Ht, yi++), Ke[Ve * 2 + 1] = pe, !(Ve > me) && (le.bl_count[pe]++, Le = 0, Ve >= _e && (Le = ce[Ve - _e]), bt = Ke[Ve * 2], le.opt_len += bt * (pe + Le), tt && (le.static_len += bt * (Ee[Ve * 2 + 1] + Le)));
              if (yi !== 0) {
                do {
                  for (pe = Ht - 1; le.bl_count[pe] === 0; )
                    pe--;
                  le.bl_count[pe]--, le.bl_count[pe + 1] += 2, le.bl_count[Ht]--, yi -= 2;
                } while (yi > 0);
                for (pe = Ht; pe !== 0; pe--)
                  for (Ve = le.bl_count[pe]; Ve !== 0; )
                    Ne = le.heap[--K], !(Ne > me) && (Ke[Ne * 2 + 1] !== pe && (le.opt_len += (pe - Ke[Ne * 2 + 1]) * Ke[Ne * 2], Ke[Ne * 2 + 1] = pe), Ve--);
              }
            }
            function be(le, ke, Ke) {
              var me = new Array(S + 1), Ee = 0, tt, ce;
              for (tt = 1; tt <= S; tt++)
                me[tt] = Ee = Ee + Ke[tt - 1] << 1;
              for (ce = 0; ce <= ke; ce++) {
                var _e = le[ce * 2 + 1];
                _e !== 0 && (le[ce * 2] = Ce(me[_e]++, _e));
              }
            }
            function Fe() {
              var le, ke, Ke, me, Ee, tt = new Array(S + 1);
              for (Ke = 0, me = 0; me < R - 1; me++)
                for (Q[me] = Ke, le = 0; le < 1 << z[me]; le++)
                  Z[Ke++] = me;
              for (Z[Ke - 1] = me, Ee = 0, me = 0; me < 16; me++)
                for (q[me] = Ee, le = 0; le < 1 << G[me]; le++)
                  X[Ee++] = me;
              for (Ee >>= 7; me < M; me++)
                for (q[me] = Ee << 7, le = 0; le < 1 << G[me] - 7; le++)
                  X[256 + Ee++] = me;
              for (ke = 0; ke <= S; ke++)
                tt[ke] = 0;
              for (le = 0; le <= 143; )
                W[le * 2 + 1] = 8, le++, tt[8]++;
              for (; le <= 255; )
                W[le * 2 + 1] = 9, le++, tt[9]++;
              for (; le <= 279; )
                W[le * 2 + 1] = 7, le++, tt[7]++;
              for (; le <= 287; )
                W[le * 2 + 1] = 8, le++, tt[8]++;
              for (be(W, b + 1, tt), le = 0; le < M; le++)
                V[le * 2 + 1] = 5, V[le * 2] = Ce(le, 5);
              ie = new J(W, z, _ + 1, b, S), ne = new J(V, G, 0, M, S), ge = new J(new Array(0), B, 0, A, D);
            }
            function et(le) {
              var ke;
              for (ke = 0; ke < b; ke++)
                le.dyn_ltree[ke * 2] = 0;
              for (ke = 0; ke < M; ke++)
                le.dyn_dtree[ke * 2] = 0;
              for (ke = 0; ke < A; ke++)
                le.bl_tree[ke * 2] = 0;
              le.dyn_ltree[O * 2] = 1, le.opt_len = le.static_len = 0, le.last_lit = le.matches = 0;
            }
            function Ye(le) {
              le.bi_valid > 8 ? we(le, le.bi_buf) : le.bi_valid > 0 && (le.pending_buf[le.pending++] = le.bi_buf), le.bi_buf = 0, le.bi_valid = 0;
            }
            function De(le, ke, Ke, me) {
              Ye(le), we(le, Ke), we(le, ~Ke), o.arraySet(le.pending_buf, le.window, ke, Ke, le.pending), le.pending += Ke;
            }
            function Ue(le, ke, Ke, me) {
              var Ee = ke * 2, tt = Ke * 2;
              return le[Ee] < le[tt] || le[Ee] === le[tt] && me[ke] <= me[Ke];
            }
            function Qe(le, ke, Ke) {
              for (var me = le.heap[Ke], Ee = Ke << 1; Ee <= le.heap_len && (Ee < le.heap_len && Ue(ke, le.heap[Ee + 1], le.heap[Ee], le.depth) && Ee++, !Ue(ke, me, le.heap[Ee], le.depth)); )
                le.heap[Ke] = le.heap[Ee], Ke = Ee, Ee <<= 1;
              le.heap[Ke] = me;
            }
            function ue(le, ke, Ke) {
              var me, Ee, tt = 0, ce, _e;
              if (le.last_lit !== 0)
                do
                  me = le.pending_buf[le.d_buf + tt * 2] << 8 | le.pending_buf[le.d_buf + tt * 2 + 1], Ee = le.pending_buf[le.l_buf + tt], tt++, me === 0 ? Te(le, Ee, ke) : (ce = Z[Ee], Te(le, ce + _ + 1, ke), _e = z[ce], _e !== 0 && (Ee -= Q[ce], de(le, Ee, _e)), me--, ce = xe(me), Te(le, ce, Ke), _e = G[ce], _e !== 0 && (me -= q[ce], de(le, me, _e)));
                while (tt < le.last_lit);
              Te(le, O, ke);
            }
            function te(le, ke) {
              var Ke = ke.dyn_tree, me = ke.stat_desc.static_tree, Ee = ke.stat_desc.has_stree, tt = ke.stat_desc.elems, ce, _e, Ht = -1, K;
              for (le.heap_len = 0, le.heap_max = $, ce = 0; ce < tt; ce++)
                Ke[ce * 2] !== 0 ? (le.heap[++le.heap_len] = Ht = ce, le.depth[ce] = 0) : Ke[ce * 2 + 1] = 0;
              for (; le.heap_len < 2; )
                K = le.heap[++le.heap_len] = Ht < 2 ? ++Ht : 0, Ke[K * 2] = 1, le.depth[K] = 0, le.opt_len--, Ee && (le.static_len -= me[K * 2 + 1]);
              for (ke.max_code = Ht, ce = le.heap_len >> 1; ce >= 1; ce--)
                Qe(le, Ke, ce);
              K = tt;
              do
                ce = le.heap[
                  1
                  /*SMALLEST*/
                ], le.heap[
                  1
                  /*SMALLEST*/
                ] = le.heap[le.heap_len--], Qe(
                  le,
                  Ke,
                  1
                  /*SMALLEST*/
                ), _e = le.heap[
                  1
                  /*SMALLEST*/
                ], le.heap[--le.heap_max] = ce, le.heap[--le.heap_max] = _e, Ke[K * 2] = Ke[ce * 2] + Ke[_e * 2], le.depth[K] = (le.depth[ce] >= le.depth[_e] ? le.depth[ce] : le.depth[_e]) + 1, Ke[ce * 2 + 1] = Ke[_e * 2 + 1] = K, le.heap[
                  1
                  /*SMALLEST*/
                ] = K++, Qe(
                  le,
                  Ke,
                  1
                  /*SMALLEST*/
                );
              while (le.heap_len >= 2);
              le.heap[--le.heap_max] = le.heap[
                1
                /*SMALLEST*/
              ], Ae(le, ke), be(Ke, Ht, le.bl_count);
            }
            function Be(le, ke, Ke) {
              var me, Ee = -1, tt, ce = ke[0 * 2 + 1], _e = 0, Ht = 7, K = 4;
              for (ce === 0 && (Ht = 138, K = 3), ke[(Ke + 1) * 2 + 1] = 65535, me = 0; me <= Ke; me++)
                tt = ce, ce = ke[(me + 1) * 2 + 1], !(++_e < Ht && tt === ce) && (_e < K ? le.bl_tree[tt * 2] += _e : tt !== 0 ? (tt !== Ee && le.bl_tree[tt * 2]++, le.bl_tree[N * 2]++) : _e <= 10 ? le.bl_tree[j * 2]++ : le.bl_tree[L * 2]++, _e = 0, Ee = tt, ce === 0 ? (Ht = 138, K = 3) : tt === ce ? (Ht = 6, K = 3) : (Ht = 7, K = 4));
            }
            function Je(le, ke, Ke) {
              var me, Ee = -1, tt, ce = ke[0 * 2 + 1], _e = 0, Ht = 7, K = 4;
              for (ce === 0 && (Ht = 138, K = 3), me = 0; me <= Ke; me++)
                if (tt = ce, ce = ke[(me + 1) * 2 + 1], !(++_e < Ht && tt === ce)) {
                  if (_e < K)
                    do
                      Te(le, tt, le.bl_tree);
                    while (--_e !== 0);
                  else
                    tt !== 0 ? (tt !== Ee && (Te(le, tt, le.bl_tree), _e--), Te(le, N, le.bl_tree), de(le, _e - 3, 2)) : _e <= 10 ? (Te(le, j, le.bl_tree), de(le, _e - 3, 3)) : (Te(le, L, le.bl_tree), de(le, _e - 11, 7));
                  _e = 0, Ee = tt, ce === 0 ? (Ht = 138, K = 3) : tt === ce ? (Ht = 6, K = 3) : (Ht = 7, K = 4);
                }
            }
            function ft(le) {
              var ke;
              for (Be(le, le.dyn_ltree, le.l_desc.max_code), Be(le, le.dyn_dtree, le.d_desc.max_code), te(le, le.bl_desc), ke = A - 1; ke >= 3 && le.bl_tree[F[ke] * 2 + 1] === 0; ke--)
                ;
              return le.opt_len += 3 * (ke + 1) + 5 + 5 + 4, ke;
            }
            function lt(le, ke, Ke, me) {
              var Ee;
              for (de(le, ke - 257, 5), de(le, Ke - 1, 5), de(le, me - 4, 4), Ee = 0; Ee < me; Ee++)
                de(le, le.bl_tree[F[Ee] * 2 + 1], 3);
              Je(le, le.dyn_ltree, ke - 1), Je(le, le.dyn_dtree, Ke - 1);
            }
            function he(le) {
              var ke = 4093624447, Ke;
              for (Ke = 0; Ke <= 31; Ke++, ke >>>= 1)
                if (ke & 1 && le.dyn_ltree[Ke * 2] !== 0)
                  return u;
              if (le.dyn_ltree[18] !== 0 || le.dyn_ltree[20] !== 0 || le.dyn_ltree[26] !== 0)
                return f;
              for (Ke = 32; Ke < _; Ke++)
                if (le.dyn_ltree[Ke * 2] !== 0)
                  return f;
              return u;
            }
            var ae = !1;
            function se(le) {
              ae || (Fe(), ae = !0), le.l_desc = new ye(le.dyn_ltree, ie), le.d_desc = new ye(le.dyn_dtree, ne), le.bl_desc = new ye(le.bl_tree, ge), le.bi_buf = 0, le.bi_valid = 0, et(le);
            }
            function Re(le, ke, Ke, me) {
              de(le, (v << 1) + (me ? 1 : 0), 3), De(le, ke, Ke);
            }
            function Oe(le) {
              de(le, g << 1, 3), Te(le, O, W), ee(le);
            }
            function We(le, ke, Ke, me) {
              var Ee, tt, ce = 0;
              le.level > 0 ? (le.strm.data_type === h && (le.strm.data_type = he(le)), te(le, le.l_desc), te(le, le.d_desc), ce = ft(le), Ee = le.opt_len + 3 + 7 >>> 3, tt = le.static_len + 3 + 7 >>> 3, tt <= Ee && (Ee = tt)) : Ee = tt = Ke + 5, Ke + 4 <= Ee && ke !== -1 ? Re(le, ke, Ke, me) : le.strategy === l || tt === Ee ? (de(le, (g << 1) + (me ? 1 : 0), 3), ue(le, W, V)) : (de(le, (w << 1) + (me ? 1 : 0), 3), lt(le, le.l_desc.max_code + 1, le.d_desc.max_code + 1, ce + 1), ue(le, le.dyn_ltree, le.dyn_dtree)), et(le), me && Ye(le);
            }
            function Ct(le, ke, Ke) {
              return le.pending_buf[le.d_buf + le.last_lit * 2] = ke >>> 8 & 255, le.pending_buf[le.d_buf + le.last_lit * 2 + 1] = ke & 255, le.pending_buf[le.l_buf + le.last_lit] = Ke & 255, le.last_lit++, ke === 0 ? le.dyn_ltree[Ke * 2]++ : (le.matches++, ke--, le.dyn_ltree[(Z[Ke] + _ + 1) * 2]++, le.dyn_dtree[xe(ke) * 2]++), le.last_lit === le.lit_bufsize - 1;
            }
            e._tr_init = se, e._tr_stored_block = Re, e._tr_flush_block = We, e._tr_tally = Ct, e._tr_align = Oe;
          }
        ),
        /***/
        "./node_modules/upng-js/node_modules/pako/lib/zlib/zstream.js": (
          /*!********************************************************************!*\
            !*** ./node_modules/upng-js/node_modules/pako/lib/zlib/zstream.js ***!
            \********************************************************************/
          /***/
          (t) => {
            function e() {
              this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
            }
            t.exports = e;
          }
        ),
        /***/
        "./src/SurfaceWorker.js": (
          /*!******************************!*\
            !*** ./src/SurfaceWorker.js ***!
            \******************************/
          /***/
          () => {
            $3Dmol.workerString = (function() {
              self.onmessage = function(t) {
                var e = t.data, n = e.type;
                if (n < 0)
                  self.atomData = e.atoms, self.volume = e.volume, self.ps = new ProteinSurface();
                else {
                  var o = self.ps;
                  o.initparm(e.expandedExtent, n != 1, self.volume), o.fillvoxels(self.atomData, e.extendedAtoms), o.buildboundary(), (n === 4 || n === 2) && (o.fastdistancemap(), o.boundingatom(!1), o.fillvoxelswaals(self.atomData, e.extendedAtoms)), o.marchingcube(n);
                  var l = o.getFacesAndVertices(e.atomsToShow);
                  self.postMessage(l);
                }
              };
            }).toString().replace(/(^.*?\{|\}$)/g, ""), $3Dmol.workerString += `;
function _classCallCheck() {};`, $3Dmol.workerString += `;
` + $3Dmol.Vector3.toString(), $3Dmol.workerString += `;
` + $3Dmol.MarchingCubeInitializer.toString() + `;

`, $3Dmol.workerString += `;
` + $3Dmol.PointGrid.toString() + `;
`, $3Dmol.workerString += `;
var ProteinSurface = ` + $3Dmol.ProteinSurface.toString() + `;
`, $3Dmol.SurfaceWorker = window.URL ? window.URL.createObjectURL(new Blob([$3Dmol.workerString], { type: "text/javascript" })) : void 0;
          }
        ),
        /***/
        "./src/exporter.js": (
          /*!*************************!*\
            !*** ./src/exporter.js ***!
            \*************************/
          /***/
          (t) => {
            typeof t.exports == "object" && (t.exports = window.$3Dmol);
          }
        ),
        /***/
        "./src/vendor/mmtf.js": (
          /*!****************************!*\
            !*** ./src/vendor/mmtf.js ***!
            \****************************/
          /***/
          function(t, e) {
            (function(n, o) {
              o(e);
            })(this, function(n) {
              function o(he, ae, se) {
                for (var Re = (he.byteLength, 0), Oe = se.length; Oe > Re; Re++) {
                  var We = se.charCodeAt(Re);
                  if (128 > We)
                    he.setUint8(ae++, We >>> 0 & 127 | 0);
                  else if (2048 > We)
                    he.setUint8(ae++, We >>> 6 & 31 | 192), he.setUint8(ae++, We >>> 0 & 63 | 128);
                  else if (65536 > We)
                    he.setUint8(ae++, We >>> 12 & 15 | 224), he.setUint8(ae++, We >>> 6 & 63 | 128), he.setUint8(ae++, We >>> 0 & 63 | 128);
                  else {
                    if (!(1114112 > We))
                      throw new Error("bad codepoint " + We);
                    he.setUint8(ae++, We >>> 18 & 7 | 240), he.setUint8(ae++, We >>> 12 & 63 | 128), he.setUint8(ae++, We >>> 6 & 63 | 128), he.setUint8(ae++, We >>> 0 & 63 | 128);
                  }
                }
              }
              function l(he) {
                for (var ae = 0, se = 0, Re = he.length; Re > se; se++) {
                  var Oe = he.charCodeAt(se);
                  if (128 > Oe)
                    ae += 1;
                  else if (2048 > Oe)
                    ae += 2;
                  else if (65536 > Oe)
                    ae += 3;
                  else {
                    if (!(1114112 > Oe))
                      throw new Error("bad codepoint " + Oe);
                    ae += 4;
                  }
                }
                return ae;
              }
              function u(he, ae, se) {
                var Re = typeof he;
                if (Re === "string") {
                  var Oe = l(he);
                  if (32 > Oe)
                    return ae.setUint8(se, 160 | Oe), o(ae, se + 1, he), 1 + Oe;
                  if (256 > Oe)
                    return ae.setUint8(se, 217), ae.setUint8(se + 1, Oe), o(ae, se + 2, he), 2 + Oe;
                  if (65536 > Oe)
                    return ae.setUint8(se, 218), ae.setUint16(se + 1, Oe), o(ae, se + 3, he), 3 + Oe;
                  if (4294967296 > Oe)
                    return ae.setUint8(se, 219), ae.setUint32(se + 1, Oe), o(ae, se + 5, he), 5 + Oe;
                }
                if (he instanceof Uint8Array) {
                  var Oe = he.byteLength, We = new Uint8Array(ae.buffer);
                  if (256 > Oe)
                    return ae.setUint8(se, 196), ae.setUint8(se + 1, Oe), We.set(he, se + 2), 2 + Oe;
                  if (65536 > Oe)
                    return ae.setUint8(se, 197), ae.setUint16(se + 1, Oe), We.set(he, se + 3), 3 + Oe;
                  if (4294967296 > Oe)
                    return ae.setUint8(se, 198), ae.setUint32(se + 1, Oe), We.set(he, se + 5), 5 + Oe;
                }
                if (Re === "number") {
                  if (!isFinite(he))
                    throw new Error("Number not finite: " + he);
                  if (Math.floor(he) !== he)
                    return ae.setUint8(se, 203), ae.setFloat64(se + 1, he), 9;
                  if (he >= 0) {
                    if (128 > he)
                      return ae.setUint8(se, he), 1;
                    if (256 > he)
                      return ae.setUint8(se, 204), ae.setUint8(se + 1, he), 2;
                    if (65536 > he)
                      return ae.setUint8(se, 205), ae.setUint16(se + 1, he), 3;
                    if (4294967296 > he)
                      return ae.setUint8(se, 206), ae.setUint32(se + 1, he), 5;
                    throw new Error("Number too big 0x" + he.toString(16));
                  }
                  if (he >= -32)
                    return ae.setInt8(se, he), 1;
                  if (he >= -128)
                    return ae.setUint8(se, 208), ae.setInt8(se + 1, he), 2;
                  if (he >= -32768)
                    return ae.setUint8(se, 209), ae.setInt16(se + 1, he), 3;
                  if (he >= -2147483648)
                    return ae.setUint8(se, 210), ae.setInt32(se + 1, he), 5;
                  throw new Error("Number too small -0x" + (-he).toString(16).substr(1));
                }
                if (he === null)
                  return ae.setUint8(se, 192), 1;
                if (Re === "boolean")
                  return ae.setUint8(se, he ? 195 : 194), 1;
                if (Re === "object") {
                  var Oe, ke = 0, Ct = Array.isArray(he);
                  if (Ct)
                    Oe = he.length;
                  else {
                    var le = Object.keys(he);
                    Oe = le.length;
                  }
                  var ke;
                  if (16 > Oe ? (ae.setUint8(se, Oe | (Ct ? 144 : 128)), ke = 1) : 65536 > Oe ? (ae.setUint8(se, Ct ? 220 : 222), ae.setUint16(se + 1, Oe), ke = 3) : 4294967296 > Oe && (ae.setUint8(se, Ct ? 221 : 223), ae.setUint32(se + 1, Oe), ke = 5), Ct)
                    for (var Ke = 0; Oe > Ke; Ke++)
                      ke += u(he[Ke], ae, se + ke);
                  else
                    for (var Ke = 0; Oe > Ke; Ke++) {
                      var me = le[Ke];
                      ke += u(me, ae, se + ke), ke += u(he[me], ae, se + ke);
                    }
                  return ke;
                }
                throw new Error("Unknown type " + Re);
              }
              function f(he) {
                var ae = typeof he;
                if (ae === "string") {
                  var se = l(he);
                  if (32 > se)
                    return 1 + se;
                  if (256 > se)
                    return 2 + se;
                  if (65536 > se)
                    return 3 + se;
                  if (4294967296 > se)
                    return 5 + se;
                }
                if (he instanceof Uint8Array) {
                  var se = he.byteLength;
                  if (256 > se)
                    return 2 + se;
                  if (65536 > se)
                    return 3 + se;
                  if (4294967296 > se)
                    return 5 + se;
                }
                if (ae === "number") {
                  if (Math.floor(he) !== he)
                    return 9;
                  if (he >= 0) {
                    if (128 > he)
                      return 1;
                    if (256 > he)
                      return 2;
                    if (65536 > he)
                      return 3;
                    if (4294967296 > he)
                      return 5;
                    throw new Error("Number too big 0x" + he.toString(16));
                  }
                  if (he >= -32)
                    return 1;
                  if (he >= -128)
                    return 2;
                  if (he >= -32768)
                    return 3;
                  if (he >= -2147483648)
                    return 5;
                  throw new Error("Number too small -0x" + he.toString(16).substr(1));
                }
                if (ae === "boolean" || he === null)
                  return 1;
                if (ae === "object") {
                  var se, Re = 0;
                  if (Array.isArray(he)) {
                    se = he.length;
                    for (var Oe = 0; se > Oe; Oe++)
                      Re += f(he[Oe]);
                  } else {
                    var We = Object.keys(he);
                    se = We.length;
                    for (var Oe = 0; se > Oe; Oe++) {
                      var Ct = We[Oe];
                      Re += f(Ct) + f(he[Ct]);
                    }
                  }
                  if (16 > se)
                    return 1 + Re;
                  if (65536 > se)
                    return 3 + Re;
                  if (4294967296 > se)
                    return 5 + Re;
                  throw new Error("Array or object too long 0x" + se.toString(16));
                }
                throw new Error("Unknown type " + ae);
              }
              function h(he) {
                var ae = new ArrayBuffer(f(he)), se = new DataView(ae);
                return u(he, se, 0), new Uint8Array(ae);
              }
              function p(he, ae, se) {
                return ae ? new he(ae.buffer, ae.byteOffset, ae.byteLength / (se || 1)) : void 0;
              }
              function v(he) {
                return p(DataView, he);
              }
              function g(he) {
                return p(Uint8Array, he);
              }
              function w(he) {
                return p(Int8Array, he);
              }
              function E(he) {
                return p(Int32Array, he, 4);
              }
              function T(he) {
                return p(Float32Array, he, 4);
              }
              function R(he, ae) {
                var se = he.length / 2;
                ae || (ae = new Int16Array(se));
                for (var Re = 0, Oe = 0; se > Re; ++Re, Oe += 2)
                  ae[Re] = he[Oe] << 8 ^ he[Oe + 1] << 0;
                return ae;
              }
              function _(he, ae) {
                var se = he.length;
                ae || (ae = new Uint8Array(2 * se));
                for (var Re = v(ae), Oe = 0; se > Oe; ++Oe)
                  Re.setInt16(2 * Oe, he[Oe]);
                return g(ae);
              }
              function b(he, ae) {
                var se = he.length / 4;
                ae || (ae = new Int32Array(se));
                for (var Re = 0, Oe = 0; se > Re; ++Re, Oe += 4)
                  ae[Re] = he[Oe] << 24 ^ he[Oe + 1] << 16 ^ he[Oe + 2] << 8 ^ he[Oe + 3] << 0;
                return ae;
              }
              function M(he, ae) {
                var se = he.length;
                ae || (ae = new Uint8Array(4 * se));
                for (var Re = v(ae), Oe = 0; se > Oe; ++Oe)
                  Re.setInt32(4 * Oe, he[Oe]);
                return g(ae);
              }
              function A(he, ae) {
                var se = he.length;
                ae || (ae = new Float32Array(se / 4));
                for (var Re = v(ae), Oe = v(he), We = 0, Ct = 0, le = se / 4; le > We; ++We, Ct += 4)
                  Re.setFloat32(Ct, Oe.getFloat32(Ct), !0);
                return ae;
              }
              function $(he, ae, se) {
                var Re = he.length, Oe = 1 / ae;
                se || (se = new Float32Array(Re));
                for (var We = 0; Re > We; ++We)
                  se[We] = he[We] * Oe;
                return se;
              }
              function S(he, ae, se) {
                var Re = he.length;
                se || (se = new Int32Array(Re));
                for (var Oe = 0; Re > Oe; ++Oe)
                  se[Oe] = Math.round(he[Oe] * ae);
                return se;
              }
              function C(he, ae) {
                var se, Re;
                if (!ae) {
                  var Oe = 0;
                  for (se = 0, Re = he.length; Re > se; se += 2)
                    Oe += he[se + 1];
                  ae = new he.constructor(Oe);
                }
                var We = 0;
                for (se = 0, Re = he.length; Re > se; se += 2)
                  for (var Ct = he[se], le = he[se + 1], ke = 0; le > ke; ++ke)
                    ae[We] = Ct, ++We;
                return ae;
              }
              function D(he) {
                if (he.length === 0)
                  return new Int32Array();
                var ae, se, Re = 2;
                for (ae = 1, se = he.length; se > ae; ++ae)
                  he[ae - 1] !== he[ae] && (Re += 2);
                var Oe = new Int32Array(Re), We = 0, Ct = 1;
                for (ae = 1, se = he.length; se > ae; ++ae)
                  he[ae - 1] !== he[ae] ? (Oe[We] = he[ae - 1], Oe[We + 1] = Ct, Ct = 1, We += 2) : ++Ct;
                return Oe[We] = he[he.length - 1], Oe[We + 1] = Ct, Oe;
              }
              function O(he, ae) {
                var se = he.length;
                ae || (ae = new he.constructor(se)), se && (ae[0] = he[0]);
                for (var Re = 1; se > Re; ++Re)
                  ae[Re] = he[Re] + ae[Re - 1];
                return ae;
              }
              function N(he, ae) {
                var se = he.length;
                ae || (ae = new he.constructor(se)), ae[0] = he[0];
                for (var Re = 1; se > Re; ++Re)
                  ae[Re] = he[Re] - he[Re - 1];
                return ae;
              }
              function j(he, ae) {
                var se, Re, Oe = he instanceof Int8Array ? 127 : 32767, We = -Oe - 1, Ct = he.length;
                if (!ae) {
                  var le = 0;
                  for (se = 0; Ct > se; ++se)
                    he[se] < Oe && he[se] > We && ++le;
                  ae = new Int32Array(le);
                }
                for (se = 0, Re = 0; Ct > se; ) {
                  for (var ke = 0; he[se] === Oe || he[se] === We; )
                    ke += he[se], ++se;
                  ke += he[se], ++se, ae[Re] = ke, ++Re;
                }
                return ae;
              }
              function L(he, ae) {
                var se, Re = 32767, Oe = -Re - 1, We = he.length, Ct = 0;
                for (se = 0; We > se; ++se) {
                  var le = he[se];
                  le === 0 ? ++Ct : le > 0 ? (Ct += Math.ceil(le / Re), le % Re === 0 && (Ct += 1)) : (Ct += Math.ceil(le / Oe), le % Oe === 0 && (Ct += 1));
                }
                var ke = new Int16Array(Ct), Ke = 0;
                for (se = 0; We > se; ++se) {
                  var le = he[se];
                  if (le >= 0)
                    for (; le >= Re; )
                      ke[Ke] = Re, ++Ke, le -= Re;
                  else
                    for (; Oe >= le; )
                      ke[Ke] = Oe, ++Ke, le -= Oe;
                  ke[Ke] = le, ++Ke;
                }
                return ke;
              }
              function z(he, ae) {
                return O(C(he), ae);
              }
              function G(he) {
                return D(N(he));
              }
              function B(he, ae, se) {
                return $(C(he, E(se)), ae, se);
              }
              function F(he, ae) {
                return D(S(he, ae));
              }
              function H(he, ae, se) {
                return $(O(he, E(se)), ae, se);
              }
              function W(he, ae, se) {
                return N(S(he, ae), se);
              }
              function V(he, ae, se) {
                return $(j(he, E(se)), ae, se);
              }
              function X(he, ae, se) {
                var Re = j(he, E(se));
                return H(Re, ae, T(Re));
              }
              function Z(he, ae, se) {
                return L(W(he, ae));
              }
              function Q(We) {
                var ae = v(We), se = ae.getInt32(0), Re = ae.getInt32(4), Oe = We.subarray(8, 12), We = We.subarray(12);
                return [se, We, Re, Oe];
              }
              function q(he, ae, se, Re) {
                var Oe = new ArrayBuffer(12 + Re.byteLength), We = new Uint8Array(Oe), Ct = new DataView(Oe);
                return Ct.setInt32(0, he), Ct.setInt32(4, ae), se && We.set(se, 8), We.set(Re, 12), We;
              }
              function J(he) {
                var ae = he.length, se = g(he);
                return q(2, ae, void 0, se);
              }
              function ie(he) {
                var ae = he.length, se = M(he);
                return q(4, ae, void 0, se);
              }
              function ne(he, ae) {
                var se = he.length / ae, Re = M([ae]), Oe = g(he);
                return q(5, se, Re, Oe);
              }
              function ge(he) {
                var ae = he.length, se = M(D(he));
                return q(6, ae, void 0, se);
              }
              function ye(he) {
                var ae = he.length, se = M(G(he));
                return q(8, ae, void 0, se);
              }
              function xe(he, ae) {
                var se = he.length, Re = M([ae]), Oe = M(F(he, ae));
                return q(9, se, Re, Oe);
              }
              function we(he, ae) {
                var se = he.length, Re = M([ae]), Oe = _(Z(he, ae));
                return q(10, se, Re, Oe);
              }
              function de(he) {
                var ae = {};
                return Qe.forEach(function(se) {
                  he[se] !== void 0 && (ae[se] = he[se]);
                }), he.bondAtomList && (ae.bondAtomList = ie(he.bondAtomList)), he.bondOrderList && (ae.bondOrderList = J(he.bondOrderList)), ae.xCoordList = we(he.xCoordList, 1e3), ae.yCoordList = we(he.yCoordList, 1e3), ae.zCoordList = we(he.zCoordList, 1e3), he.bFactorList && (ae.bFactorList = we(he.bFactorList, 100)), he.atomIdList && (ae.atomIdList = ye(he.atomIdList)), he.altLocList && (ae.altLocList = ge(he.altLocList)), he.occupancyList && (ae.occupancyList = xe(he.occupancyList, 100)), ae.groupIdList = ye(he.groupIdList), ae.groupTypeList = ie(he.groupTypeList), he.secStructList && (ae.secStructList = J(he.secStructList)), he.insCodeList && (ae.insCodeList = ge(he.insCodeList)), he.sequenceIndexList && (ae.sequenceIndexList = ye(he.sequenceIndexList)), ae.chainIdList = ne(he.chainIdList, 4), he.chainNameList && (ae.chainNameList = ne(he.chainNameList, 4)), ae;
              }
              function Te(he) {
                function ae(ke) {
                  for (var Ke = {}, me = 0; ke > me; me++) {
                    var Ee = We();
                    Ke[Ee] = We();
                  }
                  return Ke;
                }
                function se(ke) {
                  var Ke = he.subarray(Ct, Ct + ke);
                  return Ct += ke, Ke;
                }
                function Re(ke) {
                  var Ke = he.subarray(Ct, Ct + ke);
                  Ct += ke;
                  var me = 65535;
                  if (ke > me) {
                    for (var Ee = [], tt = 0; tt < Ke.length; tt += me)
                      Ee.push(String.fromCharCode.apply(null, Ke.subarray(tt, tt + me)));
                    return Ee.join("");
                  }
                  return String.fromCharCode.apply(null, Ke);
                }
                function Oe(ke) {
                  for (var Ke = new Array(ke), me = 0; ke > me; me++)
                    Ke[me] = We();
                  return Ke;
                }
                function We() {
                  var ke, Ke, me = he[Ct];
                  if (!(128 & me))
                    return Ct++, me;
                  if ((240 & me) === 128)
                    return Ke = 15 & me, Ct++, ae(Ke);
                  if ((240 & me) === 144)
                    return Ke = 15 & me, Ct++, Oe(Ke);
                  if ((224 & me) === 160)
                    return Ke = 31 & me, Ct++, Re(Ke);
                  if ((224 & me) === 224)
                    return ke = le.getInt8(Ct), Ct++, ke;
                  switch (me) {
                    case 192:
                      return Ct++, null;
                    case 194:
                      return Ct++, !1;
                    case 195:
                      return Ct++, !0;
                    case 196:
                      return Ke = le.getUint8(Ct + 1), Ct += 2, se(Ke);
                    case 197:
                      return Ke = le.getUint16(Ct + 1), Ct += 3, se(Ke);
                    case 198:
                      return Ke = le.getUint32(Ct + 1), Ct += 5, se(Ke);
                    case 202:
                      return ke = le.getFloat32(Ct + 1), Ct += 5, ke;
                    case 203:
                      return ke = le.getFloat64(Ct + 1), Ct += 9, ke;
                    case 204:
                      return ke = he[Ct + 1], Ct += 2, ke;
                    case 205:
                      return ke = le.getUint16(Ct + 1), Ct += 3, ke;
                    case 206:
                      return ke = le.getUint32(Ct + 1), Ct += 5, ke;
                    case 208:
                      return ke = le.getInt8(Ct + 1), Ct += 2, ke;
                    case 209:
                      return ke = le.getInt16(Ct + 1), Ct += 3, ke;
                    case 210:
                      return ke = le.getInt32(Ct + 1), Ct += 5, ke;
                    case 217:
                      return Ke = le.getUint8(Ct + 1), Ct += 2, Re(Ke);
                    case 218:
                      return Ke = le.getUint16(Ct + 1), Ct += 3, Re(Ke);
                    case 219:
                      return Ke = le.getUint32(Ct + 1), Ct += 5, Re(Ke);
                    case 220:
                      return Ke = le.getUint16(Ct + 1), Ct += 3, Oe(Ke);
                    case 221:
                      return Ke = le.getUint32(Ct + 1), Ct += 5, Oe(Ke);
                    case 222:
                      return Ke = le.getUint16(Ct + 1), Ct += 3, ae(Ke);
                    case 223:
                      return Ke = le.getUint32(Ct + 1), Ct += 5, ae(Ke);
                  }
                  throw new Error("Unknown type 0x" + me.toString(16));
                }
                var Ct = 0, le = new DataView(he.buffer);
                return We();
              }
              function Ce(he, ae, se, Re) {
                switch (he) {
                  case 1:
                    return A(ae);
                  case 2:
                    return w(ae);
                  case 3:
                    return R(ae);
                  case 4:
                    return b(ae);
                  case 5:
                    return g(ae);
                  case 6:
                    return C(b(ae), new Uint8Array(se));
                  case 7:
                    return C(b(ae));
                  case 8:
                    return z(b(ae));
                  case 9:
                    return B(b(ae), b(Re)[0]);
                  case 10:
                    return X(R(ae), b(Re)[0]);
                  case 11:
                    return $(R(ae), b(Re)[0]);
                  case 12:
                    return V(R(ae), b(Re)[0]);
                  case 13:
                    return V(w(ae), b(Re)[0]);
                  case 14:
                    return j(R(ae));
                  case 15:
                    return j(w(ae));
                }
              }
              function ee(he, ae) {
                ae = ae || {};
                var se = ae.ignoreFields, Re = {};
                return te.forEach(function(Oe) {
                  var We = se ? se.indexOf(Oe) !== -1 : !1, Ct = he[Oe];
                  We || Ct === void 0 || (Ct instanceof Uint8Array ? Re[Oe] = Ce.apply(null, Q(Ct)) : Re[Oe] = Ct);
                }), Re;
              }
              function Ae(he) {
                return String.fromCharCode.apply(null, he).replace(/\0/g, "");
              }
              function be(he, ae, se) {
                se = se || {};
                var Re, Oe, We, Ct, le, ke, Ke = se.firstModelOnly, me = ae.onModel, Ee = ae.onChain, tt = ae.onGroup, ce = ae.onAtom, _e = ae.onBond, Ht = 0, K = 0, Ve = 0, Ne = 0, pe = 0, Le = -1, bt = he.chainNameList, yi = he.secStructList, _n = he.insCodeList, Do = he.sequenceIndexList, ms = he.atomIdList, Bp = he.bFactorList, Sp = he.altLocList, Tp = he.occupancyList, Pp = he.bondAtomList, Xe = he.bondOrderList;
                for (Re = 0, Oe = he.chainsPerModel.length; Oe > Re && !(Ke && Ht > 0); ++Re) {
                  var Se = he.chainsPerModel[Ht];
                  for (me && me({ chainCount: Se, modelIndex: Ht }), We = 0; Se > We; ++We) {
                    var pr = he.groupsPerChain[K];
                    if (Ee) {
                      var mn = Ae(he.chainIdList.subarray(4 * K, 4 * K + 4)), Si = null;
                      bt && (Si = Ae(bt.subarray(4 * K, 4 * K + 4))), Ee({ groupCount: pr, chainIndex: K, modelIndex: Ht, chainId: mn, chainName: Si });
                    }
                    for (Ct = 0; pr > Ct; ++Ct) {
                      var Io = he.groupList[he.groupTypeList[Ve]], ve = Io.atomNameList.length;
                      if (tt) {
                        var He = null;
                        yi && (He = yi[Ve]);
                        var nt = null;
                        he.insCodeList && (nt = String.fromCharCode(_n[Ve]));
                        var dr = null;
                        Do && (dr = Do[Ve]), tt({ atomCount: ve, groupIndex: Ve, chainIndex: K, modelIndex: Ht, groupId: he.groupIdList[Ve], groupType: he.groupTypeList[Ve], groupName: Io.groupName, singleLetterCode: Io.singleLetterCode, chemCompType: Io.chemCompType, secStruct: He, insCode: nt, sequenceIndex: dr });
                      }
                      for (le = 0; ve > le; ++le) {
                        if (ce) {
                          var dt = null;
                          ms && (dt = ms[Ne]);
                          var ci = null;
                          Bp && (ci = Bp[Ne]);
                          var Uo = null;
                          Sp && (Uo = String.fromCharCode(Sp[Ne]));
                          var xs = null;
                          Tp && (xs = Tp[Ne]), ce({ atomIndex: Ne, groupIndex: Ve, chainIndex: K, modelIndex: Ht, atomId: dt, element: Io.elementList[le], atomName: Io.atomNameList[le], formalCharge: Io.formalChargeList[le], xCoord: he.xCoordList[Ne], yCoord: he.yCoordList[Ne], zCoord: he.zCoordList[Ne], bFactor: ci, altLoc: Uo, occupancy: xs });
                        }
                        Ne += 1;
                      }
                      if (_e) {
                        var vs = Io.bondAtomList;
                        for (le = 0, ke = Io.bondOrderList.length; ke > le; ++le)
                          _e({ atomIndex1: Ne - ve + vs[2 * le], atomIndex2: Ne - ve + vs[2 * le + 1], bondOrder: Io.bondOrderList[le] });
                      }
                      Ve += 1;
                    }
                    K += 1;
                  }
                  if (pe = Le + 1, Le = Ne - 1, _e && Pp)
                    for (le = 0, ke = Pp.length; ke > le; le += 2) {
                      var bp = Pp[le], Ep = Pp[le + 1];
                      (bp >= pe && Le >= bp || Ep >= pe && Le >= Ep) && _e({ atomIndex1: bp, atomIndex2: Ep, bondOrder: Xe ? Xe[le / 2] : null });
                    }
                  Ht += 1;
                }
              }
              function Fe(he) {
                return h(de(he));
              }
              function et(he, ae) {
                he instanceof ArrayBuffer && (he = new Uint8Array(he));
                var se;
                return se = he instanceof Uint8Array ? Te(he) : he, ee(se, ae);
              }
              function Ye(he, ae, se, Re) {
                function Oe() {
                  try {
                    var Ct = et(We.response);
                    se(Ct);
                  } catch (le) {
                    Re(le);
                  }
                }
                var We = new XMLHttpRequest();
                We.addEventListener("load", Oe, !0), We.addEventListener("error", Re, !0), We.responseType = "arraybuffer", We.open("GET", ae + he.toUpperCase()), We.send();
              }
              function De(he, ae, se) {
                Ye(he, ft, ae, se);
              }
              function Ue(he, ae, se) {
                Ye(he, lt, ae, se);
              }
              var Qe = ["mmtfVersion", "mmtfProducer", "unitCell", "spaceGroup", "structureId", "title", "depositionDate", "releaseDate", "experimentalMethods", "resolution", "rFree", "rWork", "bioAssemblyList", "ncsOperatorList", "entityList", "groupList", "numBonds", "numAtoms", "numGroups", "numChains", "numModels", "groupsPerChain", "chainsPerModel"], ue = ["xCoordList", "yCoordList", "zCoordList", "groupIdList", "groupTypeList", "chainIdList", "bFactorList", "atomIdList", "altLocList", "occupancyList", "secStructList", "insCodeList", "sequenceIndexList", "chainNameList", "bondAtomList", "bondOrderList"], te = Qe.concat(ue), Be = "v1.0.1", Je = "//mmtf.rcsb.org/v1.0/", ft = Je + "full/", lt = Je + "reduced/";
              n.encode = Fe, n.decode = et, n.traverse = be, n.fetch = De, n.fetchReduced = Ue, n.version = Be, n.fetchUrl = ft, n.fetchReducedUrl = lt, n.encodeMsgpack = h, n.encodeMmtf = de, n.decodeMsgpack = Te, n.decodeMmtf = ee;
            });
          }
        ),
        /***/
        "./node_modules/pako/dist/pako.esm.mjs": (
          /*!*********************************************!*\
            !*** ./node_modules/pako/dist/pako.esm.mjs ***!
            \*********************************************/
          /***/
          (t, e, n) => {
            n.r(e), n.d(e, {
              /* harmony export */
              Deflate: () => (
                /* binding */
                Zg
              ),
              /* harmony export */
              Inflate: () => (
                /* binding */
                ty
              ),
              /* harmony export */
              constants: () => (
                /* binding */
                ay
              ),
              /* harmony export */
              default: () => (
                /* binding */
                Kv
              ),
              /* harmony export */
              deflate: () => (
                /* binding */
                Qg
              ),
              /* harmony export */
              deflateRaw: () => (
                /* binding */
                Jg
              ),
              /* harmony export */
              gzip: () => (
                /* binding */
                ey
              ),
              /* harmony export */
              inflate: () => (
                /* binding */
                ry
              ),
              /* harmony export */
              inflateRaw: () => (
                /* binding */
                ny
              ),
              /* harmony export */
              ungzip: () => (
                /* binding */
                iy
              )
              /* harmony export */
            });
            /*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
            const o = 4, l = 0, u = 1, f = 2;
            function h(U) {
              let fe = U.length;
              for (; --fe >= 0; )
                U[fe] = 0;
            }
            const p = 0, v = 1, g = 2, w = 3, E = 258, T = 29, R = 256, _ = R + 1 + T, b = 30, M = 19, A = 2 * _ + 1, $ = 15, S = 16, C = 7, D = 256, O = 16, N = 17, j = 18, L = (
              /* extra bits for each length code */
              new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
            ), z = (
              /* extra bits for each distance code */
              new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
            ), G = (
              /* extra bits for each bit length code */
              new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
            ), B = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), F = 512, H = new Array((_ + 2) * 2);
            h(H);
            const W = new Array(b * 2);
            h(W);
            const V = new Array(F);
            h(V);
            const X = new Array(E - w + 1);
            h(X);
            const Z = new Array(T);
            h(Z);
            const Q = new Array(b);
            h(Q);
            function q(U, fe, Y, Me, Pe) {
              this.static_tree = U, this.extra_bits = fe, this.extra_base = Y, this.elems = Me, this.max_length = Pe, this.has_stree = U && U.length;
            }
            let J, ie, ne;
            function ge(U, fe) {
              this.dyn_tree = U, this.max_code = 0, this.stat_desc = fe;
            }
            const ye = (U) => U < 256 ? V[U] : V[256 + (U >>> 7)], xe = (U, fe) => {
              U.pending_buf[U.pending++] = fe & 255, U.pending_buf[U.pending++] = fe >>> 8 & 255;
            }, we = (U, fe, Y) => {
              U.bi_valid > S - Y ? (U.bi_buf |= fe << U.bi_valid & 65535, xe(U, U.bi_buf), U.bi_buf = fe >> S - U.bi_valid, U.bi_valid += Y - S) : (U.bi_buf |= fe << U.bi_valid & 65535, U.bi_valid += Y);
            }, de = (U, fe, Y) => {
              we(
                U,
                Y[fe * 2],
                Y[fe * 2 + 1]
                /*.Len*/
              );
            }, Te = (U, fe) => {
              let Y = 0;
              do
                Y |= U & 1, U >>>= 1, Y <<= 1;
              while (--fe > 0);
              return Y >>> 1;
            }, Ce = (U) => {
              U.bi_valid === 16 ? (xe(U, U.bi_buf), U.bi_buf = 0, U.bi_valid = 0) : U.bi_valid >= 8 && (U.pending_buf[U.pending++] = U.bi_buf & 255, U.bi_buf >>= 8, U.bi_valid -= 8);
            }, ee = (U, fe) => {
              const Y = fe.dyn_tree, Me = fe.max_code, Pe = fe.stat_desc.static_tree, Ze = fe.stat_desc.has_stree, pn = fe.stat_desc.extra_bits, mr = fe.stat_desc.extra_base, yp = fe.stat_desc.max_length;
              let it, _r, Up, Lo, Ei, Wp, Yp = 0;
              for (Lo = 0; Lo <= $; Lo++)
                U.bl_count[Lo] = 0;
              for (Y[U.heap[U.heap_max] * 2 + 1] = 0, it = U.heap_max + 1; it < A; it++)
                _r = U.heap[it], Lo = Y[Y[_r * 2 + 1] * 2 + 1] + 1, Lo > yp && (Lo = yp, Yp++), Y[_r * 2 + 1] = Lo, !(_r > Me) && (U.bl_count[Lo]++, Ei = 0, _r >= mr && (Ei = pn[_r - mr]), Wp = Y[_r * 2], U.opt_len += Wp * (Lo + Ei), Ze && (U.static_len += Wp * (Pe[_r * 2 + 1] + Ei)));
              if (Yp !== 0) {
                do {
                  for (Lo = yp - 1; U.bl_count[Lo] === 0; )
                    Lo--;
                  U.bl_count[Lo]--, U.bl_count[Lo + 1] += 2, U.bl_count[yp]--, Yp -= 2;
                } while (Yp > 0);
                for (Lo = yp; Lo !== 0; Lo--)
                  for (_r = U.bl_count[Lo]; _r !== 0; )
                    Up = U.heap[--it], !(Up > Me) && (Y[Up * 2 + 1] !== Lo && (U.opt_len += (Lo - Y[Up * 2 + 1]) * Y[Up * 2], Y[Up * 2 + 1] = Lo), _r--);
              }
            }, Ae = (U, fe, Y) => {
              const Me = new Array($ + 1);
              let Pe = 0, Ze, pn;
              for (Ze = 1; Ze <= $; Ze++)
                Pe = Pe + Y[Ze - 1] << 1, Me[Ze] = Pe;
              for (pn = 0; pn <= fe; pn++) {
                let mr = U[pn * 2 + 1];
                mr !== 0 && (U[pn * 2] = Te(Me[mr]++, mr));
              }
            }, be = () => {
              let U, fe, Y, Me, Pe;
              const Ze = new Array($ + 1);
              for (Y = 0, Me = 0; Me < T - 1; Me++)
                for (Z[Me] = Y, U = 0; U < 1 << L[Me]; U++)
                  X[Y++] = Me;
              for (X[Y - 1] = Me, Pe = 0, Me = 0; Me < 16; Me++)
                for (Q[Me] = Pe, U = 0; U < 1 << z[Me]; U++)
                  V[Pe++] = Me;
              for (Pe >>= 7; Me < b; Me++)
                for (Q[Me] = Pe << 7, U = 0; U < 1 << z[Me] - 7; U++)
                  V[256 + Pe++] = Me;
              for (fe = 0; fe <= $; fe++)
                Ze[fe] = 0;
              for (U = 0; U <= 143; )
                H[U * 2 + 1] = 8, U++, Ze[8]++;
              for (; U <= 255; )
                H[U * 2 + 1] = 9, U++, Ze[9]++;
              for (; U <= 279; )
                H[U * 2 + 1] = 7, U++, Ze[7]++;
              for (; U <= 287; )
                H[U * 2 + 1] = 8, U++, Ze[8]++;
              for (Ae(H, _ + 1, Ze), U = 0; U < b; U++)
                W[U * 2 + 1] = 5, W[U * 2] = Te(U, 5);
              J = new q(H, L, R + 1, _, $), ie = new q(W, z, 0, b, $), ne = new q(new Array(0), G, 0, M, C);
            }, Fe = (U) => {
              let fe;
              for (fe = 0; fe < _; fe++)
                U.dyn_ltree[fe * 2] = 0;
              for (fe = 0; fe < b; fe++)
                U.dyn_dtree[fe * 2] = 0;
              for (fe = 0; fe < M; fe++)
                U.bl_tree[fe * 2] = 0;
              U.dyn_ltree[D * 2] = 1, U.opt_len = U.static_len = 0, U.sym_next = U.matches = 0;
            }, et = (U) => {
              U.bi_valid > 8 ? xe(U, U.bi_buf) : U.bi_valid > 0 && (U.pending_buf[U.pending++] = U.bi_buf), U.bi_buf = 0, U.bi_valid = 0;
            }, Ye = (U, fe, Y, Me) => {
              const Pe = fe * 2, Ze = Y * 2;
              return U[Pe] < U[Ze] || U[Pe] === U[Ze] && Me[fe] <= Me[Y];
            }, De = (U, fe, Y) => {
              const Me = U.heap[Y];
              let Pe = Y << 1;
              for (; Pe <= U.heap_len && (Pe < U.heap_len && Ye(fe, U.heap[Pe + 1], U.heap[Pe], U.depth) && Pe++, !Ye(fe, Me, U.heap[Pe], U.depth)); )
                U.heap[Y] = U.heap[Pe], Y = Pe, Pe <<= 1;
              U.heap[Y] = Me;
            }, Ue = (U, fe, Y) => {
              let Me, Pe, Ze = 0, pn, mr;
              if (U.sym_next !== 0)
                do
                  Me = U.pending_buf[U.sym_buf + Ze++] & 255, Me += (U.pending_buf[U.sym_buf + Ze++] & 255) << 8, Pe = U.pending_buf[U.sym_buf + Ze++], Me === 0 ? de(U, Pe, fe) : (pn = X[Pe], de(U, pn + R + 1, fe), mr = L[pn], mr !== 0 && (Pe -= Z[pn], we(U, Pe, mr)), Me--, pn = ye(Me), de(U, pn, Y), mr = z[pn], mr !== 0 && (Me -= Q[pn], we(U, Me, mr)));
                while (Ze < U.sym_next);
              de(U, D, fe);
            }, Qe = (U, fe) => {
              const Y = fe.dyn_tree, Me = fe.stat_desc.static_tree, Pe = fe.stat_desc.has_stree, Ze = fe.stat_desc.elems;
              let pn, mr, yp = -1, it;
              for (U.heap_len = 0, U.heap_max = A, pn = 0; pn < Ze; pn++)
                Y[pn * 2] !== 0 ? (U.heap[++U.heap_len] = yp = pn, U.depth[pn] = 0) : Y[pn * 2 + 1] = 0;
              for (; U.heap_len < 2; )
                it = U.heap[++U.heap_len] = yp < 2 ? ++yp : 0, Y[it * 2] = 1, U.depth[it] = 0, U.opt_len--, Pe && (U.static_len -= Me[it * 2 + 1]);
              for (fe.max_code = yp, pn = U.heap_len >> 1; pn >= 1; pn--)
                De(U, Y, pn);
              it = Ze;
              do
                pn = U.heap[
                  1
                  /*SMALLEST*/
                ], U.heap[
                  1
                  /*SMALLEST*/
                ] = U.heap[U.heap_len--], De(
                  U,
                  Y,
                  1
                  /*SMALLEST*/
                ), mr = U.heap[
                  1
                  /*SMALLEST*/
                ], U.heap[--U.heap_max] = pn, U.heap[--U.heap_max] = mr, Y[it * 2] = Y[pn * 2] + Y[mr * 2], U.depth[it] = (U.depth[pn] >= U.depth[mr] ? U.depth[pn] : U.depth[mr]) + 1, Y[pn * 2 + 1] = Y[mr * 2 + 1] = it, U.heap[
                  1
                  /*SMALLEST*/
                ] = it++, De(
                  U,
                  Y,
                  1
                  /*SMALLEST*/
                );
              while (U.heap_len >= 2);
              U.heap[--U.heap_max] = U.heap[
                1
                /*SMALLEST*/
              ], ee(U, fe), Ae(Y, yp, U.bl_count);
            }, ue = (U, fe, Y) => {
              let Me, Pe = -1, Ze, pn = fe[0 * 2 + 1], mr = 0, yp = 7, it = 4;
              for (pn === 0 && (yp = 138, it = 3), fe[(Y + 1) * 2 + 1] = 65535, Me = 0; Me <= Y; Me++)
                Ze = pn, pn = fe[(Me + 1) * 2 + 1], !(++mr < yp && Ze === pn) && (mr < it ? U.bl_tree[Ze * 2] += mr : Ze !== 0 ? (Ze !== Pe && U.bl_tree[Ze * 2]++, U.bl_tree[O * 2]++) : mr <= 10 ? U.bl_tree[N * 2]++ : U.bl_tree[j * 2]++, mr = 0, Pe = Ze, pn === 0 ? (yp = 138, it = 3) : Ze === pn ? (yp = 6, it = 3) : (yp = 7, it = 4));
            }, te = (U, fe, Y) => {
              let Me, Pe = -1, Ze, pn = fe[0 * 2 + 1], mr = 0, yp = 7, it = 4;
              for (pn === 0 && (yp = 138, it = 3), Me = 0; Me <= Y; Me++)
                if (Ze = pn, pn = fe[(Me + 1) * 2 + 1], !(++mr < yp && Ze === pn)) {
                  if (mr < it)
                    do
                      de(U, Ze, U.bl_tree);
                    while (--mr !== 0);
                  else
                    Ze !== 0 ? (Ze !== Pe && (de(U, Ze, U.bl_tree), mr--), de(U, O, U.bl_tree), we(U, mr - 3, 2)) : mr <= 10 ? (de(U, N, U.bl_tree), we(U, mr - 3, 3)) : (de(U, j, U.bl_tree), we(U, mr - 11, 7));
                  mr = 0, Pe = Ze, pn === 0 ? (yp = 138, it = 3) : Ze === pn ? (yp = 6, it = 3) : (yp = 7, it = 4);
                }
            }, Be = (U) => {
              let fe;
              for (ue(U, U.dyn_ltree, U.l_desc.max_code), ue(U, U.dyn_dtree, U.d_desc.max_code), Qe(U, U.bl_desc), fe = M - 1; fe >= 3 && U.bl_tree[B[fe] * 2 + 1] === 0; fe--)
                ;
              return U.opt_len += 3 * (fe + 1) + 5 + 5 + 4, fe;
            }, Je = (U, fe, Y, Me) => {
              let Pe;
              for (we(U, fe - 257, 5), we(U, Y - 1, 5), we(U, Me - 4, 4), Pe = 0; Pe < Me; Pe++)
                we(U, U.bl_tree[B[Pe] * 2 + 1], 3);
              te(U, U.dyn_ltree, fe - 1), te(U, U.dyn_dtree, Y - 1);
            }, ft = (U) => {
              let fe = 4093624447, Y;
              for (Y = 0; Y <= 31; Y++, fe >>>= 1)
                if (fe & 1 && U.dyn_ltree[Y * 2] !== 0)
                  return l;
              if (U.dyn_ltree[9 * 2] !== 0 || U.dyn_ltree[10 * 2] !== 0 || U.dyn_ltree[13 * 2] !== 0)
                return u;
              for (Y = 32; Y < R; Y++)
                if (U.dyn_ltree[Y * 2] !== 0)
                  return u;
              return l;
            };
            let lt = !1;
            const he = (U) => {
              lt || (be(), lt = !0), U.l_desc = new ge(U.dyn_ltree, J), U.d_desc = new ge(U.dyn_dtree, ie), U.bl_desc = new ge(U.bl_tree, ne), U.bi_buf = 0, U.bi_valid = 0, Fe(U);
            }, ae = (U, fe, Y, Me) => {
              we(U, (p << 1) + (Me ? 1 : 0), 3), et(U), xe(U, Y), xe(U, ~Y), Y && U.pending_buf.set(U.window.subarray(fe, fe + Y), U.pending), U.pending += Y;
            }, se = (U) => {
              we(U, v << 1, 3), de(U, D, H), Ce(U);
            }, Re = (U, fe, Y, Me) => {
              let Pe, Ze, pn = 0;
              U.level > 0 ? (U.strm.data_type === f && (U.strm.data_type = ft(U)), Qe(U, U.l_desc), Qe(U, U.d_desc), pn = Be(U), Pe = U.opt_len + 3 + 7 >>> 3, Ze = U.static_len + 3 + 7 >>> 3, Ze <= Pe && (Pe = Ze)) : Pe = Ze = Y + 5, Y + 4 <= Pe && fe !== -1 ? ae(U, fe, Y, Me) : U.strategy === o || Ze === Pe ? (we(U, (v << 1) + (Me ? 1 : 0), 3), Ue(U, H, W)) : (we(U, (g << 1) + (Me ? 1 : 0), 3), Je(U, U.l_desc.max_code + 1, U.d_desc.max_code + 1, pn + 1), Ue(U, U.dyn_ltree, U.dyn_dtree)), Fe(U), Me && et(U);
            }, Oe = (U, fe, Y) => (U.pending_buf[U.sym_buf + U.sym_next++] = fe, U.pending_buf[U.sym_buf + U.sym_next++] = fe >> 8, U.pending_buf[U.sym_buf + U.sym_next++] = Y, fe === 0 ? U.dyn_ltree[Y * 2]++ : (U.matches++, fe--, U.dyn_ltree[(X[Y] + R + 1) * 2]++, U.dyn_dtree[ye(fe) * 2]++), U.sym_next === U.sym_end);
            var We = he, Ct = ae, le = Re, ke = Oe, Ke = se, me = {
              _tr_init: We,
              _tr_stored_block: Ct,
              _tr_flush_block: le,
              _tr_tally: ke,
              _tr_align: Ke
            }, Ee = (U, fe, Y, Me) => {
              let Pe = U & 65535 | 0, Ze = U >>> 16 & 65535 | 0, pn = 0;
              for (; Y !== 0; ) {
                pn = Y > 2e3 ? 2e3 : Y, Y -= pn;
                do
                  Pe = Pe + fe[Me++] | 0, Ze = Ze + Pe | 0;
                while (--pn);
                Pe %= 65521, Ze %= 65521;
              }
              return Pe | Ze << 16 | 0;
            };
            const tt = () => {
              let U, fe = [];
              for (var Y = 0; Y < 256; Y++) {
                U = Y;
                for (var Me = 0; Me < 8; Me++)
                  U = U & 1 ? 3988292384 ^ U >>> 1 : U >>> 1;
                fe[Y] = U;
              }
              return fe;
            }, ce = new Uint32Array(tt());
            var _e = (U, fe, Y, Me) => {
              const Pe = ce, Ze = Me + Y;
              U ^= -1;
              for (let pn = Me; pn < Ze; pn++)
                U = U >>> 8 ^ Pe[(U ^ fe[pn]) & 255];
              return U ^ -1;
            }, Ht = {
              2: "need dictionary",
              /* Z_NEED_DICT       2  */
              1: "stream end",
              /* Z_STREAM_END      1  */
              0: "",
              /* Z_OK              0  */
              "-1": "file error",
              /* Z_ERRNO         (-1) */
              "-2": "stream error",
              /* Z_STREAM_ERROR  (-2) */
              "-3": "data error",
              /* Z_DATA_ERROR    (-3) */
              "-4": "insufficient memory",
              /* Z_MEM_ERROR     (-4) */
              "-5": "buffer error",
              /* Z_BUF_ERROR     (-5) */
              "-6": "incompatible version"
              /* Z_VERSION_ERROR (-6) */
            }, K = {
              /* Allowed flush values; see deflate() and inflate() below for details */
              Z_NO_FLUSH: 0,
              Z_PARTIAL_FLUSH: 1,
              Z_SYNC_FLUSH: 2,
              Z_FULL_FLUSH: 3,
              Z_FINISH: 4,
              Z_BLOCK: 5,
              Z_TREES: 6,
              /* Return codes for the compression/decompression functions. Negative values
              * are errors, positive values are used for special but normal events.
              */
              Z_OK: 0,
              Z_STREAM_END: 1,
              Z_NEED_DICT: 2,
              Z_ERRNO: -1,
              Z_STREAM_ERROR: -2,
              Z_DATA_ERROR: -3,
              Z_MEM_ERROR: -4,
              Z_BUF_ERROR: -5,
              //Z_VERSION_ERROR: -6,
              /* compression levels */
              Z_NO_COMPRESSION: 0,
              Z_BEST_SPEED: 1,
              Z_BEST_COMPRESSION: 9,
              Z_DEFAULT_COMPRESSION: -1,
              Z_FILTERED: 1,
              Z_HUFFMAN_ONLY: 2,
              Z_RLE: 3,
              Z_FIXED: 4,
              Z_DEFAULT_STRATEGY: 0,
              /* Possible values of the data_type field (though see inflate()) */
              Z_BINARY: 0,
              Z_TEXT: 1,
              //Z_ASCII:                1, // = Z_TEXT (deprecated)
              Z_UNKNOWN: 2,
              /* The deflate compression method */
              Z_DEFLATED: 8
              //Z_NULL:                 null // Use -1 or null inline, depending on var type
            };
            const { _tr_init: Ve, _tr_stored_block: Ne, _tr_flush_block: pe, _tr_tally: Le, _tr_align: bt } = me, {
              Z_NO_FLUSH: yi,
              Z_PARTIAL_FLUSH: _n,
              Z_FULL_FLUSH: Do,
              Z_FINISH: ms,
              Z_BLOCK: Bp,
              Z_OK: Sp,
              Z_STREAM_END: Tp,
              Z_STREAM_ERROR: Pp,
              Z_DATA_ERROR: Xe,
              Z_BUF_ERROR: Se,
              Z_DEFAULT_COMPRESSION: pr,
              Z_FILTERED: mn,
              Z_HUFFMAN_ONLY: Si,
              Z_RLE: Io,
              Z_FIXED: ve,
              Z_DEFAULT_STRATEGY: He,
              Z_UNKNOWN: nt,
              Z_DEFLATED: dr
            } = K, dt = 9, ci = 15, Uo = 8, xs = 286, vs = 30, bp = 19, Ep = 2 * xs + 1, Ap = 15, wp = 3, jp = 258, Vp = jp + wp + 1, Qp = 32, zp = 42, Mp = 57, fm = 69, hm = 73, rm = 91, ym = 103, Jp = 113, om = 666, Lp = 1, Zp = 2, nm = 3, qp = 4, xm = 3, sm = (U, fe) => (U.msg = Ht[fe], fe), wm = (U) => U * 2 - (U > 4 ? 9 : 0), um = (U) => {
              let fe = U.length;
              for (; --fe >= 0; )
                U[fe] = 0;
            }, sy = (U) => {
              let fe, Y, Me, Pe = U.w_size;
              fe = U.hash_size, Me = fe;
              do
                Y = U.head[--Me], U.head[Me] = Y >= Pe ? Y - Pe : 0;
              while (--fe);
              fe = Pe, Me = fe;
              do
                Y = U.prev[--Me], U.prev[Me] = Y >= Pe ? Y - Pe : 0;
              while (--fe);
            };
            let dm = (U, fe, Y) => (fe << U.hash_shift ^ Y) & U.hash_mask;
            const em = (U) => {
              const fe = U.state;
              let Y = fe.pending;
              Y > U.avail_out && (Y = U.avail_out), Y !== 0 && (U.output.set(fe.pending_buf.subarray(fe.pending_out, fe.pending_out + Y), U.next_out), U.next_out += Y, fe.pending_out += Y, U.total_out += Y, U.avail_out -= Y, fe.pending -= Y, fe.pending === 0 && (fe.pending_out = 0));
            }, tm = (U, fe) => {
              pe(U, U.block_start >= 0 ? U.block_start : -1, U.strstart - U.block_start, fe), U.block_start = U.strstart, em(U.strm);
            }, Fp = (U, fe) => {
              U.pending_buf[U.pending++] = fe;
            }, Sm = (U, fe) => {
              U.pending_buf[U.pending++] = fe >>> 8 & 255, U.pending_buf[U.pending++] = fe & 255;
            }, Gm = (U, fe, Y, Me) => {
              let Pe = U.avail_in;
              return Pe > Me && (Pe = Me), Pe === 0 ? 0 : (U.avail_in -= Pe, fe.set(U.input.subarray(U.next_in, U.next_in + Pe), Y), U.state.wrap === 1 ? U.adler = Ee(U.adler, fe, Pe, Y) : U.state.wrap === 2 && (U.adler = _e(U.adler, fe, Pe, Y)), U.next_in += Pe, U.total_in += Pe, Pe);
            }, tg = (U, fe) => {
              let Y = U.max_chain_length, Me = U.strstart, Pe, Ze, pn = U.prev_length, mr = U.nice_match;
              const yp = U.strstart > U.w_size - Vp ? U.strstart - (U.w_size - Vp) : 0, it = U.window, _r = U.w_mask, Up = U.prev, Lo = U.strstart + jp;
              let Ei = it[Me + pn - 1], Wp = it[Me + pn];
              U.prev_length >= U.good_match && (Y >>= 2), mr > U.lookahead && (mr = U.lookahead);
              do
                if (Pe = fe, !(it[Pe + pn] !== Wp || it[Pe + pn - 1] !== Ei || it[Pe] !== it[Me] || it[++Pe] !== it[Me + 1])) {
                  Me += 2, Pe++;
                  do
                    ;
                  while (it[++Me] === it[++Pe] && it[++Me] === it[++Pe] && it[++Me] === it[++Pe] && it[++Me] === it[++Pe] && it[++Me] === it[++Pe] && it[++Me] === it[++Pe] && it[++Me] === it[++Pe] && it[++Me] === it[++Pe] && Me < Lo);
                  if (Ze = jp - (Lo - Me), Me = Lo - jp, Ze > pn) {
                    if (U.match_start = fe, pn = Ze, Ze >= mr)
                      break;
                    Ei = it[Me + pn - 1], Wp = it[Me + pn];
                  }
                }
              while ((fe = Up[fe & _r]) > yp && --Y !== 0);
              return pn <= U.lookahead ? pn : U.lookahead;
            }, vm = (U) => {
              const fe = U.w_size;
              let Y, Me, Pe;
              do {
                if (Me = U.window_size - U.lookahead - U.strstart, U.strstart >= fe + (fe - Vp) && (U.window.set(U.window.subarray(fe, fe + fe - Me), 0), U.match_start -= fe, U.strstart -= fe, U.block_start -= fe, U.insert > U.strstart && (U.insert = U.strstart), sy(U), Me += fe), U.strm.avail_in === 0)
                  break;
                if (Y = Gm(U.strm, U.window, U.strstart + U.lookahead, Me), U.lookahead += Y, U.lookahead + U.insert >= wp)
                  for (Pe = U.strstart - U.insert, U.ins_h = U.window[Pe], U.ins_h = dm(U, U.ins_h, U.window[Pe + 1]); U.insert && (U.ins_h = dm(U, U.ins_h, U.window[Pe + wp - 1]), U.prev[Pe & U.w_mask] = U.head[U.ins_h], U.head[U.ins_h] = Pe, Pe++, U.insert--, !(U.lookahead + U.insert < wp)); )
                    ;
              } while (U.lookahead < Vp && U.strm.avail_in !== 0);
            }, rg = (U, fe) => {
              let Y = U.pending_buf_size - 5 > U.w_size ? U.w_size : U.pending_buf_size - 5, Me, Pe, Ze, pn = 0, mr = U.strm.avail_in;
              do {
                if (Me = 65535, Ze = U.bi_valid + 42 >> 3, U.strm.avail_out < Ze || (Ze = U.strm.avail_out - Ze, Pe = U.strstart - U.block_start, Me > Pe + U.strm.avail_in && (Me = Pe + U.strm.avail_in), Me > Ze && (Me = Ze), Me < Y && (Me === 0 && fe !== ms || fe === yi || Me !== Pe + U.strm.avail_in)))
                  break;
                pn = fe === ms && Me === Pe + U.strm.avail_in ? 1 : 0, Ne(U, 0, 0, pn), U.pending_buf[U.pending - 4] = Me, U.pending_buf[U.pending - 3] = Me >> 8, U.pending_buf[U.pending - 2] = ~Me, U.pending_buf[U.pending - 1] = ~Me >> 8, em(U.strm), Pe && (Pe > Me && (Pe = Me), U.strm.output.set(U.window.subarray(U.block_start, U.block_start + Pe), U.strm.next_out), U.strm.next_out += Pe, U.strm.avail_out -= Pe, U.strm.total_out += Pe, U.block_start += Pe, Me -= Pe), Me && (Gm(U.strm, U.strm.output, U.strm.next_out, Me), U.strm.next_out += Me, U.strm.avail_out -= Me, U.strm.total_out += Me);
              } while (pn === 0);
              return mr -= U.strm.avail_in, mr && (mr >= U.w_size ? (U.matches = 2, U.window.set(U.strm.input.subarray(U.strm.next_in - U.w_size, U.strm.next_in), 0), U.strstart = U.w_size, U.insert = U.strstart) : (U.window_size - U.strstart <= mr && (U.strstart -= U.w_size, U.window.set(U.window.subarray(U.w_size, U.w_size + U.strstart), 0), U.matches < 2 && U.matches++, U.insert > U.strstart && (U.insert = U.strstart)), U.window.set(U.strm.input.subarray(U.strm.next_in - mr, U.strm.next_in), U.strstart), U.strstart += mr, U.insert += mr > U.w_size - U.insert ? U.w_size - U.insert : mr), U.block_start = U.strstart), U.high_water < U.strstart && (U.high_water = U.strstart), pn ? qp : fe !== yi && fe !== ms && U.strm.avail_in === 0 && U.strstart === U.block_start ? Zp : (Ze = U.window_size - U.strstart, U.strm.avail_in > Ze && U.block_start >= U.w_size && (U.block_start -= U.w_size, U.strstart -= U.w_size, U.window.set(U.window.subarray(U.w_size, U.w_size + U.strstart), 0), U.matches < 2 && U.matches++, Ze += U.w_size, U.insert > U.strstart && (U.insert = U.strstart)), Ze > U.strm.avail_in && (Ze = U.strm.avail_in), Ze && (Gm(U.strm, U.window, U.strstart, Ze), U.strstart += Ze, U.insert += Ze > U.w_size - U.insert ? U.w_size - U.insert : Ze), U.high_water < U.strstart && (U.high_water = U.strstart), Ze = U.bi_valid + 42 >> 3, Ze = U.pending_buf_size - Ze > 65535 ? 65535 : U.pending_buf_size - Ze, Y = Ze > U.w_size ? U.w_size : Ze, Pe = U.strstart - U.block_start, (Pe >= Y || (Pe || fe === ms) && fe !== yi && U.strm.avail_in === 0 && Pe <= Ze) && (Me = Pe > Ze ? Ze : Pe, pn = fe === ms && U.strm.avail_in === 0 && Me === Pe ? 1 : 0, Ne(U, U.block_start, Me, pn), U.block_start += Me, em(U.strm)), pn ? nm : Lp);
            }, Vm = (U, fe) => {
              let Y, Me;
              for (; ; ) {
                if (U.lookahead < Vp) {
                  if (vm(U), U.lookahead < Vp && fe === yi)
                    return Lp;
                  if (U.lookahead === 0)
                    break;
                }
                if (Y = 0, U.lookahead >= wp && (U.ins_h = dm(U, U.ins_h, U.window[U.strstart + wp - 1]), Y = U.prev[U.strstart & U.w_mask] = U.head[U.ins_h], U.head[U.ins_h] = U.strstart), Y !== 0 && U.strstart - Y <= U.w_size - Vp && (U.match_length = tg(U, Y)), U.match_length >= wp)
                  if (Me = Le(U, U.strstart - U.match_start, U.match_length - wp), U.lookahead -= U.match_length, U.match_length <= U.max_lazy_match && U.lookahead >= wp) {
                    U.match_length--;
                    do
                      U.strstart++, U.ins_h = dm(U, U.ins_h, U.window[U.strstart + wp - 1]), Y = U.prev[U.strstart & U.w_mask] = U.head[U.ins_h], U.head[U.ins_h] = U.strstart;
                    while (--U.match_length !== 0);
                    U.strstart++;
                  } else
                    U.strstart += U.match_length, U.match_length = 0, U.ins_h = U.window[U.strstart], U.ins_h = dm(U, U.ins_h, U.window[U.strstart + 1]);
                else
                  Me = Le(U, 0, U.window[U.strstart]), U.lookahead--, U.strstart++;
                if (Me && (tm(U, !1), U.strm.avail_out === 0))
                  return Lp;
              }
              return U.insert = U.strstart < wp - 1 ? U.strstart : wp - 1, fe === ms ? (tm(U, !0), U.strm.avail_out === 0 ? nm : qp) : U.sym_next && (tm(U, !1), U.strm.avail_out === 0) ? Lp : Zp;
            }, _m = (U, fe) => {
              let Y, Me, Pe;
              for (; ; ) {
                if (U.lookahead < Vp) {
                  if (vm(U), U.lookahead < Vp && fe === yi)
                    return Lp;
                  if (U.lookahead === 0)
                    break;
                }
                if (Y = 0, U.lookahead >= wp && (U.ins_h = dm(U, U.ins_h, U.window[U.strstart + wp - 1]), Y = U.prev[U.strstart & U.w_mask] = U.head[U.ins_h], U.head[U.ins_h] = U.strstart), U.prev_length = U.match_length, U.prev_match = U.match_start, U.match_length = wp - 1, Y !== 0 && U.prev_length < U.max_lazy_match && U.strstart - Y <= U.w_size - Vp && (U.match_length = tg(U, Y), U.match_length <= 5 && (U.strategy === mn || U.match_length === wp && U.strstart - U.match_start > 4096) && (U.match_length = wp - 1)), U.prev_length >= wp && U.match_length <= U.prev_length) {
                  Pe = U.strstart + U.lookahead - wp, Me = Le(U, U.strstart - 1 - U.prev_match, U.prev_length - wp), U.lookahead -= U.prev_length - 1, U.prev_length -= 2;
                  do
                    ++U.strstart <= Pe && (U.ins_h = dm(U, U.ins_h, U.window[U.strstart + wp - 1]), Y = U.prev[U.strstart & U.w_mask] = U.head[U.ins_h], U.head[U.ins_h] = U.strstart);
                  while (--U.prev_length !== 0);
                  if (U.match_available = 0, U.match_length = wp - 1, U.strstart++, Me && (tm(U, !1), U.strm.avail_out === 0))
                    return Lp;
                } else if (U.match_available) {
                  if (Me = Le(U, 0, U.window[U.strstart - 1]), Me && tm(U, !1), U.strstart++, U.lookahead--, U.strm.avail_out === 0)
                    return Lp;
                } else
                  U.match_available = 1, U.strstart++, U.lookahead--;
              }
              return U.match_available && (Me = Le(U, 0, U.window[U.strstart - 1]), U.match_available = 0), U.insert = U.strstart < wp - 1 ? U.strstart : wp - 1, fe === ms ? (tm(U, !0), U.strm.avail_out === 0 ? nm : qp) : U.sym_next && (tm(U, !1), U.strm.avail_out === 0) ? Lp : Zp;
            }, ly = (U, fe) => {
              let Y, Me, Pe, Ze;
              const pn = U.window;
              for (; ; ) {
                if (U.lookahead <= jp) {
                  if (vm(U), U.lookahead <= jp && fe === yi)
                    return Lp;
                  if (U.lookahead === 0)
                    break;
                }
                if (U.match_length = 0, U.lookahead >= wp && U.strstart > 0 && (Pe = U.strstart - 1, Me = pn[Pe], Me === pn[++Pe] && Me === pn[++Pe] && Me === pn[++Pe])) {
                  Ze = U.strstart + jp;
                  do
                    ;
                  while (Me === pn[++Pe] && Me === pn[++Pe] && Me === pn[++Pe] && Me === pn[++Pe] && Me === pn[++Pe] && Me === pn[++Pe] && Me === pn[++Pe] && Me === pn[++Pe] && Pe < Ze);
                  U.match_length = jp - (Ze - Pe), U.match_length > U.lookahead && (U.match_length = U.lookahead);
                }
                if (U.match_length >= wp ? (Y = Le(U, 1, U.match_length - wp), U.lookahead -= U.match_length, U.strstart += U.match_length, U.match_length = 0) : (Y = Le(U, 0, U.window[U.strstart]), U.lookahead--, U.strstart++), Y && (tm(U, !1), U.strm.avail_out === 0))
                  return Lp;
              }
              return U.insert = 0, fe === ms ? (tm(U, !0), U.strm.avail_out === 0 ? nm : qp) : U.sym_next && (tm(U, !1), U.strm.avail_out === 0) ? Lp : Zp;
            }, cy = (U, fe) => {
              let Y;
              for (; ; ) {
                if (U.lookahead === 0 && (vm(U), U.lookahead === 0)) {
                  if (fe === yi)
                    return Lp;
                  break;
                }
                if (U.match_length = 0, Y = Le(U, 0, U.window[U.strstart]), U.lookahead--, U.strstart++, Y && (tm(U, !1), U.strm.avail_out === 0))
                  return Lp;
              }
              return U.insert = 0, fe === ms ? (tm(U, !0), U.strm.avail_out === 0 ? nm : qp) : U.sym_next && (tm(U, !1), U.strm.avail_out === 0) ? Lp : Zp;
            };
            function am(U, fe, Y, Me, Pe) {
              this.good_length = U, this.max_lazy = fe, this.nice_length = Y, this.max_chain = Me, this.func = Pe;
            }
            const Em = [
              /*      good lazy nice chain */
              new am(0, 0, 0, 0, rg),
              /* 0 store only */
              new am(4, 4, 8, 4, Vm),
              /* 1 max speed, no lazy matches */
              new am(4, 5, 16, 8, Vm),
              /* 2 */
              new am(4, 6, 32, 32, Vm),
              /* 3 */
              new am(4, 4, 16, 16, _m),
              /* 4 lazy matches */
              new am(8, 16, 32, 32, _m),
              /* 5 */
              new am(8, 16, 128, 128, _m),
              /* 6 */
              new am(8, 32, 128, 256, _m),
              /* 7 */
              new am(32, 128, 258, 1024, _m),
              /* 8 */
              new am(32, 258, 258, 4096, _m)
              /* 9 max compression */
            ], uy = (U) => {
              U.window_size = 2 * U.w_size, um(U.head), U.max_lazy_match = Em[U.level].max_lazy, U.good_match = Em[U.level].good_length, U.nice_match = Em[U.level].nice_length, U.max_chain_length = Em[U.level].max_chain, U.strstart = 0, U.block_start = 0, U.lookahead = 0, U.insert = 0, U.match_length = U.prev_length = wp - 1, U.match_available = 0, U.ins_h = 0;
            };
            function dy() {
              this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = dr, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(Ep * 2), this.dyn_dtree = new Uint16Array((2 * vs + 1) * 2), this.bl_tree = new Uint16Array((2 * bp + 1) * 2), um(this.dyn_ltree), um(this.dyn_dtree), um(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(Ap + 1), this.heap = new Uint16Array(2 * xs + 1), um(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(2 * xs + 1), um(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
            }
            const Tm = (U) => {
              if (!U)
                return 1;
              const fe = U.state;
              return !fe || fe.strm !== U || fe.status !== zp && //#ifdef GZIP
              fe.status !== Mp && //#endif
              fe.status !== fm && fe.status !== hm && fe.status !== rm && fe.status !== ym && fe.status !== Jp && fe.status !== om ? 1 : 0;
            }, ng = (U) => {
              if (Tm(U))
                return sm(U, Pp);
              U.total_in = U.total_out = 0, U.data_type = nt;
              const fe = U.state;
              return fe.pending = 0, fe.pending_out = 0, fe.wrap < 0 && (fe.wrap = -fe.wrap), fe.status = //#ifdef GZIP
              fe.wrap === 2 ? Mp : (
                //#endif
                fe.wrap ? zp : Jp
              ), U.adler = fe.wrap === 2 ? 0 : 1, fe.last_flush = -2, Ve(fe), Sp;
            }, ig = (U) => {
              const fe = ng(U);
              return fe === Sp && uy(U.state), fe;
            }, fy = (U, fe) => Tm(U) || U.state.wrap !== 2 ? Pp : (U.state.gzhead = fe, Sp), ag = (U, fe, Y, Me, Pe, Ze) => {
              if (!U)
                return Pp;
              let pn = 1;
              if (fe === pr && (fe = 6), Me < 0 ? (pn = 0, Me = -Me) : Me > 15 && (pn = 2, Me -= 16), Pe < 1 || Pe > dt || Y !== dr || Me < 8 || Me > 15 || fe < 0 || fe > 9 || Ze < 0 || Ze > ve || Me === 8 && pn !== 1)
                return sm(U, Pp);
              Me === 8 && (Me = 9);
              const mr = new dy();
              return U.state = mr, mr.strm = U, mr.status = zp, mr.wrap = pn, mr.gzhead = null, mr.w_bits = Me, mr.w_size = 1 << mr.w_bits, mr.w_mask = mr.w_size - 1, mr.hash_bits = Pe + 7, mr.hash_size = 1 << mr.hash_bits, mr.hash_mask = mr.hash_size - 1, mr.hash_shift = ~~((mr.hash_bits + wp - 1) / wp), mr.window = new Uint8Array(mr.w_size * 2), mr.head = new Uint16Array(mr.hash_size), mr.prev = new Uint16Array(mr.w_size), mr.lit_bufsize = 1 << Pe + 6, mr.pending_buf_size = mr.lit_bufsize * 4, mr.pending_buf = new Uint8Array(mr.pending_buf_size), mr.sym_buf = mr.lit_bufsize, mr.sym_end = (mr.lit_bufsize - 1) * 3, mr.level = fe, mr.strategy = Ze, mr.method = Y, ig(U);
            }, hy = (U, fe) => ag(U, fe, dr, ci, Uo, He), py = (U, fe) => {
              if (Tm(U) || fe > Bp || fe < 0)
                return U ? sm(U, Pp) : Pp;
              const Y = U.state;
              if (!U.output || U.avail_in !== 0 && !U.input || Y.status === om && fe !== ms)
                return sm(U, U.avail_out === 0 ? Se : Pp);
              const Me = Y.last_flush;
              if (Y.last_flush = fe, Y.pending !== 0) {
                if (em(U), U.avail_out === 0)
                  return Y.last_flush = -1, Sp;
              } else if (U.avail_in === 0 && wm(fe) <= wm(Me) && fe !== ms)
                return sm(U, Se);
              if (Y.status === om && U.avail_in !== 0)
                return sm(U, Se);
              if (Y.status === zp && Y.wrap === 0 && (Y.status = Jp), Y.status === zp) {
                let Pe = dr + (Y.w_bits - 8 << 4) << 8, Ze = -1;
                if (Y.strategy >= Si || Y.level < 2 ? Ze = 0 : Y.level < 6 ? Ze = 1 : Y.level === 6 ? Ze = 2 : Ze = 3, Pe |= Ze << 6, Y.strstart !== 0 && (Pe |= Qp), Pe += 31 - Pe % 31, Sm(Y, Pe), Y.strstart !== 0 && (Sm(Y, U.adler >>> 16), Sm(Y, U.adler & 65535)), U.adler = 1, Y.status = Jp, em(U), Y.pending !== 0)
                  return Y.last_flush = -1, Sp;
              }
              if (Y.status === Mp) {
                if (U.adler = 0, Fp(Y, 31), Fp(Y, 139), Fp(Y, 8), Y.gzhead)
                  Fp(
                    Y,
                    (Y.gzhead.text ? 1 : 0) + (Y.gzhead.hcrc ? 2 : 0) + (Y.gzhead.extra ? 4 : 0) + (Y.gzhead.name ? 8 : 0) + (Y.gzhead.comment ? 16 : 0)
                  ), Fp(Y, Y.gzhead.time & 255), Fp(Y, Y.gzhead.time >> 8 & 255), Fp(Y, Y.gzhead.time >> 16 & 255), Fp(Y, Y.gzhead.time >> 24 & 255), Fp(Y, Y.level === 9 ? 2 : Y.strategy >= Si || Y.level < 2 ? 4 : 0), Fp(Y, Y.gzhead.os & 255), Y.gzhead.extra && Y.gzhead.extra.length && (Fp(Y, Y.gzhead.extra.length & 255), Fp(Y, Y.gzhead.extra.length >> 8 & 255)), Y.gzhead.hcrc && (U.adler = _e(U.adler, Y.pending_buf, Y.pending, 0)), Y.gzindex = 0, Y.status = fm;
                else if (Fp(Y, 0), Fp(Y, 0), Fp(Y, 0), Fp(Y, 0), Fp(Y, 0), Fp(Y, Y.level === 9 ? 2 : Y.strategy >= Si || Y.level < 2 ? 4 : 0), Fp(Y, xm), Y.status = Jp, em(U), Y.pending !== 0)
                  return Y.last_flush = -1, Sp;
              }
              if (Y.status === fm) {
                if (Y.gzhead.extra) {
                  let Pe = Y.pending, Ze = (Y.gzhead.extra.length & 65535) - Y.gzindex;
                  for (; Y.pending + Ze > Y.pending_buf_size; ) {
                    let mr = Y.pending_buf_size - Y.pending;
                    if (Y.pending_buf.set(Y.gzhead.extra.subarray(Y.gzindex, Y.gzindex + mr), Y.pending), Y.pending = Y.pending_buf_size, Y.gzhead.hcrc && Y.pending > Pe && (U.adler = _e(U.adler, Y.pending_buf, Y.pending - Pe, Pe)), Y.gzindex += mr, em(U), Y.pending !== 0)
                      return Y.last_flush = -1, Sp;
                    Pe = 0, Ze -= mr;
                  }
                  let pn = new Uint8Array(Y.gzhead.extra);
                  Y.pending_buf.set(pn.subarray(Y.gzindex, Y.gzindex + Ze), Y.pending), Y.pending += Ze, Y.gzhead.hcrc && Y.pending > Pe && (U.adler = _e(U.adler, Y.pending_buf, Y.pending - Pe, Pe)), Y.gzindex = 0;
                }
                Y.status = hm;
              }
              if (Y.status === hm) {
                if (Y.gzhead.name) {
                  let Pe = Y.pending, Ze;
                  do {
                    if (Y.pending === Y.pending_buf_size) {
                      if (Y.gzhead.hcrc && Y.pending > Pe && (U.adler = _e(U.adler, Y.pending_buf, Y.pending - Pe, Pe)), em(U), Y.pending !== 0)
                        return Y.last_flush = -1, Sp;
                      Pe = 0;
                    }
                    Y.gzindex < Y.gzhead.name.length ? Ze = Y.gzhead.name.charCodeAt(Y.gzindex++) & 255 : Ze = 0, Fp(Y, Ze);
                  } while (Ze !== 0);
                  Y.gzhead.hcrc && Y.pending > Pe && (U.adler = _e(U.adler, Y.pending_buf, Y.pending - Pe, Pe)), Y.gzindex = 0;
                }
                Y.status = rm;
              }
              if (Y.status === rm) {
                if (Y.gzhead.comment) {
                  let Pe = Y.pending, Ze;
                  do {
                    if (Y.pending === Y.pending_buf_size) {
                      if (Y.gzhead.hcrc && Y.pending > Pe && (U.adler = _e(U.adler, Y.pending_buf, Y.pending - Pe, Pe)), em(U), Y.pending !== 0)
                        return Y.last_flush = -1, Sp;
                      Pe = 0;
                    }
                    Y.gzindex < Y.gzhead.comment.length ? Ze = Y.gzhead.comment.charCodeAt(Y.gzindex++) & 255 : Ze = 0, Fp(Y, Ze);
                  } while (Ze !== 0);
                  Y.gzhead.hcrc && Y.pending > Pe && (U.adler = _e(U.adler, Y.pending_buf, Y.pending - Pe, Pe));
                }
                Y.status = ym;
              }
              if (Y.status === ym) {
                if (Y.gzhead.hcrc) {
                  if (Y.pending + 2 > Y.pending_buf_size && (em(U), Y.pending !== 0))
                    return Y.last_flush = -1, Sp;
                  Fp(Y, U.adler & 255), Fp(Y, U.adler >> 8 & 255), U.adler = 0;
                }
                if (Y.status = Jp, em(U), Y.pending !== 0)
                  return Y.last_flush = -1, Sp;
              }
              if (U.avail_in !== 0 || Y.lookahead !== 0 || fe !== yi && Y.status !== om) {
                let Pe = Y.level === 0 ? rg(Y, fe) : Y.strategy === Si ? cy(Y, fe) : Y.strategy === Io ? ly(Y, fe) : Em[Y.level].func(Y, fe);
                if ((Pe === nm || Pe === qp) && (Y.status = om), Pe === Lp || Pe === nm)
                  return U.avail_out === 0 && (Y.last_flush = -1), Sp;
                if (Pe === Zp && (fe === _n ? bt(Y) : fe !== Bp && (Ne(Y, 0, 0, !1), fe === Do && (um(Y.head), Y.lookahead === 0 && (Y.strstart = 0, Y.block_start = 0, Y.insert = 0))), em(U), U.avail_out === 0))
                  return Y.last_flush = -1, Sp;
              }
              return fe !== ms ? Sp : Y.wrap <= 0 ? Tp : (Y.wrap === 2 ? (Fp(Y, U.adler & 255), Fp(Y, U.adler >> 8 & 255), Fp(Y, U.adler >> 16 & 255), Fp(Y, U.adler >> 24 & 255), Fp(Y, U.total_in & 255), Fp(Y, U.total_in >> 8 & 255), Fp(Y, U.total_in >> 16 & 255), Fp(Y, U.total_in >> 24 & 255)) : (Sm(Y, U.adler >>> 16), Sm(Y, U.adler & 65535)), em(U), Y.wrap > 0 && (Y.wrap = -Y.wrap), Y.pending !== 0 ? Sp : Tp);
            }, my = (U) => {
              if (Tm(U))
                return Pp;
              const fe = U.state.status;
              return U.state = null, fe === Jp ? sm(U, Xe) : Sp;
            }, gy = (U, fe) => {
              let Y = fe.length;
              if (Tm(U))
                return Pp;
              const Me = U.state, Pe = Me.wrap;
              if (Pe === 2 || Pe === 1 && Me.status !== zp || Me.lookahead)
                return Pp;
              if (Pe === 1 && (U.adler = Ee(U.adler, fe, Y, 0)), Me.wrap = 0, Y >= Me.w_size) {
                Pe === 0 && (um(Me.head), Me.strstart = 0, Me.block_start = 0, Me.insert = 0);
                let yp = new Uint8Array(Me.w_size);
                yp.set(fe.subarray(Y - Me.w_size, Y), 0), fe = yp, Y = Me.w_size;
              }
              const Ze = U.avail_in, pn = U.next_in, mr = U.input;
              for (U.avail_in = Y, U.next_in = 0, U.input = fe, vm(Me); Me.lookahead >= wp; ) {
                let yp = Me.strstart, it = Me.lookahead - (wp - 1);
                do
                  Me.ins_h = dm(Me, Me.ins_h, Me.window[yp + wp - 1]), Me.prev[yp & Me.w_mask] = Me.head[Me.ins_h], Me.head[Me.ins_h] = yp, yp++;
                while (--it);
                Me.strstart = yp, Me.lookahead = wp - 1, vm(Me);
              }
              return Me.strstart += Me.lookahead, Me.block_start = Me.strstart, Me.insert = Me.lookahead, Me.lookahead = 0, Me.match_length = Me.prev_length = wp - 1, Me.match_available = 0, U.next_in = pn, U.input = mr, U.avail_in = Ze, Me.wrap = Pe, Sp;
            };
            var yy = hy, vy = ag, _y = ig, by = ng, xy = fy, wy = py, Sy = my, Ey = gy, Ty = "pako deflate (from Nodeca project)", Cm = {
              deflateInit: yy,
              deflateInit2: vy,
              deflateReset: _y,
              deflateResetKeep: by,
              deflateSetHeader: xy,
              deflate: wy,
              deflateEnd: Sy,
              deflateSetDictionary: Ey,
              deflateInfo: Ty
            };
            const Cy = (U, fe) => Object.prototype.hasOwnProperty.call(U, fe);
            var My = function(U) {
              const fe = Array.prototype.slice.call(arguments, 1);
              for (; fe.length; ) {
                const Y = fe.shift();
                if (Y) {
                  if (typeof Y != "object")
                    throw new TypeError(Y + "must be non-object");
                  for (const Me in Y)
                    Cy(Y, Me) && (U[Me] = Y[Me]);
                }
              }
              return U;
            }, Ay = (U) => {
              let fe = 0;
              for (let Me = 0, Pe = U.length; Me < Pe; Me++)
                fe += U[Me].length;
              const Y = new Uint8Array(fe);
              for (let Me = 0, Pe = 0, Ze = U.length; Me < Ze; Me++) {
                let pn = U[Me];
                Y.set(pn, Pe), Pe += pn.length;
              }
              return Y;
            }, Om = {
              assign: My,
              flattenChunks: Ay
            };
            let og = !0;
            try {
              String.fromCharCode.apply(null, new Uint8Array(1));
            } catch {
              og = !1;
            }
            const Mm = new Uint8Array(256);
            for (let U = 0; U < 256; U++)
              Mm[U] = U >= 252 ? 6 : U >= 248 ? 5 : U >= 240 ? 4 : U >= 224 ? 3 : U >= 192 ? 2 : 1;
            Mm[254] = Mm[254] = 1;
            var Py = (U) => {
              if (typeof TextEncoder == "function" && TextEncoder.prototype.encode)
                return new TextEncoder().encode(U);
              let fe, Y, Me, Pe, Ze, pn = U.length, mr = 0;
              for (Pe = 0; Pe < pn; Pe++)
                Y = U.charCodeAt(Pe), (Y & 64512) === 55296 && Pe + 1 < pn && (Me = U.charCodeAt(Pe + 1), (Me & 64512) === 56320 && (Y = 65536 + (Y - 55296 << 10) + (Me - 56320), Pe++)), mr += Y < 128 ? 1 : Y < 2048 ? 2 : Y < 65536 ? 3 : 4;
              for (fe = new Uint8Array(mr), Ze = 0, Pe = 0; Ze < mr; Pe++)
                Y = U.charCodeAt(Pe), (Y & 64512) === 55296 && Pe + 1 < pn && (Me = U.charCodeAt(Pe + 1), (Me & 64512) === 56320 && (Y = 65536 + (Y - 55296 << 10) + (Me - 56320), Pe++)), Y < 128 ? fe[Ze++] = Y : Y < 2048 ? (fe[Ze++] = 192 | Y >>> 6, fe[Ze++] = 128 | Y & 63) : Y < 65536 ? (fe[Ze++] = 224 | Y >>> 12, fe[Ze++] = 128 | Y >>> 6 & 63, fe[Ze++] = 128 | Y & 63) : (fe[Ze++] = 240 | Y >>> 18, fe[Ze++] = 128 | Y >>> 12 & 63, fe[Ze++] = 128 | Y >>> 6 & 63, fe[Ze++] = 128 | Y & 63);
              return fe;
            };
            const Ry = (U, fe) => {
              if (fe < 65534 && U.subarray && og)
                return String.fromCharCode.apply(null, U.length === fe ? U : U.subarray(0, fe));
              let Y = "";
              for (let Me = 0; Me < fe; Me++)
                Y += String.fromCharCode(U[Me]);
              return Y;
            };
            var $y = (U, fe) => {
              const Y = fe || U.length;
              if (typeof TextDecoder == "function" && TextDecoder.prototype.decode)
                return new TextDecoder().decode(U.subarray(0, fe));
              let Me, Pe;
              const Ze = new Array(Y * 2);
              for (Pe = 0, Me = 0; Me < Y; ) {
                let pn = U[Me++];
                if (pn < 128) {
                  Ze[Pe++] = pn;
                  continue;
                }
                let mr = Mm[pn];
                if (mr > 4) {
                  Ze[Pe++] = 65533, Me += mr - 1;
                  continue;
                }
                for (pn &= mr === 2 ? 31 : mr === 3 ? 15 : 7; mr > 1 && Me < Y; )
                  pn = pn << 6 | U[Me++] & 63, mr--;
                if (mr > 1) {
                  Ze[Pe++] = 65533;
                  continue;
                }
                pn < 65536 ? Ze[Pe++] = pn : (pn -= 65536, Ze[Pe++] = 55296 | pn >> 10 & 1023, Ze[Pe++] = 56320 | pn & 1023);
              }
              return Ry(Ze, Pe);
            }, Dy = (U, fe) => {
              fe = fe || U.length, fe > U.length && (fe = U.length);
              let Y = fe - 1;
              for (; Y >= 0 && (U[Y] & 192) === 128; )
                Y--;
              return Y < 0 || Y === 0 ? fe : Y + Mm[U[Y]] > fe ? Y : fe;
            }, Am = {
              string2buf: Py,
              buf2string: $y,
              utf8border: Dy
            };
            function Oy() {
              this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
            }
            var sg = Oy;
            const lg = Object.prototype.toString, {
              Z_NO_FLUSH: Iy,
              Z_SYNC_FLUSH: Ny,
              Z_FULL_FLUSH: Ly,
              Z_FINISH: jy,
              Z_OK: Im,
              Z_STREAM_END: Fy,
              Z_DEFAULT_COMPRESSION: zy,
              Z_DEFAULT_STRATEGY: Uy,
              Z_DEFLATED: By
            } = K;
            function Pm(U) {
              this.options = Om.assign({
                level: zy,
                method: By,
                chunkSize: 16384,
                windowBits: 15,
                memLevel: 8,
                strategy: Uy
              }, U || {});
              let fe = this.options;
              fe.raw && fe.windowBits > 0 ? fe.windowBits = -fe.windowBits : fe.gzip && fe.windowBits > 0 && fe.windowBits < 16 && (fe.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new sg(), this.strm.avail_out = 0;
              let Y = Cm.deflateInit2(
                this.strm,
                fe.level,
                fe.method,
                fe.windowBits,
                fe.memLevel,
                fe.strategy
              );
              if (Y !== Im)
                throw new Error(Ht[Y]);
              if (fe.header && Cm.deflateSetHeader(this.strm, fe.header), fe.dictionary) {
                let Me;
                if (typeof fe.dictionary == "string" ? Me = Am.string2buf(fe.dictionary) : lg.call(fe.dictionary) === "[object ArrayBuffer]" ? Me = new Uint8Array(fe.dictionary) : Me = fe.dictionary, Y = Cm.deflateSetDictionary(this.strm, Me), Y !== Im)
                  throw new Error(Ht[Y]);
                this._dict_set = !0;
              }
            }
            Pm.prototype.push = function(U, fe) {
              const Y = this.strm, Me = this.options.chunkSize;
              let Pe, Ze;
              if (this.ended)
                return !1;
              for (fe === ~~fe ? Ze = fe : Ze = fe === !0 ? jy : Iy, typeof U == "string" ? Y.input = Am.string2buf(U) : lg.call(U) === "[object ArrayBuffer]" ? Y.input = new Uint8Array(U) : Y.input = U, Y.next_in = 0, Y.avail_in = Y.input.length; ; ) {
                if (Y.avail_out === 0 && (Y.output = new Uint8Array(Me), Y.next_out = 0, Y.avail_out = Me), (Ze === Ny || Ze === Ly) && Y.avail_out <= 6) {
                  this.onData(Y.output.subarray(0, Y.next_out)), Y.avail_out = 0;
                  continue;
                }
                if (Pe = Cm.deflate(Y, Ze), Pe === Fy)
                  return Y.next_out > 0 && this.onData(Y.output.subarray(0, Y.next_out)), Pe = Cm.deflateEnd(this.strm), this.onEnd(Pe), this.ended = !0, Pe === Im;
                if (Y.avail_out === 0) {
                  this.onData(Y.output);
                  continue;
                }
                if (Ze > 0 && Y.next_out > 0) {
                  this.onData(Y.output.subarray(0, Y.next_out)), Y.avail_out = 0;
                  continue;
                }
                if (Y.avail_in === 0)
                  break;
              }
              return !0;
            }, Pm.prototype.onData = function(U) {
              this.chunks.push(U);
            }, Pm.prototype.onEnd = function(U) {
              U === Im && (this.result = Om.flattenChunks(this.chunks)), this.chunks = [], this.err = U, this.msg = this.strm.msg;
            };
            function Wm(U, fe) {
              const Y = new Pm(fe);
              if (Y.push(U, !0), Y.err)
                throw Y.msg || Ht[Y.err];
              return Y.result;
            }
            function Gy(U, fe) {
              return fe = fe || {}, fe.raw = !0, Wm(U, fe);
            }
            function Vy(U, fe) {
              return fe = fe || {}, fe.gzip = !0, Wm(U, fe);
            }
            var Wy = Pm, Hy = Wm, Yy = Gy, qy = Vy, Ky = K, Xy = {
              Deflate: Wy,
              deflate: Hy,
              deflateRaw: Yy,
              gzip: qy,
              constants: Ky
            };
            const Nm = 16209, Zy = 16191;
            var Qy = function(U, fe) {
              let Y, Me, Pe, Ze, pn, mr, yp, it, _r, Up, Lo, Ei, Wp, Yp, Np, Dp, $p, gs, Rp, Kp, kp, Ip, Gp, Cp;
              const Op = U.state;
              Y = U.next_in, Gp = U.input, Me = Y + (U.avail_in - 5), Pe = U.next_out, Cp = U.output, Ze = Pe - (fe - U.avail_out), pn = Pe + (U.avail_out - 257), mr = Op.dmax, yp = Op.wsize, it = Op.whave, _r = Op.wnext, Up = Op.window, Lo = Op.hold, Ei = Op.bits, Wp = Op.lencode, Yp = Op.distcode, Np = (1 << Op.lenbits) - 1, Dp = (1 << Op.distbits) - 1;
              e:
                do {
                  Ei < 15 && (Lo += Gp[Y++] << Ei, Ei += 8, Lo += Gp[Y++] << Ei, Ei += 8), $p = Wp[Lo & Np];
                  t:
                    for (; ; ) {
                      if (gs = $p >>> 24, Lo >>>= gs, Ei -= gs, gs = $p >>> 16 & 255, gs === 0)
                        Cp[Pe++] = $p & 65535;
                      else if (gs & 16) {
                        Rp = $p & 65535, gs &= 15, gs && (Ei < gs && (Lo += Gp[Y++] << Ei, Ei += 8), Rp += Lo & (1 << gs) - 1, Lo >>>= gs, Ei -= gs), Ei < 15 && (Lo += Gp[Y++] << Ei, Ei += 8, Lo += Gp[Y++] << Ei, Ei += 8), $p = Yp[Lo & Dp];
                        r:
                          for (; ; ) {
                            if (gs = $p >>> 24, Lo >>>= gs, Ei -= gs, gs = $p >>> 16 & 255, gs & 16) {
                              if (Kp = $p & 65535, gs &= 15, Ei < gs && (Lo += Gp[Y++] << Ei, Ei += 8, Ei < gs && (Lo += Gp[Y++] << Ei, Ei += 8)), Kp += Lo & (1 << gs) - 1, Kp > mr) {
                                U.msg = "invalid distance too far back", Op.mode = Nm;
                                break e;
                              }
                              if (Lo >>>= gs, Ei -= gs, gs = Pe - Ze, Kp > gs) {
                                if (gs = Kp - gs, gs > it && Op.sane) {
                                  U.msg = "invalid distance too far back", Op.mode = Nm;
                                  break e;
                                }
                                if (kp = 0, Ip = Up, _r === 0) {
                                  if (kp += yp - gs, gs < Rp) {
                                    Rp -= gs;
                                    do
                                      Cp[Pe++] = Up[kp++];
                                    while (--gs);
                                    kp = Pe - Kp, Ip = Cp;
                                  }
                                } else if (_r < gs) {
                                  if (kp += yp + _r - gs, gs -= _r, gs < Rp) {
                                    Rp -= gs;
                                    do
                                      Cp[Pe++] = Up[kp++];
                                    while (--gs);
                                    if (kp = 0, _r < Rp) {
                                      gs = _r, Rp -= gs;
                                      do
                                        Cp[Pe++] = Up[kp++];
                                      while (--gs);
                                      kp = Pe - Kp, Ip = Cp;
                                    }
                                  }
                                } else if (kp += _r - gs, gs < Rp) {
                                  Rp -= gs;
                                  do
                                    Cp[Pe++] = Up[kp++];
                                  while (--gs);
                                  kp = Pe - Kp, Ip = Cp;
                                }
                                for (; Rp > 2; )
                                  Cp[Pe++] = Ip[kp++], Cp[Pe++] = Ip[kp++], Cp[Pe++] = Ip[kp++], Rp -= 3;
                                Rp && (Cp[Pe++] = Ip[kp++], Rp > 1 && (Cp[Pe++] = Ip[kp++]));
                              } else {
                                kp = Pe - Kp;
                                do
                                  Cp[Pe++] = Cp[kp++], Cp[Pe++] = Cp[kp++], Cp[Pe++] = Cp[kp++], Rp -= 3;
                                while (Rp > 2);
                                Rp && (Cp[Pe++] = Cp[kp++], Rp > 1 && (Cp[Pe++] = Cp[kp++]));
                              }
                            } else if (gs & 64) {
                              U.msg = "invalid distance code", Op.mode = Nm;
                              break e;
                            } else {
                              $p = Yp[($p & 65535) + (Lo & (1 << gs) - 1)];
                              continue r;
                            }
                            break;
                          }
                      } else if (gs & 64)
                        if (gs & 32) {
                          Op.mode = Zy;
                          break e;
                        } else {
                          U.msg = "invalid literal/length code", Op.mode = Nm;
                          break e;
                        }
                      else {
                        $p = Wp[($p & 65535) + (Lo & (1 << gs) - 1)];
                        continue t;
                      }
                      break;
                    }
                } while (Y < Me && Pe < pn);
              Rp = Ei >> 3, Y -= Rp, Ei -= Rp << 3, Lo &= (1 << Ei) - 1, U.next_in = Y, U.next_out = Pe, U.avail_in = Y < Me ? 5 + (Me - Y) : 5 - (Y - Me), U.avail_out = Pe < pn ? 257 + (pn - Pe) : 257 - (Pe - pn), Op.hold = Lo, Op.bits = Ei;
            };
            const bm = 15, cg = 852, ug = 592, dg = 0, Hm = 1, fg = 2, Jy = new Uint16Array([
              /* Length codes 257..285 base */
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              10,
              11,
              13,
              15,
              17,
              19,
              23,
              27,
              31,
              35,
              43,
              51,
              59,
              67,
              83,
              99,
              115,
              131,
              163,
              195,
              227,
              258,
              0,
              0
            ]), ev = new Uint8Array([
              /* Length codes 257..285 extra */
              16,
              16,
              16,
              16,
              16,
              16,
              16,
              16,
              17,
              17,
              17,
              17,
              18,
              18,
              18,
              18,
              19,
              19,
              19,
              19,
              20,
              20,
              20,
              20,
              21,
              21,
              21,
              21,
              16,
              72,
              78
            ]), tv = new Uint16Array([
              /* Distance codes 0..29 base */
              1,
              2,
              3,
              4,
              5,
              7,
              9,
              13,
              17,
              25,
              33,
              49,
              65,
              97,
              129,
              193,
              257,
              385,
              513,
              769,
              1025,
              1537,
              2049,
              3073,
              4097,
              6145,
              8193,
              12289,
              16385,
              24577,
              0,
              0
            ]), rv = new Uint8Array([
              /* Distance codes 0..29 extra */
              16,
              16,
              16,
              16,
              17,
              17,
              18,
              18,
              19,
              19,
              20,
              20,
              21,
              21,
              22,
              22,
              23,
              23,
              24,
              24,
              25,
              25,
              26,
              26,
              27,
              27,
              28,
              28,
              29,
              29,
              64,
              64
            ]);
            var Rm = (U, fe, Y, Me, Pe, Ze, pn, mr) => {
              const yp = mr.bits;
              let it = 0, _r = 0, Up = 0, Lo = 0, Ei = 0, Wp = 0, Yp = 0, Np = 0, Dp = 0, $p = 0, gs, Rp, Kp, kp, Ip, Gp = null, Cp;
              const Op = new Uint16Array(bm + 1), Xp = new Uint16Array(bm + 1);
              let gm = null, oy, Um, Bm;
              for (it = 0; it <= bm; it++)
                Op[it] = 0;
              for (_r = 0; _r < Me; _r++)
                Op[fe[Y + _r]]++;
              for (Ei = yp, Lo = bm; Lo >= 1 && Op[Lo] === 0; Lo--)
                ;
              if (Ei > Lo && (Ei = Lo), Lo === 0)
                return Pe[Ze++] = 1 << 24 | 64 << 16 | 0, Pe[Ze++] = 1 << 24 | 64 << 16 | 0, mr.bits = 1, 0;
              for (Up = 1; Up < Lo && Op[Up] === 0; Up++)
                ;
              for (Ei < Up && (Ei = Up), Np = 1, it = 1; it <= bm; it++)
                if (Np <<= 1, Np -= Op[it], Np < 0)
                  return -1;
              if (Np > 0 && (U === dg || Lo !== 1))
                return -1;
              for (Xp[1] = 0, it = 1; it < bm; it++)
                Xp[it + 1] = Xp[it] + Op[it];
              for (_r = 0; _r < Me; _r++)
                fe[Y + _r] !== 0 && (pn[Xp[fe[Y + _r]]++] = _r);
              if (U === dg ? (Gp = gm = pn, Cp = 20) : U === Hm ? (Gp = Jy, gm = ev, Cp = 257) : (Gp = tv, gm = rv, Cp = 0), $p = 0, _r = 0, it = Up, Ip = Ze, Wp = Ei, Yp = 0, Kp = -1, Dp = 1 << Ei, kp = Dp - 1, U === Hm && Dp > cg || U === fg && Dp > ug)
                return 1;
              for (; ; ) {
                oy = it - Yp, pn[_r] + 1 < Cp ? (Um = 0, Bm = pn[_r]) : pn[_r] >= Cp ? (Um = gm[pn[_r] - Cp], Bm = Gp[pn[_r] - Cp]) : (Um = 96, Bm = 0), gs = 1 << it - Yp, Rp = 1 << Wp, Up = Rp;
                do
                  Rp -= gs, Pe[Ip + ($p >> Yp) + Rp] = oy << 24 | Um << 16 | Bm | 0;
                while (Rp !== 0);
                for (gs = 1 << it - 1; $p & gs; )
                  gs >>= 1;
                if (gs !== 0 ? ($p &= gs - 1, $p += gs) : $p = 0, _r++, --Op[it] === 0) {
                  if (it === Lo)
                    break;
                  it = fe[Y + pn[_r]];
                }
                if (it > Ei && ($p & kp) !== Kp) {
                  for (Yp === 0 && (Yp = Ei), Ip += Up, Wp = it - Yp, Np = 1 << Wp; Wp + Yp < Lo && (Np -= Op[Wp + Yp], !(Np <= 0)); )
                    Wp++, Np <<= 1;
                  if (Dp += 1 << Wp, U === Hm && Dp > cg || U === fg && Dp > ug)
                    return 1;
                  Kp = $p & kp, Pe[Kp] = Ei << 24 | Wp << 16 | Ip - Ze | 0;
                }
              }
              return $p !== 0 && (Pe[Ip + $p] = it - Yp << 24 | 64 << 16 | 0), mr.bits = Ei, 0;
            };
            const nv = 0, hg = 1, pg = 2, {
              Z_FINISH: mg,
              Z_BLOCK: iv,
              Z_TREES: Lm,
              Z_OK: pm,
              Z_STREAM_END: av,
              Z_NEED_DICT: ov,
              Z_STREAM_ERROR: im,
              Z_DATA_ERROR: gg,
              Z_MEM_ERROR: yg,
              Z_BUF_ERROR: sv,
              Z_DEFLATED: vg
            } = K, km = 16180, _g = 16181, bg = 16182, xg = 16183, wg = 16184, Sg = 16185, Eg = 16186, Tg = 16187, Cg = 16188, Mg = 16189, jm = 16190, lm = 16191, Ym = 16192, Ag = 16193, qm = 16194, Pg = 16195, Rg = 16196, $g = 16197, Dg = 16198, Fm = 16199, zm = 16200, Og = 16201, Ig = 16202, Ng = 16203, Lg = 16204, kg = 16205, Km = 16206, jg = 16207, Fg = 16208, Hp = 16209, zg = 16210, Ug = 16211, lv = 852, cv = 592, uv = 15, Bg = (U) => (U >>> 24 & 255) + (U >>> 8 & 65280) + ((U & 65280) << 8) + ((U & 255) << 24);
            function dv() {
              this.strm = null, this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
            }
            const mm = (U) => {
              if (!U)
                return 1;
              const fe = U.state;
              return !fe || fe.strm !== U || fe.mode < km || fe.mode > Ug ? 1 : 0;
            }, Gg = (U) => {
              if (mm(U))
                return im;
              const fe = U.state;
              return U.total_in = U.total_out = fe.total = 0, U.msg = "", fe.wrap && (U.adler = fe.wrap & 1), fe.mode = km, fe.last = 0, fe.havedict = 0, fe.flags = -1, fe.dmax = 32768, fe.head = null, fe.hold = 0, fe.bits = 0, fe.lencode = fe.lendyn = new Int32Array(lv), fe.distcode = fe.distdyn = new Int32Array(cv), fe.sane = 1, fe.back = -1, pm;
            }, Vg = (U) => {
              if (mm(U))
                return im;
              const fe = U.state;
              return fe.wsize = 0, fe.whave = 0, fe.wnext = 0, Gg(U);
            }, Wg = (U, fe) => {
              let Y;
              if (mm(U))
                return im;
              const Me = U.state;
              return fe < 0 ? (Y = 0, fe = -fe) : (Y = (fe >> 4) + 5, fe < 48 && (fe &= 15)), fe && (fe < 8 || fe > 15) ? im : (Me.window !== null && Me.wbits !== fe && (Me.window = null), Me.wrap = Y, Me.wbits = fe, Vg(U));
            }, Hg = (U, fe) => {
              if (!U)
                return im;
              const Y = new dv();
              U.state = Y, Y.strm = U, Y.window = null, Y.mode = km;
              const Me = Wg(U, fe);
              return Me !== pm && (U.state = null), Me;
            }, fv = (U) => Hg(U, uv);
            let Yg = !0, Xm, Zm;
            const hv = (U) => {
              if (Yg) {
                Xm = new Int32Array(512), Zm = new Int32Array(32);
                let fe = 0;
                for (; fe < 144; )
                  U.lens[fe++] = 8;
                for (; fe < 256; )
                  U.lens[fe++] = 9;
                for (; fe < 280; )
                  U.lens[fe++] = 7;
                for (; fe < 288; )
                  U.lens[fe++] = 8;
                for (Rm(hg, U.lens, 0, 288, Xm, 0, U.work, { bits: 9 }), fe = 0; fe < 32; )
                  U.lens[fe++] = 5;
                Rm(pg, U.lens, 0, 32, Zm, 0, U.work, { bits: 5 }), Yg = !1;
              }
              U.lencode = Xm, U.lenbits = 9, U.distcode = Zm, U.distbits = 5;
            }, qg = (U, fe, Y, Me) => {
              let Pe;
              const Ze = U.state;
              return Ze.window === null && (Ze.wsize = 1 << Ze.wbits, Ze.wnext = 0, Ze.whave = 0, Ze.window = new Uint8Array(Ze.wsize)), Me >= Ze.wsize ? (Ze.window.set(fe.subarray(Y - Ze.wsize, Y), 0), Ze.wnext = 0, Ze.whave = Ze.wsize) : (Pe = Ze.wsize - Ze.wnext, Pe > Me && (Pe = Me), Ze.window.set(fe.subarray(Y - Me, Y - Me + Pe), Ze.wnext), Me -= Pe, Me ? (Ze.window.set(fe.subarray(Y - Me, Y), 0), Ze.wnext = Me, Ze.whave = Ze.wsize) : (Ze.wnext += Pe, Ze.wnext === Ze.wsize && (Ze.wnext = 0), Ze.whave < Ze.wsize && (Ze.whave += Pe))), 0;
            }, pv = (U, fe) => {
              let Y, Me, Pe, Ze, pn, mr, yp, it, _r, Up, Lo, Ei, Wp, Yp, Np = 0, Dp, $p, gs, Rp, Kp, kp, Ip, Gp;
              const Cp = new Uint8Array(4);
              let Op, Xp;
              const gm = (
                /* permutation of code lengths */
                new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
              );
              if (mm(U) || !U.output || !U.input && U.avail_in !== 0)
                return im;
              Y = U.state, Y.mode === lm && (Y.mode = Ym), pn = U.next_out, Pe = U.output, yp = U.avail_out, Ze = U.next_in, Me = U.input, mr = U.avail_in, it = Y.hold, _r = Y.bits, Up = mr, Lo = yp, Gp = pm;
              e:
                for (; ; )
                  switch (Y.mode) {
                    case km:
                      if (Y.wrap === 0) {
                        Y.mode = Ym;
                        break;
                      }
                      for (; _r < 16; ) {
                        if (mr === 0)
                          break e;
                        mr--, it += Me[Ze++] << _r, _r += 8;
                      }
                      if (Y.wrap & 2 && it === 35615) {
                        Y.wbits === 0 && (Y.wbits = 15), Y.check = 0, Cp[0] = it & 255, Cp[1] = it >>> 8 & 255, Y.check = _e(Y.check, Cp, 2, 0), it = 0, _r = 0, Y.mode = _g;
                        break;
                      }
                      if (Y.head && (Y.head.done = !1), !(Y.wrap & 1) || /* check if zlib header allowed */
                      (((it & 255) << 8) + (it >> 8)) % 31) {
                        U.msg = "incorrect header check", Y.mode = Hp;
                        break;
                      }
                      if ((it & 15) !== vg) {
                        U.msg = "unknown compression method", Y.mode = Hp;
                        break;
                      }
                      if (it >>>= 4, _r -= 4, Ip = (it & 15) + 8, Y.wbits === 0 && (Y.wbits = Ip), Ip > 15 || Ip > Y.wbits) {
                        U.msg = "invalid window size", Y.mode = Hp;
                        break;
                      }
                      Y.dmax = 1 << Y.wbits, Y.flags = 0, U.adler = Y.check = 1, Y.mode = it & 512 ? Mg : lm, it = 0, _r = 0;
                      break;
                    case _g:
                      for (; _r < 16; ) {
                        if (mr === 0)
                          break e;
                        mr--, it += Me[Ze++] << _r, _r += 8;
                      }
                      if (Y.flags = it, (Y.flags & 255) !== vg) {
                        U.msg = "unknown compression method", Y.mode = Hp;
                        break;
                      }
                      if (Y.flags & 57344) {
                        U.msg = "unknown header flags set", Y.mode = Hp;
                        break;
                      }
                      Y.head && (Y.head.text = it >> 8 & 1), Y.flags & 512 && Y.wrap & 4 && (Cp[0] = it & 255, Cp[1] = it >>> 8 & 255, Y.check = _e(Y.check, Cp, 2, 0)), it = 0, _r = 0, Y.mode = bg;
                    case bg:
                      for (; _r < 32; ) {
                        if (mr === 0)
                          break e;
                        mr--, it += Me[Ze++] << _r, _r += 8;
                      }
                      Y.head && (Y.head.time = it), Y.flags & 512 && Y.wrap & 4 && (Cp[0] = it & 255, Cp[1] = it >>> 8 & 255, Cp[2] = it >>> 16 & 255, Cp[3] = it >>> 24 & 255, Y.check = _e(Y.check, Cp, 4, 0)), it = 0, _r = 0, Y.mode = xg;
                    case xg:
                      for (; _r < 16; ) {
                        if (mr === 0)
                          break e;
                        mr--, it += Me[Ze++] << _r, _r += 8;
                      }
                      Y.head && (Y.head.xflags = it & 255, Y.head.os = it >> 8), Y.flags & 512 && Y.wrap & 4 && (Cp[0] = it & 255, Cp[1] = it >>> 8 & 255, Y.check = _e(Y.check, Cp, 2, 0)), it = 0, _r = 0, Y.mode = wg;
                    case wg:
                      if (Y.flags & 1024) {
                        for (; _r < 16; ) {
                          if (mr === 0)
                            break e;
                          mr--, it += Me[Ze++] << _r, _r += 8;
                        }
                        Y.length = it, Y.head && (Y.head.extra_len = it), Y.flags & 512 && Y.wrap & 4 && (Cp[0] = it & 255, Cp[1] = it >>> 8 & 255, Y.check = _e(Y.check, Cp, 2, 0)), it = 0, _r = 0;
                      } else
                        Y.head && (Y.head.extra = null);
                      Y.mode = Sg;
                    case Sg:
                      if (Y.flags & 1024 && (Ei = Y.length, Ei > mr && (Ei = mr), Ei && (Y.head && (Ip = Y.head.extra_len - Y.length, Y.head.extra || (Y.head.extra = new Uint8Array(Y.head.extra_len)), Y.head.extra.set(
                        Me.subarray(
                          Ze,
                          // extra field is limited to 65536 bytes
                          // - no need for additional size check
                          Ze + Ei
                        ),
                        /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                        Ip
                      )), Y.flags & 512 && Y.wrap & 4 && (Y.check = _e(Y.check, Me, Ei, Ze)), mr -= Ei, Ze += Ei, Y.length -= Ei), Y.length))
                        break e;
                      Y.length = 0, Y.mode = Eg;
                    case Eg:
                      if (Y.flags & 2048) {
                        if (mr === 0)
                          break e;
                        Ei = 0;
                        do
                          Ip = Me[Ze + Ei++], Y.head && Ip && Y.length < 65536 && (Y.head.name += String.fromCharCode(Ip));
                        while (Ip && Ei < mr);
                        if (Y.flags & 512 && Y.wrap & 4 && (Y.check = _e(Y.check, Me, Ei, Ze)), mr -= Ei, Ze += Ei, Ip)
                          break e;
                      } else
                        Y.head && (Y.head.name = null);
                      Y.length = 0, Y.mode = Tg;
                    case Tg:
                      if (Y.flags & 4096) {
                        if (mr === 0)
                          break e;
                        Ei = 0;
                        do
                          Ip = Me[Ze + Ei++], Y.head && Ip && Y.length < 65536 && (Y.head.comment += String.fromCharCode(Ip));
                        while (Ip && Ei < mr);
                        if (Y.flags & 512 && Y.wrap & 4 && (Y.check = _e(Y.check, Me, Ei, Ze)), mr -= Ei, Ze += Ei, Ip)
                          break e;
                      } else
                        Y.head && (Y.head.comment = null);
                      Y.mode = Cg;
                    case Cg:
                      if (Y.flags & 512) {
                        for (; _r < 16; ) {
                          if (mr === 0)
                            break e;
                          mr--, it += Me[Ze++] << _r, _r += 8;
                        }
                        if (Y.wrap & 4 && it !== (Y.check & 65535)) {
                          U.msg = "header crc mismatch", Y.mode = Hp;
                          break;
                        }
                        it = 0, _r = 0;
                      }
                      Y.head && (Y.head.hcrc = Y.flags >> 9 & 1, Y.head.done = !0), U.adler = Y.check = 0, Y.mode = lm;
                      break;
                    case Mg:
                      for (; _r < 32; ) {
                        if (mr === 0)
                          break e;
                        mr--, it += Me[Ze++] << _r, _r += 8;
                      }
                      U.adler = Y.check = Bg(it), it = 0, _r = 0, Y.mode = jm;
                    case jm:
                      if (Y.havedict === 0)
                        return U.next_out = pn, U.avail_out = yp, U.next_in = Ze, U.avail_in = mr, Y.hold = it, Y.bits = _r, ov;
                      U.adler = Y.check = 1, Y.mode = lm;
                    case lm:
                      if (fe === iv || fe === Lm)
                        break e;
                    case Ym:
                      if (Y.last) {
                        it >>>= _r & 7, _r -= _r & 7, Y.mode = Km;
                        break;
                      }
                      for (; _r < 3; ) {
                        if (mr === 0)
                          break e;
                        mr--, it += Me[Ze++] << _r, _r += 8;
                      }
                      switch (Y.last = it & 1, it >>>= 1, _r -= 1, it & 3) {
                        case 0:
                          Y.mode = Ag;
                          break;
                        case 1:
                          if (hv(Y), Y.mode = Fm, fe === Lm) {
                            it >>>= 2, _r -= 2;
                            break e;
                          }
                          break;
                        case 2:
                          Y.mode = Rg;
                          break;
                        case 3:
                          U.msg = "invalid block type", Y.mode = Hp;
                      }
                      it >>>= 2, _r -= 2;
                      break;
                    case Ag:
                      for (it >>>= _r & 7, _r -= _r & 7; _r < 32; ) {
                        if (mr === 0)
                          break e;
                        mr--, it += Me[Ze++] << _r, _r += 8;
                      }
                      if ((it & 65535) !== (it >>> 16 ^ 65535)) {
                        U.msg = "invalid stored block lengths", Y.mode = Hp;
                        break;
                      }
                      if (Y.length = it & 65535, it = 0, _r = 0, Y.mode = qm, fe === Lm)
                        break e;
                    case qm:
                      Y.mode = Pg;
                    case Pg:
                      if (Ei = Y.length, Ei) {
                        if (Ei > mr && (Ei = mr), Ei > yp && (Ei = yp), Ei === 0)
                          break e;
                        Pe.set(Me.subarray(Ze, Ze + Ei), pn), mr -= Ei, Ze += Ei, yp -= Ei, pn += Ei, Y.length -= Ei;
                        break;
                      }
                      Y.mode = lm;
                      break;
                    case Rg:
                      for (; _r < 14; ) {
                        if (mr === 0)
                          break e;
                        mr--, it += Me[Ze++] << _r, _r += 8;
                      }
                      if (Y.nlen = (it & 31) + 257, it >>>= 5, _r -= 5, Y.ndist = (it & 31) + 1, it >>>= 5, _r -= 5, Y.ncode = (it & 15) + 4, it >>>= 4, _r -= 4, Y.nlen > 286 || Y.ndist > 30) {
                        U.msg = "too many length or distance symbols", Y.mode = Hp;
                        break;
                      }
                      Y.have = 0, Y.mode = $g;
                    case $g:
                      for (; Y.have < Y.ncode; ) {
                        for (; _r < 3; ) {
                          if (mr === 0)
                            break e;
                          mr--, it += Me[Ze++] << _r, _r += 8;
                        }
                        Y.lens[gm[Y.have++]] = it & 7, it >>>= 3, _r -= 3;
                      }
                      for (; Y.have < 19; )
                        Y.lens[gm[Y.have++]] = 0;
                      if (Y.lencode = Y.lendyn, Y.lenbits = 7, Op = { bits: Y.lenbits }, Gp = Rm(nv, Y.lens, 0, 19, Y.lencode, 0, Y.work, Op), Y.lenbits = Op.bits, Gp) {
                        U.msg = "invalid code lengths set", Y.mode = Hp;
                        break;
                      }
                      Y.have = 0, Y.mode = Dg;
                    case Dg:
                      for (; Y.have < Y.nlen + Y.ndist; ) {
                        for (; Np = Y.lencode[it & (1 << Y.lenbits) - 1], Dp = Np >>> 24, $p = Np >>> 16 & 255, gs = Np & 65535, !(Dp <= _r); ) {
                          if (mr === 0)
                            break e;
                          mr--, it += Me[Ze++] << _r, _r += 8;
                        }
                        if (gs < 16)
                          it >>>= Dp, _r -= Dp, Y.lens[Y.have++] = gs;
                        else {
                          if (gs === 16) {
                            for (Xp = Dp + 2; _r < Xp; ) {
                              if (mr === 0)
                                break e;
                              mr--, it += Me[Ze++] << _r, _r += 8;
                            }
                            if (it >>>= Dp, _r -= Dp, Y.have === 0) {
                              U.msg = "invalid bit length repeat", Y.mode = Hp;
                              break;
                            }
                            Ip = Y.lens[Y.have - 1], Ei = 3 + (it & 3), it >>>= 2, _r -= 2;
                          } else if (gs === 17) {
                            for (Xp = Dp + 3; _r < Xp; ) {
                              if (mr === 0)
                                break e;
                              mr--, it += Me[Ze++] << _r, _r += 8;
                            }
                            it >>>= Dp, _r -= Dp, Ip = 0, Ei = 3 + (it & 7), it >>>= 3, _r -= 3;
                          } else {
                            for (Xp = Dp + 7; _r < Xp; ) {
                              if (mr === 0)
                                break e;
                              mr--, it += Me[Ze++] << _r, _r += 8;
                            }
                            it >>>= Dp, _r -= Dp, Ip = 0, Ei = 11 + (it & 127), it >>>= 7, _r -= 7;
                          }
                          if (Y.have + Ei > Y.nlen + Y.ndist) {
                            U.msg = "invalid bit length repeat", Y.mode = Hp;
                            break;
                          }
                          for (; Ei--; )
                            Y.lens[Y.have++] = Ip;
                        }
                      }
                      if (Y.mode === Hp)
                        break;
                      if (Y.lens[256] === 0) {
                        U.msg = "invalid code -- missing end-of-block", Y.mode = Hp;
                        break;
                      }
                      if (Y.lenbits = 9, Op = { bits: Y.lenbits }, Gp = Rm(hg, Y.lens, 0, Y.nlen, Y.lencode, 0, Y.work, Op), Y.lenbits = Op.bits, Gp) {
                        U.msg = "invalid literal/lengths set", Y.mode = Hp;
                        break;
                      }
                      if (Y.distbits = 6, Y.distcode = Y.distdyn, Op = { bits: Y.distbits }, Gp = Rm(pg, Y.lens, Y.nlen, Y.ndist, Y.distcode, 0, Y.work, Op), Y.distbits = Op.bits, Gp) {
                        U.msg = "invalid distances set", Y.mode = Hp;
                        break;
                      }
                      if (Y.mode = Fm, fe === Lm)
                        break e;
                    case Fm:
                      Y.mode = zm;
                    case zm:
                      if (mr >= 6 && yp >= 258) {
                        U.next_out = pn, U.avail_out = yp, U.next_in = Ze, U.avail_in = mr, Y.hold = it, Y.bits = _r, Qy(U, Lo), pn = U.next_out, Pe = U.output, yp = U.avail_out, Ze = U.next_in, Me = U.input, mr = U.avail_in, it = Y.hold, _r = Y.bits, Y.mode === lm && (Y.back = -1);
                        break;
                      }
                      for (Y.back = 0; Np = Y.lencode[it & (1 << Y.lenbits) - 1], Dp = Np >>> 24, $p = Np >>> 16 & 255, gs = Np & 65535, !(Dp <= _r); ) {
                        if (mr === 0)
                          break e;
                        mr--, it += Me[Ze++] << _r, _r += 8;
                      }
                      if ($p && !($p & 240)) {
                        for (Rp = Dp, Kp = $p, kp = gs; Np = Y.lencode[kp + ((it & (1 << Rp + Kp) - 1) >> Rp)], Dp = Np >>> 24, $p = Np >>> 16 & 255, gs = Np & 65535, !(Rp + Dp <= _r); ) {
                          if (mr === 0)
                            break e;
                          mr--, it += Me[Ze++] << _r, _r += 8;
                        }
                        it >>>= Rp, _r -= Rp, Y.back += Rp;
                      }
                      if (it >>>= Dp, _r -= Dp, Y.back += Dp, Y.length = gs, $p === 0) {
                        Y.mode = kg;
                        break;
                      }
                      if ($p & 32) {
                        Y.back = -1, Y.mode = lm;
                        break;
                      }
                      if ($p & 64) {
                        U.msg = "invalid literal/length code", Y.mode = Hp;
                        break;
                      }
                      Y.extra = $p & 15, Y.mode = Og;
                    case Og:
                      if (Y.extra) {
                        for (Xp = Y.extra; _r < Xp; ) {
                          if (mr === 0)
                            break e;
                          mr--, it += Me[Ze++] << _r, _r += 8;
                        }
                        Y.length += it & (1 << Y.extra) - 1, it >>>= Y.extra, _r -= Y.extra, Y.back += Y.extra;
                      }
                      Y.was = Y.length, Y.mode = Ig;
                    case Ig:
                      for (; Np = Y.distcode[it & (1 << Y.distbits) - 1], Dp = Np >>> 24, $p = Np >>> 16 & 255, gs = Np & 65535, !(Dp <= _r); ) {
                        if (mr === 0)
                          break e;
                        mr--, it += Me[Ze++] << _r, _r += 8;
                      }
                      if (!($p & 240)) {
                        for (Rp = Dp, Kp = $p, kp = gs; Np = Y.distcode[kp + ((it & (1 << Rp + Kp) - 1) >> Rp)], Dp = Np >>> 24, $p = Np >>> 16 & 255, gs = Np & 65535, !(Rp + Dp <= _r); ) {
                          if (mr === 0)
                            break e;
                          mr--, it += Me[Ze++] << _r, _r += 8;
                        }
                        it >>>= Rp, _r -= Rp, Y.back += Rp;
                      }
                      if (it >>>= Dp, _r -= Dp, Y.back += Dp, $p & 64) {
                        U.msg = "invalid distance code", Y.mode = Hp;
                        break;
                      }
                      Y.offset = gs, Y.extra = $p & 15, Y.mode = Ng;
                    case Ng:
                      if (Y.extra) {
                        for (Xp = Y.extra; _r < Xp; ) {
                          if (mr === 0)
                            break e;
                          mr--, it += Me[Ze++] << _r, _r += 8;
                        }
                        Y.offset += it & (1 << Y.extra) - 1, it >>>= Y.extra, _r -= Y.extra, Y.back += Y.extra;
                      }
                      if (Y.offset > Y.dmax) {
                        U.msg = "invalid distance too far back", Y.mode = Hp;
                        break;
                      }
                      Y.mode = Lg;
                    case Lg:
                      if (yp === 0)
                        break e;
                      if (Ei = Lo - yp, Y.offset > Ei) {
                        if (Ei = Y.offset - Ei, Ei > Y.whave && Y.sane) {
                          U.msg = "invalid distance too far back", Y.mode = Hp;
                          break;
                        }
                        Ei > Y.wnext ? (Ei -= Y.wnext, Wp = Y.wsize - Ei) : Wp = Y.wnext - Ei, Ei > Y.length && (Ei = Y.length), Yp = Y.window;
                      } else
                        Yp = Pe, Wp = pn - Y.offset, Ei = Y.length;
                      Ei > yp && (Ei = yp), yp -= Ei, Y.length -= Ei;
                      do
                        Pe[pn++] = Yp[Wp++];
                      while (--Ei);
                      Y.length === 0 && (Y.mode = zm);
                      break;
                    case kg:
                      if (yp === 0)
                        break e;
                      Pe[pn++] = Y.length, yp--, Y.mode = zm;
                      break;
                    case Km:
                      if (Y.wrap) {
                        for (; _r < 32; ) {
                          if (mr === 0)
                            break e;
                          mr--, it |= Me[Ze++] << _r, _r += 8;
                        }
                        if (Lo -= yp, U.total_out += Lo, Y.total += Lo, Y.wrap & 4 && Lo && (U.adler = Y.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
                        Y.flags ? _e(Y.check, Pe, Lo, pn - Lo) : Ee(Y.check, Pe, Lo, pn - Lo)), Lo = yp, Y.wrap & 4 && (Y.flags ? it : Bg(it)) !== Y.check) {
                          U.msg = "incorrect data check", Y.mode = Hp;
                          break;
                        }
                        it = 0, _r = 0;
                      }
                      Y.mode = jg;
                    case jg:
                      if (Y.wrap && Y.flags) {
                        for (; _r < 32; ) {
                          if (mr === 0)
                            break e;
                          mr--, it += Me[Ze++] << _r, _r += 8;
                        }
                        if (Y.wrap & 4 && it !== (Y.total & 4294967295)) {
                          U.msg = "incorrect length check", Y.mode = Hp;
                          break;
                        }
                        it = 0, _r = 0;
                      }
                      Y.mode = Fg;
                    case Fg:
                      Gp = av;
                      break e;
                    case Hp:
                      Gp = gg;
                      break e;
                    case zg:
                      return yg;
                    case Ug:
                    default:
                      return im;
                  }
              return U.next_out = pn, U.avail_out = yp, U.next_in = Ze, U.avail_in = mr, Y.hold = it, Y.bits = _r, (Y.wsize || Lo !== U.avail_out && Y.mode < Hp && (Y.mode < Km || fe !== mg)) && qg(U, U.output, U.next_out, Lo - U.avail_out), Up -= U.avail_in, Lo -= U.avail_out, U.total_in += Up, U.total_out += Lo, Y.total += Lo, Y.wrap & 4 && Lo && (U.adler = Y.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
              Y.flags ? _e(Y.check, Pe, Lo, U.next_out - Lo) : Ee(Y.check, Pe, Lo, U.next_out - Lo)), U.data_type = Y.bits + (Y.last ? 64 : 0) + (Y.mode === lm ? 128 : 0) + (Y.mode === Fm || Y.mode === qm ? 256 : 0), (Up === 0 && Lo === 0 || fe === mg) && Gp === pm && (Gp = sv), Gp;
            }, mv = (U) => {
              if (mm(U))
                return im;
              let fe = U.state;
              return fe.window && (fe.window = null), U.state = null, pm;
            }, gv = (U, fe) => {
              if (mm(U))
                return im;
              const Y = U.state;
              return Y.wrap & 2 ? (Y.head = fe, fe.done = !1, pm) : im;
            }, yv = (U, fe) => {
              const Y = fe.length;
              let Me, Pe, Ze;
              return mm(U) || (Me = U.state, Me.wrap !== 0 && Me.mode !== jm) ? im : Me.mode === jm && (Pe = 1, Pe = Ee(Pe, fe, Y, 0), Pe !== Me.check) ? gg : (Ze = qg(U, fe, Y, Y), Ze ? (Me.mode = zg, yg) : (Me.havedict = 1, pm));
            };
            var vv = Vg, _v = Wg, bv = Gg, xv = fv, wv = Hg, Sv = pv, Ev = mv, Tv = gv, Cv = yv, Mv = "pako inflate (from Nodeca project)", cm = {
              inflateReset: vv,
              inflateReset2: _v,
              inflateResetKeep: bv,
              inflateInit: xv,
              inflateInit2: wv,
              inflate: Sv,
              inflateEnd: Ev,
              inflateGetHeader: Tv,
              inflateSetDictionary: Cv,
              inflateInfo: Mv
            };
            function Av() {
              this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
            }
            var Pv = Av;
            const Kg = Object.prototype.toString, {
              Z_NO_FLUSH: Rv,
              Z_FINISH: $v,
              Z_OK: $m,
              Z_STREAM_END: Qm,
              Z_NEED_DICT: Jm,
              Z_STREAM_ERROR: Dv,
              Z_DATA_ERROR: Xg,
              Z_MEM_ERROR: Ov
            } = K;
            function Dm(U) {
              this.options = Om.assign({
                chunkSize: 65536,
                windowBits: 15,
                to: ""
              }, U || {});
              const fe = this.options;
              fe.raw && fe.windowBits >= 0 && fe.windowBits < 16 && (fe.windowBits = -fe.windowBits, fe.windowBits === 0 && (fe.windowBits = -15)), fe.windowBits >= 0 && fe.windowBits < 16 && !(U && U.windowBits) && (fe.windowBits += 32), fe.windowBits > 15 && fe.windowBits < 48 && (fe.windowBits & 15 || (fe.windowBits |= 15)), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new sg(), this.strm.avail_out = 0;
              let Y = cm.inflateInit2(
                this.strm,
                fe.windowBits
              );
              if (Y !== $m)
                throw new Error(Ht[Y]);
              if (this.header = new Pv(), cm.inflateGetHeader(this.strm, this.header), fe.dictionary && (typeof fe.dictionary == "string" ? fe.dictionary = Am.string2buf(fe.dictionary) : Kg.call(fe.dictionary) === "[object ArrayBuffer]" && (fe.dictionary = new Uint8Array(fe.dictionary)), fe.raw && (Y = cm.inflateSetDictionary(this.strm, fe.dictionary), Y !== $m)))
                throw new Error(Ht[Y]);
            }
            Dm.prototype.push = function(U, fe) {
              const Y = this.strm, Me = this.options.chunkSize, Pe = this.options.dictionary;
              let Ze, pn, mr;
              if (this.ended)
                return !1;
              for (fe === ~~fe ? pn = fe : pn = fe === !0 ? $v : Rv, Kg.call(U) === "[object ArrayBuffer]" ? Y.input = new Uint8Array(U) : Y.input = U, Y.next_in = 0, Y.avail_in = Y.input.length; ; ) {
                for (Y.avail_out === 0 && (Y.output = new Uint8Array(Me), Y.next_out = 0, Y.avail_out = Me), Ze = cm.inflate(Y, pn), Ze === Jm && Pe && (Ze = cm.inflateSetDictionary(Y, Pe), Ze === $m ? Ze = cm.inflate(Y, pn) : Ze === Xg && (Ze = Jm)); Y.avail_in > 0 && Ze === Qm && Y.state.wrap > 0 && U[Y.next_in] !== 0; )
                  cm.inflateReset(Y), Ze = cm.inflate(Y, pn);
                switch (Ze) {
                  case Dv:
                  case Xg:
                  case Jm:
                  case Ov:
                    return this.onEnd(Ze), this.ended = !0, !1;
                }
                if (mr = Y.avail_out, Y.next_out && (Y.avail_out === 0 || Ze === Qm))
                  if (this.options.to === "string") {
                    let yp = Am.utf8border(Y.output, Y.next_out), it = Y.next_out - yp, _r = Am.buf2string(Y.output, yp);
                    Y.next_out = it, Y.avail_out = Me - it, it && Y.output.set(Y.output.subarray(yp, yp + it), 0), this.onData(_r);
                  } else
                    this.onData(Y.output.length === Y.next_out ? Y.output : Y.output.subarray(0, Y.next_out));
                if (!(Ze === $m && mr === 0)) {
                  if (Ze === Qm)
                    return Ze = cm.inflateEnd(this.strm), this.onEnd(Ze), this.ended = !0, !0;
                  if (Y.avail_in === 0)
                    break;
                }
              }
              return !0;
            }, Dm.prototype.onData = function(U) {
              this.chunks.push(U);
            }, Dm.prototype.onEnd = function(U) {
              U === $m && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = Om.flattenChunks(this.chunks)), this.chunks = [], this.err = U, this.msg = this.strm.msg;
            };
            function eg(U, fe) {
              const Y = new Dm(fe);
              if (Y.push(U), Y.err)
                throw Y.msg || Ht[Y.err];
              return Y.result;
            }
            function Iv(U, fe) {
              return fe = fe || {}, fe.raw = !0, eg(U, fe);
            }
            var Nv = Dm, Lv = eg, kv = Iv, jv = eg, Fv = K, zv = {
              Inflate: Nv,
              inflate: Lv,
              inflateRaw: kv,
              ungzip: jv,
              constants: Fv
            };
            const { Deflate: Uv, deflate: Bv, deflateRaw: Gv, gzip: Vv } = Xy, { Inflate: Wv, inflate: Hv, inflateRaw: Yv, ungzip: qv } = zv;
            var Zg = Uv, Qg = Bv, Jg = Gv, ey = Vv, ty = Wv, ry = Hv, ny = Yv, iy = qv, ay = K, Kv = {
              Deflate: Zg,
              deflate: Qg,
              deflateRaw: Jg,
              gzip: ey,
              Inflate: ty,
              inflate: ry,
              inflateRaw: ny,
              ungzip: iy,
              constants: ay
            };
          }
        )
        /******/
      }, __webpack_module_cache__ = {};
      function __webpack_require__(t) {
        var e = __webpack_module_cache__[t];
        if (e !== void 0)
          return e.exports;
        var n = __webpack_module_cache__[t] = {
          /******/
          // no module.id needed
          /******/
          // no module.loaded needed
          /******/
          exports: {}
          /******/
        };
        return __webpack_modules__[t].call(n.exports, n, n.exports, __webpack_require__), n.exports;
      }
      __webpack_require__.n = (t) => {
        var e = t && t.__esModule ? (
          /******/
          () => t.default
        ) : (
          /******/
          () => t
        );
        return __webpack_require__.d(e, { a: e }), e;
      }, __webpack_require__.d = (t, e) => {
        for (var n in e)
          __webpack_require__.o(e, n) && !__webpack_require__.o(t, n) && Object.defineProperty(t, n, { enumerable: !0, get: e[n] });
      }, __webpack_require__.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), __webpack_require__.r = (t) => {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 });
      }, __webpack_require__("./src/index.ts"), __webpack_require__("./src/SurfaceWorker.js");
      var __webpack_exports__ = __webpack_require__("./src/exporter.js");
      return __webpack_exports__;
    })()
  ));
})(_3Dmol);
var _3DmolExports = _3Dmol.exports;
const covalentRadii = {
  H: 0.31,
  He: 0.28,
  Li: 1.28,
  Be: 0.96,
  B: 0.84,
  C: 0.76,
  N: 0.71,
  O: 0.66,
  F: 0.57,
  Ne: 0.58,
  Na: 1.66,
  Mg: 1.41,
  Al: 1.21,
  Si: 1.11,
  P: 1.07,
  S: 1.05,
  Cl: 1.02,
  Ar: 1.06,
  K: 2.03,
  Ca: 1.76,
  Sc: 1.7,
  Ti: 1.6,
  V: 1.53,
  Cr: 1.39,
  Mn: 1.61,
  Fe: 1.52,
  Co: 1.5,
  Ni: 1.24,
  Cu: 1.32,
  Zn: 1.22,
  Ga: 1.22,
  Ge: 1.2,
  As: 1.19,
  Se: 1.2,
  Br: 1.2,
  Kr: 1.16,
  Rb: 2.2,
  Sr: 1.95,
  Y: 1.9,
  Zr: 1.75,
  Nb: 1.64,
  Mo: 1.54,
  Tc: 1.47,
  Ru: 1.46,
  Rh: 1.42,
  Pd: 1.39,
  Ag: 1.45,
  Cd: 1.44,
  In: 1.42,
  Sn: 1.39,
  Sb: 1.39,
  Te: 1.38,
  I: 1.39,
  Xe: 1.4,
  Cs: 2.44,
  Ba: 2.15,
  La: 2.07,
  Ce: 2.04,
  Pr: 2.03,
  Nd: 2.01,
  Pm: 1.99,
  Sm: 1.98,
  Eu: 1.98,
  Gd: 1.96,
  Tb: 1.94,
  Dy: 1.92,
  Ho: 1.92,
  Er: 1.89,
  Tm: 1.9,
  Yb: 1.87,
  Lu: 1.75,
  Hf: 1.87,
  Ta: 1.7,
  W: 1.62,
  Re: 1.51,
  Os: 1.44,
  Ir: 1.41,
  Pt: 1.36,
  Au: 1.36,
  Hg: 1.32,
  Tl: 1.45,
  Pb: 1.46,
  Bi: 1.48,
  Po: 1.4,
  At: 1.5,
  Rn: 1.5,
  Fr: 2.6,
  Ra: 2.21,
  Ac: 2.15,
  Th: 2.06,
  Pa: 2,
  U: 1.96,
  Np: 1.9,
  Pu: 1.87,
  Am: 1.8,
  Cm: 1.69
};
function mod(t, e) {
  return (t % e + e) % e;
}
function setCustomBondLengths() {
  function t(e, n) {
    _3DmolExports.setBondLength(e, n);
  }
  Object.keys(covalentRadii).forEach((e) => {
    t(e, covalentRadii[e]);
  });
}
class Visualizer3dmol extends React__default.Component {
  constructor(e) {
    super(e), setCustomBondLengths(), this.viewer = null, this.model = null, this.divId = "gldiv-" + (Math.random() + 1).toString(36).substring(7);
  }
  componentDidMount() {
    let e = { backgroundColor: "white", orthographic: !0 };
    this.viewer = _3DmolExports.createViewer(this.divId, e), this.updateView();
  }
  componentDidUpdate(e) {
    (e.viewerParams != this.props.viewerParams || e.cifText != this.props.cifText) && this.updateView();
  }
  custom3dmolSetup() {
    if (this.model = this.viewer.addModel(), this.props.cifText) {
      let e = _3DmolExports.Parsers.CIF(this.props.cifText), n = e[0], o = e.modelData[0].cryst;
      this.model.setCrystData(
        o.a,
        o.b,
        o.c,
        o.alpha,
        o.beta,
        o.gamma
      );
      let l = this.model.modelData.cryst.matrix, u = new _3DmolExports.Matrix3().getInverse3(l), f = [], h = [];
      n.forEach((v) => {
        let g = new _3DmolExports.Vector3(v.x, v.y, v.z);
        if (this.props.viewerParams.packedCell) {
          let w = g.clone().applyMatrix3(u);
          g = new _3DmolExports.Vector3(
            mod(w.x, 1),
            mod(w.y, 1),
            mod(w.z, 1)
          ).applyMatrix3(l);
        }
        h.push({
          elem: v.elem,
          x: g.x,
          y: g.y,
          z: g.z
        });
      });
      let p = this.props.viewerParams.supercell;
      for (let v = -1; v < p[0] + 1; v++)
        for (let g = -1; g < p[1] + 1; g++)
          for (let w = -1; w < p[2] + 1; w++) {
            let E = new _3DmolExports.Vector3(v, g, w);
            if (E.applyMatrix3(l), v == -1 || v == p[0] || g == -1 || g == p[1] || w == -1 || w == p[2])
              if (this.props.viewerParams.packedCell)
                h.forEach((T) => {
                  let R = new _3DmolExports.Vector3(T.x, T.y, T.z);
                  R.add(E);
                  let _ = R.clone().applyMatrix3(u);
                  _.x > -1e-4 && _.x < p[0] + 1e-4 && _.y > -1e-4 && _.y < p[1] + 1e-4 && _.z > -1e-4 && _.z < p[2] + 1e-4 && f.push({
                    elem: T.elem,
                    x: R.x,
                    y: R.y,
                    z: R.z
                  });
                });
              else
                continue;
            else
              h.forEach((T) => {
                f.push({
                  elem: T.elem,
                  x: T.x + E.x,
                  y: T.y + E.y,
                  z: T.z + E.z
                });
              });
          }
      this.model.addAtoms(f);
    }
  }
  updateView() {
    this.viewer.removeAllModels(), this.custom3dmolSetup();
    let e = {
      sphere: { scale: 0.3, colorscheme: "Jmol" }
    };
    this.props.viewerParams.vdwRadius && (e.sphere.scale = 1), this.props.viewerParams.bonds && (e.stick = { radius: 0.15, colorscheme: "Jmol" }), this.viewer.setStyle(e), this.viewer.addUnitCell(this.model), this.model.assignBonds(), this.viewer.removeAllLabels(), this.props.viewerParams.atomLabels && this.model.atoms.forEach((n) => {
      this.viewer.addLabel(
        n.elem,
        {
          position: { x: n.x, y: n.y, z: n.z },
          fontColor: "black",
          bold: !0,
          fontSize: 18,
          showBackground: !1,
          backgroundOpacity: 1,
          inFront: !0
        },
        null,
        !0
      );
    }), this.viewer.zoomTo(), this.viewer.zoom(1.4), this.viewer.render();
  }
  handleEvent(e, n) {
    e == "camera" && (n == "x" && this.viewer.setView([0, 0, 0, 0, -0.5, -0.5, -0.5, 0.5]), n == "y" && this.viewer.setView([0, 0, 0, 0, 0.5, 0.5, 0.5, 0.5]), n == "z" && this.viewer.setView([0, 0, 0, 0, 0, 0, 0, 1]), this.viewer.zoomTo(), this.viewer.zoom(1.4));
  }
  render() {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { id: this.divId, className: "gldiv", children: "No data!" });
  }
}
class StructureWindow extends React__default.Component {
  constructor(e) {
    super(e);
  }
  render() {
    let e = "structure-window";
    this.props.mouseEnabled || (e += " disable-mouse");
    let n = "Interaction off", o = "mouse-disabled-note";
    return this.props.mouseEnabled && (n = "Interaction on", o = "mouse-disabled-note on"), /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "structure-window-outer", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: () => this.props.setMouseEnabledState(!0), children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: e, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Visualizer3dmol,
        {
          ref: this.props.visualizerRef,
          viewerParams: this.props.viewerParams,
          cifText: this.props.cifText
        }
      ) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: o,
          onClick: () => this.props.setMouseEnabledState(!this.props.mouseEnabled),
          children: n
        }
      )
    ] });
  }
}
const StructureVisualizer = (t) => {
  const [e, n] = useState({
    supercell: t.initSupercell || [2, 2, 2],
    bonds: !0,
    packedCell: !0,
    atomLabels: !1,
    vdwRadius: !1
  }), [o, l] = useState(!1), u = useRef(null), f = useRef(null);
  useEffect(() => {
    const g = (w) => {
      f && !f.current.contains(w.target) && l(!1);
    };
    return document.addEventListener("mousedown", g), () => {
      document.removeEventListener("mousedown", g);
    };
  }, []);
  const h = (g) => {
    l(g);
  }, p = (g, w) => {
    n((E) => ({
      ...E,
      [g]: w
    }));
  }, v = (g, w) => {
    u.current.handleEvent(g, w);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref: f, className: "structure-visualizer", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      StructureWindow,
      {
        visualizerRef: u,
        viewerParams: e,
        cifText: t.cifText,
        mouseEnabled: o,
        setMouseEnabledState: h
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ControlBox,
      {
        viewerParams: e,
        onViewerParamChange: p,
        onViewerEvent: v
      }
    )
  ] });
};
var cssUnit = {
  cm: !0,
  mm: !0,
  in: !0,
  px: !0,
  pt: !0,
  pc: !0,
  em: !0,
  ex: !0,
  ch: !0,
  rem: !0,
  vw: !0,
  vh: !0,
  vmin: !0,
  vmax: !0,
  "%": !0
};
function parseLengthAndUnit(t) {
  if (typeof t == "number")
    return {
      value: t,
      unit: "px"
    };
  var e, n = (t.match(/^[0-9.]*/) || "").toString();
  n.includes(".") ? e = parseFloat(n) : e = parseInt(n, 10);
  var o = (t.match(/[^0-9]*$/) || "").toString();
  return cssUnit[o] ? {
    value: e,
    unit: o
  } : (console.warn("React Spinners: ".concat(t, " is not a valid css value. Defaulting to ").concat(e, "px.")), {
    value: e,
    unit: "px"
  });
}
function cssValue(t) {
  var e = parseLengthAndUnit(t);
  return "".concat(e.value).concat(e.unit);
}
var createAnimation = function(t, e, n) {
  var o = "react-spinners-".concat(t, "-").concat(n);
  if (typeof window > "u" || !window.document)
    return o;
  var l = document.createElement("style");
  document.head.appendChild(l);
  var u = l.sheet, f = `
    @keyframes `.concat(o, ` {
      `).concat(e, `
    }
  `);
  return u && u.insertRule(f, 0), o;
}, __assign = function() {
  return __assign = Object.assign || function(t) {
    for (var e, n = 1, o = arguments.length; n < o; n++) {
      e = arguments[n];
      for (var l in e) Object.prototype.hasOwnProperty.call(e, l) && (t[l] = e[l]);
    }
    return t;
  }, __assign.apply(this, arguments);
}, __rest = function(t, e) {
  var n = {};
  for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && e.indexOf(o) < 0 && (n[o] = t[o]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var l = 0, o = Object.getOwnPropertySymbols(t); l < o.length; l++)
      e.indexOf(o[l]) < 0 && Object.prototype.propertyIsEnumerable.call(t, o[l]) && (n[o[l]] = t[o[l]]);
  return n;
}, clip = createAnimation("ClipLoader", "0% {transform: rotate(0deg) scale(1)} 50% {transform: rotate(180deg) scale(0.8)} 100% {transform: rotate(360deg) scale(1)}", "clip");
function ClipLoader(t) {
  var e = t.loading, n = e === void 0 ? !0 : e, o = t.color, l = o === void 0 ? "#000000" : o, u = t.speedMultiplier, f = u === void 0 ? 1 : u, h = t.cssOverride, p = h === void 0 ? {} : h, v = t.size, g = v === void 0 ? 35 : v, w = __rest(t, ["loading", "color", "speedMultiplier", "cssOverride", "size"]), E = __assign({ background: "transparent !important", width: cssValue(g), height: cssValue(g), borderRadius: "100%", border: "2px solid", borderTopColor: l, borderBottomColor: "transparent", borderLeftColor: l, borderRightColor: l, display: "inline-block", animation: "".concat(clip, " ").concat(0.75 / f, "s 0s infinite linear"), animationFillMode: "both" }, p);
  return n ? React.createElement("span", __assign({ style: E }, w)) : null;
}
var Component = {}, toggleSelection = function() {
  var t = document.getSelection();
  if (!t.rangeCount)
    return function() {
    };
  for (var e = document.activeElement, n = [], o = 0; o < t.rangeCount; o++)
    n.push(t.getRangeAt(o));
  switch (e.tagName.toUpperCase()) {
    case "INPUT":
    case "TEXTAREA":
      e.blur();
      break;
    default:
      e = null;
      break;
  }
  return t.removeAllRanges(), function() {
    t.type === "Caret" && t.removeAllRanges(), t.rangeCount || n.forEach(function(l) {
      t.addRange(l);
    }), e && e.focus();
  };
}, deselectCurrent = toggleSelection, clipboardToIE11Formatting = {
  "text/plain": "Text",
  "text/html": "Url",
  default: "Text"
}, defaultMessage = "Copy to clipboard: #{key}, Enter";
function format$2(t) {
  var e = (/mac os x/i.test(navigator.userAgent) ? "⌘" : "Ctrl") + "+C";
  return t.replace(/#{\s*key\s*}/g, e);
}
function copy$3(t, e) {
  var n, o, l, u, f, h, p = !1;
  e || (e = {}), n = e.debug || !1;
  try {
    l = deselectCurrent(), u = document.createRange(), f = document.getSelection(), h = document.createElement("span"), h.textContent = t, h.ariaHidden = "true", h.style.all = "unset", h.style.position = "fixed", h.style.top = 0, h.style.clip = "rect(0, 0, 0, 0)", h.style.whiteSpace = "pre", h.style.webkitUserSelect = "text", h.style.MozUserSelect = "text", h.style.msUserSelect = "text", h.style.userSelect = "text", h.addEventListener("copy", function(g) {
      if (g.stopPropagation(), e.format)
        if (g.preventDefault(), typeof g.clipboardData > "u") {
          n && console.warn("unable to use e.clipboardData"), n && console.warn("trying IE specific stuff"), window.clipboardData.clearData();
          var w = clipboardToIE11Formatting[e.format] || clipboardToIE11Formatting.default;
          window.clipboardData.setData(w, t);
        } else
          g.clipboardData.clearData(), g.clipboardData.setData(e.format, t);
      e.onCopy && (g.preventDefault(), e.onCopy(g.clipboardData));
    }), document.body.appendChild(h), u.selectNodeContents(h), f.addRange(u);
    var v = document.execCommand("copy");
    if (!v)
      throw new Error("copy command was unsuccessful");
    p = !0;
  } catch (g) {
    n && console.error("unable to copy using execCommand: ", g), n && console.warn("trying IE specific stuff");
    try {
      window.clipboardData.setData(e.format || "text", t), e.onCopy && e.onCopy(window.clipboardData), p = !0;
    } catch (w) {
      n && console.error("unable to copy using clipboardData: ", w), n && console.error("falling back to prompt"), o = format$2("message" in e ? e.message : defaultMessage), window.prompt(o, t);
    }
  } finally {
    f && (typeof f.removeRange == "function" ? f.removeRange(u) : f.removeAllRanges()), h && document.body.removeChild(h), l();
  }
  return p;
}
var copyToClipboard = copy$3;
const copyToClipboard$1 = /* @__PURE__ */ getDefaultExportFromCjs(copyToClipboard);
function _typeof$J(t) {
  "@babel/helpers - typeof";
  return _typeof$J = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof$J(t);
}
Object.defineProperty(Component, "__esModule", {
  value: !0
});
Component.CopyToClipboard = void 0;
var _react = _interopRequireDefault$2(React__default), _copyToClipboard = _interopRequireDefault$2(copyToClipboard), _excluded$z = ["text", "onCopy", "options", "children"];
function _interopRequireDefault$2(t) {
  return t && t.__esModule ? t : { default: t };
}
function ownKeys$E(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(l) {
      return Object.getOwnPropertyDescriptor(t, l).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function _objectSpread$D(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ownKeys$E(Object(n), !0).forEach(function(o) {
      _defineProperty$H(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : ownKeys$E(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
function _objectWithoutProperties$k(t, e) {
  if (t == null) return {};
  var n = _objectWithoutPropertiesLoose$l(t, e), o, l;
  if (Object.getOwnPropertySymbols) {
    var u = Object.getOwnPropertySymbols(t);
    for (l = 0; l < u.length; l++)
      o = u[l], !(e.indexOf(o) >= 0) && Object.prototype.propertyIsEnumerable.call(t, o) && (n[o] = t[o]);
  }
  return n;
}
function _objectWithoutPropertiesLoose$l(t, e) {
  if (t == null) return {};
  var n = {}, o = Object.keys(t), l, u;
  for (u = 0; u < o.length; u++)
    l = o[u], !(e.indexOf(l) >= 0) && (n[l] = t[l]);
  return n;
}
function _classCallCheck$g(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$g(t, e) {
  for (var n = 0; n < e.length; n++) {
    var o = e[n];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
  }
}
function _createClass$g(t, e, n) {
  return e && _defineProperties$g(t.prototype, e), Object.defineProperty(t, "prototype", { writable: !1 }), t;
}
function _inherits$d(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf$e(t, e);
}
function _setPrototypeOf$e(t, e) {
  return _setPrototypeOf$e = Object.setPrototypeOf || function(o, l) {
    return o.__proto__ = l, o;
  }, _setPrototypeOf$e(t, e);
}
function _createSuper$1(t) {
  var e = _isNativeReflectConstruct$d();
  return function() {
    var o = _getPrototypeOf$d(t), l;
    if (e) {
      var u = _getPrototypeOf$d(this).constructor;
      l = Reflect.construct(o, arguments, u);
    } else
      l = o.apply(this, arguments);
    return _possibleConstructorReturn$d(this, l);
  };
}
function _possibleConstructorReturn$d(t, e) {
  if (e && (_typeof$J(e) === "object" || typeof e == "function"))
    return e;
  if (e !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized$e(t);
}
function _assertThisInitialized$e(t) {
  if (t === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t;
}
function _isNativeReflectConstruct$d() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
  if (typeof Proxy == "function") return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function _getPrototypeOf$d(t) {
  return _getPrototypeOf$d = Object.setPrototypeOf ? Object.getPrototypeOf : function(n) {
    return n.__proto__ || Object.getPrototypeOf(n);
  }, _getPrototypeOf$d(t);
}
function _defineProperty$H(t, e, n) {
  return e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
var CopyToClipboard$1 = /* @__PURE__ */ function(t) {
  _inherits$d(n, t);
  var e = _createSuper$1(n);
  function n() {
    var o;
    _classCallCheck$g(this, n);
    for (var l = arguments.length, u = new Array(l), f = 0; f < l; f++)
      u[f] = arguments[f];
    return o = e.call.apply(e, [this].concat(u)), _defineProperty$H(_assertThisInitialized$e(o), "onClick", function(h) {
      var p = o.props, v = p.text, g = p.onCopy, w = p.children, E = p.options, T = _react.default.Children.only(w), R = (0, _copyToClipboard.default)(v, E);
      g && g(v, R), T && T.props && typeof T.props.onClick == "function" && T.props.onClick(h);
    }), o;
  }
  return _createClass$g(n, [{
    key: "render",
    value: function() {
      var l = this.props;
      l.text, l.onCopy, l.options;
      var u = l.children, f = _objectWithoutProperties$k(l, _excluded$z), h = _react.default.Children.only(u);
      return /* @__PURE__ */ _react.default.cloneElement(h, _objectSpread$D(_objectSpread$D({}, f), {}, {
        onClick: this.onClick
      }));
    }
  }]), n;
}(_react.default.PureComponent);
Component.CopyToClipboard = CopyToClipboard$1;
_defineProperty$H(CopyToClipboard$1, "defaultProps", {
  onCopy: void 0,
  options: void 0
});
var _require = Component, CopyToClipboard = _require.CopyToClipboard;
CopyToClipboard.CopyToClipboard = CopyToClipboard;
var lib = CopyToClipboard;
function bind(t, e) {
  return function() {
    return t.apply(e, arguments);
  };
}
const { toString: toString$5 } = Object.prototype, { getPrototypeOf } = Object, kindOf = /* @__PURE__ */ ((t) => (e) => {
  const n = toString$5.call(e);
  return t[n] || (t[n] = n.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), kindOfTest = (t) => (t = t.toLowerCase(), (e) => kindOf(e) === t), typeOfTest = (t) => (e) => typeof e === t, { isArray: isArray$g } = Array, isUndefined = typeOfTest("undefined");
function isBuffer$3(t) {
  return t !== null && !isUndefined(t) && t.constructor !== null && !isUndefined(t.constructor) && isFunction$5(t.constructor.isBuffer) && t.constructor.isBuffer(t);
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(t) {
  let e;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(t) : e = t && t.buffer && isArrayBuffer(t.buffer), e;
}
const isString$2 = typeOfTest("string"), isFunction$5 = typeOfTest("function"), isNumber$4 = typeOfTest("number"), isObject$9 = (t) => t !== null && typeof t == "object", isBoolean$2 = (t) => t === !0 || t === !1, isPlainObject$4 = (t) => {
  if (kindOf(t) !== "object")
    return !1;
  const e = getPrototypeOf(t);
  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in t) && !(Symbol.iterator in t);
}, isDate$1 = kindOfTest("Date"), isFile = kindOfTest("File"), isBlob = kindOfTest("Blob"), isFileList = kindOfTest("FileList"), isStream = (t) => isObject$9(t) && isFunction$5(t.pipe), isFormData = (t) => {
  let e;
  return t && (typeof FormData == "function" && t instanceof FormData || isFunction$5(t.append) && ((e = kindOf(t)) === "formdata" || // detect form-data instance
  e === "object" && isFunction$5(t.toString) && t.toString() === "[object FormData]"));
}, isURLSearchParams = kindOfTest("URLSearchParams"), [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest), trim$1 = (t) => t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(t, e, { allOwnKeys: n = !1 } = {}) {
  if (t === null || typeof t > "u")
    return;
  let o, l;
  if (typeof t != "object" && (t = [t]), isArray$g(t))
    for (o = 0, l = t.length; o < l; o++)
      e.call(null, t[o], o, t);
  else {
    const u = n ? Object.getOwnPropertyNames(t) : Object.keys(t), f = u.length;
    let h;
    for (o = 0; o < f; o++)
      h = u[o], e.call(null, t[h], h, t);
  }
}
function findKey$1(t, e) {
  e = e.toLowerCase();
  const n = Object.keys(t);
  let o = n.length, l;
  for (; o-- > 0; )
    if (l = n[o], e === l.toLowerCase())
      return l;
  return null;
}
const _global = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, isContextDefined = (t) => !isUndefined(t) && t !== _global;
function merge$1() {
  const { caseless: t } = isContextDefined(this) && this || {}, e = {}, n = (o, l) => {
    const u = t && findKey$1(e, l) || l;
    isPlainObject$4(e[u]) && isPlainObject$4(o) ? e[u] = merge$1(e[u], o) : isPlainObject$4(o) ? e[u] = merge$1({}, o) : isArray$g(o) ? e[u] = o.slice() : e[u] = o;
  };
  for (let o = 0, l = arguments.length; o < l; o++)
    arguments[o] && forEach(arguments[o], n);
  return e;
}
const extend$1 = (t, e, n, { allOwnKeys: o } = {}) => (forEach(e, (l, u) => {
  n && isFunction$5(l) ? t[u] = bind(l, n) : t[u] = l;
}, { allOwnKeys: o }), t), stripBOM = (t) => (t.charCodeAt(0) === 65279 && (t = t.slice(1)), t), inherits = (t, e, n, o) => {
  t.prototype = Object.create(e.prototype, o), t.prototype.constructor = t, Object.defineProperty(t, "super", {
    value: e.prototype
  }), n && Object.assign(t.prototype, n);
}, toFlatObject = (t, e, n, o) => {
  let l, u, f;
  const h = {};
  if (e = e || {}, t == null) return e;
  do {
    for (l = Object.getOwnPropertyNames(t), u = l.length; u-- > 0; )
      f = l[u], (!o || o(f, t, e)) && !h[f] && (e[f] = t[f], h[f] = !0);
    t = n !== !1 && getPrototypeOf(t);
  } while (t && (!n || n(t, e)) && t !== Object.prototype);
  return e;
}, endsWith = (t, e, n) => {
  t = String(t), (n === void 0 || n > t.length) && (n = t.length), n -= e.length;
  const o = t.indexOf(e, n);
  return o !== -1 && o === n;
}, toArray$1 = (t) => {
  if (!t) return null;
  if (isArray$g(t)) return t;
  let e = t.length;
  if (!isNumber$4(e)) return null;
  const n = new Array(e);
  for (; e-- > 0; )
    n[e] = t[e];
  return n;
}, isTypedArray$4 = /* @__PURE__ */ ((t) => (e) => t && e instanceof t)(typeof Uint8Array < "u" && getPrototypeOf(Uint8Array)), forEachEntry = (t, e) => {
  const o = (t && t[Symbol.iterator]).call(t);
  let l;
  for (; (l = o.next()) && !l.done; ) {
    const u = l.value;
    e.call(t, u[0], u[1]);
  }
}, matchAll = (t, e) => {
  let n;
  const o = [];
  for (; (n = t.exec(e)) !== null; )
    o.push(n);
  return o;
}, isHTMLForm = kindOfTest("HTMLFormElement"), toCamelCase = (t) => t.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(n, o, l) {
    return o.toUpperCase() + l;
  }
), hasOwnProperty$b = (({ hasOwnProperty: t }) => (e, n) => t.call(e, n))(Object.prototype), isRegExp = kindOfTest("RegExp"), reduceDescriptors = (t, e) => {
  const n = Object.getOwnPropertyDescriptors(t), o = {};
  forEach(n, (l, u) => {
    let f;
    (f = e(l, u, t)) !== !1 && (o[u] = f || l);
  }), Object.defineProperties(t, o);
}, freezeMethods = (t) => {
  reduceDescriptors(t, (e, n) => {
    if (isFunction$5(t) && ["arguments", "caller", "callee"].indexOf(n) !== -1)
      return !1;
    const o = t[n];
    if (isFunction$5(o)) {
      if (e.enumerable = !1, "writable" in e) {
        e.writable = !1;
        return;
      }
      e.set || (e.set = () => {
        throw Error("Can not rewrite read-only method '" + n + "'");
      });
    }
  });
}, toObjectSet = (t, e) => {
  const n = {}, o = (l) => {
    l.forEach((u) => {
      n[u] = !0;
    });
  };
  return isArray$g(t) ? o(t) : o(String(t).split(e)), n;
}, noop$5 = () => {
}, toFiniteNumber = (t, e) => t != null && Number.isFinite(t = +t) ? t : e, ALPHA = "abcdefghijklmnopqrstuvwxyz", DIGIT = "0123456789", ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
}, generateString = (t = 16, e = ALPHABET.ALPHA_DIGIT) => {
  let n = "";
  const { length: o } = e;
  for (; t--; )
    n += e[Math.random() * o | 0];
  return n;
};
function isSpecCompliantForm(t) {
  return !!(t && isFunction$5(t.append) && t[Symbol.toStringTag] === "FormData" && t[Symbol.iterator]);
}
const toJSONObject = (t) => {
  const e = new Array(10), n = (o, l) => {
    if (isObject$9(o)) {
      if (e.indexOf(o) >= 0)
        return;
      if (!("toJSON" in o)) {
        e[l] = o;
        const u = isArray$g(o) ? [] : {};
        return forEach(o, (f, h) => {
          const p = n(f, l + 1);
          !isUndefined(p) && (u[h] = p);
        }), e[l] = void 0, u;
      }
    }
    return o;
  };
  return n(t, 0);
}, isAsyncFn = kindOfTest("AsyncFunction"), isThenable = (t) => t && (isObject$9(t) || isFunction$5(t)) && isFunction$5(t.then) && isFunction$5(t.catch), _setImmediate = ((t, e) => t ? setImmediate : e ? ((n, o) => (_global.addEventListener("message", ({ source: l, data: u }) => {
  l === _global && u === n && o.length && o.shift()();
}, !1), (l) => {
  o.push(l), _global.postMessage(n, "*");
}))(`axios@${Math.random()}`, []) : (n) => setTimeout(n))(
  typeof setImmediate == "function",
  isFunction$5(_global.postMessage)
), asap = typeof queueMicrotask < "u" ? queueMicrotask.bind(_global) : typeof process < "u" && process.nextTick || _setImmediate, utils$1 = {
  isArray: isArray$g,
  isArrayBuffer,
  isBuffer: isBuffer$3,
  isFormData,
  isArrayBufferView,
  isString: isString$2,
  isNumber: isNumber$4,
  isBoolean: isBoolean$2,
  isObject: isObject$9,
  isPlainObject: isPlainObject$4,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate: isDate$1,
  isFile,
  isBlob,
  isRegExp,
  isFunction: isFunction$5,
  isStream,
  isURLSearchParams,
  isTypedArray: isTypedArray$4,
  isFileList,
  forEach,
  merge: merge$1,
  extend: extend$1,
  trim: trim$1,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray: toArray$1,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty: hasOwnProperty$b,
  hasOwnProp: hasOwnProperty$b,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop: noop$5,
  toFiniteNumber,
  findKey: findKey$1,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap
};
function AxiosError(t, e, n, o, l) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = t, this.name = "AxiosError", e && (this.code = e), n && (this.config = n), o && (this.request = o), l && (this.response = l);
}
utils$1.inherits(AxiosError, Error, {
  toJSON: function t() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$1.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const prototype$1 = AxiosError.prototype, descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((t) => {
  descriptors[t] = { value: t };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: !0 });
AxiosError.from = (t, e, n, o, l, u) => {
  const f = Object.create(prototype$1);
  return utils$1.toFlatObject(t, f, function(p) {
    return p !== Error.prototype;
  }, (h) => h !== "isAxiosError"), AxiosError.call(f, t.message, e, n, o, l), f.cause = t, f.name = t.name, u && Object.assign(f, u), f;
};
const httpAdapter = null;
function isVisitable(t) {
  return utils$1.isPlainObject(t) || utils$1.isArray(t);
}
function removeBrackets(t) {
  return utils$1.endsWith(t, "[]") ? t.slice(0, -2) : t;
}
function renderKey(t, e, n) {
  return t ? t.concat(e).map(function(l, u) {
    return l = removeBrackets(l), !n && u ? "[" + l + "]" : l;
  }).join(n ? "." : "") : e;
}
function isFlatArray(t) {
  return utils$1.isArray(t) && !t.some(isVisitable);
}
const predicates = utils$1.toFlatObject(utils$1, {}, null, function t(e) {
  return /^is[A-Z]/.test(e);
});
function toFormData(t, e, n) {
  if (!utils$1.isObject(t))
    throw new TypeError("target must be an object");
  e = e || new FormData(), n = utils$1.toFlatObject(n, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(_, b) {
    return !utils$1.isUndefined(b[_]);
  });
  const o = n.metaTokens, l = n.visitor || g, u = n.dots, f = n.indexes, p = (n.Blob || typeof Blob < "u" && Blob) && utils$1.isSpecCompliantForm(e);
  if (!utils$1.isFunction(l))
    throw new TypeError("visitor must be a function");
  function v(R) {
    if (R === null) return "";
    if (utils$1.isDate(R))
      return R.toISOString();
    if (!p && utils$1.isBlob(R))
      throw new AxiosError("Blob is not supported. Use a Buffer instead.");
    return utils$1.isArrayBuffer(R) || utils$1.isTypedArray(R) ? p && typeof Blob == "function" ? new Blob([R]) : Buffer.from(R) : R;
  }
  function g(R, _, b) {
    let M = R;
    if (R && !b && typeof R == "object") {
      if (utils$1.endsWith(_, "{}"))
        _ = o ? _ : _.slice(0, -2), R = JSON.stringify(R);
      else if (utils$1.isArray(R) && isFlatArray(R) || (utils$1.isFileList(R) || utils$1.endsWith(_, "[]")) && (M = utils$1.toArray(R)))
        return _ = removeBrackets(_), M.forEach(function($, S) {
          !(utils$1.isUndefined($) || $ === null) && e.append(
            // eslint-disable-next-line no-nested-ternary
            f === !0 ? renderKey([_], S, u) : f === null ? _ : _ + "[]",
            v($)
          );
        }), !1;
    }
    return isVisitable(R) ? !0 : (e.append(renderKey(b, _, u), v(R)), !1);
  }
  const w = [], E = Object.assign(predicates, {
    defaultVisitor: g,
    convertValue: v,
    isVisitable
  });
  function T(R, _) {
    if (!utils$1.isUndefined(R)) {
      if (w.indexOf(R) !== -1)
        throw Error("Circular reference detected in " + _.join("."));
      w.push(R), utils$1.forEach(R, function(M, A) {
        (!(utils$1.isUndefined(M) || M === null) && l.call(
          e,
          M,
          utils$1.isString(A) ? A.trim() : A,
          _,
          E
        )) === !0 && T(M, _ ? _.concat(A) : [A]);
      }), w.pop();
    }
  }
  if (!utils$1.isObject(t))
    throw new TypeError("data must be an object");
  return T(t), e;
}
function encode$1(t) {
  const e = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g, function(o) {
    return e[o];
  });
}
function AxiosURLSearchParams(t, e) {
  this._pairs = [], t && toFormData(t, this, e);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function t(e, n) {
  this._pairs.push([e, n]);
};
prototype.toString = function t(e) {
  const n = e ? function(o) {
    return e.call(this, o, encode$1);
  } : encode$1;
  return this._pairs.map(function(l) {
    return n(l[0]) + "=" + n(l[1]);
  }, "").join("&");
};
function encode(t) {
  return encodeURIComponent(t).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(t, e, n) {
  if (!e)
    return t;
  const o = n && n.encode || encode, l = n && n.serialize;
  let u;
  if (l ? u = l(e, n) : u = utils$1.isURLSearchParams(e) ? e.toString() : new AxiosURLSearchParams(e, n).toString(o), u) {
    const f = t.indexOf("#");
    f !== -1 && (t = t.slice(0, f)), t += (t.indexOf("?") === -1 ? "?" : "&") + u;
  }
  return t;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(e, n, o) {
    return this.handlers.push({
      fulfilled: e,
      rejected: n,
      synchronous: o ? o.synchronous : !1,
      runWhen: o ? o.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(e) {
    this.handlers[e] && (this.handlers[e] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(e) {
    utils$1.forEach(this.handlers, function(o) {
      o !== null && e(o);
    });
  }
}
const transitionalDefaults = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, URLSearchParams$1 = typeof URLSearchParams < "u" ? URLSearchParams : AxiosURLSearchParams, FormData$1 = typeof FormData < "u" ? FormData : null, Blob$1 = typeof Blob < "u" ? Blob : null, platform$2 = {
  isBrowser: !0,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, hasBrowserEnv = typeof window < "u" && typeof document < "u", hasStandardBrowserEnv = ((t) => hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(t) < 0)(typeof navigator < "u" && navigator.product), hasStandardBrowserWebWorkerEnv = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", origin = hasBrowserEnv && window.location.href || "http://localhost", utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv,
  hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv,
  origin
}, Symbol.toStringTag, { value: "Module" })), platform$1 = {
  ...utils,
  ...platform$2
};
function toURLEncodedForm(t, e) {
  return toFormData(t, new platform$1.classes.URLSearchParams(), Object.assign({
    visitor: function(n, o, l, u) {
      return platform$1.isNode && utils$1.isBuffer(n) ? (this.append(o, n.toString("base64")), !1) : u.defaultVisitor.apply(this, arguments);
    }
  }, e));
}
function parsePropPath(t) {
  return utils$1.matchAll(/\w+|\[(\w*)]/g, t).map((e) => e[0] === "[]" ? "" : e[1] || e[0]);
}
function arrayToObject(t) {
  const e = {}, n = Object.keys(t);
  let o;
  const l = n.length;
  let u;
  for (o = 0; o < l; o++)
    u = n[o], e[u] = t[u];
  return e;
}
function formDataToJSON(t) {
  function e(n, o, l, u) {
    let f = n[u++];
    if (f === "__proto__") return !0;
    const h = Number.isFinite(+f), p = u >= n.length;
    return f = !f && utils$1.isArray(l) ? l.length : f, p ? (utils$1.hasOwnProp(l, f) ? l[f] = [l[f], o] : l[f] = o, !h) : ((!l[f] || !utils$1.isObject(l[f])) && (l[f] = []), e(n, o, l[f], u) && utils$1.isArray(l[f]) && (l[f] = arrayToObject(l[f])), !h);
  }
  if (utils$1.isFormData(t) && utils$1.isFunction(t.entries)) {
    const n = {};
    return utils$1.forEachEntry(t, (o, l) => {
      e(parsePropPath(o), l, n, 0);
    }), n;
  }
  return null;
}
function stringifySafely(t, e, n) {
  if (utils$1.isString(t))
    try {
      return (e || JSON.parse)(t), utils$1.trim(t);
    } catch (o) {
      if (o.name !== "SyntaxError")
        throw o;
    }
  return (n || JSON.stringify)(t);
}
const defaults$1 = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function t(e, n) {
    const o = n.getContentType() || "", l = o.indexOf("application/json") > -1, u = utils$1.isObject(e);
    if (u && utils$1.isHTMLForm(e) && (e = new FormData(e)), utils$1.isFormData(e))
      return l ? JSON.stringify(formDataToJSON(e)) : e;
    if (utils$1.isArrayBuffer(e) || utils$1.isBuffer(e) || utils$1.isStream(e) || utils$1.isFile(e) || utils$1.isBlob(e) || utils$1.isReadableStream(e))
      return e;
    if (utils$1.isArrayBufferView(e))
      return e.buffer;
    if (utils$1.isURLSearchParams(e))
      return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
    let h;
    if (u) {
      if (o.indexOf("application/x-www-form-urlencoded") > -1)
        return toURLEncodedForm(e, this.formSerializer).toString();
      if ((h = utils$1.isFileList(e)) || o.indexOf("multipart/form-data") > -1) {
        const p = this.env && this.env.FormData;
        return toFormData(
          h ? { "files[]": e } : e,
          p && new p(),
          this.formSerializer
        );
      }
    }
    return u || l ? (n.setContentType("application/json", !1), stringifySafely(e)) : e;
  }],
  transformResponse: [function t(e) {
    const n = this.transitional || defaults$1.transitional, o = n && n.forcedJSONParsing, l = this.responseType === "json";
    if (utils$1.isResponse(e) || utils$1.isReadableStream(e))
      return e;
    if (e && utils$1.isString(e) && (o && !this.responseType || l)) {
      const f = !(n && n.silentJSONParsing) && l;
      try {
        return JSON.parse(e);
      } catch (h) {
        if (f)
          throw h.name === "SyntaxError" ? AxiosError.from(h, AxiosError.ERR_BAD_RESPONSE, this, null, this.response) : h;
      }
    }
    return e;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform$1.classes.FormData,
    Blob: platform$1.classes.Blob
  },
  validateStatus: function t(e) {
    return e >= 200 && e < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (t) => {
  defaults$1.headers[t] = {};
});
const ignoreDuplicateOf = utils$1.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), parseHeaders = (t) => {
  const e = {};
  let n, o, l;
  return t && t.split(`
`).forEach(function(f) {
    l = f.indexOf(":"), n = f.substring(0, l).trim().toLowerCase(), o = f.substring(l + 1).trim(), !(!n || e[n] && ignoreDuplicateOf[n]) && (n === "set-cookie" ? e[n] ? e[n].push(o) : e[n] = [o] : e[n] = e[n] ? e[n] + ", " + o : o);
  }), e;
}, $internals = Symbol("internals");
function normalizeHeader(t) {
  return t && String(t).trim().toLowerCase();
}
function normalizeValue(t) {
  return t === !1 || t == null ? t : utils$1.isArray(t) ? t.map(normalizeValue) : String(t);
}
function parseTokens(t) {
  const e = /* @__PURE__ */ Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let o;
  for (; o = n.exec(t); )
    e[o[1]] = o[2];
  return e;
}
const isValidHeaderName = (t) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(t.trim());
function matchHeaderValue(t, e, n, o, l) {
  if (utils$1.isFunction(o))
    return o.call(this, e, n);
  if (l && (e = n), !!utils$1.isString(e)) {
    if (utils$1.isString(o))
      return e.indexOf(o) !== -1;
    if (utils$1.isRegExp(o))
      return o.test(e);
  }
}
function formatHeader(t) {
  return t.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, n, o) => n.toUpperCase() + o);
}
function buildAccessors(t, e) {
  const n = utils$1.toCamelCase(" " + e);
  ["get", "set", "has"].forEach((o) => {
    Object.defineProperty(t, o + n, {
      value: function(l, u, f) {
        return this[o].call(this, e, l, u, f);
      },
      configurable: !0
    });
  });
}
class AxiosHeaders {
  constructor(e) {
    e && this.set(e);
  }
  set(e, n, o) {
    const l = this;
    function u(h, p, v) {
      const g = normalizeHeader(p);
      if (!g)
        throw new Error("header name must be a non-empty string");
      const w = utils$1.findKey(l, g);
      (!w || l[w] === void 0 || v === !0 || v === void 0 && l[w] !== !1) && (l[w || p] = normalizeValue(h));
    }
    const f = (h, p) => utils$1.forEach(h, (v, g) => u(v, g, p));
    if (utils$1.isPlainObject(e) || e instanceof this.constructor)
      f(e, n);
    else if (utils$1.isString(e) && (e = e.trim()) && !isValidHeaderName(e))
      f(parseHeaders(e), n);
    else if (utils$1.isHeaders(e))
      for (const [h, p] of e.entries())
        u(p, h, o);
    else
      e != null && u(n, e, o);
    return this;
  }
  get(e, n) {
    if (e = normalizeHeader(e), e) {
      const o = utils$1.findKey(this, e);
      if (o) {
        const l = this[o];
        if (!n)
          return l;
        if (n === !0)
          return parseTokens(l);
        if (utils$1.isFunction(n))
          return n.call(this, l, o);
        if (utils$1.isRegExp(n))
          return n.exec(l);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(e, n) {
    if (e = normalizeHeader(e), e) {
      const o = utils$1.findKey(this, e);
      return !!(o && this[o] !== void 0 && (!n || matchHeaderValue(this, this[o], o, n)));
    }
    return !1;
  }
  delete(e, n) {
    const o = this;
    let l = !1;
    function u(f) {
      if (f = normalizeHeader(f), f) {
        const h = utils$1.findKey(o, f);
        h && (!n || matchHeaderValue(o, o[h], h, n)) && (delete o[h], l = !0);
      }
    }
    return utils$1.isArray(e) ? e.forEach(u) : u(e), l;
  }
  clear(e) {
    const n = Object.keys(this);
    let o = n.length, l = !1;
    for (; o--; ) {
      const u = n[o];
      (!e || matchHeaderValue(this, this[u], u, e, !0)) && (delete this[u], l = !0);
    }
    return l;
  }
  normalize(e) {
    const n = this, o = {};
    return utils$1.forEach(this, (l, u) => {
      const f = utils$1.findKey(o, u);
      if (f) {
        n[f] = normalizeValue(l), delete n[u];
        return;
      }
      const h = e ? formatHeader(u) : String(u).trim();
      h !== u && delete n[u], n[h] = normalizeValue(l), o[h] = !0;
    }), this;
  }
  concat(...e) {
    return this.constructor.concat(this, ...e);
  }
  toJSON(e) {
    const n = /* @__PURE__ */ Object.create(null);
    return utils$1.forEach(this, (o, l) => {
      o != null && o !== !1 && (n[l] = e && utils$1.isArray(o) ? o.join(", ") : o);
    }), n;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([e, n]) => e + ": " + n).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(e) {
    return e instanceof this ? e : new this(e);
  }
  static concat(e, ...n) {
    const o = new this(e);
    return n.forEach((l) => o.set(l)), o;
  }
  static accessor(e) {
    const o = (this[$internals] = this[$internals] = {
      accessors: {}
    }).accessors, l = this.prototype;
    function u(f) {
      const h = normalizeHeader(f);
      o[h] || (buildAccessors(l, f), o[h] = !0);
    }
    return utils$1.isArray(e) ? e.forEach(u) : u(e), this;
  }
}
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value: t }, e) => {
  let n = e[0].toUpperCase() + e.slice(1);
  return {
    get: () => t,
    set(o) {
      this[n] = o;
    }
  };
});
utils$1.freezeMethods(AxiosHeaders);
function transformData(t, e) {
  const n = this || defaults$1, o = e || n, l = AxiosHeaders.from(o.headers);
  let u = o.data;
  return utils$1.forEach(t, function(h) {
    u = h.call(n, u, l.normalize(), e ? e.status : void 0);
  }), l.normalize(), u;
}
function isCancel(t) {
  return !!(t && t.__CANCEL__);
}
function CanceledError(t, e, n) {
  AxiosError.call(this, t ?? "canceled", AxiosError.ERR_CANCELED, e, n), this.name = "CanceledError";
}
utils$1.inherits(CanceledError, AxiosError, {
  __CANCEL__: !0
});
function settle(t, e, n) {
  const o = n.config.validateStatus;
  !n.status || !o || o(n.status) ? t(n) : e(new AxiosError(
    "Request failed with status code " + n.status,
    [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],
    n.config,
    n.request,
    n
  ));
}
function parseProtocol(t) {
  const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(t);
  return e && e[1] || "";
}
function speedometer(t, e) {
  t = t || 10;
  const n = new Array(t), o = new Array(t);
  let l = 0, u = 0, f;
  return e = e !== void 0 ? e : 1e3, function(p) {
    const v = Date.now(), g = o[u];
    f || (f = v), n[l] = p, o[l] = v;
    let w = u, E = 0;
    for (; w !== l; )
      E += n[w++], w = w % t;
    if (l = (l + 1) % t, l === u && (u = (u + 1) % t), v - f < e)
      return;
    const T = g && v - g;
    return T ? Math.round(E * 1e3 / T) : void 0;
  };
}
function throttle$2(t, e) {
  let n = 0, o = 1e3 / e, l, u;
  const f = (v, g = Date.now()) => {
    n = g, l = null, u && (clearTimeout(u), u = null), t.apply(null, v);
  };
  return [(...v) => {
    const g = Date.now(), w = g - n;
    w >= o ? f(v, g) : (l = v, u || (u = setTimeout(() => {
      u = null, f(l);
    }, o - w)));
  }, () => l && f(l)];
}
const progressEventReducer = (t, e, n = 3) => {
  let o = 0;
  const l = speedometer(50, 250);
  return throttle$2((u) => {
    const f = u.loaded, h = u.lengthComputable ? u.total : void 0, p = f - o, v = l(p), g = f <= h;
    o = f;
    const w = {
      loaded: f,
      total: h,
      progress: h ? f / h : void 0,
      bytes: p,
      rate: v || void 0,
      estimated: v && h && g ? (h - f) / v : void 0,
      event: u,
      lengthComputable: h != null,
      [e ? "download" : "upload"]: !0
    };
    t(w);
  }, n);
}, progressEventDecorator = (t, e) => {
  const n = t != null;
  return [(o) => e[0]({
    lengthComputable: n,
    total: t,
    loaded: o
  }), e[1]];
}, asyncDecorator = (t) => (...e) => utils$1.asap(() => t(...e)), isURLSameOrigin = platform$1.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function t() {
    const e = /(msie|trident)/i.test(navigator.userAgent), n = document.createElement("a");
    let o;
    function l(u) {
      let f = u;
      return e && (n.setAttribute("href", f), f = n.href), n.setAttribute("href", f), {
        href: n.href,
        protocol: n.protocol ? n.protocol.replace(/:$/, "") : "",
        host: n.host,
        search: n.search ? n.search.replace(/^\?/, "") : "",
        hash: n.hash ? n.hash.replace(/^#/, "") : "",
        hostname: n.hostname,
        port: n.port,
        pathname: n.pathname.charAt(0) === "/" ? n.pathname : "/" + n.pathname
      };
    }
    return o = l(window.location.href), function(f) {
      const h = utils$1.isString(f) ? l(f) : f;
      return h.protocol === o.protocol && h.host === o.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  /* @__PURE__ */ function t() {
    return function() {
      return !0;
    };
  }()
), cookies = platform$1.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(t, e, n, o, l, u) {
      const f = [t + "=" + encodeURIComponent(e)];
      utils$1.isNumber(n) && f.push("expires=" + new Date(n).toGMTString()), utils$1.isString(o) && f.push("path=" + o), utils$1.isString(l) && f.push("domain=" + l), u === !0 && f.push("secure"), document.cookie = f.join("; ");
    },
    read(t) {
      const e = document.cookie.match(new RegExp("(^|;\\s*)(" + t + ")=([^;]*)"));
      return e ? decodeURIComponent(e[3]) : null;
    },
    remove(t) {
      this.write(t, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function isAbsoluteURL(t) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(t);
}
function combineURLs(t, e) {
  return e ? t.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "") : t;
}
function buildFullPath(t, e) {
  return t && !isAbsoluteURL(e) ? combineURLs(t, e) : e;
}
const headersToObject = (t) => t instanceof AxiosHeaders ? { ...t } : t;
function mergeConfig(t, e) {
  e = e || {};
  const n = {};
  function o(v, g, w) {
    return utils$1.isPlainObject(v) && utils$1.isPlainObject(g) ? utils$1.merge.call({ caseless: w }, v, g) : utils$1.isPlainObject(g) ? utils$1.merge({}, g) : utils$1.isArray(g) ? g.slice() : g;
  }
  function l(v, g, w) {
    if (utils$1.isUndefined(g)) {
      if (!utils$1.isUndefined(v))
        return o(void 0, v, w);
    } else return o(v, g, w);
  }
  function u(v, g) {
    if (!utils$1.isUndefined(g))
      return o(void 0, g);
  }
  function f(v, g) {
    if (utils$1.isUndefined(g)) {
      if (!utils$1.isUndefined(v))
        return o(void 0, v);
    } else return o(void 0, g);
  }
  function h(v, g, w) {
    if (w in e)
      return o(v, g);
    if (w in t)
      return o(void 0, v);
  }
  const p = {
    url: u,
    method: u,
    data: u,
    baseURL: f,
    transformRequest: f,
    transformResponse: f,
    paramsSerializer: f,
    timeout: f,
    timeoutMessage: f,
    withCredentials: f,
    withXSRFToken: f,
    adapter: f,
    responseType: f,
    xsrfCookieName: f,
    xsrfHeaderName: f,
    onUploadProgress: f,
    onDownloadProgress: f,
    decompress: f,
    maxContentLength: f,
    maxBodyLength: f,
    beforeRedirect: f,
    transport: f,
    httpAgent: f,
    httpsAgent: f,
    cancelToken: f,
    socketPath: f,
    responseEncoding: f,
    validateStatus: h,
    headers: (v, g) => l(headersToObject(v), headersToObject(g), !0)
  };
  return utils$1.forEach(Object.keys(Object.assign({}, t, e)), function(g) {
    const w = p[g] || l, E = w(t[g], e[g], g);
    utils$1.isUndefined(E) && w !== h || (n[g] = E);
  }), n;
}
const resolveConfig = (t) => {
  const e = mergeConfig({}, t);
  let { data: n, withXSRFToken: o, xsrfHeaderName: l, xsrfCookieName: u, headers: f, auth: h } = e;
  e.headers = f = AxiosHeaders.from(f), e.url = buildURL(buildFullPath(e.baseURL, e.url), t.params, t.paramsSerializer), h && f.set(
    "Authorization",
    "Basic " + btoa((h.username || "") + ":" + (h.password ? unescape(encodeURIComponent(h.password)) : ""))
  );
  let p;
  if (utils$1.isFormData(n)) {
    if (platform$1.hasStandardBrowserEnv || platform$1.hasStandardBrowserWebWorkerEnv)
      f.setContentType(void 0);
    else if ((p = f.getContentType()) !== !1) {
      const [v, ...g] = p ? p.split(";").map((w) => w.trim()).filter(Boolean) : [];
      f.setContentType([v || "multipart/form-data", ...g].join("; "));
    }
  }
  if (platform$1.hasStandardBrowserEnv && (o && utils$1.isFunction(o) && (o = o(e)), o || o !== !1 && isURLSameOrigin(e.url))) {
    const v = l && u && cookies.read(u);
    v && f.set(l, v);
  }
  return e;
}, isXHRAdapterSupported = typeof XMLHttpRequest < "u", xhrAdapter = isXHRAdapterSupported && function(t) {
  return new Promise(function(n, o) {
    const l = resolveConfig(t);
    let u = l.data;
    const f = AxiosHeaders.from(l.headers).normalize();
    let { responseType: h, onUploadProgress: p, onDownloadProgress: v } = l, g, w, E, T, R;
    function _() {
      T && T(), R && R(), l.cancelToken && l.cancelToken.unsubscribe(g), l.signal && l.signal.removeEventListener("abort", g);
    }
    let b = new XMLHttpRequest();
    b.open(l.method.toUpperCase(), l.url, !0), b.timeout = l.timeout;
    function M() {
      if (!b)
        return;
      const $ = AxiosHeaders.from(
        "getAllResponseHeaders" in b && b.getAllResponseHeaders()
      ), C = {
        data: !h || h === "text" || h === "json" ? b.responseText : b.response,
        status: b.status,
        statusText: b.statusText,
        headers: $,
        config: t,
        request: b
      };
      settle(function(O) {
        n(O), _();
      }, function(O) {
        o(O), _();
      }, C), b = null;
    }
    "onloadend" in b ? b.onloadend = M : b.onreadystatechange = function() {
      !b || b.readyState !== 4 || b.status === 0 && !(b.responseURL && b.responseURL.indexOf("file:") === 0) || setTimeout(M);
    }, b.onabort = function() {
      b && (o(new AxiosError("Request aborted", AxiosError.ECONNABORTED, t, b)), b = null);
    }, b.onerror = function() {
      o(new AxiosError("Network Error", AxiosError.ERR_NETWORK, t, b)), b = null;
    }, b.ontimeout = function() {
      let S = l.timeout ? "timeout of " + l.timeout + "ms exceeded" : "timeout exceeded";
      const C = l.transitional || transitionalDefaults;
      l.timeoutErrorMessage && (S = l.timeoutErrorMessage), o(new AxiosError(
        S,
        C.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        t,
        b
      )), b = null;
    }, u === void 0 && f.setContentType(null), "setRequestHeader" in b && utils$1.forEach(f.toJSON(), function(S, C) {
      b.setRequestHeader(C, S);
    }), utils$1.isUndefined(l.withCredentials) || (b.withCredentials = !!l.withCredentials), h && h !== "json" && (b.responseType = l.responseType), v && ([E, R] = progressEventReducer(v, !0), b.addEventListener("progress", E)), p && b.upload && ([w, T] = progressEventReducer(p), b.upload.addEventListener("progress", w), b.upload.addEventListener("loadend", T)), (l.cancelToken || l.signal) && (g = ($) => {
      b && (o(!$ || $.type ? new CanceledError(null, t, b) : $), b.abort(), b = null);
    }, l.cancelToken && l.cancelToken.subscribe(g), l.signal && (l.signal.aborted ? g() : l.signal.addEventListener("abort", g)));
    const A = parseProtocol(l.url);
    if (A && platform$1.protocols.indexOf(A) === -1) {
      o(new AxiosError("Unsupported protocol " + A + ":", AxiosError.ERR_BAD_REQUEST, t));
      return;
    }
    b.send(u || null);
  });
}, composeSignals = (t, e) => {
  let n = new AbortController(), o;
  const l = function(p) {
    if (!o) {
      o = !0, f();
      const v = p instanceof Error ? p : this.reason;
      n.abort(v instanceof AxiosError ? v : new CanceledError(v instanceof Error ? v.message : v));
    }
  };
  let u = e && setTimeout(() => {
    l(new AxiosError(`timeout ${e} of ms exceeded`, AxiosError.ETIMEDOUT));
  }, e);
  const f = () => {
    t && (u && clearTimeout(u), u = null, t.forEach((p) => {
      p && (p.removeEventListener ? p.removeEventListener("abort", l) : p.unsubscribe(l));
    }), t = null);
  };
  t.forEach((p) => p && p.addEventListener && p.addEventListener("abort", l));
  const { signal: h } = n;
  return h.unsubscribe = f, [h, () => {
    u && clearTimeout(u), u = null;
  }];
}, streamChunk = function* (t, e) {
  let n = t.byteLength;
  if (!e || n < e) {
    yield t;
    return;
  }
  let o = 0, l;
  for (; o < n; )
    l = o + e, yield t.slice(o, l), o = l;
}, readBytes = async function* (t, e, n) {
  for await (const o of t)
    yield* streamChunk(ArrayBuffer.isView(o) ? o : await n(String(o)), e);
}, trackStream = (t, e, n, o, l) => {
  const u = readBytes(t, e, l);
  let f = 0, h, p = (v) => {
    h || (h = !0, o && o(v));
  };
  return new ReadableStream({
    async pull(v) {
      try {
        const { done: g, value: w } = await u.next();
        if (g) {
          p(), v.close();
          return;
        }
        let E = w.byteLength;
        if (n) {
          let T = f += E;
          n(T);
        }
        v.enqueue(new Uint8Array(w));
      } catch (g) {
        throw p(g), g;
      }
    },
    cancel(v) {
      return p(v), u.return();
    }
  }, {
    highWaterMark: 2
  });
}, isFetchSupported = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", isReadableStreamSupported = isFetchSupported && typeof ReadableStream == "function", encodeText = isFetchSupported && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((t) => (e) => t.encode(e))(new TextEncoder()) : async (t) => new Uint8Array(await new Response(t).arrayBuffer())), test = (t, ...e) => {
  try {
    return !!t(...e);
  } catch {
    return !1;
  }
}, supportsRequestStream = isReadableStreamSupported && test(() => {
  let t = !1;
  const e = new Request(platform$1.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return t = !0, "half";
    }
  }).headers.has("Content-Type");
  return t && !e;
}), DEFAULT_CHUNK_SIZE = 64 * 1024, supportsResponseStream = isReadableStreamSupported && test(() => utils$1.isReadableStream(new Response("").body)), resolvers = {
  stream: supportsResponseStream && ((t) => t.body)
};
isFetchSupported && ((t) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((e) => {
    !resolvers[e] && (resolvers[e] = utils$1.isFunction(t[e]) ? (n) => n[e]() : (n, o) => {
      throw new AxiosError(`Response type '${e}' is not supported`, AxiosError.ERR_NOT_SUPPORT, o);
    });
  });
})(new Response());
const getBodyLength = async (t) => {
  if (t == null)
    return 0;
  if (utils$1.isBlob(t))
    return t.size;
  if (utils$1.isSpecCompliantForm(t))
    return (await new Request(t).arrayBuffer()).byteLength;
  if (utils$1.isArrayBufferView(t) || utils$1.isArrayBuffer(t))
    return t.byteLength;
  if (utils$1.isURLSearchParams(t) && (t = t + ""), utils$1.isString(t))
    return (await encodeText(t)).byteLength;
}, resolveBodyLength = async (t, e) => {
  const n = utils$1.toFiniteNumber(t.getContentLength());
  return n ?? getBodyLength(e);
}, fetchAdapter = isFetchSupported && (async (t) => {
  let {
    url: e,
    method: n,
    data: o,
    signal: l,
    cancelToken: u,
    timeout: f,
    onDownloadProgress: h,
    onUploadProgress: p,
    responseType: v,
    headers: g,
    withCredentials: w = "same-origin",
    fetchOptions: E
  } = resolveConfig(t);
  v = v ? (v + "").toLowerCase() : "text";
  let [T, R] = l || u || f ? composeSignals([l, u], f) : [], _, b;
  const M = () => {
    !_ && setTimeout(() => {
      T && T.unsubscribe();
    }), _ = !0;
  };
  let A;
  try {
    if (p && supportsRequestStream && n !== "get" && n !== "head" && (A = await resolveBodyLength(g, o)) !== 0) {
      let D = new Request(e, {
        method: "POST",
        body: o,
        duplex: "half"
      }), O;
      if (utils$1.isFormData(o) && (O = D.headers.get("content-type")) && g.setContentType(O), D.body) {
        const [N, j] = progressEventDecorator(
          A,
          progressEventReducer(asyncDecorator(p))
        );
        o = trackStream(D.body, DEFAULT_CHUNK_SIZE, N, j, encodeText);
      }
    }
    utils$1.isString(w) || (w = w ? "include" : "omit"), b = new Request(e, {
      ...E,
      signal: T,
      method: n.toUpperCase(),
      headers: g.normalize().toJSON(),
      body: o,
      duplex: "half",
      credentials: w
    });
    let $ = await fetch(b);
    const S = supportsResponseStream && (v === "stream" || v === "response");
    if (supportsResponseStream && (h || S)) {
      const D = {};
      ["status", "statusText", "headers"].forEach((L) => {
        D[L] = $[L];
      });
      const O = utils$1.toFiniteNumber($.headers.get("content-length")), [N, j] = h && progressEventDecorator(
        O,
        progressEventReducer(asyncDecorator(h), !0)
      ) || [];
      $ = new Response(
        trackStream($.body, DEFAULT_CHUNK_SIZE, N, () => {
          j && j(), S && M();
        }, encodeText),
        D
      );
    }
    v = v || "text";
    let C = await resolvers[utils$1.findKey(resolvers, v) || "text"]($, t);
    return !S && M(), R && R(), await new Promise((D, O) => {
      settle(D, O, {
        data: C,
        headers: AxiosHeaders.from($.headers),
        status: $.status,
        statusText: $.statusText,
        config: t,
        request: b
      });
    });
  } catch ($) {
    throw M(), $ && $.name === "TypeError" && /fetch/i.test($.message) ? Object.assign(
      new AxiosError("Network Error", AxiosError.ERR_NETWORK, t, b),
      {
        cause: $.cause || $
      }
    ) : AxiosError.from($, $ && $.code, t, b);
  }
}), knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter,
  fetch: fetchAdapter
};
utils$1.forEach(knownAdapters, (t, e) => {
  if (t) {
    try {
      Object.defineProperty(t, "name", { value: e });
    } catch {
    }
    Object.defineProperty(t, "adapterName", { value: e });
  }
});
const renderReason = (t) => `- ${t}`, isResolvedHandle = (t) => utils$1.isFunction(t) || t === null || t === !1, adapters = {
  getAdapter: (t) => {
    t = utils$1.isArray(t) ? t : [t];
    const { length: e } = t;
    let n, o;
    const l = {};
    for (let u = 0; u < e; u++) {
      n = t[u];
      let f;
      if (o = n, !isResolvedHandle(n) && (o = knownAdapters[(f = String(n)).toLowerCase()], o === void 0))
        throw new AxiosError(`Unknown adapter '${f}'`);
      if (o)
        break;
      l[f || "#" + u] = o;
    }
    if (!o) {
      const u = Object.entries(l).map(
        ([h, p]) => `adapter ${h} ` + (p === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let f = e ? u.length > 1 ? `since :
` + u.map(renderReason).join(`
`) : " " + renderReason(u[0]) : "as no adapter specified";
      throw new AxiosError(
        "There is no suitable adapter to dispatch the request " + f,
        "ERR_NOT_SUPPORT"
      );
    }
    return o;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested(t) {
  if (t.cancelToken && t.cancelToken.throwIfRequested(), t.signal && t.signal.aborted)
    throw new CanceledError(null, t);
}
function dispatchRequest(t) {
  return throwIfCancellationRequested(t), t.headers = AxiosHeaders.from(t.headers), t.data = transformData.call(
    t,
    t.transformRequest
  ), ["post", "put", "patch"].indexOf(t.method) !== -1 && t.headers.setContentType("application/x-www-form-urlencoded", !1), adapters.getAdapter(t.adapter || defaults$1.adapter)(t).then(function(o) {
    return throwIfCancellationRequested(t), o.data = transformData.call(
      t,
      t.transformResponse,
      o
    ), o.headers = AxiosHeaders.from(o.headers), o;
  }, function(o) {
    return isCancel(o) || (throwIfCancellationRequested(t), o && o.response && (o.response.data = transformData.call(
      t,
      t.transformResponse,
      o.response
    ), o.response.headers = AxiosHeaders.from(o.response.headers))), Promise.reject(o);
  });
}
const VERSION = "1.7.4", validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((t, e) => {
  validators$1[t] = function(o) {
    return typeof o === t || "a" + (e < 1 ? "n " : " ") + t;
  };
});
const deprecatedWarnings = {};
validators$1.transitional = function t(e, n, o) {
  function l(u, f) {
    return "[Axios v" + VERSION + "] Transitional option '" + u + "'" + f + (o ? ". " + o : "");
  }
  return (u, f, h) => {
    if (e === !1)
      throw new AxiosError(
        l(f, " has been removed" + (n ? " in " + n : "")),
        AxiosError.ERR_DEPRECATED
      );
    return n && !deprecatedWarnings[f] && (deprecatedWarnings[f] = !0, console.warn(
      l(
        f,
        " has been deprecated since v" + n + " and will be removed in the near future"
      )
    )), e ? e(u, f, h) : !0;
  };
};
function assertOptions(t, e, n) {
  if (typeof t != "object")
    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
  const o = Object.keys(t);
  let l = o.length;
  for (; l-- > 0; ) {
    const u = o[l], f = e[u];
    if (f) {
      const h = t[u], p = h === void 0 || f(h, u, t);
      if (p !== !0)
        throw new AxiosError("option " + u + " must be " + p, AxiosError.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (n !== !0)
      throw new AxiosError("Unknown option " + u, AxiosError.ERR_BAD_OPTION);
  }
}
const validator$1 = {
  assertOptions,
  validators: validators$1
}, validators = validator$1.validators;
class Axios {
  constructor(e) {
    this.defaults = e, this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(e, n) {
    try {
      return await this._request(e, n);
    } catch (o) {
      if (o instanceof Error) {
        let l;
        Error.captureStackTrace ? Error.captureStackTrace(l = {}) : l = new Error();
        const u = l.stack ? l.stack.replace(/^.+\n/, "") : "";
        try {
          o.stack ? u && !String(o.stack).endsWith(u.replace(/^.+\n.+\n/, "")) && (o.stack += `
` + u) : o.stack = u;
        } catch {
        }
      }
      throw o;
    }
  }
  _request(e, n) {
    typeof e == "string" ? (n = n || {}, n.url = e) : n = e || {}, n = mergeConfig(this.defaults, n);
    const { transitional: o, paramsSerializer: l, headers: u } = n;
    o !== void 0 && validator$1.assertOptions(o, {
      silentJSONParsing: validators.transitional(validators.boolean),
      forcedJSONParsing: validators.transitional(validators.boolean),
      clarifyTimeoutError: validators.transitional(validators.boolean)
    }, !1), l != null && (utils$1.isFunction(l) ? n.paramsSerializer = {
      serialize: l
    } : validator$1.assertOptions(l, {
      encode: validators.function,
      serialize: validators.function
    }, !0)), n.method = (n.method || this.defaults.method || "get").toLowerCase();
    let f = u && utils$1.merge(
      u.common,
      u[n.method]
    );
    u && utils$1.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (R) => {
        delete u[R];
      }
    ), n.headers = AxiosHeaders.concat(f, u);
    const h = [];
    let p = !0;
    this.interceptors.request.forEach(function(_) {
      typeof _.runWhen == "function" && _.runWhen(n) === !1 || (p = p && _.synchronous, h.unshift(_.fulfilled, _.rejected));
    });
    const v = [];
    this.interceptors.response.forEach(function(_) {
      v.push(_.fulfilled, _.rejected);
    });
    let g, w = 0, E;
    if (!p) {
      const R = [dispatchRequest.bind(this), void 0];
      for (R.unshift.apply(R, h), R.push.apply(R, v), E = R.length, g = Promise.resolve(n); w < E; )
        g = g.then(R[w++], R[w++]);
      return g;
    }
    E = h.length;
    let T = n;
    for (w = 0; w < E; ) {
      const R = h[w++], _ = h[w++];
      try {
        T = R(T);
      } catch (b) {
        _.call(this, b);
        break;
      }
    }
    try {
      g = dispatchRequest.call(this, T);
    } catch (R) {
      return Promise.reject(R);
    }
    for (w = 0, E = v.length; w < E; )
      g = g.then(v[w++], v[w++]);
    return g;
  }
  getUri(e) {
    e = mergeConfig(this.defaults, e);
    const n = buildFullPath(e.baseURL, e.url);
    return buildURL(n, e.params, e.paramsSerializer);
  }
}
utils$1.forEach(["delete", "get", "head", "options"], function t(e) {
  Axios.prototype[e] = function(n, o) {
    return this.request(mergeConfig(o || {}, {
      method: e,
      url: n,
      data: (o || {}).data
    }));
  };
});
utils$1.forEach(["post", "put", "patch"], function t(e) {
  function n(o) {
    return function(u, f, h) {
      return this.request(mergeConfig(h || {}, {
        method: e,
        headers: o ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: u,
        data: f
      }));
    };
  }
  Axios.prototype[e] = n(), Axios.prototype[e + "Form"] = n(!0);
});
class CancelToken {
  constructor(e) {
    if (typeof e != "function")
      throw new TypeError("executor must be a function.");
    let n;
    this.promise = new Promise(function(u) {
      n = u;
    });
    const o = this;
    this.promise.then((l) => {
      if (!o._listeners) return;
      let u = o._listeners.length;
      for (; u-- > 0; )
        o._listeners[u](l);
      o._listeners = null;
    }), this.promise.then = (l) => {
      let u;
      const f = new Promise((h) => {
        o.subscribe(h), u = h;
      }).then(l);
      return f.cancel = function() {
        o.unsubscribe(u);
      }, f;
    }, e(function(u, f, h) {
      o.reason || (o.reason = new CanceledError(u, f, h), n(o.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(e) {
    if (this.reason) {
      e(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(e) : this._listeners = [e];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(e) {
    if (!this._listeners)
      return;
    const n = this._listeners.indexOf(e);
    n !== -1 && this._listeners.splice(n, 1);
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let e;
    return {
      token: new CancelToken(function(l) {
        e = l;
      }),
      cancel: e
    };
  }
}
function spread(t) {
  return function(n) {
    return t.apply(null, n);
  };
}
function isAxiosError(t) {
  return utils$1.isObject(t) && t.isAxiosError === !0;
}
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([t, e]) => {
  HttpStatusCode[e] = t;
});
function createInstance(t) {
  const e = new Axios(t), n = bind(Axios.prototype.request, e);
  return utils$1.extend(n, Axios.prototype, e, { allOwnKeys: !0 }), utils$1.extend(n, e, null, { allOwnKeys: !0 }), n.create = function(l) {
    return createInstance(mergeConfig(t, l));
  }, n;
}
const axios = createInstance(defaults$1);
axios.Axios = Axios;
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;
axios.AxiosError = AxiosError;
axios.Cancel = axios.CanceledError;
axios.all = function t(e) {
  return Promise.all(e);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders;
axios.formToJSON = (t) => formDataToJSON(utils$1.isHTMLForm(t) ? new FormData(t) : t);
axios.getAdapter = adapters.getAdapter;
axios.HttpStatusCode = HttpStatusCode;
axios.default = axios;
const common = {
  black: "#000",
  white: "#fff"
}, red = {
  50: "#ffebee",
  100: "#ffcdd2",
  200: "#ef9a9a",
  300: "#e57373",
  400: "#ef5350",
  500: "#f44336",
  600: "#e53935",
  700: "#d32f2f",
  800: "#c62828",
  900: "#b71c1c",
  A100: "#ff8a80",
  A200: "#ff5252",
  A400: "#ff1744",
  A700: "#d50000"
}, purple = {
  50: "#f3e5f5",
  100: "#e1bee7",
  200: "#ce93d8",
  300: "#ba68c8",
  400: "#ab47bc",
  500: "#9c27b0",
  600: "#8e24aa",
  700: "#7b1fa2",
  800: "#6a1b9a",
  900: "#4a148c",
  A100: "#ea80fc",
  A200: "#e040fb",
  A400: "#d500f9",
  A700: "#aa00ff"
}, blue = {
  50: "#e3f2fd",
  100: "#bbdefb",
  200: "#90caf9",
  300: "#64b5f6",
  400: "#42a5f5",
  500: "#2196f3",
  600: "#1e88e5",
  700: "#1976d2",
  800: "#1565c0",
  900: "#0d47a1",
  A100: "#82b1ff",
  A200: "#448aff",
  A400: "#2979ff",
  A700: "#2962ff"
}, lightBlue = {
  50: "#e1f5fe",
  100: "#b3e5fc",
  200: "#81d4fa",
  300: "#4fc3f7",
  400: "#29b6f6",
  500: "#03a9f4",
  600: "#039be5",
  700: "#0288d1",
  800: "#0277bd",
  900: "#01579b",
  A100: "#80d8ff",
  A200: "#40c4ff",
  A400: "#00b0ff",
  A700: "#0091ea"
}, green = {
  50: "#e8f5e9",
  100: "#c8e6c9",
  200: "#a5d6a7",
  300: "#81c784",
  400: "#66bb6a",
  500: "#4caf50",
  600: "#43a047",
  700: "#388e3c",
  800: "#2e7d32",
  900: "#1b5e20",
  A100: "#b9f6ca",
  A200: "#69f0ae",
  A400: "#00e676",
  A700: "#00c853"
}, orange = {
  50: "#fff3e0",
  100: "#ffe0b2",
  200: "#ffcc80",
  300: "#ffb74d",
  400: "#ffa726",
  500: "#ff9800",
  600: "#fb8c00",
  700: "#f57c00",
  800: "#ef6c00",
  900: "#e65100",
  A100: "#ffd180",
  A200: "#ffab40",
  A400: "#ff9100",
  A700: "#ff6d00"
}, grey = {
  50: "#fafafa",
  100: "#f5f5f5",
  200: "#eeeeee",
  300: "#e0e0e0",
  400: "#bdbdbd",
  500: "#9e9e9e",
  600: "#757575",
  700: "#616161",
  800: "#424242",
  900: "#212121",
  A100: "#f5f5f5",
  A200: "#eeeeee",
  A400: "#bdbdbd",
  A700: "#616161"
};
function formatMuiErrorMessage$1(t) {
  let e = "https://mui.com/production-error/?code=" + t;
  for (let n = 1; n < arguments.length; n += 1)
    e += "&args[]=" + encodeURIComponent(arguments[n]);
  return "Minified MUI error #" + t + "; visit " + e + " for the full message.";
}
const formatMuiErrorMessage = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: formatMuiErrorMessage$1
}, Symbol.toStringTag, { value: "Module" })), THEME_ID = "$$material";
function memoize$5(t) {
  var e = /* @__PURE__ */ Object.create(null);
  return function(n) {
    return e[n] === void 0 && (e[n] = t(n)), e[n];
  };
}
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, isPropValid = /* @__PURE__ */ memoize$5(
  function(t) {
    return reactPropsRegex.test(t) || t.charCodeAt(0) === 111 && t.charCodeAt(1) === 110 && t.charCodeAt(2) < 91;
  }
  /* Z+1 */
), isDevelopment$2 = !1;
function sheetForTag(t) {
  if (t.sheet)
    return t.sheet;
  for (var e = 0; e < document.styleSheets.length; e++)
    if (document.styleSheets[e].ownerNode === t)
      return document.styleSheets[e];
}
function createStyleElement(t) {
  var e = document.createElement("style");
  return e.setAttribute("data-emotion", t.key), t.nonce !== void 0 && e.setAttribute("nonce", t.nonce), e.appendChild(document.createTextNode("")), e.setAttribute("data-s", ""), e;
}
var StyleSheet = /* @__PURE__ */ function() {
  function t(n) {
    var o = this;
    this._insertTag = function(l) {
      var u;
      o.tags.length === 0 ? o.insertionPoint ? u = o.insertionPoint.nextSibling : o.prepend ? u = o.container.firstChild : u = o.before : u = o.tags[o.tags.length - 1].nextSibling, o.container.insertBefore(l, u), o.tags.push(l);
    }, this.isSpeedy = n.speedy === void 0 ? !isDevelopment$2 : n.speedy, this.tags = [], this.ctr = 0, this.nonce = n.nonce, this.key = n.key, this.container = n.container, this.prepend = n.prepend, this.insertionPoint = n.insertionPoint, this.before = null;
  }
  var e = t.prototype;
  return e.hydrate = function(o) {
    o.forEach(this._insertTag);
  }, e.insert = function(o) {
    this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(createStyleElement(this));
    var l = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var u = sheetForTag(l);
      try {
        u.insertRule(o, u.cssRules.length);
      } catch {
      }
    } else
      l.appendChild(document.createTextNode(o));
    this.ctr++;
  }, e.flush = function() {
    this.tags.forEach(function(o) {
      var l;
      return (l = o.parentNode) == null ? void 0 : l.removeChild(o);
    }), this.tags = [], this.ctr = 0;
  }, t;
}(), MS = "-ms-", MOZ = "-moz-", WEBKIT = "-webkit-", COMMENT = "comm", RULESET = "rule", DECLARATION = "decl", IMPORT = "@import", KEYFRAMES = "@keyframes", LAYER = "@layer", abs = Math.abs, from = String.fromCharCode, assign$1 = Object.assign;
function hash(t, e) {
  return charat(t, 0) ^ 45 ? (((e << 2 ^ charat(t, 0)) << 2 ^ charat(t, 1)) << 2 ^ charat(t, 2)) << 2 ^ charat(t, 3) : 0;
}
function trim(t) {
  return t.trim();
}
function match$1(t, e) {
  return (t = e.exec(t)) ? t[0] : t;
}
function replace(t, e, n) {
  return t.replace(e, n);
}
function indexof(t, e) {
  return t.indexOf(e);
}
function charat(t, e) {
  return t.charCodeAt(e) | 0;
}
function substr(t, e, n) {
  return t.slice(e, n);
}
function strlen(t) {
  return t.length;
}
function sizeof(t) {
  return t.length;
}
function append$1(t, e) {
  return e.push(t), t;
}
function combine(t, e) {
  return t.map(e).join("");
}
var line = 1, column = 1, length$1 = 0, position = 0, character = 0, characters = "";
function node(t, e, n, o, l, u, f) {
  return { value: t, root: e, parent: n, type: o, props: l, children: u, line, column, length: f, return: "" };
}
function copy$2(t, e) {
  return assign$1(node("", null, null, "", null, null, 0), t, { length: -t.length }, e);
}
function char() {
  return character;
}
function prev() {
  return character = position > 0 ? charat(characters, --position) : 0, column--, character === 10 && (column = 1, line--), character;
}
function next() {
  return character = position < length$1 ? charat(characters, position++) : 0, column++, character === 10 && (column = 1, line++), character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(t, e) {
  return substr(characters, t, e);
}
function token(t) {
  switch (t) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(t) {
  return line = column = 1, length$1 = strlen(characters = t), position = 0, [];
}
function dealloc(t) {
  return characters = "", t;
}
function delimit(t) {
  return trim(slice(position - 1, delimiter(t === 91 ? t + 2 : t === 40 ? t + 1 : t)));
}
function whitespace(t) {
  for (; (character = peek()) && character < 33; )
    next();
  return token(t) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(t, e) {
  for (; --e && next() && !(character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97); )
    ;
  return slice(t, caret() + (e < 6 && peek() == 32 && next() == 32));
}
function delimiter(t) {
  for (; next(); )
    switch (character) {
      case t:
        return position;
      case 34:
      case 39:
        t !== 34 && t !== 39 && delimiter(character);
        break;
      case 40:
        t === 41 && delimiter(t);
        break;
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(t, e) {
  for (; next() && t + character !== 57; )
    if (t + character === 84 && peek() === 47)
      break;
  return "/*" + slice(e, position - 1) + "*" + from(t === 47 ? t : next());
}
function identifier(t) {
  for (; !token(peek()); )
    next();
  return slice(t, position);
}
function compile(t) {
  return dealloc(parse$1("", null, null, null, [""], t = alloc(t), 0, [0], t));
}
function parse$1(t, e, n, o, l, u, f, h, p) {
  for (var v = 0, g = 0, w = f, E = 0, T = 0, R = 0, _ = 1, b = 1, M = 1, A = 0, $ = "", S = l, C = u, D = o, O = $; b; )
    switch (R = A, A = next()) {
      case 40:
        if (R != 108 && charat(O, w - 1) == 58) {
          indexof(O += replace(delimit(A), "&", "&\f"), "&\f") != -1 && (M = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        O += delimit(A);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        O += whitespace(R);
        break;
      case 92:
        O += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append$1(comment(commenter(next(), caret()), e, n), p);
            break;
          default:
            O += "/";
        }
        break;
      case 123 * _:
        h[v++] = strlen(O) * M;
      case 125 * _:
      case 59:
      case 0:
        switch (A) {
          case 0:
          case 125:
            b = 0;
          case 59 + g:
            M == -1 && (O = replace(O, /\f/g, "")), T > 0 && strlen(O) - w && append$1(T > 32 ? declaration(O + ";", o, n, w - 1) : declaration(replace(O, " ", "") + ";", o, n, w - 2), p);
            break;
          case 59:
            O += ";";
          default:
            if (append$1(D = ruleset(O, e, n, v, g, l, h, $, S = [], C = [], w), u), A === 123)
              if (g === 0)
                parse$1(O, e, D, D, S, u, w, h, C);
              else
                switch (E === 99 && charat(O, 3) === 110 ? 100 : E) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse$1(t, D, D, o && append$1(ruleset(t, D, D, 0, 0, l, h, $, l, S = [], w), C), l, C, w, h, o ? S : C);
                    break;
                  default:
                    parse$1(O, D, D, D, [""], C, 0, h, C);
                }
        }
        v = g = T = 0, _ = M = 1, $ = O = "", w = f;
        break;
      case 58:
        w = 1 + strlen(O), T = R;
      default:
        if (_ < 1) {
          if (A == 123)
            --_;
          else if (A == 125 && _++ == 0 && prev() == 125)
            continue;
        }
        switch (O += from(A), A * _) {
          case 38:
            M = g > 0 ? 1 : (O += "\f", -1);
            break;
          case 44:
            h[v++] = (strlen(O) - 1) * M, M = 1;
            break;
          case 64:
            peek() === 45 && (O += delimit(next())), E = peek(), g = w = strlen($ = O += identifier(caret())), A++;
            break;
          case 45:
            R === 45 && strlen(O) == 2 && (_ = 0);
        }
    }
  return u;
}
function ruleset(t, e, n, o, l, u, f, h, p, v, g) {
  for (var w = l - 1, E = l === 0 ? u : [""], T = sizeof(E), R = 0, _ = 0, b = 0; R < o; ++R)
    for (var M = 0, A = substr(t, w + 1, w = abs(_ = f[R])), $ = t; M < T; ++M)
      ($ = trim(_ > 0 ? E[M] + " " + A : replace(A, /&\f/g, E[M]))) && (p[b++] = $);
  return node(t, e, n, l === 0 ? RULESET : h, p, v, g);
}
function comment(t, e, n) {
  return node(t, e, n, COMMENT, from(char()), substr(t, 2, -2), 0);
}
function declaration(t, e, n, o) {
  return node(t, e, n, DECLARATION, substr(t, 0, o), substr(t, o + 1, -1), o);
}
function serialize(t, e) {
  for (var n = "", o = sizeof(t), l = 0; l < o; l++)
    n += e(t[l], l, t, e) || "";
  return n;
}
function stringify(t, e, n, o) {
  switch (t.type) {
    case LAYER:
      if (t.children.length) break;
    case IMPORT:
    case DECLARATION:
      return t.return = t.return || t.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return t.return = t.value + "{" + serialize(t.children, o) + "}";
    case RULESET:
      t.value = t.props.join(",");
  }
  return strlen(n = serialize(t.children, o)) ? t.return = t.value + "{" + n + "}" : "";
}
function middleware(t) {
  var e = sizeof(t);
  return function(n, o, l, u) {
    for (var f = "", h = 0; h < e; h++)
      f += t[h](n, o, l, u) || "";
    return f;
  };
}
function rulesheet(t) {
  return function(e) {
    e.root || (e = e.return) && t(e);
  };
}
var identifierWithPointTracking = function t(e, n, o) {
  for (var l = 0, u = 0; l = u, u = peek(), l === 38 && u === 12 && (n[o] = 1), !token(u); )
    next();
  return slice(e, position);
}, toRules = function t(e, n) {
  var o = -1, l = 44;
  do
    switch (token(l)) {
      case 0:
        l === 38 && peek() === 12 && (n[o] = 1), e[o] += identifierWithPointTracking(position - 1, n, o);
        break;
      case 2:
        e[o] += delimit(l);
        break;
      case 4:
        if (l === 44) {
          e[++o] = peek() === 58 ? "&\f" : "", n[o] = e[o].length;
          break;
        }
      default:
        e[o] += from(l);
    }
  while (l = next());
  return e;
}, getRules = function t(e, n) {
  return dealloc(toRules(alloc(e), n));
}, fixedElements = /* @__PURE__ */ new WeakMap(), compat = function t(e) {
  if (!(e.type !== "rule" || !e.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  e.length < 1)) {
    for (var n = e.value, o = e.parent, l = e.column === o.column && e.line === o.line; o.type !== "rule"; )
      if (o = o.parent, !o) return;
    if (!(e.props.length === 1 && n.charCodeAt(0) !== 58 && !fixedElements.get(o)) && !l) {
      fixedElements.set(e, !0);
      for (var u = [], f = getRules(n, u), h = o.props, p = 0, v = 0; p < f.length; p++)
        for (var g = 0; g < h.length; g++, v++)
          e.props[v] = u[p] ? f[p].replace(/&\f/g, h[g]) : h[g] + " " + f[p];
    }
  }
}, removeLabel = function t(e) {
  if (e.type === "decl") {
    var n = e.value;
    // charcode for l
    n.charCodeAt(0) === 108 && // charcode for b
    n.charCodeAt(2) === 98 && (e.return = "", e.value = "");
  }
};
function prefix$1(t, e) {
  switch (hash(t, e)) {
    case 5103:
      return WEBKIT + "print-" + t + t;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + t + t;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + t + MOZ + t + MS + t + t;
    case 6828:
    case 4268:
      return WEBKIT + t + MS + t + t;
    case 6165:
      return WEBKIT + t + MS + "flex-" + t + t;
    case 5187:
      return WEBKIT + t + replace(t, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + t;
    case 5443:
      return WEBKIT + t + MS + "flex-item-" + replace(t, /flex-|-self/, "") + t;
    case 4675:
      return WEBKIT + t + MS + "flex-line-pack" + replace(t, /align-content|flex-|-self/, "") + t;
    case 5548:
      return WEBKIT + t + MS + replace(t, "shrink", "negative") + t;
    case 5292:
      return WEBKIT + t + MS + replace(t, "basis", "preferred-size") + t;
    case 6060:
      return WEBKIT + "box-" + replace(t, "-grow", "") + WEBKIT + t + MS + replace(t, "grow", "positive") + t;
    case 4554:
      return WEBKIT + replace(t, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + t;
    case 6187:
      return replace(replace(replace(t, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), t, "") + t;
    case 5495:
    case 3959:
      return replace(t, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace(replace(t, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + t + t;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(t, /(.+)-inline(.+)/, WEBKIT + "$1$2") + t;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(t) - 1 - e > 6) switch (charat(t, e + 1)) {
        case 109:
          if (charat(t, e + 4) !== 45) break;
        case 102:
          return replace(t, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(t, e + 3) == 108 ? "$3" : "$2-$3")) + t;
        case 115:
          return ~indexof(t, "stretch") ? prefix$1(replace(t, "stretch", "fill-available"), e) + t : t;
      }
      break;
    case 4949:
      if (charat(t, e + 1) !== 115) break;
    case 6444:
      switch (charat(t, strlen(t) - 3 - (~indexof(t, "!important") && 10))) {
        case 107:
          return replace(t, ":", ":" + WEBKIT) + t;
        case 101:
          return replace(t, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(t, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + t;
      }
      break;
    case 5936:
      switch (charat(t, e + 11)) {
        case 114:
          return WEBKIT + t + MS + replace(t, /[svh]\w+-[tblr]{2}/, "tb") + t;
        case 108:
          return WEBKIT + t + MS + replace(t, /[svh]\w+-[tblr]{2}/, "tb-rl") + t;
        case 45:
          return WEBKIT + t + MS + replace(t, /[svh]\w+-[tblr]{2}/, "lr") + t;
      }
      return WEBKIT + t + MS + t + t;
  }
  return t;
}
var prefixer = function t(e, n, o, l) {
  if (e.length > -1 && !e.return) switch (e.type) {
    case DECLARATION:
      e.return = prefix$1(e.value, e.length);
      break;
    case KEYFRAMES:
      return serialize([copy$2(e, {
        value: replace(e.value, "@", "@" + WEBKIT)
      })], l);
    case RULESET:
      if (e.length) return combine(e.props, function(u) {
        switch (match$1(u, /(::plac\w+|:read-\w+)/)) {
          case ":read-only":
          case ":read-write":
            return serialize([copy$2(e, {
              props: [replace(u, /:(read-\w+)/, ":" + MOZ + "$1")]
            })], l);
          case "::placeholder":
            return serialize([copy$2(e, {
              props: [replace(u, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
            }), copy$2(e, {
              props: [replace(u, /:(plac\w+)/, ":" + MOZ + "$1")]
            }), copy$2(e, {
              props: [replace(u, /:(plac\w+)/, MS + "input-$1")]
            })], l);
        }
        return "";
      });
  }
}, defaultStylisPlugins = [prefixer], createCache = function t(e) {
  var n = e.key;
  if (n === "css") {
    var o = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(o, function(_) {
      var b = _.getAttribute("data-emotion");
      b.indexOf(" ") !== -1 && (document.head.appendChild(_), _.setAttribute("data-s", ""));
    });
  }
  var l = e.stylisPlugins || defaultStylisPlugins, u = {}, f, h = [];
  f = e.container || document.head, Array.prototype.forEach.call(
    // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll('style[data-emotion^="' + n + ' "]'),
    function(_) {
      for (var b = _.getAttribute("data-emotion").split(" "), M = 1; M < b.length; M++)
        u[b[M]] = !0;
      h.push(_);
    }
  );
  var p, v = [compat, removeLabel];
  {
    var g, w = [stringify, rulesheet(function(_) {
      g.insert(_);
    })], E = middleware(v.concat(l, w)), T = function(b) {
      return serialize(compile(b), E);
    };
    p = function(b, M, A, $) {
      g = A, T(b ? b + "{" + M.styles + "}" : M.styles), $ && (R.inserted[M.name] = !0);
    };
  }
  var R = {
    key: n,
    sheet: new StyleSheet({
      key: n,
      container: f,
      nonce: e.nonce,
      speedy: e.speedy,
      prepend: e.prepend,
      insertionPoint: e.insertionPoint
    }),
    nonce: e.nonce,
    inserted: u,
    registered: {},
    insert: p
  };
  return R.sheet.hydrate(h), R;
}, reactIs$3 = { exports: {} }, reactIs_production_min$2 = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_production_min$2;
function requireReactIs_production_min$2() {
  if (hasRequiredReactIs_production_min$2) return reactIs_production_min$2;
  hasRequiredReactIs_production_min$2 = 1;
  var t = typeof Symbol == "function" && Symbol.for, e = t ? Symbol.for("react.element") : 60103, n = t ? Symbol.for("react.portal") : 60106, o = t ? Symbol.for("react.fragment") : 60107, l = t ? Symbol.for("react.strict_mode") : 60108, u = t ? Symbol.for("react.profiler") : 60114, f = t ? Symbol.for("react.provider") : 60109, h = t ? Symbol.for("react.context") : 60110, p = t ? Symbol.for("react.async_mode") : 60111, v = t ? Symbol.for("react.concurrent_mode") : 60111, g = t ? Symbol.for("react.forward_ref") : 60112, w = t ? Symbol.for("react.suspense") : 60113, E = t ? Symbol.for("react.suspense_list") : 60120, T = t ? Symbol.for("react.memo") : 60115, R = t ? Symbol.for("react.lazy") : 60116, _ = t ? Symbol.for("react.block") : 60121, b = t ? Symbol.for("react.fundamental") : 60117, M = t ? Symbol.for("react.responder") : 60118, A = t ? Symbol.for("react.scope") : 60119;
  function $(C) {
    if (typeof C == "object" && C !== null) {
      var D = C.$$typeof;
      switch (D) {
        case e:
          switch (C = C.type, C) {
            case p:
            case v:
            case o:
            case u:
            case l:
            case w:
              return C;
            default:
              switch (C = C && C.$$typeof, C) {
                case h:
                case g:
                case R:
                case T:
                case f:
                  return C;
                default:
                  return D;
              }
          }
        case n:
          return D;
      }
    }
  }
  function S(C) {
    return $(C) === v;
  }
  return reactIs_production_min$2.AsyncMode = p, reactIs_production_min$2.ConcurrentMode = v, reactIs_production_min$2.ContextConsumer = h, reactIs_production_min$2.ContextProvider = f, reactIs_production_min$2.Element = e, reactIs_production_min$2.ForwardRef = g, reactIs_production_min$2.Fragment = o, reactIs_production_min$2.Lazy = R, reactIs_production_min$2.Memo = T, reactIs_production_min$2.Portal = n, reactIs_production_min$2.Profiler = u, reactIs_production_min$2.StrictMode = l, reactIs_production_min$2.Suspense = w, reactIs_production_min$2.isAsyncMode = function(C) {
    return S(C) || $(C) === p;
  }, reactIs_production_min$2.isConcurrentMode = S, reactIs_production_min$2.isContextConsumer = function(C) {
    return $(C) === h;
  }, reactIs_production_min$2.isContextProvider = function(C) {
    return $(C) === f;
  }, reactIs_production_min$2.isElement = function(C) {
    return typeof C == "object" && C !== null && C.$$typeof === e;
  }, reactIs_production_min$2.isForwardRef = function(C) {
    return $(C) === g;
  }, reactIs_production_min$2.isFragment = function(C) {
    return $(C) === o;
  }, reactIs_production_min$2.isLazy = function(C) {
    return $(C) === R;
  }, reactIs_production_min$2.isMemo = function(C) {
    return $(C) === T;
  }, reactIs_production_min$2.isPortal = function(C) {
    return $(C) === n;
  }, reactIs_production_min$2.isProfiler = function(C) {
    return $(C) === u;
  }, reactIs_production_min$2.isStrictMode = function(C) {
    return $(C) === l;
  }, reactIs_production_min$2.isSuspense = function(C) {
    return $(C) === w;
  }, reactIs_production_min$2.isValidElementType = function(C) {
    return typeof C == "string" || typeof C == "function" || C === o || C === v || C === u || C === l || C === w || C === E || typeof C == "object" && C !== null && (C.$$typeof === R || C.$$typeof === T || C.$$typeof === f || C.$$typeof === h || C.$$typeof === g || C.$$typeof === b || C.$$typeof === M || C.$$typeof === A || C.$$typeof === _);
  }, reactIs_production_min$2.typeOf = $, reactIs_production_min$2;
}
var reactIs_development$2 = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_development$2;
function requireReactIs_development$2() {
  return hasRequiredReactIs_development$2 || (hasRequiredReactIs_development$2 = 1, process.env.NODE_ENV !== "production" && function() {
    var t = typeof Symbol == "function" && Symbol.for, e = t ? Symbol.for("react.element") : 60103, n = t ? Symbol.for("react.portal") : 60106, o = t ? Symbol.for("react.fragment") : 60107, l = t ? Symbol.for("react.strict_mode") : 60108, u = t ? Symbol.for("react.profiler") : 60114, f = t ? Symbol.for("react.provider") : 60109, h = t ? Symbol.for("react.context") : 60110, p = t ? Symbol.for("react.async_mode") : 60111, v = t ? Symbol.for("react.concurrent_mode") : 60111, g = t ? Symbol.for("react.forward_ref") : 60112, w = t ? Symbol.for("react.suspense") : 60113, E = t ? Symbol.for("react.suspense_list") : 60120, T = t ? Symbol.for("react.memo") : 60115, R = t ? Symbol.for("react.lazy") : 60116, _ = t ? Symbol.for("react.block") : 60121, b = t ? Symbol.for("react.fundamental") : 60117, M = t ? Symbol.for("react.responder") : 60118, A = t ? Symbol.for("react.scope") : 60119;
    function $(ee) {
      return typeof ee == "string" || typeof ee == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      ee === o || ee === v || ee === u || ee === l || ee === w || ee === E || typeof ee == "object" && ee !== null && (ee.$$typeof === R || ee.$$typeof === T || ee.$$typeof === f || ee.$$typeof === h || ee.$$typeof === g || ee.$$typeof === b || ee.$$typeof === M || ee.$$typeof === A || ee.$$typeof === _);
    }
    function S(ee) {
      if (typeof ee == "object" && ee !== null) {
        var Ae = ee.$$typeof;
        switch (Ae) {
          case e:
            var be = ee.type;
            switch (be) {
              case p:
              case v:
              case o:
              case u:
              case l:
              case w:
                return be;
              default:
                var Fe = be && be.$$typeof;
                switch (Fe) {
                  case h:
                  case g:
                  case R:
                  case T:
                  case f:
                    return Fe;
                  default:
                    return Ae;
                }
            }
          case n:
            return Ae;
        }
      }
    }
    var C = p, D = v, O = h, N = f, j = e, L = g, z = o, G = R, B = T, F = n, H = u, W = l, V = w, X = !1;
    function Z(ee) {
      return X || (X = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), Q(ee) || S(ee) === p;
    }
    function Q(ee) {
      return S(ee) === v;
    }
    function q(ee) {
      return S(ee) === h;
    }
    function J(ee) {
      return S(ee) === f;
    }
    function ie(ee) {
      return typeof ee == "object" && ee !== null && ee.$$typeof === e;
    }
    function ne(ee) {
      return S(ee) === g;
    }
    function ge(ee) {
      return S(ee) === o;
    }
    function ye(ee) {
      return S(ee) === R;
    }
    function xe(ee) {
      return S(ee) === T;
    }
    function we(ee) {
      return S(ee) === n;
    }
    function de(ee) {
      return S(ee) === u;
    }
    function Te(ee) {
      return S(ee) === l;
    }
    function Ce(ee) {
      return S(ee) === w;
    }
    reactIs_development$2.AsyncMode = C, reactIs_development$2.ConcurrentMode = D, reactIs_development$2.ContextConsumer = O, reactIs_development$2.ContextProvider = N, reactIs_development$2.Element = j, reactIs_development$2.ForwardRef = L, reactIs_development$2.Fragment = z, reactIs_development$2.Lazy = G, reactIs_development$2.Memo = B, reactIs_development$2.Portal = F, reactIs_development$2.Profiler = H, reactIs_development$2.StrictMode = W, reactIs_development$2.Suspense = V, reactIs_development$2.isAsyncMode = Z, reactIs_development$2.isConcurrentMode = Q, reactIs_development$2.isContextConsumer = q, reactIs_development$2.isContextProvider = J, reactIs_development$2.isElement = ie, reactIs_development$2.isForwardRef = ne, reactIs_development$2.isFragment = ge, reactIs_development$2.isLazy = ye, reactIs_development$2.isMemo = xe, reactIs_development$2.isPortal = we, reactIs_development$2.isProfiler = de, reactIs_development$2.isStrictMode = Te, reactIs_development$2.isSuspense = Ce, reactIs_development$2.isValidElementType = $, reactIs_development$2.typeOf = S;
  }()), reactIs_development$2;
}
process.env.NODE_ENV === "production" ? reactIs$3.exports = requireReactIs_production_min$2() : reactIs$3.exports = requireReactIs_development$2();
var reactIsExports$2 = reactIs$3.exports, reactIs$2 = reactIsExports$2, FORWARD_REF_STATICS = {
  $$typeof: !0,
  render: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0
}, MEMO_STATICS = {
  $$typeof: !0,
  compare: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0,
  type: !0
}, TYPE_STATICS = {};
TYPE_STATICS[reactIs$2.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs$2.Memo] = MEMO_STATICS;
var isBrowser = !0;
function getRegisteredStyles(t, e, n) {
  var o = "";
  return n.split(" ").forEach(function(l) {
    t[l] !== void 0 ? e.push(t[l] + ";") : o += l + " ";
  }), o;
}
var registerStyles = function t(e, n, o) {
  var l = e.key + "-" + n.name;
  // we only need to add the styles to the registered cache if the
  // class name could be used further down
  // the tree but if it's a string tag, we know it won't
  // so we don't have to add it to registered cache.
  // this improves memory usage since we can avoid storing the whole style string
  (o === !1 || // we need to always store it if we're in compat mode and
  // in node since emotion-server relies on whether a style is in
  // the registered cache to know whether a style is global or not
  // also, note that this check will be dead code eliminated in the browser
  isBrowser === !1) && e.registered[l] === void 0 && (e.registered[l] = n.styles);
}, insertStyles = function t(e, n, o) {
  registerStyles(e, n, o);
  var l = e.key + "-" + n.name;
  if (e.inserted[n.name] === void 0) {
    var u = n;
    do
      e.insert(n === u ? "." + l : "", u, e.sheet, !0), u = u.next;
    while (u !== void 0);
  }
};
function murmur2(t) {
  for (var e = 0, n, o = 0, l = t.length; l >= 4; ++o, l -= 4)
    n = t.charCodeAt(o) & 255 | (t.charCodeAt(++o) & 255) << 8 | (t.charCodeAt(++o) & 255) << 16 | (t.charCodeAt(++o) & 255) << 24, n = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= /* k >>> r: */
    n >>> 24, e = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16);
  switch (l) {
    case 3:
      e ^= (t.charCodeAt(o + 2) & 255) << 16;
    case 2:
      e ^= (t.charCodeAt(o + 1) & 255) << 8;
    case 1:
      e ^= t.charCodeAt(o) & 255, e = /* Math.imul(h, m): */
      (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16);
  }
  return e ^= e >>> 13, e = /* Math.imul(h, m): */
  (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16), ((e ^ e >>> 15) >>> 0).toString(36);
}
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, isDevelopment$1 = !1, hyphenateRegex = /[A-Z]|^ms/g, animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g, isCustomProperty = function t(e) {
  return e.charCodeAt(1) === 45;
}, isProcessableValue = function t(e) {
  return e != null && typeof e != "boolean";
}, processStyleName = /* @__PURE__ */ memoize$5(function(t) {
  return isCustomProperty(t) ? t : t.replace(hyphenateRegex, "-$&").toLowerCase();
}), processStyleValue = function t(e, n) {
  switch (e) {
    case "animation":
    case "animationName":
      if (typeof n == "string")
        return n.replace(animationRegex, function(o, l, u) {
          return cursor = {
            name: l,
            styles: u,
            next: cursor
          }, l;
        });
  }
  return unitlessKeys[e] !== 1 && !isCustomProperty(e) && typeof n == "number" && n !== 0 ? n + "px" : n;
}, noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function handleInterpolation(t, e, n) {
  if (n == null)
    return "";
  var o = n;
  if (o.__emotion_styles !== void 0)
    return o;
  switch (typeof n) {
    case "boolean":
      return "";
    case "object": {
      var l = n;
      if (l.anim === 1)
        return cursor = {
          name: l.name,
          styles: l.styles,
          next: cursor
        }, l.name;
      var u = n;
      if (u.styles !== void 0) {
        var f = u.next;
        if (f !== void 0)
          for (; f !== void 0; )
            cursor = {
              name: f.name,
              styles: f.styles,
              next: cursor
            }, f = f.next;
        var h = u.styles + ";";
        return h;
      }
      return createStringFromObject(t, e, n);
    }
    case "function": {
      if (t !== void 0) {
        var p = cursor, v = n(t);
        return cursor = p, handleInterpolation(t, e, v);
      }
      break;
    }
  }
  var g = n;
  if (e == null)
    return g;
  var w = e[g];
  return w !== void 0 ? w : g;
}
function createStringFromObject(t, e, n) {
  var o = "";
  if (Array.isArray(n))
    for (var l = 0; l < n.length; l++)
      o += handleInterpolation(t, e, n[l]) + ";";
  else
    for (var u in n) {
      var f = n[u];
      if (typeof f != "object") {
        var h = f;
        e != null && e[h] !== void 0 ? o += u + "{" + e[h] + "}" : isProcessableValue(h) && (o += processStyleName(u) + ":" + processStyleValue(u, h) + ";");
      } else {
        if (u === "NO_COMPONENT_SELECTOR" && isDevelopment$1)
          throw new Error(noComponentSelectorMessage);
        if (Array.isArray(f) && typeof f[0] == "string" && (e == null || e[f[0]] === void 0))
          for (var p = 0; p < f.length; p++)
            isProcessableValue(f[p]) && (o += processStyleName(u) + ":" + processStyleValue(u, f[p]) + ";");
        else {
          var v = handleInterpolation(t, e, f);
          switch (u) {
            case "animation":
            case "animationName": {
              o += processStyleName(u) + ":" + v + ";";
              break;
            }
            default:
              o += u + "{" + v + "}";
          }
        }
      }
    }
  return o;
}
var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g, cursor;
function serializeStyles(t, e, n) {
  if (t.length === 1 && typeof t[0] == "object" && t[0] !== null && t[0].styles !== void 0)
    return t[0];
  var o = !0, l = "";
  cursor = void 0;
  var u = t[0];
  if (u == null || u.raw === void 0)
    o = !1, l += handleInterpolation(n, e, u);
  else {
    var f = u;
    l += f[0];
  }
  for (var h = 1; h < t.length; h++)
    if (l += handleInterpolation(n, e, t[h]), o) {
      var p = u;
      l += p[h];
    }
  labelPattern.lastIndex = 0;
  for (var v = "", g; (g = labelPattern.exec(l)) !== null; )
    v += "-" + g[1];
  var w = murmur2(l) + v;
  return {
    name: w,
    styles: l,
    next: cursor
  };
}
var syncFallback = function t(e) {
  return e();
}, useInsertionEffect$1 = React.useInsertionEffect ? React.useInsertionEffect : !1, useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect$1 || syncFallback, useInsertionEffectWithLayoutFallback = useInsertionEffect$1 || React.useLayoutEffect, EmotionCacheContext = /* @__PURE__ */ React.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement < "u" ? /* @__PURE__ */ createCache({
    key: "css"
  }) : null
), CacheProvider = EmotionCacheContext.Provider, withEmotionCache = function t(e) {
  return /* @__PURE__ */ forwardRef(function(n, o) {
    var l = useContext(EmotionCacheContext);
    return e(n, l, o);
  });
}, ThemeContext$1 = /* @__PURE__ */ React.createContext({}), Global$1 = /* @__PURE__ */ withEmotionCache(function(t, e) {
  var n = t.styles, o = serializeStyles([n], void 0, React.useContext(ThemeContext$1)), l = React.useRef();
  return useInsertionEffectWithLayoutFallback(function() {
    var u = e.key + "-global", f = new e.sheet.constructor({
      key: u,
      nonce: e.sheet.nonce,
      container: e.sheet.container,
      speedy: e.sheet.isSpeedy
    }), h = !1, p = document.querySelector('style[data-emotion="' + u + " " + o.name + '"]');
    return e.sheet.tags.length && (f.before = e.sheet.tags[0]), p !== null && (h = !0, p.setAttribute("data-emotion", u), f.hydrate([p])), l.current = [f, h], function() {
      f.flush();
    };
  }, [e]), useInsertionEffectWithLayoutFallback(function() {
    var u = l.current, f = u[0], h = u[1];
    if (h) {
      u[1] = !1;
      return;
    }
    if (o.next !== void 0 && insertStyles(e, o.next, !0), f.tags.length) {
      var p = f.tags[f.tags.length - 1].nextElementSibling;
      f.before = p, f.flush();
    }
    e.insert("", o, f, !1);
  }, [e, o.name]), null;
});
function css() {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
    e[n] = arguments[n];
  return serializeStyles(e);
}
var keyframes = function t() {
  var e = css.apply(void 0, arguments), n = "animation-" + e.name;
  return {
    name: n,
    styles: "@keyframes " + n + "{" + e.styles + "}",
    anim: 1,
    toString: function() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
}, testOmitPropsOnStringTag = isPropValid, testOmitPropsOnComponent = function t(e) {
  return e !== "theme";
}, getDefaultShouldForwardProp = function t(e) {
  return typeof e == "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  e.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
}, composeShouldForwardProps = function t(e, n, o) {
  var l;
  if (n) {
    var u = n.shouldForwardProp;
    l = e.__emotion_forwardProp && u ? function(f) {
      return e.__emotion_forwardProp(f) && u(f);
    } : u;
  }
  return typeof l != "function" && o && (l = e.__emotion_forwardProp), l;
}, isDevelopment = !1, Insertion = function t(e) {
  var n = e.cache, o = e.serialized, l = e.isStringTag;
  return registerStyles(n, o, l), useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(n, o, l);
  }), null;
}, createStyled$2 = function t(e, n) {
  var o = e.__emotion_real === e, l = o && e.__emotion_base || e, u, f;
  n !== void 0 && (u = n.label, f = n.target);
  var h = composeShouldForwardProps(e, n, o), p = h || getDefaultShouldForwardProp(l), v = !p("as");
  return function() {
    var g = arguments, w = o && e.__emotion_styles !== void 0 ? e.__emotion_styles.slice(0) : [];
    if (u !== void 0 && w.push("label:" + u + ";"), g[0] == null || g[0].raw === void 0)
      w.push.apply(w, g);
    else {
      w.push(g[0][0]);
      for (var E = g.length, T = 1; T < E; T++)
        w.push(g[T], g[0][T]);
    }
    var R = withEmotionCache(function(_, b, M) {
      var A = v && _.as || l, $ = "", S = [], C = _;
      if (_.theme == null) {
        C = {};
        for (var D in _)
          C[D] = _[D];
        C.theme = React.useContext(ThemeContext$1);
      }
      typeof _.className == "string" ? $ = getRegisteredStyles(b.registered, S, _.className) : _.className != null && ($ = _.className + " ");
      var O = serializeStyles(w.concat(S), b.registered, C);
      $ += b.key + "-" + O.name, f !== void 0 && ($ += " " + f);
      var N = v && h === void 0 ? getDefaultShouldForwardProp(A) : p, j = {};
      for (var L in _)
        v && L === "as" || N(L) && (j[L] = _[L]);
      return j.className = $, M && (j.ref = M), /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Insertion, {
        cache: b,
        serialized: O,
        isStringTag: typeof A == "string"
      }), /* @__PURE__ */ React.createElement(A, j));
    });
    return R.displayName = u !== void 0 ? u : "Styled(" + (typeof l == "string" ? l : l.displayName || l.name || "Component") + ")", R.defaultProps = e.defaultProps, R.__emotion_real = R, R.__emotion_base = l, R.__emotion_styles = w, R.__emotion_forwardProp = h, Object.defineProperty(R, "toString", {
      value: function() {
        return f === void 0 && isDevelopment ? "NO_COMPONENT_SELECTOR" : "." + f;
      }
    }), R.withComponent = function(_, b) {
      return t(_, _extends$x({}, n, b, {
        shouldForwardProp: composeShouldForwardProps(R, b, !0)
      })).apply(void 0, w);
    }, R;
  };
}, tags = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
], newStyled = createStyled$2.bind();
tags.forEach(function(t) {
  newStyled[t] = newStyled(t);
});
let cache;
typeof document == "object" && (cache = createCache({
  key: "css",
  prepend: !0
}));
function StyledEngineProvider(t) {
  const {
    injectFirst: e,
    children: n
  } = t;
  return e && cache ? /* @__PURE__ */ jsxRuntimeExports$1.jsx(CacheProvider, {
    value: cache,
    children: n
  }) : n;
}
process.env.NODE_ENV !== "production" && (StyledEngineProvider.propTypes = {
  /**
   * Your component tree.
   */
  children: PropTypes.node,
  /**
   * By default, the styles are injected last in the <head> element of the page.
   * As a result, they gain more specificity than any other style sheet.
   * If you want to override MUI's styles, set this prop.
   */
  injectFirst: PropTypes.bool
});
function isEmpty$2(t) {
  return t == null || Object.keys(t).length === 0;
}
function GlobalStyles$2(t) {
  const {
    styles: e,
    defaultTheme: n = {}
  } = t, o = typeof e == "function" ? (l) => e(isEmpty$2(l) ? n : l) : e;
  return /* @__PURE__ */ jsxRuntimeExports$1.jsx(Global$1, {
    styles: o
  });
}
process.env.NODE_ENV !== "production" && (GlobalStyles$2.propTypes = {
  defaultTheme: PropTypes.object,
  styles: PropTypes.oneOfType([PropTypes.array, PropTypes.string, PropTypes.object, PropTypes.func])
});
/**
 * @mui/styled-engine v5.16.6
 *
 * @license MIT
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
function styled$1(t, e) {
  const n = newStyled(t, e);
  return process.env.NODE_ENV !== "production" ? (...o) => {
    const l = typeof t == "string" ? `"${t}"` : "component";
    return o.length === 0 ? console.error([`MUI: Seems like you called \`styled(${l})()\` without a \`style\` argument.`, 'You must provide a `styles` argument: `styled("div")(styleYouForgotToPass)`.'].join(`
`)) : o.some((u) => u === void 0) && console.error(`MUI: the styled(${l})(...args) API requires all its args to be defined.`), n(...o);
  } : n;
}
const internal_processStyles = (t, e) => {
  Array.isArray(t.__emotion_styles) && (t.__emotion_styles = e(t.__emotion_styles));
}, styledEngine = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  GlobalStyles: GlobalStyles$2,
  StyledEngineProvider,
  ThemeContext: ThemeContext$1,
  css,
  default: styled$1,
  internal_processStyles,
  keyframes
}, Symbol.toStringTag, { value: "Module" }));
function isPlainObject$3(t) {
  if (typeof t != "object" || t === null)
    return !1;
  const e = Object.getPrototypeOf(t);
  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in t) && !(Symbol.iterator in t);
}
function deepClone(t) {
  if (!isPlainObject$3(t))
    return t;
  const e = {};
  return Object.keys(t).forEach((n) => {
    e[n] = deepClone(t[n]);
  }), e;
}
function deepmerge$1(t, e, n = {
  clone: !0
}) {
  const o = n.clone ? _extends$x({}, t) : t;
  return isPlainObject$3(t) && isPlainObject$3(e) && Object.keys(e).forEach((l) => {
    isPlainObject$3(e[l]) && // Avoid prototype pollution
    Object.prototype.hasOwnProperty.call(t, l) && isPlainObject$3(t[l]) ? o[l] = deepmerge$1(t[l], e[l], n) : n.clone ? o[l] = isPlainObject$3(e[l]) ? deepClone(e[l]) : e[l] : o[l] = e[l];
  }), o;
}
const deepmerge = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: deepmerge$1,
  isPlainObject: isPlainObject$3
}, Symbol.toStringTag, { value: "Module" })), _excluded$y = ["values", "unit", "step"], sortBreakpointsValues = (t) => {
  const e = Object.keys(t).map((n) => ({
    key: n,
    val: t[n]
  })) || [];
  return e.sort((n, o) => n.val - o.val), e.reduce((n, o) => _extends$x({}, n, {
    [o.key]: o.val
  }), {});
};
function createBreakpoints(t) {
  const {
    // The breakpoint **start** at this value.
    // For instance with the first breakpoint xs: [xs, sm).
    values: e = {
      xs: 0,
      // phone
      sm: 600,
      // tablet
      md: 900,
      // small laptop
      lg: 1200,
      // desktop
      xl: 1536
      // large screen
    },
    unit: n = "px",
    step: o = 5
  } = t, l = _objectWithoutPropertiesLoose$n(t, _excluded$y), u = sortBreakpointsValues(e), f = Object.keys(u);
  function h(E) {
    return `@media (min-width:${typeof e[E] == "number" ? e[E] : E}${n})`;
  }
  function p(E) {
    return `@media (max-width:${(typeof e[E] == "number" ? e[E] : E) - o / 100}${n})`;
  }
  function v(E, T) {
    const R = f.indexOf(T);
    return `@media (min-width:${typeof e[E] == "number" ? e[E] : E}${n}) and (max-width:${(R !== -1 && typeof e[f[R]] == "number" ? e[f[R]] : T) - o / 100}${n})`;
  }
  function g(E) {
    return f.indexOf(E) + 1 < f.length ? v(E, f[f.indexOf(E) + 1]) : h(E);
  }
  function w(E) {
    const T = f.indexOf(E);
    return T === 0 ? h(f[1]) : T === f.length - 1 ? p(f[T]) : v(E, f[f.indexOf(E) + 1]).replace("@media", "@media not all and");
  }
  return _extends$x({
    keys: f,
    values: u,
    up: h,
    down: p,
    between: v,
    only: g,
    not: w,
    unit: n
  }, l);
}
const shape = {
  borderRadius: 4
}, responsivePropType = process.env.NODE_ENV !== "production" ? PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.object, PropTypes.array]) : {};
function merge(t, e) {
  return e ? deepmerge$1(t, e, {
    clone: !1
    // No need to clone deep, it's way faster.
  }) : t;
}
const values = {
  xs: 0,
  // phone
  sm: 600,
  // tablet
  md: 900,
  // small laptop
  lg: 1200,
  // desktop
  xl: 1536
  // large screen
}, defaultBreakpoints = {
  // Sorted ASC by size. That's important.
  // It can't be configured as it's used statically for propTypes.
  keys: ["xs", "sm", "md", "lg", "xl"],
  up: (t) => `@media (min-width:${values[t]}px)`
};
function handleBreakpoints(t, e, n) {
  const o = t.theme || {};
  if (Array.isArray(e)) {
    const u = o.breakpoints || defaultBreakpoints;
    return e.reduce((f, h, p) => (f[u.up(u.keys[p])] = n(e[p]), f), {});
  }
  if (typeof e == "object") {
    const u = o.breakpoints || defaultBreakpoints;
    return Object.keys(e).reduce((f, h) => {
      if (Object.keys(u.values || values).indexOf(h) !== -1) {
        const p = u.up(h);
        f[p] = n(e[h], h);
      } else {
        const p = h;
        f[p] = e[p];
      }
      return f;
    }, {});
  }
  return n(e);
}
function createEmptyBreakpointObject(t = {}) {
  var e;
  return ((e = t.keys) == null ? void 0 : e.reduce((o, l) => {
    const u = t.up(l);
    return o[u] = {}, o;
  }, {})) || {};
}
function removeUnusedBreakpoints(t, e) {
  return t.reduce((n, o) => {
    const l = n[o];
    return (!l || Object.keys(l).length === 0) && delete n[o], n;
  }, e);
}
function capitalize$1(t) {
  if (typeof t != "string")
    throw new Error(process.env.NODE_ENV !== "production" ? "MUI: `capitalize(string)` expects a string argument." : formatMuiErrorMessage$1(7));
  return t.charAt(0).toUpperCase() + t.slice(1);
}
const capitalize = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: capitalize$1
}, Symbol.toStringTag, { value: "Module" }));
function getPath$2(t, e, n = !0) {
  if (!e || typeof e != "string")
    return null;
  if (t && t.vars && n) {
    const o = `vars.${e}`.split(".").reduce((l, u) => l && l[u] ? l[u] : null, t);
    if (o != null)
      return o;
  }
  return e.split(".").reduce((o, l) => o && o[l] != null ? o[l] : null, t);
}
function getStyleValue$1(t, e, n, o = n) {
  let l;
  return typeof t == "function" ? l = t(n) : Array.isArray(t) ? l = t[n] || o : l = getPath$2(t, n) || o, e && (l = e(l, o, t)), l;
}
function style$2(t) {
  const {
    prop: e,
    cssProperty: n = t.prop,
    themeKey: o,
    transform: l
  } = t, u = (f) => {
    if (f[e] == null)
      return null;
    const h = f[e], p = f.theme, v = getPath$2(p, o) || {};
    return handleBreakpoints(f, h, (w) => {
      let E = getStyleValue$1(v, l, w);
      return w === E && typeof w == "string" && (E = getStyleValue$1(v, l, `${e}${w === "default" ? "" : capitalize$1(w)}`, w)), n === !1 ? E : {
        [n]: E
      };
    });
  };
  return u.propTypes = process.env.NODE_ENV !== "production" ? {
    [e]: responsivePropType
  } : {}, u.filterProps = [e], u;
}
function memoize$4(t) {
  const e = {};
  return (n) => (e[n] === void 0 && (e[n] = t(n)), e[n]);
}
const properties = {
  m: "margin",
  p: "padding"
}, directions = {
  t: "Top",
  r: "Right",
  b: "Bottom",
  l: "Left",
  x: ["Left", "Right"],
  y: ["Top", "Bottom"]
}, aliases = {
  marginX: "mx",
  marginY: "my",
  paddingX: "px",
  paddingY: "py"
}, getCssProperties = memoize$4((t) => {
  if (t.length > 2)
    if (aliases[t])
      t = aliases[t];
    else
      return [t];
  const [e, n] = t.split(""), o = properties[e], l = directions[n] || "";
  return Array.isArray(l) ? l.map((u) => o + u) : [o + l];
}), marginKeys = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"], paddingKeys = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"], spacingKeys = [...marginKeys, ...paddingKeys];
function createUnaryUnit(t, e, n, o) {
  var l;
  const u = (l = getPath$2(t, e, !1)) != null ? l : n;
  return typeof u == "number" ? (f) => typeof f == "string" ? f : (process.env.NODE_ENV !== "production" && typeof f != "number" && console.error(`MUI: Expected ${o} argument to be a number or a string, got ${f}.`), u * f) : Array.isArray(u) ? (f) => typeof f == "string" ? f : (process.env.NODE_ENV !== "production" && (Number.isInteger(f) ? f > u.length - 1 && console.error([`MUI: The value provided (${f}) overflows.`, `The supported values are: ${JSON.stringify(u)}.`, `${f} > ${u.length - 1}, you need to add the missing values.`].join(`
`)) : console.error([`MUI: The \`theme.${e}\` array type cannot be combined with non integer values.You should either use an integer value that can be used as index, or define the \`theme.${e}\` as a number.`].join(`
`))), u[f]) : typeof u == "function" ? u : (process.env.NODE_ENV !== "production" && console.error([`MUI: The \`theme.${e}\` value (${u}) is invalid.`, "It should be a number, an array or a function."].join(`
`)), () => {
  });
}
function createUnarySpacing(t) {
  return createUnaryUnit(t, "spacing", 8, "spacing");
}
function getValue$2(t, e) {
  if (typeof e == "string" || e == null)
    return e;
  const n = Math.abs(e), o = t(n);
  return e >= 0 ? o : typeof o == "number" ? -o : `-${o}`;
}
function getStyleFromPropValue(t, e) {
  return (n) => t.reduce((o, l) => (o[l] = getValue$2(e, n), o), {});
}
function resolveCssProperty(t, e, n, o) {
  if (e.indexOf(n) === -1)
    return null;
  const l = getCssProperties(n), u = getStyleFromPropValue(l, o), f = t[n];
  return handleBreakpoints(t, f, u);
}
function style$1(t, e) {
  const n = createUnarySpacing(t.theme);
  return Object.keys(t).map((o) => resolveCssProperty(t, e, o, n)).reduce(merge, {});
}
function margin(t) {
  return style$1(t, marginKeys);
}
margin.propTypes = process.env.NODE_ENV !== "production" ? marginKeys.reduce((t, e) => (t[e] = responsivePropType, t), {}) : {};
margin.filterProps = marginKeys;
function padding(t) {
  return style$1(t, paddingKeys);
}
padding.propTypes = process.env.NODE_ENV !== "production" ? paddingKeys.reduce((t, e) => (t[e] = responsivePropType, t), {}) : {};
padding.filterProps = paddingKeys;
process.env.NODE_ENV !== "production" && spacingKeys.reduce((t, e) => (t[e] = responsivePropType, t), {});
function createSpacing(t = 8) {
  if (t.mui)
    return t;
  const e = createUnarySpacing({
    spacing: t
  }), n = (...o) => (process.env.NODE_ENV !== "production" && (o.length <= 4 || console.error(`MUI: Too many arguments provided, expected between 0 and 4, got ${o.length}`)), (o.length === 0 ? [1] : o).map((u) => {
    const f = e(u);
    return typeof f == "number" ? `${f}px` : f;
  }).join(" "));
  return n.mui = !0, n;
}
function compose$1(...t) {
  const e = t.reduce((o, l) => (l.filterProps.forEach((u) => {
    o[u] = l;
  }), o), {}), n = (o) => Object.keys(o).reduce((l, u) => e[u] ? merge(l, e[u](o)) : l, {});
  return n.propTypes = process.env.NODE_ENV !== "production" ? t.reduce((o, l) => Object.assign(o, l.propTypes), {}) : {}, n.filterProps = t.reduce((o, l) => o.concat(l.filterProps), []), n;
}
function borderTransform(t) {
  return typeof t != "number" ? t : `${t}px solid`;
}
function createBorderStyle(t, e) {
  return style$2({
    prop: t,
    themeKey: "borders",
    transform: e
  });
}
const border = createBorderStyle("border", borderTransform), borderTop = createBorderStyle("borderTop", borderTransform), borderRight = createBorderStyle("borderRight", borderTransform), borderBottom = createBorderStyle("borderBottom", borderTransform), borderLeft = createBorderStyle("borderLeft", borderTransform), borderColor = createBorderStyle("borderColor"), borderTopColor = createBorderStyle("borderTopColor"), borderRightColor = createBorderStyle("borderRightColor"), borderBottomColor = createBorderStyle("borderBottomColor"), borderLeftColor = createBorderStyle("borderLeftColor"), outline = createBorderStyle("outline", borderTransform), outlineColor = createBorderStyle("outlineColor"), borderRadius = (t) => {
  if (t.borderRadius !== void 0 && t.borderRadius !== null) {
    const e = createUnaryUnit(t.theme, "shape.borderRadius", 4, "borderRadius"), n = (o) => ({
      borderRadius: getValue$2(e, o)
    });
    return handleBreakpoints(t, t.borderRadius, n);
  }
  return null;
};
borderRadius.propTypes = process.env.NODE_ENV !== "production" ? {
  borderRadius: responsivePropType
} : {};
borderRadius.filterProps = ["borderRadius"];
compose$1(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderRadius, outline, outlineColor);
const gap = (t) => {
  if (t.gap !== void 0 && t.gap !== null) {
    const e = createUnaryUnit(t.theme, "spacing", 8, "gap"), n = (o) => ({
      gap: getValue$2(e, o)
    });
    return handleBreakpoints(t, t.gap, n);
  }
  return null;
};
gap.propTypes = process.env.NODE_ENV !== "production" ? {
  gap: responsivePropType
} : {};
gap.filterProps = ["gap"];
const columnGap = (t) => {
  if (t.columnGap !== void 0 && t.columnGap !== null) {
    const e = createUnaryUnit(t.theme, "spacing", 8, "columnGap"), n = (o) => ({
      columnGap: getValue$2(e, o)
    });
    return handleBreakpoints(t, t.columnGap, n);
  }
  return null;
};
columnGap.propTypes = process.env.NODE_ENV !== "production" ? {
  columnGap: responsivePropType
} : {};
columnGap.filterProps = ["columnGap"];
const rowGap = (t) => {
  if (t.rowGap !== void 0 && t.rowGap !== null) {
    const e = createUnaryUnit(t.theme, "spacing", 8, "rowGap"), n = (o) => ({
      rowGap: getValue$2(e, o)
    });
    return handleBreakpoints(t, t.rowGap, n);
  }
  return null;
};
rowGap.propTypes = process.env.NODE_ENV !== "production" ? {
  rowGap: responsivePropType
} : {};
rowGap.filterProps = ["rowGap"];
const gridColumn = style$2({
  prop: "gridColumn"
}), gridRow = style$2({
  prop: "gridRow"
}), gridAutoFlow = style$2({
  prop: "gridAutoFlow"
}), gridAutoColumns = style$2({
  prop: "gridAutoColumns"
}), gridAutoRows = style$2({
  prop: "gridAutoRows"
}), gridTemplateColumns = style$2({
  prop: "gridTemplateColumns"
}), gridTemplateRows = style$2({
  prop: "gridTemplateRows"
}), gridTemplateAreas = style$2({
  prop: "gridTemplateAreas"
}), gridArea = style$2({
  prop: "gridArea"
});
compose$1(gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea);
function paletteTransform(t, e) {
  return e === "grey" ? e : t;
}
const color$1 = style$2({
  prop: "color",
  themeKey: "palette",
  transform: paletteTransform
}), bgcolor = style$2({
  prop: "bgcolor",
  cssProperty: "backgroundColor",
  themeKey: "palette",
  transform: paletteTransform
}), backgroundColor = style$2({
  prop: "backgroundColor",
  themeKey: "palette",
  transform: paletteTransform
});
compose$1(color$1, bgcolor, backgroundColor);
function sizingTransform(t) {
  return t <= 1 && t !== 0 ? `${t * 100}%` : t;
}
const width = style$2({
  prop: "width",
  transform: sizingTransform
}), maxWidth = (t) => {
  if (t.maxWidth !== void 0 && t.maxWidth !== null) {
    const e = (n) => {
      var o, l;
      const u = ((o = t.theme) == null || (o = o.breakpoints) == null || (o = o.values) == null ? void 0 : o[n]) || values[n];
      return u ? ((l = t.theme) == null || (l = l.breakpoints) == null ? void 0 : l.unit) !== "px" ? {
        maxWidth: `${u}${t.theme.breakpoints.unit}`
      } : {
        maxWidth: u
      } : {
        maxWidth: sizingTransform(n)
      };
    };
    return handleBreakpoints(t, t.maxWidth, e);
  }
  return null;
};
maxWidth.filterProps = ["maxWidth"];
const minWidth = style$2({
  prop: "minWidth",
  transform: sizingTransform
}), height = style$2({
  prop: "height",
  transform: sizingTransform
}), maxHeight = style$2({
  prop: "maxHeight",
  transform: sizingTransform
}), minHeight = style$2({
  prop: "minHeight",
  transform: sizingTransform
});
style$2({
  prop: "size",
  cssProperty: "width",
  transform: sizingTransform
});
style$2({
  prop: "size",
  cssProperty: "height",
  transform: sizingTransform
});
const boxSizing = style$2({
  prop: "boxSizing"
});
compose$1(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing);
const defaultSxConfig = {
  // borders
  border: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderTop: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderRight: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderBottom: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderLeft: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderColor: {
    themeKey: "palette"
  },
  borderTopColor: {
    themeKey: "palette"
  },
  borderRightColor: {
    themeKey: "palette"
  },
  borderBottomColor: {
    themeKey: "palette"
  },
  borderLeftColor: {
    themeKey: "palette"
  },
  outline: {
    themeKey: "borders",
    transform: borderTransform
  },
  outlineColor: {
    themeKey: "palette"
  },
  borderRadius: {
    themeKey: "shape.borderRadius",
    style: borderRadius
  },
  // palette
  color: {
    themeKey: "palette",
    transform: paletteTransform
  },
  bgcolor: {
    themeKey: "palette",
    cssProperty: "backgroundColor",
    transform: paletteTransform
  },
  backgroundColor: {
    themeKey: "palette",
    transform: paletteTransform
  },
  // spacing
  p: {
    style: padding
  },
  pt: {
    style: padding
  },
  pr: {
    style: padding
  },
  pb: {
    style: padding
  },
  pl: {
    style: padding
  },
  px: {
    style: padding
  },
  py: {
    style: padding
  },
  padding: {
    style: padding
  },
  paddingTop: {
    style: padding
  },
  paddingRight: {
    style: padding
  },
  paddingBottom: {
    style: padding
  },
  paddingLeft: {
    style: padding
  },
  paddingX: {
    style: padding
  },
  paddingY: {
    style: padding
  },
  paddingInline: {
    style: padding
  },
  paddingInlineStart: {
    style: padding
  },
  paddingInlineEnd: {
    style: padding
  },
  paddingBlock: {
    style: padding
  },
  paddingBlockStart: {
    style: padding
  },
  paddingBlockEnd: {
    style: padding
  },
  m: {
    style: margin
  },
  mt: {
    style: margin
  },
  mr: {
    style: margin
  },
  mb: {
    style: margin
  },
  ml: {
    style: margin
  },
  mx: {
    style: margin
  },
  my: {
    style: margin
  },
  margin: {
    style: margin
  },
  marginTop: {
    style: margin
  },
  marginRight: {
    style: margin
  },
  marginBottom: {
    style: margin
  },
  marginLeft: {
    style: margin
  },
  marginX: {
    style: margin
  },
  marginY: {
    style: margin
  },
  marginInline: {
    style: margin
  },
  marginInlineStart: {
    style: margin
  },
  marginInlineEnd: {
    style: margin
  },
  marginBlock: {
    style: margin
  },
  marginBlockStart: {
    style: margin
  },
  marginBlockEnd: {
    style: margin
  },
  // display
  displayPrint: {
    cssProperty: !1,
    transform: (t) => ({
      "@media print": {
        display: t
      }
    })
  },
  display: {},
  overflow: {},
  textOverflow: {},
  visibility: {},
  whiteSpace: {},
  // flexbox
  flexBasis: {},
  flexDirection: {},
  flexWrap: {},
  justifyContent: {},
  alignItems: {},
  alignContent: {},
  order: {},
  flex: {},
  flexGrow: {},
  flexShrink: {},
  alignSelf: {},
  justifyItems: {},
  justifySelf: {},
  // grid
  gap: {
    style: gap
  },
  rowGap: {
    style: rowGap
  },
  columnGap: {
    style: columnGap
  },
  gridColumn: {},
  gridRow: {},
  gridAutoFlow: {},
  gridAutoColumns: {},
  gridAutoRows: {},
  gridTemplateColumns: {},
  gridTemplateRows: {},
  gridTemplateAreas: {},
  gridArea: {},
  // positions
  position: {},
  zIndex: {
    themeKey: "zIndex"
  },
  top: {},
  right: {},
  bottom: {},
  left: {},
  // shadows
  boxShadow: {
    themeKey: "shadows"
  },
  // sizing
  width: {
    transform: sizingTransform
  },
  maxWidth: {
    style: maxWidth
  },
  minWidth: {
    transform: sizingTransform
  },
  height: {
    transform: sizingTransform
  },
  maxHeight: {
    transform: sizingTransform
  },
  minHeight: {
    transform: sizingTransform
  },
  boxSizing: {},
  // typography
  fontFamily: {
    themeKey: "typography"
  },
  fontSize: {
    themeKey: "typography"
  },
  fontStyle: {
    themeKey: "typography"
  },
  fontWeight: {
    themeKey: "typography"
  },
  letterSpacing: {},
  textTransform: {},
  lineHeight: {},
  textAlign: {},
  typography: {
    cssProperty: !1,
    themeKey: "typography"
  }
};
function objectsHaveSameKeys(...t) {
  const e = t.reduce((o, l) => o.concat(Object.keys(l)), []), n = new Set(e);
  return t.every((o) => n.size === Object.keys(o).length);
}
function callIfFn(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function unstable_createStyleFunctionSx() {
  function t(n, o, l, u) {
    const f = {
      [n]: o,
      theme: l
    }, h = u[n];
    if (!h)
      return {
        [n]: o
      };
    const {
      cssProperty: p = n,
      themeKey: v,
      transform: g,
      style: w
    } = h;
    if (o == null)
      return null;
    if (v === "typography" && o === "inherit")
      return {
        [n]: o
      };
    const E = getPath$2(l, v) || {};
    return w ? w(f) : handleBreakpoints(f, o, (R) => {
      let _ = getStyleValue$1(E, g, R);
      return R === _ && typeof R == "string" && (_ = getStyleValue$1(E, g, `${n}${R === "default" ? "" : capitalize$1(R)}`, R)), p === !1 ? _ : {
        [p]: _
      };
    });
  }
  function e(n) {
    var o;
    const {
      sx: l,
      theme: u = {}
    } = n || {};
    if (!l)
      return null;
    const f = (o = u.unstable_sxConfig) != null ? o : defaultSxConfig;
    function h(p) {
      let v = p;
      if (typeof p == "function")
        v = p(u);
      else if (typeof p != "object")
        return p;
      if (!v)
        return null;
      const g = createEmptyBreakpointObject(u.breakpoints), w = Object.keys(g);
      let E = g;
      return Object.keys(v).forEach((T) => {
        const R = callIfFn(v[T], u);
        if (R != null)
          if (typeof R == "object")
            if (f[T])
              E = merge(E, t(T, R, u, f));
            else {
              const _ = handleBreakpoints({
                theme: u
              }, R, (b) => ({
                [T]: b
              }));
              objectsHaveSameKeys(_, R) ? E[T] = e({
                sx: R,
                theme: u
              }) : E = merge(E, _);
            }
          else
            E = merge(E, t(T, R, u, f));
      }), removeUnusedBreakpoints(w, E);
    }
    return Array.isArray(l) ? l.map(h) : h(l);
  }
  return e;
}
const styleFunctionSx$1 = unstable_createStyleFunctionSx();
styleFunctionSx$1.filterProps = ["sx"];
function applyStyles(t, e) {
  const n = this;
  return n.vars && typeof n.getColorSchemeSelector == "function" ? {
    [n.getColorSchemeSelector(t).replace(/(\[[^\]]+\])/, "*:where($1)")]: e
  } : n.palette.mode === t ? e : {};
}
const _excluded$x = ["breakpoints", "palette", "spacing", "shape"];
function createTheme$2(t = {}, ...e) {
  const {
    breakpoints: n = {},
    palette: o = {},
    spacing: l,
    shape: u = {}
  } = t, f = _objectWithoutPropertiesLoose$n(t, _excluded$x), h = createBreakpoints(n), p = createSpacing(l);
  let v = deepmerge$1({
    breakpoints: h,
    direction: "ltr",
    components: {},
    // Inject component definitions.
    palette: _extends$x({
      mode: "light"
    }, o),
    spacing: p,
    shape: _extends$x({}, shape, u)
  }, f);
  return v.applyStyles = applyStyles, v = e.reduce((g, w) => deepmerge$1(g, w), v), v.unstable_sxConfig = _extends$x({}, defaultSxConfig, f == null ? void 0 : f.unstable_sxConfig), v.unstable_sx = function(w) {
    return styleFunctionSx$1({
      sx: w,
      theme: this
    });
  }, v;
}
const createTheme$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: createTheme$2,
  private_createBreakpoints: createBreakpoints,
  unstable_applyStyles: applyStyles
}, Symbol.toStringTag, { value: "Module" }));
function isObjectEmpty(t) {
  return Object.keys(t).length === 0;
}
function useTheme$3(t = null) {
  const e = React.useContext(ThemeContext$1);
  return !e || isObjectEmpty(e) ? t : e;
}
const systemDefaultTheme$1 = createTheme$2();
function useTheme$2(t = systemDefaultTheme$1) {
  return useTheme$3(t);
}
function GlobalStyles$1({
  styles: t,
  themeId: e,
  defaultTheme: n = {}
}) {
  const o = useTheme$2(n), l = typeof t == "function" ? t(e && o[e] || o) : t;
  return /* @__PURE__ */ jsxRuntimeExports$1.jsx(GlobalStyles$2, {
    styles: l
  });
}
process.env.NODE_ENV !== "production" && (GlobalStyles$1.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │ To update them, edit the TypeScript types and run `pnpm proptypes`. │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * @ignore
   */
  defaultTheme: PropTypes.object,
  /**
   * @ignore
   */
  styles: PropTypes.oneOfType([PropTypes.array, PropTypes.func, PropTypes.number, PropTypes.object, PropTypes.string, PropTypes.bool]),
  /**
   * @ignore
   */
  themeId: PropTypes.string
});
const _excluded$w = ["sx"], splitProps = (t) => {
  var e, n;
  const o = {
    systemProps: {},
    otherProps: {}
  }, l = (e = t == null || (n = t.theme) == null ? void 0 : n.unstable_sxConfig) != null ? e : defaultSxConfig;
  return Object.keys(t).forEach((u) => {
    l[u] ? o.systemProps[u] = t[u] : o.otherProps[u] = t[u];
  }), o;
};
function extendSxProp(t) {
  const {
    sx: e
  } = t, n = _objectWithoutPropertiesLoose$n(t, _excluded$w), {
    systemProps: o,
    otherProps: l
  } = splitProps(n);
  let u;
  return Array.isArray(e) ? u = [o, ...e] : typeof e == "function" ? u = (...f) => {
    const h = e(...f);
    return isPlainObject$3(h) ? _extends$x({}, o, h) : o;
  } : u = _extends$x({}, o, e), _extends$x({}, l, {
    sx: u
  });
}
const styleFunctionSx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: styleFunctionSx$1,
  extendSxProp,
  unstable_createStyleFunctionSx,
  unstable_defaultSxConfig: defaultSxConfig
}, Symbol.toStringTag, { value: "Module" })), defaultGenerator = (t) => t, createClassNameGenerator = () => {
  let t = defaultGenerator;
  return {
    configure(e) {
      t = e;
    },
    generate(e) {
      return t(e);
    },
    reset() {
      t = defaultGenerator;
    }
  };
}, ClassNameGenerator = createClassNameGenerator();
function r$1(t) {
  var e, n, o = "";
  if (typeof t == "string" || typeof t == "number") o += t;
  else if (typeof t == "object") if (Array.isArray(t)) {
    var l = t.length;
    for (e = 0; e < l; e++) t[e] && (n = r$1(t[e])) && (o && (o += " "), o += n);
  } else for (n in t) t[n] && (o && (o += " "), o += n);
  return o;
}
function clsx$1() {
  for (var t, e, n = 0, o = "", l = arguments.length; n < l; n++) (t = arguments[n]) && (e = r$1(t)) && (o && (o += " "), o += e);
  return o;
}
const _excluded$v = ["className", "component"];
function createBox(t = {}) {
  const {
    themeId: e,
    defaultTheme: n,
    defaultClassName: o = "MuiBox-root",
    generateClassName: l
  } = t, u = styled$1("div", {
    shouldForwardProp: (h) => h !== "theme" && h !== "sx" && h !== "as"
  })(styleFunctionSx$1);
  return /* @__PURE__ */ React.forwardRef(function(p, v) {
    const g = useTheme$2(n), w = extendSxProp(p), {
      className: E,
      component: T = "div"
    } = w, R = _objectWithoutPropertiesLoose$n(w, _excluded$v);
    return /* @__PURE__ */ jsxRuntimeExports$1.jsx(u, _extends$x({
      as: T,
      ref: v,
      className: clsx$1(E, l ? l(o) : o),
      theme: e && g[e] || g
    }, R));
  });
}
const globalStateClasses = {
  active: "active",
  checked: "checked",
  completed: "completed",
  disabled: "disabled",
  error: "error",
  expanded: "expanded",
  focused: "focused",
  focusVisible: "focusVisible",
  open: "open",
  readOnly: "readOnly",
  required: "required",
  selected: "selected"
};
function generateUtilityClass(t, e, n = "Mui") {
  const o = globalStateClasses[e];
  return o ? `${n}-${o}` : `${ClassNameGenerator.generate(t)}-${e}`;
}
function generateUtilityClasses(t, e, n = "Mui") {
  const o = {};
  return e.forEach((l) => {
    o[l] = generateUtilityClass(t, l, n);
  }), o;
}
var reactIs$1 = { exports: {} }, reactIs_production_min$1 = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_production_min$1;
function requireReactIs_production_min$1() {
  if (hasRequiredReactIs_production_min$1) return reactIs_production_min$1;
  hasRequiredReactIs_production_min$1 = 1;
  var t = Symbol.for("react.element"), e = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), l = Symbol.for("react.profiler"), u = Symbol.for("react.provider"), f = Symbol.for("react.context"), h = Symbol.for("react.server_context"), p = Symbol.for("react.forward_ref"), v = Symbol.for("react.suspense"), g = Symbol.for("react.suspense_list"), w = Symbol.for("react.memo"), E = Symbol.for("react.lazy"), T = Symbol.for("react.offscreen"), R;
  R = Symbol.for("react.module.reference");
  function _(b) {
    if (typeof b == "object" && b !== null) {
      var M = b.$$typeof;
      switch (M) {
        case t:
          switch (b = b.type, b) {
            case n:
            case l:
            case o:
            case v:
            case g:
              return b;
            default:
              switch (b = b && b.$$typeof, b) {
                case h:
                case f:
                case p:
                case E:
                case w:
                case u:
                  return b;
                default:
                  return M;
              }
          }
        case e:
          return M;
      }
    }
  }
  return reactIs_production_min$1.ContextConsumer = f, reactIs_production_min$1.ContextProvider = u, reactIs_production_min$1.Element = t, reactIs_production_min$1.ForwardRef = p, reactIs_production_min$1.Fragment = n, reactIs_production_min$1.Lazy = E, reactIs_production_min$1.Memo = w, reactIs_production_min$1.Portal = e, reactIs_production_min$1.Profiler = l, reactIs_production_min$1.StrictMode = o, reactIs_production_min$1.Suspense = v, reactIs_production_min$1.SuspenseList = g, reactIs_production_min$1.isAsyncMode = function() {
    return !1;
  }, reactIs_production_min$1.isConcurrentMode = function() {
    return !1;
  }, reactIs_production_min$1.isContextConsumer = function(b) {
    return _(b) === f;
  }, reactIs_production_min$1.isContextProvider = function(b) {
    return _(b) === u;
  }, reactIs_production_min$1.isElement = function(b) {
    return typeof b == "object" && b !== null && b.$$typeof === t;
  }, reactIs_production_min$1.isForwardRef = function(b) {
    return _(b) === p;
  }, reactIs_production_min$1.isFragment = function(b) {
    return _(b) === n;
  }, reactIs_production_min$1.isLazy = function(b) {
    return _(b) === E;
  }, reactIs_production_min$1.isMemo = function(b) {
    return _(b) === w;
  }, reactIs_production_min$1.isPortal = function(b) {
    return _(b) === e;
  }, reactIs_production_min$1.isProfiler = function(b) {
    return _(b) === l;
  }, reactIs_production_min$1.isStrictMode = function(b) {
    return _(b) === o;
  }, reactIs_production_min$1.isSuspense = function(b) {
    return _(b) === v;
  }, reactIs_production_min$1.isSuspenseList = function(b) {
    return _(b) === g;
  }, reactIs_production_min$1.isValidElementType = function(b) {
    return typeof b == "string" || typeof b == "function" || b === n || b === l || b === o || b === v || b === g || b === T || typeof b == "object" && b !== null && (b.$$typeof === E || b.$$typeof === w || b.$$typeof === u || b.$$typeof === f || b.$$typeof === p || b.$$typeof === R || b.getModuleId !== void 0);
  }, reactIs_production_min$1.typeOf = _, reactIs_production_min$1;
}
var reactIs_development$1 = {};
/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_development$1;
function requireReactIs_development$1() {
  return hasRequiredReactIs_development$1 || (hasRequiredReactIs_development$1 = 1, process.env.NODE_ENV !== "production" && function() {
    var t = Symbol.for("react.element"), e = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), l = Symbol.for("react.profiler"), u = Symbol.for("react.provider"), f = Symbol.for("react.context"), h = Symbol.for("react.server_context"), p = Symbol.for("react.forward_ref"), v = Symbol.for("react.suspense"), g = Symbol.for("react.suspense_list"), w = Symbol.for("react.memo"), E = Symbol.for("react.lazy"), T = Symbol.for("react.offscreen"), R = !1, _ = !1, b = !1, M = !1, A = !1, $;
    $ = Symbol.for("react.module.reference");
    function S(be) {
      return !!(typeof be == "string" || typeof be == "function" || be === n || be === l || A || be === o || be === v || be === g || M || be === T || R || _ || b || typeof be == "object" && be !== null && (be.$$typeof === E || be.$$typeof === w || be.$$typeof === u || be.$$typeof === f || be.$$typeof === p || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      be.$$typeof === $ || be.getModuleId !== void 0));
    }
    function C(be) {
      if (typeof be == "object" && be !== null) {
        var Fe = be.$$typeof;
        switch (Fe) {
          case t:
            var et = be.type;
            switch (et) {
              case n:
              case l:
              case o:
              case v:
              case g:
                return et;
              default:
                var Ye = et && et.$$typeof;
                switch (Ye) {
                  case h:
                  case f:
                  case p:
                  case E:
                  case w:
                  case u:
                    return Ye;
                  default:
                    return Fe;
                }
            }
          case e:
            return Fe;
        }
      }
    }
    var D = f, O = u, N = t, j = p, L = n, z = E, G = w, B = e, F = l, H = o, W = v, V = g, X = !1, Z = !1;
    function Q(be) {
      return X || (X = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function q(be) {
      return Z || (Z = !0, console.warn("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function J(be) {
      return C(be) === f;
    }
    function ie(be) {
      return C(be) === u;
    }
    function ne(be) {
      return typeof be == "object" && be !== null && be.$$typeof === t;
    }
    function ge(be) {
      return C(be) === p;
    }
    function ye(be) {
      return C(be) === n;
    }
    function xe(be) {
      return C(be) === E;
    }
    function we(be) {
      return C(be) === w;
    }
    function de(be) {
      return C(be) === e;
    }
    function Te(be) {
      return C(be) === l;
    }
    function Ce(be) {
      return C(be) === o;
    }
    function ee(be) {
      return C(be) === v;
    }
    function Ae(be) {
      return C(be) === g;
    }
    reactIs_development$1.ContextConsumer = D, reactIs_development$1.ContextProvider = O, reactIs_development$1.Element = N, reactIs_development$1.ForwardRef = j, reactIs_development$1.Fragment = L, reactIs_development$1.Lazy = z, reactIs_development$1.Memo = G, reactIs_development$1.Portal = B, reactIs_development$1.Profiler = F, reactIs_development$1.StrictMode = H, reactIs_development$1.Suspense = W, reactIs_development$1.SuspenseList = V, reactIs_development$1.isAsyncMode = Q, reactIs_development$1.isConcurrentMode = q, reactIs_development$1.isContextConsumer = J, reactIs_development$1.isContextProvider = ie, reactIs_development$1.isElement = ne, reactIs_development$1.isForwardRef = ge, reactIs_development$1.isFragment = ye, reactIs_development$1.isLazy = xe, reactIs_development$1.isMemo = we, reactIs_development$1.isPortal = de, reactIs_development$1.isProfiler = Te, reactIs_development$1.isStrictMode = Ce, reactIs_development$1.isSuspense = ee, reactIs_development$1.isSuspenseList = Ae, reactIs_development$1.isValidElementType = S, reactIs_development$1.typeOf = C;
  }()), reactIs_development$1;
}
process.env.NODE_ENV === "production" ? reactIs$1.exports = requireReactIs_production_min$1() : reactIs$1.exports = requireReactIs_development$1();
var reactIsExports$1 = reactIs$1.exports;
const fnNameMatchRegex = /^\s*function(?:\s|\s*\/\*.*\*\/\s*)+([^(\s/]*)\s*/;
function getFunctionName(t) {
  const e = `${t}`.match(fnNameMatchRegex);
  return e && e[1] || "";
}
function getFunctionComponentName(t, e = "") {
  return t.displayName || t.name || getFunctionName(t) || e;
}
function getWrappedName(t, e, n) {
  const o = getFunctionComponentName(e);
  return t.displayName || (o !== "" ? `${n}(${o})` : n);
}
function getDisplayName$2(t) {
  if (t != null) {
    if (typeof t == "string")
      return t;
    if (typeof t == "function")
      return getFunctionComponentName(t, "Component");
    if (typeof t == "object")
      switch (t.$$typeof) {
        case reactIsExports$1.ForwardRef:
          return getWrappedName(t, t.render, "ForwardRef");
        case reactIsExports$1.Memo:
          return getWrappedName(t, t.type, "memo");
        default:
          return;
      }
  }
}
const getDisplayName$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: getDisplayName$2,
  getFunctionName
}, Symbol.toStringTag, { value: "Module" }));
function resolveProps(t, e) {
  const n = _extends$x({}, e);
  return Object.keys(t).forEach((o) => {
    if (o.toString().match(/^(components|slots)$/))
      n[o] = _extends$x({}, t[o], n[o]);
    else if (o.toString().match(/^(componentsProps|slotProps)$/)) {
      const l = t[o] || {}, u = e[o];
      n[o] = {}, !u || !Object.keys(u) ? n[o] = l : !l || !Object.keys(l) ? n[o] = u : (n[o] = _extends$x({}, u), Object.keys(l).forEach((f) => {
        n[o][f] = resolveProps(l[f], u[f]);
      }));
    } else n[o] === void 0 && (n[o] = t[o]);
  }), n;
}
const useEnhancedEffect = typeof window < "u" ? React.useLayoutEffect : React.useEffect;
function clamp$3(t, e = Number.MIN_SAFE_INTEGER, n = Number.MAX_SAFE_INTEGER) {
  return Math.max(e, Math.min(t, n));
}
const clamp$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: clamp$3
}, Symbol.toStringTag, { value: "Module" }));
function chainPropTypes(t, e) {
  return process.env.NODE_ENV === "production" ? () => null : function(...o) {
    return t(...o) || e(...o);
  };
}
function isClassComponent$1(t) {
  const {
    prototype: e = {}
  } = t;
  return !!e.isReactComponent;
}
function elementTypeAcceptingRef(t, e, n, o, l) {
  const u = t[e], f = l || e;
  if (u == null || // When server-side rendering React doesn't warn either.
  // This is not an accurate check for SSR.
  // This is only in place for emotion compat.
  // TODO: Revisit once https://github.com/facebook/react/issues/20047 is resolved.
  typeof window > "u")
    return null;
  let h;
  return typeof u == "function" && !isClassComponent$1(u) && (h = "Did you accidentally provide a plain function component instead?"), h !== void 0 ? new Error(`Invalid ${o} \`${f}\` supplied to \`${n}\`. Expected an element type that can hold a ref. ${h} For more information see https://mui.com/r/caveat-with-refs-guide`) : null;
}
const elementTypeAcceptingRef$1 = chainPropTypes(PropTypes.elementType, elementTypeAcceptingRef), specialProperty = "exact-prop: ​";
function exactProp(t) {
  return process.env.NODE_ENV === "production" ? t : _extends$x({}, t, {
    [specialProperty]: (e) => {
      const n = Object.keys(e).filter((o) => !t.hasOwnProperty(o));
      return n.length > 0 ? new Error(`The following props are not supported: ${n.map((o) => `\`${o}\``).join(", ")}. Please remove them.`) : null;
    }
  });
}
const refType = PropTypes.oneOfType([PropTypes.func, PropTypes.object]);
function debounce$2(t, e = 166) {
  let n;
  function o(...l) {
    const u = () => {
      t.apply(this, l);
    };
    clearTimeout(n), n = setTimeout(u, e);
  }
  return o.clear = () => {
    clearTimeout(n);
  }, o;
}
function ownerDocument(t) {
  return t && t.ownerDocument || document;
}
function ownerWindow(t) {
  return ownerDocument(t).defaultView || window;
}
function setRef(t, e) {
  typeof t == "function" ? t(e) : t && (t.current = e);
}
function useForkRef(...t) {
  return React.useMemo(() => t.every((e) => e == null) ? null : (e) => {
    t.forEach((n) => {
      setRef(n, e);
    });
  }, t);
}
function getTypeByValue(t) {
  const e = typeof t;
  switch (e) {
    case "number":
      return Number.isNaN(t) ? "NaN" : Number.isFinite(t) ? t !== Math.floor(t) ? "float" : "number" : "Infinity";
    case "object":
      return t === null ? "null" : t.constructor.name;
    default:
      return e;
  }
}
function ponyfillIsInteger(t) {
  return typeof t == "number" && isFinite(t) && Math.floor(t) === t;
}
const isInteger = Number.isInteger || ponyfillIsInteger;
function requiredInteger(t, e, n, o) {
  const l = t[e];
  if (l == null || !isInteger(l)) {
    const u = getTypeByValue(l);
    return new RangeError(`Invalid ${o} \`${e}\` of type \`${u}\` supplied to \`${n}\`, expected \`integer\`.`);
  }
  return null;
}
function validator(t, e, ...n) {
  return t[e] === void 0 ? null : requiredInteger(t, e, ...n);
}
function validatorNoop() {
  return null;
}
validator.isRequired = requiredInteger;
validatorNoop.isRequired = validatorNoop;
const integerPropType = process.env.NODE_ENV === "production" ? validatorNoop : validator;
function composeClasses(t, e, n = void 0) {
  const o = {};
  return Object.keys(t).forEach(
    // `Object.keys(slots)` can't be wider than `T` because we infer `T` from `slots`.
    // @ts-expect-error https://github.com/microsoft/TypeScript/pull/12253#issuecomment-263132208
    (l) => {
      o[l] = t[l].reduce((u, f) => {
        if (f) {
          const h = e(f);
          h !== "" && u.push(h), n && n[f] && u.push(n[f]);
        }
        return u;
      }, []).join(" ");
    }
  ), o;
}
function isHostComponent(t) {
  return typeof t == "string";
}
const ThemeContext = /* @__PURE__ */ React.createContext(null);
process.env.NODE_ENV !== "production" && (ThemeContext.displayName = "ThemeContext");
function useTheme$1() {
  const t = React.useContext(ThemeContext);
  return process.env.NODE_ENV !== "production" && React.useDebugValue(t), t;
}
const hasSymbol = typeof Symbol == "function" && Symbol.for, nested = hasSymbol ? Symbol.for("mui.nested") : "__THEME_NESTED__";
function mergeOuterLocalTheme(t, e) {
  if (typeof e == "function") {
    const n = e(t);
    return process.env.NODE_ENV !== "production" && (n || console.error(["MUI: You should return an object from your theme function, i.e.", "<ThemeProvider theme={() => ({})} />"].join(`
`))), n;
  }
  return _extends$x({}, t, e);
}
function ThemeProvider$2(t) {
  const {
    children: e,
    theme: n
  } = t, o = useTheme$1();
  process.env.NODE_ENV !== "production" && o === null && typeof n == "function" && console.error(["MUI: You are providing a theme function prop to the ThemeProvider component:", "<ThemeProvider theme={outerTheme => outerTheme} />", "", "However, no outer theme is present.", "Make sure a theme is already injected higher in the React tree or provide a theme object."].join(`
`));
  const l = React.useMemo(() => {
    const u = o === null ? n : mergeOuterLocalTheme(o, n);
    return u != null && (u[nested] = o !== null), u;
  }, [n, o]);
  return /* @__PURE__ */ jsxRuntimeExports$1.jsx(ThemeContext.Provider, {
    value: l,
    children: e
  });
}
process.env.NODE_ENV !== "production" && (ThemeProvider$2.propTypes = {
  /**
   * Your component tree.
   */
  children: PropTypes.node,
  /**
   * A theme object. You can provide a function to extend the outer theme.
   */
  theme: PropTypes.oneOfType([PropTypes.object, PropTypes.func]).isRequired
});
process.env.NODE_ENV !== "production" && process.env.NODE_ENV !== "production" && (ThemeProvider$2.propTypes = exactProp(ThemeProvider$2.propTypes));
const _excluded$u = ["value"], RtlContext = /* @__PURE__ */ React.createContext();
function RtlProvider(t) {
  let {
    value: e
  } = t, n = _objectWithoutPropertiesLoose$n(t, _excluded$u);
  return /* @__PURE__ */ jsxRuntimeExports$1.jsx(RtlContext.Provider, _extends$x({
    value: e ?? !0
  }, n));
}
process.env.NODE_ENV !== "production" && (RtlProvider.propTypes = {
  children: PropTypes.node,
  value: PropTypes.bool
});
const PropsContext = /* @__PURE__ */ React.createContext(void 0);
function DefaultPropsProvider({
  value: t,
  children: e
}) {
  return /* @__PURE__ */ jsxRuntimeExports$1.jsx(PropsContext.Provider, {
    value: t,
    children: e
  });
}
process.env.NODE_ENV !== "production" && (DefaultPropsProvider.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │ To update them, edit the TypeScript types and run `pnpm proptypes`. │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * @ignore
   */
  children: PropTypes.node,
  /**
   * @ignore
   */
  value: PropTypes.object
});
function getThemeProps(t) {
  const {
    theme: e,
    name: n,
    props: o
  } = t;
  if (!e || !e.components || !e.components[n])
    return o;
  const l = e.components[n];
  return l.defaultProps ? resolveProps(l.defaultProps, o) : !l.styleOverrides && !l.variants ? resolveProps(l, o) : o;
}
function useDefaultProps$1({
  props: t,
  name: e
}) {
  const n = React.useContext(PropsContext);
  return getThemeProps({
    props: t,
    name: e,
    theme: {
      components: n
    }
  });
}
const EMPTY_THEME = {};
function useThemeScoping(t, e, n, o = !1) {
  return React.useMemo(() => {
    const l = t && e[t] || e;
    if (typeof n == "function") {
      const u = n(l), f = t ? _extends$x({}, e, {
        [t]: u
      }) : u;
      return o ? () => f : f;
    }
    return t ? _extends$x({}, e, {
      [t]: n
    }) : _extends$x({}, e, n);
  }, [t, e, n, o]);
}
function ThemeProvider$1(t) {
  const {
    children: e,
    theme: n,
    themeId: o
  } = t, l = useTheme$3(EMPTY_THEME), u = useTheme$1() || EMPTY_THEME;
  process.env.NODE_ENV !== "production" && (l === null && typeof n == "function" || o && l && !l[o] && typeof n == "function") && console.error(["MUI: You are providing a theme function prop to the ThemeProvider component:", "<ThemeProvider theme={outerTheme => outerTheme} />", "", "However, no outer theme is present.", "Make sure a theme is already injected higher in the React tree or provide a theme object."].join(`
`));
  const f = useThemeScoping(o, l, n), h = useThemeScoping(o, u, n, !0), p = f.direction === "rtl";
  return /* @__PURE__ */ jsxRuntimeExports$1.jsx(ThemeProvider$2, {
    theme: h,
    children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(ThemeContext$1.Provider, {
      value: f,
      children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(RtlProvider, {
        value: p,
        children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(DefaultPropsProvider, {
          value: f == null ? void 0 : f.components,
          children: e
        })
      })
    })
  });
}
process.env.NODE_ENV !== "production" && (ThemeProvider$1.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * Your component tree.
   */
  children: PropTypes.node,
  /**
   * A theme object. You can provide a function to extend the outer theme.
   */
  theme: PropTypes.oneOfType([PropTypes.func, PropTypes.object]).isRequired,
  /**
   * The design system's unique id for getting the corresponded theme when there are multiple design systems.
   */
  themeId: PropTypes.string
});
process.env.NODE_ENV !== "production" && process.env.NODE_ENV !== "production" && (ThemeProvider$1.propTypes = exactProp(ThemeProvider$1.propTypes));
function createMixins(t, e) {
  return _extends$x({
    toolbar: {
      minHeight: 56,
      [t.up("xs")]: {
        "@media (orientation: landscape)": {
          minHeight: 48
        }
      },
      [t.up("sm")]: {
        minHeight: 64
      }
    }
  }, e);
}
var colorManipulator = {}, interopRequireDefault = { exports: {} };
(function(t) {
  function e(n) {
    return n && n.__esModule ? n : {
      default: n
    };
  }
  t.exports = e, t.exports.__esModule = !0, t.exports.default = t.exports;
})(interopRequireDefault);
var interopRequireDefaultExports = interopRequireDefault.exports;
const require$$1$2 = /* @__PURE__ */ getAugmentedNamespace(formatMuiErrorMessage), require$$2 = /* @__PURE__ */ getAugmentedNamespace(clamp$2);
var _interopRequireDefault$1 = interopRequireDefaultExports;
Object.defineProperty(colorManipulator, "__esModule", {
  value: !0
});
var alpha_1 = colorManipulator.alpha = alpha$1;
colorManipulator.blend = blend;
colorManipulator.colorChannel = void 0;
var darken_1 = colorManipulator.darken = darken;
colorManipulator.decomposeColor = decomposeColor;
colorManipulator.emphasize = emphasize;
var getContrastRatio_1 = colorManipulator.getContrastRatio = getContrastRatio;
colorManipulator.getLuminance = getLuminance;
colorManipulator.hexToRgb = hexToRgb;
colorManipulator.hslToRgb = hslToRgb;
var lighten_1 = colorManipulator.lighten = lighten;
colorManipulator.private_safeAlpha = private_safeAlpha;
colorManipulator.private_safeColorChannel = void 0;
colorManipulator.private_safeDarken = private_safeDarken;
colorManipulator.private_safeEmphasize = private_safeEmphasize;
colorManipulator.private_safeLighten = private_safeLighten;
colorManipulator.recomposeColor = recomposeColor;
colorManipulator.rgbToHex = rgbToHex;
var _formatMuiErrorMessage2 = _interopRequireDefault$1(require$$1$2), _clamp = _interopRequireDefault$1(require$$2);
function clampWrapper(t, e = 0, n = 1) {
  return process.env.NODE_ENV !== "production" && (t < e || t > n) && console.error(`MUI: The value provided ${t} is out of range [${e}, ${n}].`), (0, _clamp.default)(t, e, n);
}
function hexToRgb(t) {
  t = t.slice(1);
  const e = new RegExp(`.{1,${t.length >= 6 ? 2 : 1}}`, "g");
  let n = t.match(e);
  return n && n[0].length === 1 && (n = n.map((o) => o + o)), n ? `rgb${n.length === 4 ? "a" : ""}(${n.map((o, l) => l < 3 ? parseInt(o, 16) : Math.round(parseInt(o, 16) / 255 * 1e3) / 1e3).join(", ")})` : "";
}
function intToHex(t) {
  const e = t.toString(16);
  return e.length === 1 ? `0${e}` : e;
}
function decomposeColor(t) {
  if (t.type)
    return t;
  if (t.charAt(0) === "#")
    return decomposeColor(hexToRgb(t));
  const e = t.indexOf("("), n = t.substring(0, e);
  if (["rgb", "rgba", "hsl", "hsla", "color"].indexOf(n) === -1)
    throw new Error(process.env.NODE_ENV !== "production" ? `MUI: Unsupported \`${t}\` color.
The following formats are supported: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().` : (0, _formatMuiErrorMessage2.default)(9, t));
  let o = t.substring(e + 1, t.length - 1), l;
  if (n === "color") {
    if (o = o.split(" "), l = o.shift(), o.length === 4 && o[3].charAt(0) === "/" && (o[3] = o[3].slice(1)), ["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(l) === -1)
      throw new Error(process.env.NODE_ENV !== "production" ? `MUI: unsupported \`${l}\` color space.
The following color spaces are supported: srgb, display-p3, a98-rgb, prophoto-rgb, rec-2020.` : (0, _formatMuiErrorMessage2.default)(10, l));
  } else
    o = o.split(",");
  return o = o.map((u) => parseFloat(u)), {
    type: n,
    values: o,
    colorSpace: l
  };
}
const colorChannel = (t) => {
  const e = decomposeColor(t);
  return e.values.slice(0, 3).map((n, o) => e.type.indexOf("hsl") !== -1 && o !== 0 ? `${n}%` : n).join(" ");
};
colorManipulator.colorChannel = colorChannel;
const private_safeColorChannel = (t, e) => {
  try {
    return colorChannel(t);
  } catch {
    return e && process.env.NODE_ENV !== "production" && console.warn(e), t;
  }
};
colorManipulator.private_safeColorChannel = private_safeColorChannel;
function recomposeColor(t) {
  const {
    type: e,
    colorSpace: n
  } = t;
  let {
    values: o
  } = t;
  return e.indexOf("rgb") !== -1 ? o = o.map((l, u) => u < 3 ? parseInt(l, 10) : l) : e.indexOf("hsl") !== -1 && (o[1] = `${o[1]}%`, o[2] = `${o[2]}%`), e.indexOf("color") !== -1 ? o = `${n} ${o.join(" ")}` : o = `${o.join(", ")}`, `${e}(${o})`;
}
function rgbToHex(t) {
  if (t.indexOf("#") === 0)
    return t;
  const {
    values: e
  } = decomposeColor(t);
  return `#${e.map((n, o) => intToHex(o === 3 ? Math.round(255 * n) : n)).join("")}`;
}
function hslToRgb(t) {
  t = decomposeColor(t);
  const {
    values: e
  } = t, n = e[0], o = e[1] / 100, l = e[2] / 100, u = o * Math.min(l, 1 - l), f = (v, g = (v + n / 30) % 12) => l - u * Math.max(Math.min(g - 3, 9 - g, 1), -1);
  let h = "rgb";
  const p = [Math.round(f(0) * 255), Math.round(f(8) * 255), Math.round(f(4) * 255)];
  return t.type === "hsla" && (h += "a", p.push(e[3])), recomposeColor({
    type: h,
    values: p
  });
}
function getLuminance(t) {
  t = decomposeColor(t);
  let e = t.type === "hsl" || t.type === "hsla" ? decomposeColor(hslToRgb(t)).values : t.values;
  return e = e.map((n) => (t.type !== "color" && (n /= 255), n <= 0.03928 ? n / 12.92 : ((n + 0.055) / 1.055) ** 2.4)), Number((0.2126 * e[0] + 0.7152 * e[1] + 0.0722 * e[2]).toFixed(3));
}
function getContrastRatio(t, e) {
  const n = getLuminance(t), o = getLuminance(e);
  return (Math.max(n, o) + 0.05) / (Math.min(n, o) + 0.05);
}
function alpha$1(t, e) {
  return t = decomposeColor(t), e = clampWrapper(e), (t.type === "rgb" || t.type === "hsl") && (t.type += "a"), t.type === "color" ? t.values[3] = `/${e}` : t.values[3] = e, recomposeColor(t);
}
function private_safeAlpha(t, e, n) {
  try {
    return alpha$1(t, e);
  } catch {
    return n && process.env.NODE_ENV !== "production" && console.warn(n), t;
  }
}
function darken(t, e) {
  if (t = decomposeColor(t), e = clampWrapper(e), t.type.indexOf("hsl") !== -1)
    t.values[2] *= 1 - e;
  else if (t.type.indexOf("rgb") !== -1 || t.type.indexOf("color") !== -1)
    for (let n = 0; n < 3; n += 1)
      t.values[n] *= 1 - e;
  return recomposeColor(t);
}
function private_safeDarken(t, e, n) {
  try {
    return darken(t, e);
  } catch {
    return n && process.env.NODE_ENV !== "production" && console.warn(n), t;
  }
}
function lighten(t, e) {
  if (t = decomposeColor(t), e = clampWrapper(e), t.type.indexOf("hsl") !== -1)
    t.values[2] += (100 - t.values[2]) * e;
  else if (t.type.indexOf("rgb") !== -1)
    for (let n = 0; n < 3; n += 1)
      t.values[n] += (255 - t.values[n]) * e;
  else if (t.type.indexOf("color") !== -1)
    for (let n = 0; n < 3; n += 1)
      t.values[n] += (1 - t.values[n]) * e;
  return recomposeColor(t);
}
function private_safeLighten(t, e, n) {
  try {
    return lighten(t, e);
  } catch {
    return n && process.env.NODE_ENV !== "production" && console.warn(n), t;
  }
}
function emphasize(t, e = 0.15) {
  return getLuminance(t) > 0.5 ? darken(t, e) : lighten(t, e);
}
function private_safeEmphasize(t, e, n) {
  try {
    return emphasize(t, e);
  } catch {
    return n && process.env.NODE_ENV !== "production" && console.warn(n), t;
  }
}
function blend(t, e, n, o = 1) {
  const l = (p, v) => Math.round((p ** (1 / o) * (1 - n) + v ** (1 / o) * n) ** o), u = decomposeColor(t), f = decomposeColor(e), h = [l(u.values[0], f.values[0]), l(u.values[1], f.values[1]), l(u.values[2], f.values[2])];
  return recomposeColor({
    type: "rgb",
    values: h
  });
}
const _excluded$t = ["mode", "contrastThreshold", "tonalOffset"], light = {
  // The colors used to style the text.
  text: {
    // The most important text.
    primary: "rgba(0, 0, 0, 0.87)",
    // Secondary text.
    secondary: "rgba(0, 0, 0, 0.6)",
    // Disabled text have even lower visual prominence.
    disabled: "rgba(0, 0, 0, 0.38)"
  },
  // The color used to divide different elements.
  divider: "rgba(0, 0, 0, 0.12)",
  // The background colors used to style the surfaces.
  // Consistency between these values is important.
  background: {
    paper: common.white,
    default: common.white
  },
  // The colors used to style the action elements.
  action: {
    // The color of an active action like an icon button.
    active: "rgba(0, 0, 0, 0.54)",
    // The color of an hovered action.
    hover: "rgba(0, 0, 0, 0.04)",
    hoverOpacity: 0.04,
    // The color of a selected action.
    selected: "rgba(0, 0, 0, 0.08)",
    selectedOpacity: 0.08,
    // The color of a disabled action.
    disabled: "rgba(0, 0, 0, 0.26)",
    // The background color of a disabled action.
    disabledBackground: "rgba(0, 0, 0, 0.12)",
    disabledOpacity: 0.38,
    focus: "rgba(0, 0, 0, 0.12)",
    focusOpacity: 0.12,
    activatedOpacity: 0.12
  }
}, dark = {
  text: {
    primary: common.white,
    secondary: "rgba(255, 255, 255, 0.7)",
    disabled: "rgba(255, 255, 255, 0.5)",
    icon: "rgba(255, 255, 255, 0.5)"
  },
  divider: "rgba(255, 255, 255, 0.12)",
  background: {
    paper: "#121212",
    default: "#121212"
  },
  action: {
    active: common.white,
    hover: "rgba(255, 255, 255, 0.08)",
    hoverOpacity: 0.08,
    selected: "rgba(255, 255, 255, 0.16)",
    selectedOpacity: 0.16,
    disabled: "rgba(255, 255, 255, 0.3)",
    disabledBackground: "rgba(255, 255, 255, 0.12)",
    disabledOpacity: 0.38,
    focus: "rgba(255, 255, 255, 0.12)",
    focusOpacity: 0.12,
    activatedOpacity: 0.24
  }
};
function addLightOrDark(t, e, n, o) {
  const l = o.light || o, u = o.dark || o * 1.5;
  t[e] || (t.hasOwnProperty(n) ? t[e] = t[n] : e === "light" ? t.light = lighten_1(t.main, l) : e === "dark" && (t.dark = darken_1(t.main, u)));
}
function getDefaultPrimary(t = "light") {
  return t === "dark" ? {
    main: blue[200],
    light: blue[50],
    dark: blue[400]
  } : {
    main: blue[700],
    light: blue[400],
    dark: blue[800]
  };
}
function getDefaultSecondary(t = "light") {
  return t === "dark" ? {
    main: purple[200],
    light: purple[50],
    dark: purple[400]
  } : {
    main: purple[500],
    light: purple[300],
    dark: purple[700]
  };
}
function getDefaultError(t = "light") {
  return t === "dark" ? {
    main: red[500],
    light: red[300],
    dark: red[700]
  } : {
    main: red[700],
    light: red[400],
    dark: red[800]
  };
}
function getDefaultInfo(t = "light") {
  return t === "dark" ? {
    main: lightBlue[400],
    light: lightBlue[300],
    dark: lightBlue[700]
  } : {
    main: lightBlue[700],
    light: lightBlue[500],
    dark: lightBlue[900]
  };
}
function getDefaultSuccess(t = "light") {
  return t === "dark" ? {
    main: green[400],
    light: green[300],
    dark: green[700]
  } : {
    main: green[800],
    light: green[500],
    dark: green[900]
  };
}
function getDefaultWarning(t = "light") {
  return t === "dark" ? {
    main: orange[400],
    light: orange[300],
    dark: orange[700]
  } : {
    main: "#ed6c02",
    // closest to orange[800] that pass 3:1.
    light: orange[500],
    dark: orange[900]
  };
}
function createPalette(t) {
  const {
    mode: e = "light",
    contrastThreshold: n = 3,
    tonalOffset: o = 0.2
  } = t, l = _objectWithoutPropertiesLoose$n(t, _excluded$t), u = t.primary || getDefaultPrimary(e), f = t.secondary || getDefaultSecondary(e), h = t.error || getDefaultError(e), p = t.info || getDefaultInfo(e), v = t.success || getDefaultSuccess(e), g = t.warning || getDefaultWarning(e);
  function w(_) {
    const b = getContrastRatio_1(_, dark.text.primary) >= n ? dark.text.primary : light.text.primary;
    if (process.env.NODE_ENV !== "production") {
      const M = getContrastRatio_1(_, b);
      M < 3 && console.error([`MUI: The contrast ratio of ${M}:1 for ${b} on ${_}`, "falls below the WCAG recommended absolute minimum contrast ratio of 3:1.", "https://www.w3.org/TR/2008/REC-WCAG20-20081211/#visual-audio-contrast-contrast"].join(`
`));
    }
    return b;
  }
  const E = ({
    color: _,
    name: b,
    mainShade: M = 500,
    lightShade: A = 300,
    darkShade: $ = 700
  }) => {
    if (_ = _extends$x({}, _), !_.main && _[M] && (_.main = _[M]), !_.hasOwnProperty("main"))
      throw new Error(process.env.NODE_ENV !== "production" ? `MUI: The color${b ? ` (${b})` : ""} provided to augmentColor(color) is invalid.
The color object needs to have a \`main\` property or a \`${M}\` property.` : formatMuiErrorMessage$1(11, b ? ` (${b})` : "", M));
    if (typeof _.main != "string")
      throw new Error(process.env.NODE_ENV !== "production" ? `MUI: The color${b ? ` (${b})` : ""} provided to augmentColor(color) is invalid.
\`color.main\` should be a string, but \`${JSON.stringify(_.main)}\` was provided instead.

Did you intend to use one of the following approaches?

import { green } from "@mui/material/colors";

const theme1 = createTheme({ palette: {
  primary: green,
} });

const theme2 = createTheme({ palette: {
  primary: { main: green[500] },
} });` : formatMuiErrorMessage$1(12, b ? ` (${b})` : "", JSON.stringify(_.main)));
    return addLightOrDark(_, "light", A, o), addLightOrDark(_, "dark", $, o), _.contrastText || (_.contrastText = w(_.main)), _;
  }, T = {
    dark,
    light
  };
  return process.env.NODE_ENV !== "production" && (T[e] || console.error(`MUI: The palette mode \`${e}\` is not supported.`)), deepmerge$1(_extends$x({
    // A collection of common colors.
    common: _extends$x({}, common),
    // prevent mutable object.
    // The palette mode, can be light or dark.
    mode: e,
    // The colors used to represent primary interface elements for a user.
    primary: E({
      color: u,
      name: "primary"
    }),
    // The colors used to represent secondary interface elements for a user.
    secondary: E({
      color: f,
      name: "secondary",
      mainShade: "A400",
      lightShade: "A200",
      darkShade: "A700"
    }),
    // The colors used to represent interface elements that the user should be made aware of.
    error: E({
      color: h,
      name: "error"
    }),
    // The colors used to represent potentially dangerous actions or important messages.
    warning: E({
      color: g,
      name: "warning"
    }),
    // The colors used to present information to the user that is neutral and not necessarily important.
    info: E({
      color: p,
      name: "info"
    }),
    // The colors used to indicate the successful completion of an action that user triggered.
    success: E({
      color: v,
      name: "success"
    }),
    // The grey colors.
    grey,
    // Used by `getContrastText()` to maximize the contrast between
    // the background and the text.
    contrastThreshold: n,
    // Takes a background color and returns the text color that maximizes the contrast.
    getContrastText: w,
    // Generate a rich color object.
    augmentColor: E,
    // Used by the functions below to shift a color's luminance by approximately
    // two indexes within its tonal palette.
    // E.g., shift from Red 500 to Red 300 or Red 700.
    tonalOffset: o
  }, T[e]), l);
}
const _excluded$s = ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "fontWeightBold", "htmlFontSize", "allVariants", "pxToRem"];
function round$2(t) {
  return Math.round(t * 1e5) / 1e5;
}
const caseAllCaps = {
  textTransform: "uppercase"
}, defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
function createTypography(t, e) {
  const n = typeof e == "function" ? e(t) : e, {
    fontFamily: o = defaultFontFamily,
    // The default font size of the Material Specification.
    fontSize: l = 14,
    // px
    fontWeightLight: u = 300,
    fontWeightRegular: f = 400,
    fontWeightMedium: h = 500,
    fontWeightBold: p = 700,
    // Tell MUI what's the font-size on the html element.
    // 16px is the default font-size used by browsers.
    htmlFontSize: v = 16,
    // Apply the CSS properties to all the variants.
    allVariants: g,
    pxToRem: w
  } = n, E = _objectWithoutPropertiesLoose$n(n, _excluded$s);
  process.env.NODE_ENV !== "production" && (typeof l != "number" && console.error("MUI: `fontSize` is required to be a number."), typeof v != "number" && console.error("MUI: `htmlFontSize` is required to be a number."));
  const T = l / 14, R = w || ((M) => `${M / v * T}rem`), _ = (M, A, $, S, C) => _extends$x({
    fontFamily: o,
    fontWeight: M,
    fontSize: R(A),
    // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
    lineHeight: $
  }, o === defaultFontFamily ? {
    letterSpacing: `${round$2(S / A)}em`
  } : {}, C, g), b = {
    h1: _(u, 96, 1.167, -1.5),
    h2: _(u, 60, 1.2, -0.5),
    h3: _(f, 48, 1.167, 0),
    h4: _(f, 34, 1.235, 0.25),
    h5: _(f, 24, 1.334, 0),
    h6: _(h, 20, 1.6, 0.15),
    subtitle1: _(f, 16, 1.75, 0.15),
    subtitle2: _(h, 14, 1.57, 0.1),
    body1: _(f, 16, 1.5, 0.15),
    body2: _(f, 14, 1.43, 0.15),
    button: _(h, 14, 1.75, 0.4, caseAllCaps),
    caption: _(f, 12, 1.66, 0.4),
    overline: _(f, 12, 2.66, 1, caseAllCaps),
    // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.
    inherit: {
      fontFamily: "inherit",
      fontWeight: "inherit",
      fontSize: "inherit",
      lineHeight: "inherit",
      letterSpacing: "inherit"
    }
  };
  return deepmerge$1(_extends$x({
    htmlFontSize: v,
    pxToRem: R,
    fontFamily: o,
    fontSize: l,
    fontWeightLight: u,
    fontWeightRegular: f,
    fontWeightMedium: h,
    fontWeightBold: p
  }, b), E, {
    clone: !1
    // No need to clone deep
  });
}
const shadowKeyUmbraOpacity = 0.2, shadowKeyPenumbraOpacity = 0.14, shadowAmbientShadowOpacity = 0.12;
function createShadow(...t) {
  return [`${t[0]}px ${t[1]}px ${t[2]}px ${t[3]}px rgba(0,0,0,${shadowKeyUmbraOpacity})`, `${t[4]}px ${t[5]}px ${t[6]}px ${t[7]}px rgba(0,0,0,${shadowKeyPenumbraOpacity})`, `${t[8]}px ${t[9]}px ${t[10]}px ${t[11]}px rgba(0,0,0,${shadowAmbientShadowOpacity})`].join(",");
}
const shadows = ["none", createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)], _excluded$r = ["duration", "easing", "delay"], easing = {
  // This is the most common easing curve.
  easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
  // Objects enter the screen at full velocity from off-screen and
  // slowly decelerate to a resting point.
  easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
  // Objects leave the screen at full velocity. They do not decelerate when off-screen.
  easeIn: "cubic-bezier(0.4, 0, 1, 1)",
  // The sharp curve is used by objects that may return to the screen at any time.
  sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
}, duration = {
  shortest: 150,
  shorter: 200,
  short: 250,
  // most basic recommended timing
  standard: 300,
  // this is to be used in complex animations
  complex: 375,
  // recommended when something is entering screen
  enteringScreen: 225,
  // recommended when something is leaving screen
  leavingScreen: 195
};
function formatMs(t) {
  return `${Math.round(t)}ms`;
}
function getAutoHeightDuration(t) {
  if (!t)
    return 0;
  const e = t / 36;
  return Math.round((4 + 15 * e ** 0.25 + e / 5) * 10);
}
function createTransitions(t) {
  const e = _extends$x({}, easing, t.easing), n = _extends$x({}, duration, t.duration);
  return _extends$x({
    getAutoHeightDuration,
    create: (l = ["all"], u = {}) => {
      const {
        duration: f = n.standard,
        easing: h = e.easeInOut,
        delay: p = 0
      } = u, v = _objectWithoutPropertiesLoose$n(u, _excluded$r);
      if (process.env.NODE_ENV !== "production") {
        const g = (E) => typeof E == "string", w = (E) => !isNaN(parseFloat(E));
        !g(l) && !Array.isArray(l) && console.error('MUI: Argument "props" must be a string or Array.'), !w(f) && !g(f) && console.error(`MUI: Argument "duration" must be a number or a string but found ${f}.`), g(h) || console.error('MUI: Argument "easing" must be a string.'), !w(p) && !g(p) && console.error('MUI: Argument "delay" must be a number or a string.'), typeof u != "object" && console.error(["MUI: Secong argument of transition.create must be an object.", "Arguments should be either `create('prop1', options)` or `create(['prop1', 'prop2'], options)`"].join(`
`)), Object.keys(v).length !== 0 && console.error(`MUI: Unrecognized argument(s) [${Object.keys(v).join(",")}].`);
      }
      return (Array.isArray(l) ? l : [l]).map((g) => `${g} ${typeof f == "string" ? f : formatMs(f)} ${h} ${typeof p == "string" ? p : formatMs(p)}`).join(",");
    }
  }, t, {
    easing: e,
    duration: n
  });
}
const zIndex = {
  mobileStepper: 1e3,
  fab: 1050,
  speedDial: 1050,
  appBar: 1100,
  drawer: 1200,
  modal: 1300,
  snackbar: 1400,
  tooltip: 1500
}, _excluded$q = ["breakpoints", "mixins", "spacing", "palette", "transitions", "typography", "shape"];
function createTheme(t = {}, ...e) {
  const {
    mixins: n = {},
    palette: o = {},
    transitions: l = {},
    typography: u = {}
  } = t, f = _objectWithoutPropertiesLoose$n(t, _excluded$q);
  if (t.vars)
    throw new Error(process.env.NODE_ENV !== "production" ? "MUI: `vars` is a private field used for CSS variables support.\nPlease use another name." : formatMuiErrorMessage$1(18));
  const h = createPalette(o), p = createTheme$2(t);
  let v = deepmerge$1(p, {
    mixins: createMixins(p.breakpoints, n),
    palette: h,
    // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
    shadows: shadows.slice(),
    typography: createTypography(h, u),
    transitions: createTransitions(l),
    zIndex: _extends$x({}, zIndex)
  });
  if (v = deepmerge$1(v, f), v = e.reduce((g, w) => deepmerge$1(g, w), v), process.env.NODE_ENV !== "production") {
    const g = ["active", "checked", "completed", "disabled", "error", "expanded", "focused", "focusVisible", "required", "selected"], w = (E, T) => {
      let R;
      for (R in E) {
        const _ = E[R];
        if (g.indexOf(R) !== -1 && Object.keys(_).length > 0) {
          if (process.env.NODE_ENV !== "production") {
            const b = generateUtilityClass("", R);
            console.error([`MUI: The \`${T}\` component increases the CSS specificity of the \`${R}\` internal state.`, "You can not override it like this: ", JSON.stringify(E, null, 2), "", `Instead, you need to use the '&.${b}' syntax:`, JSON.stringify({
              root: {
                [`&.${b}`]: _
              }
            }, null, 2), "", "https://mui.com/r/state-classes-guide"].join(`
`));
          }
          E[R] = {};
        }
      }
    };
    Object.keys(v.components).forEach((E) => {
      const T = v.components[E].styleOverrides;
      T && E.indexOf("Mui") === 0 && w(T, E);
    });
  }
  return v.unstable_sxConfig = _extends$x({}, defaultSxConfig, f == null ? void 0 : f.unstable_sxConfig), v.unstable_sx = function(w) {
    return styleFunctionSx$1({
      sx: w,
      theme: this
    });
  }, v;
}
const defaultTheme$1 = createTheme();
function useTheme() {
  const t = useTheme$2(defaultTheme$1);
  return process.env.NODE_ENV !== "production" && React.useDebugValue(t), t[THEME_ID] || t;
}
var createStyled$1 = {};
const require$$1$1 = /* @__PURE__ */ getAugmentedNamespace(_extends$y);
var objectWithoutPropertiesLoose = { exports: {} }, hasRequiredObjectWithoutPropertiesLoose;
function requireObjectWithoutPropertiesLoose() {
  return hasRequiredObjectWithoutPropertiesLoose || (hasRequiredObjectWithoutPropertiesLoose = 1, function(t) {
    function e(n, o) {
      if (n == null) return {};
      var l = {};
      for (var u in n) if ({}.hasOwnProperty.call(n, u)) {
        if (o.includes(u)) continue;
        l[u] = n[u];
      }
      return l;
    }
    t.exports = e, t.exports.__esModule = !0, t.exports.default = t.exports;
  }(objectWithoutPropertiesLoose)), objectWithoutPropertiesLoose.exports;
}
const require$$1 = /* @__PURE__ */ getAugmentedNamespace(styledEngine), require$$4 = /* @__PURE__ */ getAugmentedNamespace(deepmerge), require$$5 = /* @__PURE__ */ getAugmentedNamespace(capitalize), require$$6 = /* @__PURE__ */ getAugmentedNamespace(getDisplayName$1), require$$7 = /* @__PURE__ */ getAugmentedNamespace(createTheme$1), require$$8 = /* @__PURE__ */ getAugmentedNamespace(styleFunctionSx);
var _interopRequireDefault = interopRequireDefaultExports;
Object.defineProperty(createStyled$1, "__esModule", {
  value: !0
});
var _default = createStyled$1.default = createStyled;
createStyled$1.shouldForwardProp = shouldForwardProp;
createStyled$1.systemDefaultTheme = void 0;
var _extends2 = _interopRequireDefault(require$$1$1), _objectWithoutPropertiesLoose2 = _interopRequireDefault(requireObjectWithoutPropertiesLoose()), _styledEngine = _interopRequireWildcard(require$$1), _deepmerge = require$$4, _capitalize = _interopRequireDefault(require$$5), _getDisplayName = _interopRequireDefault(require$$6), _createTheme = _interopRequireDefault(require$$7), _styleFunctionSx = _interopRequireDefault(require$$8);
const _excluded$p = ["ownerState"], _excluded2$7 = ["variants"], _excluded3$1 = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"];
function _getRequireWildcardCache(t) {
  if (typeof WeakMap != "function") return null;
  var e = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap();
  return (_getRequireWildcardCache = function(o) {
    return o ? n : e;
  })(t);
}
function _interopRequireWildcard(t, e) {
  if (t && t.__esModule) return t;
  if (t === null || typeof t != "object" && typeof t != "function") return { default: t };
  var n = _getRequireWildcardCache(e);
  if (n && n.has(t)) return n.get(t);
  var o = { __proto__: null }, l = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var u in t) if (u !== "default" && Object.prototype.hasOwnProperty.call(t, u)) {
    var f = l ? Object.getOwnPropertyDescriptor(t, u) : null;
    f && (f.get || f.set) ? Object.defineProperty(o, u, f) : o[u] = t[u];
  }
  return o.default = t, n && n.set(t, o), o;
}
function isEmpty$1(t) {
  return Object.keys(t).length === 0;
}
function isStringTag(t) {
  return typeof t == "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  t.charCodeAt(0) > 96;
}
function shouldForwardProp(t) {
  return t !== "ownerState" && t !== "theme" && t !== "sx" && t !== "as";
}
const systemDefaultTheme = createStyled$1.systemDefaultTheme = (0, _createTheme.default)(), lowercaseFirstLetter = (t) => t && t.charAt(0).toLowerCase() + t.slice(1);
function resolveTheme({
  defaultTheme: t,
  theme: e,
  themeId: n
}) {
  return isEmpty$1(e) ? t : e[n] || e;
}
function defaultOverridesResolver(t) {
  return t ? (e, n) => n[t] : null;
}
function processStyleArg(t, e) {
  let {
    ownerState: n
  } = e, o = (0, _objectWithoutPropertiesLoose2.default)(e, _excluded$p);
  const l = typeof t == "function" ? t((0, _extends2.default)({
    ownerState: n
  }, o)) : t;
  if (Array.isArray(l))
    return l.flatMap((u) => processStyleArg(u, (0, _extends2.default)({
      ownerState: n
    }, o)));
  if (l && typeof l == "object" && Array.isArray(l.variants)) {
    const {
      variants: u = []
    } = l;
    let h = (0, _objectWithoutPropertiesLoose2.default)(l, _excluded2$7);
    return u.forEach((p) => {
      let v = !0;
      typeof p.props == "function" ? v = p.props((0, _extends2.default)({
        ownerState: n
      }, o, n)) : Object.keys(p.props).forEach((g) => {
        (n == null ? void 0 : n[g]) !== p.props[g] && o[g] !== p.props[g] && (v = !1);
      }), v && (Array.isArray(h) || (h = [h]), h.push(typeof p.style == "function" ? p.style((0, _extends2.default)({
        ownerState: n
      }, o, n)) : p.style));
    }), h;
  }
  return l;
}
function createStyled(t = {}) {
  const {
    themeId: e,
    defaultTheme: n = systemDefaultTheme,
    rootShouldForwardProp: o = shouldForwardProp,
    slotShouldForwardProp: l = shouldForwardProp
  } = t, u = (f) => (0, _styleFunctionSx.default)((0, _extends2.default)({}, f, {
    theme: resolveTheme((0, _extends2.default)({}, f, {
      defaultTheme: n,
      themeId: e
    }))
  }));
  return u.__mui_systemSx = !0, (f, h = {}) => {
    (0, _styledEngine.internal_processStyles)(f, (C) => C.filter((D) => !(D != null && D.__mui_systemSx)));
    const {
      name: p,
      slot: v,
      skipVariantsResolver: g,
      skipSx: w,
      // TODO v6: remove `lowercaseFirstLetter()` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      overridesResolver: E = defaultOverridesResolver(lowercaseFirstLetter(v))
    } = h, T = (0, _objectWithoutPropertiesLoose2.default)(h, _excluded3$1), R = g !== void 0 ? g : (
      // TODO v6: remove `Root` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      v && v !== "Root" && v !== "root" || !1
    ), _ = w || !1;
    let b;
    process.env.NODE_ENV !== "production" && p && (b = `${p}-${lowercaseFirstLetter(v || "Root")}`);
    let M = shouldForwardProp;
    v === "Root" || v === "root" ? M = o : v ? M = l : isStringTag(f) && (M = void 0);
    const A = (0, _styledEngine.default)(f, (0, _extends2.default)({
      shouldForwardProp: M,
      label: b
    }, T)), $ = (C) => typeof C == "function" && C.__emotion_real !== C || (0, _deepmerge.isPlainObject)(C) ? (D) => processStyleArg(C, (0, _extends2.default)({}, D, {
      theme: resolveTheme({
        theme: D.theme,
        defaultTheme: n,
        themeId: e
      })
    })) : C, S = (C, ...D) => {
      let O = $(C);
      const N = D ? D.map($) : [];
      p && E && N.push((z) => {
        const G = resolveTheme((0, _extends2.default)({}, z, {
          defaultTheme: n,
          themeId: e
        }));
        if (!G.components || !G.components[p] || !G.components[p].styleOverrides)
          return null;
        const B = G.components[p].styleOverrides, F = {};
        return Object.entries(B).forEach(([H, W]) => {
          F[H] = processStyleArg(W, (0, _extends2.default)({}, z, {
            theme: G
          }));
        }), E(z, F);
      }), p && !R && N.push((z) => {
        var G;
        const B = resolveTheme((0, _extends2.default)({}, z, {
          defaultTheme: n,
          themeId: e
        })), F = B == null || (G = B.components) == null || (G = G[p]) == null ? void 0 : G.variants;
        return processStyleArg({
          variants: F
        }, (0, _extends2.default)({}, z, {
          theme: B
        }));
      }), _ || N.push(u);
      const j = N.length - D.length;
      if (Array.isArray(C) && j > 0) {
        const z = new Array(j).fill("");
        O = [...C, ...z], O.raw = [...C.raw, ...z];
      }
      const L = A(O, ...N);
      if (process.env.NODE_ENV !== "production") {
        let z;
        p && (z = `${p}${(0, _capitalize.default)(v || "")}`), z === void 0 && (z = `Styled(${(0, _getDisplayName.default)(f)})`), L.displayName = z;
      }
      return f.muiName && (L.muiName = f.muiName), L;
    };
    return A.withConfig && (S.withConfig = A.withConfig), S;
  };
}
function slotShouldForwardProp(t) {
  return t !== "ownerState" && t !== "theme" && t !== "sx" && t !== "as";
}
const rootShouldForwardProp = (t) => slotShouldForwardProp(t) && t !== "classes", styled = _default({
  themeId: THEME_ID,
  defaultTheme: defaultTheme$1,
  rootShouldForwardProp
}), _excluded$o = ["theme"];
function ThemeProvider(t) {
  let {
    theme: e
  } = t, n = _objectWithoutPropertiesLoose$n(t, _excluded$o);
  const o = e[THEME_ID];
  return /* @__PURE__ */ jsxRuntimeExports$1.jsx(ThemeProvider$1, _extends$x({}, n, {
    themeId: o ? THEME_ID : void 0,
    theme: o || e
  }));
}
process.env.NODE_ENV !== "production" && (ThemeProvider.propTypes = {
  /**
   * Your component tree.
   */
  children: PropTypes.node,
  /**
   * A theme object. You can provide a function to extend the outer theme.
   */
  theme: PropTypes.oneOfType([PropTypes.object, PropTypes.func]).isRequired
});
const getOverlayAlpha = (t) => {
  let e;
  return t < 1 ? e = 5.11916 * t ** 2 : e = 4.5 * Math.log(t + 1) + 2, (e / 100).toFixed(2);
};
process.env.NODE_ENV !== "production" && (PropTypes.node, PropTypes.object.isRequired);
function useDefaultProps(t) {
  return useDefaultProps$1(t);
}
function getSvgIconUtilityClass(t) {
  return generateUtilityClass("MuiSvgIcon", t);
}
generateUtilityClasses("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
const _excluded$n = ["children", "className", "color", "component", "fontSize", "htmlColor", "inheritViewBox", "titleAccess", "viewBox"], useUtilityClasses$2 = (t) => {
  const {
    color: e,
    fontSize: n,
    classes: o
  } = t, l = {
    root: ["root", e !== "inherit" && `color${capitalize$1(e)}`, `fontSize${capitalize$1(n)}`]
  };
  return composeClasses(l, getSvgIconUtilityClass, o);
}, SvgIconRoot = styled("svg", {
  name: "MuiSvgIcon",
  slot: "Root",
  overridesResolver: (t, e) => {
    const {
      ownerState: n
    } = t;
    return [e.root, n.color !== "inherit" && e[`color${capitalize$1(n.color)}`], e[`fontSize${capitalize$1(n.fontSize)}`]];
  }
})(({
  theme: t,
  ownerState: e
}) => {
  var n, o, l, u, f, h, p, v, g, w, E, T, R;
  return {
    userSelect: "none",
    width: "1em",
    height: "1em",
    display: "inline-block",
    // the <svg> will define the property that has `currentColor`
    // for example heroicons uses fill="none" and stroke="currentColor"
    fill: e.hasSvgAsChild ? void 0 : "currentColor",
    flexShrink: 0,
    transition: (n = t.transitions) == null || (o = n.create) == null ? void 0 : o.call(n, "fill", {
      duration: (l = t.transitions) == null || (l = l.duration) == null ? void 0 : l.shorter
    }),
    fontSize: {
      inherit: "inherit",
      small: ((u = t.typography) == null || (f = u.pxToRem) == null ? void 0 : f.call(u, 20)) || "1.25rem",
      medium: ((h = t.typography) == null || (p = h.pxToRem) == null ? void 0 : p.call(h, 24)) || "1.5rem",
      large: ((v = t.typography) == null || (g = v.pxToRem) == null ? void 0 : g.call(v, 35)) || "2.1875rem"
    }[e.fontSize],
    // TODO v5 deprecate, v6 remove for sx
    color: (w = (E = (t.vars || t).palette) == null || (E = E[e.color]) == null ? void 0 : E.main) != null ? w : {
      action: (T = (t.vars || t).palette) == null || (T = T.action) == null ? void 0 : T.active,
      disabled: (R = (t.vars || t).palette) == null || (R = R.action) == null ? void 0 : R.disabled,
      inherit: void 0
    }[e.color]
  };
}), SvgIcon = /* @__PURE__ */ React.forwardRef(function t(e, n) {
  const o = useDefaultProps({
    props: e,
    name: "MuiSvgIcon"
  }), {
    children: l,
    className: u,
    color: f = "inherit",
    component: h = "svg",
    fontSize: p = "medium",
    htmlColor: v,
    inheritViewBox: g = !1,
    titleAccess: w,
    viewBox: E = "0 0 24 24"
  } = o, T = _objectWithoutPropertiesLoose$n(o, _excluded$n), R = /* @__PURE__ */ React.isValidElement(l) && l.type === "svg", _ = _extends$x({}, o, {
    color: f,
    component: h,
    fontSize: p,
    instanceFontSize: e.fontSize,
    inheritViewBox: g,
    viewBox: E,
    hasSvgAsChild: R
  }), b = {};
  g || (b.viewBox = E);
  const M = useUtilityClasses$2(_);
  return /* @__PURE__ */ jsxRuntimeExports$1.jsxs(SvgIconRoot, _extends$x({
    as: h,
    className: clsx$1(M.root, u),
    focusable: "false",
    color: v,
    "aria-hidden": w ? void 0 : !0,
    role: w ? "img" : void 0,
    ref: n
  }, b, T, R && l.props, {
    ownerState: _,
    children: [R ? l.props.children : l, w ? /* @__PURE__ */ jsxRuntimeExports$1.jsx("title", {
      children: w
    }) : null]
  }));
});
process.env.NODE_ENV !== "production" && (SvgIcon.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * Node passed into the SVG element.
   */
  children: PropTypes.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: PropTypes.object,
  /**
   * @ignore
   */
  className: PropTypes.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   * You can use the `htmlColor` prop to apply a color attribute to the SVG element.
   * @default 'inherit'
   */
  color: PropTypes.oneOfType([PropTypes.oneOf(["inherit", "action", "disabled", "primary", "secondary", "error", "info", "success", "warning"]), PropTypes.string]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: PropTypes.elementType,
  /**
   * The fontSize applied to the icon. Defaults to 24px, but can be configure to inherit font size.
   * @default 'medium'
   */
  fontSize: PropTypes.oneOfType([PropTypes.oneOf(["inherit", "large", "medium", "small"]), PropTypes.string]),
  /**
   * Applies a color attribute to the SVG element.
   */
  htmlColor: PropTypes.string,
  /**
   * If `true`, the root node will inherit the custom `component`'s viewBox and the `viewBox`
   * prop will be ignored.
   * Useful when you want to reference a custom `component` and have `SvgIcon` pass that
   * `component`'s viewBox to the root node.
   * @default false
   */
  inheritViewBox: PropTypes.bool,
  /**
   * The shape-rendering attribute. The behavior of the different options is described on the
   * [MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/shape-rendering).
   * If you are having issues with blurry icons you should investigate this prop.
   */
  shapeRendering: PropTypes.string,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),
  /**
   * Provides a human-readable title for the element that contains it.
   * https://www.w3.org/TR/SVG-access/#Equivalent
   */
  titleAccess: PropTypes.string,
  /**
   * Allows you to redefine what the coordinates without units mean inside an SVG element.
   * For example, if the SVG element is 500 (width) by 200 (height),
   * and you pass viewBox="0 0 50 20",
   * this means that the coordinates inside the SVG will go from the top left corner (0,0)
   * to bottom right (50,20) and each unit will be worth 10px.
   * @default '0 0 24 24'
   */
  viewBox: PropTypes.string
});
SvgIcon.muiName = "SvgIcon";
function getPaperUtilityClass(t) {
  return generateUtilityClass("MuiPaper", t);
}
generateUtilityClasses("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]);
const _excluded$m = ["className", "component", "elevation", "square", "variant"], useUtilityClasses$1 = (t) => {
  const {
    square: e,
    elevation: n,
    variant: o,
    classes: l
  } = t, u = {
    root: ["root", o, !e && "rounded", o === "elevation" && `elevation${n}`]
  };
  return composeClasses(u, getPaperUtilityClass, l);
}, PaperRoot = styled("div", {
  name: "MuiPaper",
  slot: "Root",
  overridesResolver: (t, e) => {
    const {
      ownerState: n
    } = t;
    return [e.root, e[n.variant], !n.square && e.rounded, n.variant === "elevation" && e[`elevation${n.elevation}`]];
  }
})(({
  theme: t,
  ownerState: e
}) => {
  var n;
  return _extends$x({
    backgroundColor: (t.vars || t).palette.background.paper,
    color: (t.vars || t).palette.text.primary,
    transition: t.transitions.create("box-shadow")
  }, !e.square && {
    borderRadius: t.shape.borderRadius
  }, e.variant === "outlined" && {
    border: `1px solid ${(t.vars || t).palette.divider}`
  }, e.variant === "elevation" && _extends$x({
    boxShadow: (t.vars || t).shadows[e.elevation]
  }, !t.vars && t.palette.mode === "dark" && {
    backgroundImage: `linear-gradient(${alpha_1("#fff", getOverlayAlpha(e.elevation))}, ${alpha_1("#fff", getOverlayAlpha(e.elevation))})`
  }, t.vars && {
    backgroundImage: (n = t.vars.overlays) == null ? void 0 : n[e.elevation]
  }));
}), Paper = /* @__PURE__ */ React.forwardRef(function t(e, n) {
  const o = useDefaultProps({
    props: e,
    name: "MuiPaper"
  }), {
    className: l,
    component: u = "div",
    elevation: f = 1,
    square: h = !1,
    variant: p = "elevation"
  } = o, v = _objectWithoutPropertiesLoose$n(o, _excluded$m), g = _extends$x({}, o, {
    component: u,
    elevation: f,
    square: h,
    variant: p
  }), w = useUtilityClasses$1(g);
  return process.env.NODE_ENV !== "production" && useTheme().shadows[f] === void 0 && console.error([`MUI: The elevation provided <Paper elevation={${f}}> is not available in the theme.`, `Please make sure that \`theme.shadows[${f}]\` is defined.`].join(`
`)), /* @__PURE__ */ jsxRuntimeExports$1.jsx(PaperRoot, _extends$x({
    as: u,
    ownerState: g,
    className: clsx$1(w.root, l),
    ref: n
  }, v));
});
process.env.NODE_ENV !== "production" && (Paper.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * The content of the component.
   */
  children: PropTypes.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: PropTypes.object,
  /**
   * @ignore
   */
  className: PropTypes.string,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: PropTypes.elementType,
  /**
   * Shadow depth, corresponds to `dp` in the spec.
   * It accepts values between 0 and 24 inclusive.
   * @default 1
   */
  elevation: chainPropTypes(integerPropType, (t) => {
    const {
      elevation: e,
      variant: n
    } = t;
    return e > 0 && n === "outlined" ? new Error(`MUI: Combining \`elevation={${e}}\` with \`variant="${n}"\` has no effect. Either use \`elevation={0}\` or use a different \`variant\`.`) : null;
  }),
  /**
   * If `true`, rounded corners are disabled.
   * @default false
   */
  square: PropTypes.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),
  /**
   * The variant to use.
   * @default 'elevation'
   */
  variant: PropTypes.oneOfType([PropTypes.oneOf(["elevation", "outlined"]), PropTypes.string])
});
const _excluded$l = ["onChange", "maxRows", "minRows", "style", "value"];
function getStyleValue(t) {
  return parseInt(t, 10) || 0;
}
const styles = {
  shadow: {
    // Visibility needed to hide the extra text area on iPads
    visibility: "hidden",
    // Remove from the content flow
    position: "absolute",
    // Ignore the scrollbar width
    overflow: "hidden",
    height: 0,
    top: 0,
    left: 0,
    // Create a new layer, increase the isolation of the computed values
    transform: "translateZ(0)"
  }
};
function isEmpty(t) {
  return t == null || Object.keys(t).length === 0 || t.outerHeightStyle === 0 && !t.overflowing;
}
const TextareaAutosize = /* @__PURE__ */ React.forwardRef(function t(e, n) {
  const {
    onChange: o,
    maxRows: l,
    minRows: u = 1,
    style: f,
    value: h
  } = e, p = _objectWithoutPropertiesLoose$n(e, _excluded$l), {
    current: v
  } = React.useRef(h != null), g = React.useRef(null), w = useForkRef(n, g), E = React.useRef(null), T = React.useRef(null), R = React.useCallback(() => {
    const M = g.current, $ = ownerWindow(M).getComputedStyle(M);
    if ($.width === "0px")
      return {
        outerHeightStyle: 0,
        overflowing: !1
      };
    const S = T.current;
    S.style.width = $.width, S.value = M.value || e.placeholder || "x", S.value.slice(-1) === `
` && (S.value += " ");
    const C = $.boxSizing, D = getStyleValue($.paddingBottom) + getStyleValue($.paddingTop), O = getStyleValue($.borderBottomWidth) + getStyleValue($.borderTopWidth), N = S.scrollHeight;
    S.value = "x";
    const j = S.scrollHeight;
    let L = N;
    u && (L = Math.max(Number(u) * j, L)), l && (L = Math.min(Number(l) * j, L)), L = Math.max(L, j);
    const z = L + (C === "border-box" ? D + O : 0), G = Math.abs(L - N) <= 1;
    return {
      outerHeightStyle: z,
      overflowing: G
    };
  }, [l, u, e.placeholder]), _ = React.useCallback(() => {
    const M = R();
    if (isEmpty(M))
      return;
    const A = M.outerHeightStyle, $ = g.current;
    E.current !== A && (E.current = A, $.style.height = `${A}px`), $.style.overflow = M.overflowing ? "hidden" : "";
  }, [R]);
  useEnhancedEffect(() => {
    const M = () => {
      _();
    };
    let A;
    const $ = () => {
      cancelAnimationFrame(A), A = requestAnimationFrame(() => {
        M();
      });
    }, S = debounce$2(M), C = g.current, D = ownerWindow(C);
    D.addEventListener("resize", S);
    let O;
    return typeof ResizeObserver < "u" && (O = new ResizeObserver(process.env.NODE_ENV === "test" ? $ : M), O.observe(C)), () => {
      S.clear(), cancelAnimationFrame(A), D.removeEventListener("resize", S), O && O.disconnect();
    };
  }, [R, _]), useEnhancedEffect(() => {
    _();
  });
  const b = (M) => {
    v || _(), o && o(M);
  };
  return /* @__PURE__ */ jsxRuntimeExports$1.jsxs(React.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports$1.jsx("textarea", _extends$x({
      value: h,
      onChange: b,
      ref: w,
      rows: u,
      style: f
    }, p)), /* @__PURE__ */ jsxRuntimeExports$1.jsx("textarea", {
      "aria-hidden": !0,
      className: e.className,
      readOnly: !0,
      ref: T,
      tabIndex: -1,
      style: _extends$x({}, styles.shadow, f, {
        paddingTop: 0,
        paddingBottom: 0
      })
    })]
  });
});
process.env.NODE_ENV !== "production" && (TextareaAutosize.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │ To update them, edit the TypeScript types and run `pnpm proptypes`. │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * @ignore
   */
  className: PropTypes.string,
  /**
   * Maximum number of rows to display.
   */
  maxRows: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  /**
   * Minimum number of rows to display.
   * @default 1
   */
  minRows: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  /**
   * @ignore
   */
  onChange: PropTypes.func,
  /**
   * @ignore
   */
  placeholder: PropTypes.string,
  /**
   * @ignore
   */
  style: PropTypes.object,
  /**
   * @ignore
   */
  value: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string), PropTypes.number, PropTypes.string])
});
function formControlState({
  props: t,
  states: e,
  muiFormControl: n
}) {
  return e.reduce((o, l) => (o[l] = t[l], n && typeof t[l] > "u" && (o[l] = n[l]), o), {});
}
const FormControlContext = /* @__PURE__ */ React.createContext(void 0);
process.env.NODE_ENV !== "production" && (FormControlContext.displayName = "FormControlContext");
function useFormControl() {
  return React.useContext(FormControlContext);
}
function GlobalStyles(t) {
  return /* @__PURE__ */ jsxRuntimeExports$1.jsx(GlobalStyles$1, _extends$x({}, t, {
    defaultTheme: defaultTheme$1,
    themeId: THEME_ID
  }));
}
process.env.NODE_ENV !== "production" && (GlobalStyles.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * The styles you want to apply globally.
   */
  styles: PropTypes.oneOfType([PropTypes.array, PropTypes.func, PropTypes.number, PropTypes.object, PropTypes.string, PropTypes.bool])
});
function hasValue(t) {
  return t != null && !(Array.isArray(t) && t.length === 0);
}
function isFilled(t, e = !1) {
  return t && (hasValue(t.value) && t.value !== "" || e && hasValue(t.defaultValue) && t.defaultValue !== "");
}
function getInputBaseUtilityClass(t) {
  return generateUtilityClass("MuiInputBase", t);
}
const inputBaseClasses = generateUtilityClasses("MuiInputBase", ["root", "formControl", "focused", "disabled", "adornedStart", "adornedEnd", "error", "sizeSmall", "multiline", "colorSecondary", "fullWidth", "hiddenLabel", "readOnly", "input", "inputSizeSmall", "inputMultiline", "inputTypeSearch", "inputAdornedStart", "inputAdornedEnd", "inputHiddenLabel"]), _excluded$k = ["aria-describedby", "autoComplete", "autoFocus", "className", "color", "components", "componentsProps", "defaultValue", "disabled", "disableInjectingGlobalStyles", "endAdornment", "error", "fullWidth", "id", "inputComponent", "inputProps", "inputRef", "margin", "maxRows", "minRows", "multiline", "name", "onBlur", "onChange", "onClick", "onFocus", "onKeyDown", "onKeyUp", "placeholder", "readOnly", "renderSuffix", "rows", "size", "slotProps", "slots", "startAdornment", "type", "value"], rootOverridesResolver = (t, e) => {
  const {
    ownerState: n
  } = t;
  return [e.root, n.formControl && e.formControl, n.startAdornment && e.adornedStart, n.endAdornment && e.adornedEnd, n.error && e.error, n.size === "small" && e.sizeSmall, n.multiline && e.multiline, n.color && e[`color${capitalize$1(n.color)}`], n.fullWidth && e.fullWidth, n.hiddenLabel && e.hiddenLabel];
}, inputOverridesResolver = (t, e) => {
  const {
    ownerState: n
  } = t;
  return [e.input, n.size === "small" && e.inputSizeSmall, n.multiline && e.inputMultiline, n.type === "search" && e.inputTypeSearch, n.startAdornment && e.inputAdornedStart, n.endAdornment && e.inputAdornedEnd, n.hiddenLabel && e.inputHiddenLabel];
}, useUtilityClasses = (t) => {
  const {
    classes: e,
    color: n,
    disabled: o,
    error: l,
    endAdornment: u,
    focused: f,
    formControl: h,
    fullWidth: p,
    hiddenLabel: v,
    multiline: g,
    readOnly: w,
    size: E,
    startAdornment: T,
    type: R
  } = t, _ = {
    root: ["root", `color${capitalize$1(n)}`, o && "disabled", l && "error", p && "fullWidth", f && "focused", h && "formControl", E && E !== "medium" && `size${capitalize$1(E)}`, g && "multiline", T && "adornedStart", u && "adornedEnd", v && "hiddenLabel", w && "readOnly"],
    input: ["input", o && "disabled", R === "search" && "inputTypeSearch", g && "inputMultiline", E === "small" && "inputSizeSmall", v && "inputHiddenLabel", T && "inputAdornedStart", u && "inputAdornedEnd", w && "readOnly"]
  };
  return composeClasses(_, getInputBaseUtilityClass, e);
}, InputBaseRoot = styled("div", {
  name: "MuiInputBase",
  slot: "Root",
  overridesResolver: rootOverridesResolver
})(({
  theme: t,
  ownerState: e
}) => _extends$x({}, t.typography.body1, {
  color: (t.vars || t).palette.text.primary,
  lineHeight: "1.4375em",
  // 23px
  boxSizing: "border-box",
  // Prevent padding issue with fullWidth.
  position: "relative",
  cursor: "text",
  display: "inline-flex",
  alignItems: "center",
  [`&.${inputBaseClasses.disabled}`]: {
    color: (t.vars || t).palette.text.disabled,
    cursor: "default"
  }
}, e.multiline && _extends$x({
  padding: "4px 0 5px"
}, e.size === "small" && {
  paddingTop: 1
}), e.fullWidth && {
  width: "100%"
})), InputBaseComponent = styled("input", {
  name: "MuiInputBase",
  slot: "Input",
  overridesResolver: inputOverridesResolver
})(({
  theme: t,
  ownerState: e
}) => {
  const n = t.palette.mode === "light", o = _extends$x({
    color: "currentColor"
  }, t.vars ? {
    opacity: t.vars.opacity.inputPlaceholder
  } : {
    opacity: n ? 0.42 : 0.5
  }, {
    transition: t.transitions.create("opacity", {
      duration: t.transitions.duration.shorter
    })
  }), l = {
    opacity: "0 !important"
  }, u = t.vars ? {
    opacity: t.vars.opacity.inputPlaceholder
  } : {
    opacity: n ? 0.42 : 0.5
  };
  return _extends$x({
    font: "inherit",
    letterSpacing: "inherit",
    color: "currentColor",
    padding: "4px 0 5px",
    border: 0,
    boxSizing: "content-box",
    background: "none",
    height: "1.4375em",
    // Reset 23pxthe native input line-height
    margin: 0,
    // Reset for Safari
    WebkitTapHighlightColor: "transparent",
    display: "block",
    // Make the flex item shrink with Firefox
    minWidth: 0,
    width: "100%",
    // Fix IE11 width issue
    animationName: "mui-auto-fill-cancel",
    animationDuration: "10ms",
    "&::-webkit-input-placeholder": o,
    "&::-moz-placeholder": o,
    // Firefox 19+
    "&:-ms-input-placeholder": o,
    // IE11
    "&::-ms-input-placeholder": o,
    // Edge
    "&:focus": {
      outline: 0
    },
    // Reset Firefox invalid required input style
    "&:invalid": {
      boxShadow: "none"
    },
    "&::-webkit-search-decoration": {
      // Remove the padding when type=search.
      WebkitAppearance: "none"
    },
    // Show and hide the placeholder logic
    [`label[data-shrink=false] + .${inputBaseClasses.formControl} &`]: {
      "&::-webkit-input-placeholder": l,
      "&::-moz-placeholder": l,
      // Firefox 19+
      "&:-ms-input-placeholder": l,
      // IE11
      "&::-ms-input-placeholder": l,
      // Edge
      "&:focus::-webkit-input-placeholder": u,
      "&:focus::-moz-placeholder": u,
      // Firefox 19+
      "&:focus:-ms-input-placeholder": u,
      // IE11
      "&:focus::-ms-input-placeholder": u
      // Edge
    },
    [`&.${inputBaseClasses.disabled}`]: {
      opacity: 1,
      // Reset iOS opacity
      WebkitTextFillColor: (t.vars || t).palette.text.disabled
      // Fix opacity Safari bug
    },
    "&:-webkit-autofill": {
      animationDuration: "5000s",
      animationName: "mui-auto-fill"
    }
  }, e.size === "small" && {
    paddingTop: 1
  }, e.multiline && {
    height: "auto",
    resize: "none",
    padding: 0,
    paddingTop: 0
  }, e.type === "search" && {
    // Improve type search style.
    MozAppearance: "textfield"
  });
}), inputGlobalStyles = /* @__PURE__ */ jsxRuntimeExports$1.jsx(GlobalStyles, {
  styles: {
    "@keyframes mui-auto-fill": {
      from: {
        display: "block"
      }
    },
    "@keyframes mui-auto-fill-cancel": {
      from: {
        display: "block"
      }
    }
  }
}), InputBase = /* @__PURE__ */ React.forwardRef(function t(e, n) {
  var o;
  const l = useDefaultProps({
    props: e,
    name: "MuiInputBase"
  }), {
    "aria-describedby": u,
    autoComplete: f,
    autoFocus: h,
    className: p,
    components: v = {},
    componentsProps: g = {},
    defaultValue: w,
    disabled: E,
    disableInjectingGlobalStyles: T,
    endAdornment: R,
    fullWidth: _ = !1,
    id: b,
    inputComponent: M = "input",
    inputProps: A = {},
    inputRef: $,
    maxRows: S,
    minRows: C,
    multiline: D = !1,
    name: O,
    onBlur: N,
    onChange: j,
    onClick: L,
    onFocus: z,
    onKeyDown: G,
    onKeyUp: B,
    placeholder: F,
    readOnly: H,
    renderSuffix: W,
    rows: V,
    slotProps: X = {},
    slots: Z = {},
    startAdornment: Q,
    type: q = "text",
    value: J
  } = l, ie = _objectWithoutPropertiesLoose$n(l, _excluded$k), ne = A.value != null ? A.value : J, {
    current: ge
  } = React.useRef(ne != null), ye = React.useRef(), xe = React.useCallback((ae) => {
    process.env.NODE_ENV !== "production" && ae && ae.nodeName !== "INPUT" && !ae.focus && console.error(["MUI: You have provided a `inputComponent` to the input component", "that does not correctly handle the `ref` prop.", "Make sure the `ref` prop is called with a HTMLInputElement."].join(`
`));
  }, []), we = useForkRef(ye, $, A.ref, xe), [de, Te] = React.useState(!1), Ce = useFormControl();
  process.env.NODE_ENV !== "production" && React.useEffect(() => {
    if (Ce)
      return Ce.registerEffect();
  }, [Ce]);
  const ee = formControlState({
    props: l,
    muiFormControl: Ce,
    states: ["color", "disabled", "error", "hiddenLabel", "size", "required", "filled"]
  });
  ee.focused = Ce ? Ce.focused : de, React.useEffect(() => {
    !Ce && E && de && (Te(!1), N && N());
  }, [Ce, E, de, N]);
  const Ae = Ce && Ce.onFilled, be = Ce && Ce.onEmpty, Fe = React.useCallback((ae) => {
    isFilled(ae) ? Ae && Ae() : be && be();
  }, [Ae, be]);
  useEnhancedEffect(() => {
    ge && Fe({
      value: ne
    });
  }, [ne, Fe, ge]);
  const et = (ae) => {
    if (ee.disabled) {
      ae.stopPropagation();
      return;
    }
    z && z(ae), A.onFocus && A.onFocus(ae), Ce && Ce.onFocus ? Ce.onFocus(ae) : Te(!0);
  }, Ye = (ae) => {
    N && N(ae), A.onBlur && A.onBlur(ae), Ce && Ce.onBlur ? Ce.onBlur(ae) : Te(!1);
  }, De = (ae, ...se) => {
    if (!ge) {
      const Re = ae.target || ye.current;
      if (Re == null)
        throw new Error(process.env.NODE_ENV !== "production" ? "MUI: Expected valid input target. Did you use a custom `inputComponent` and forget to forward refs? See https://mui.com/r/input-component-ref-interface for more info." : formatMuiErrorMessage$1(1));
      Fe({
        value: Re.value
      });
    }
    A.onChange && A.onChange(ae, ...se), j && j(ae, ...se);
  };
  React.useEffect(() => {
    Fe(ye.current);
  }, []);
  const Ue = (ae) => {
    ye.current && ae.currentTarget === ae.target && ye.current.focus(), L && L(ae);
  };
  let Qe = M, ue = A;
  D && Qe === "input" && (V ? (process.env.NODE_ENV !== "production" && (C || S) && console.warn("MUI: You can not use the `minRows` or `maxRows` props when the input `rows` prop is set."), ue = _extends$x({
    type: void 0,
    minRows: V,
    maxRows: V
  }, ue)) : ue = _extends$x({
    type: void 0,
    maxRows: S,
    minRows: C
  }, ue), Qe = TextareaAutosize);
  const te = (ae) => {
    Fe(ae.animationName === "mui-auto-fill-cancel" ? ye.current : {
      value: "x"
    });
  };
  React.useEffect(() => {
    Ce && Ce.setAdornedStart(!!Q);
  }, [Ce, Q]);
  const Be = _extends$x({}, l, {
    color: ee.color || "primary",
    disabled: ee.disabled,
    endAdornment: R,
    error: ee.error,
    focused: ee.focused,
    formControl: Ce,
    fullWidth: _,
    hiddenLabel: ee.hiddenLabel,
    multiline: D,
    size: ee.size,
    startAdornment: Q,
    type: q
  }), Je = useUtilityClasses(Be), ft = Z.root || v.Root || InputBaseRoot, lt = X.root || g.root || {}, he = Z.input || v.Input || InputBaseComponent;
  return ue = _extends$x({}, ue, (o = X.input) != null ? o : g.input), /* @__PURE__ */ jsxRuntimeExports$1.jsxs(React.Fragment, {
    children: [!T && inputGlobalStyles, /* @__PURE__ */ jsxRuntimeExports$1.jsxs(ft, _extends$x({}, lt, !isHostComponent(ft) && {
      ownerState: _extends$x({}, Be, lt.ownerState)
    }, {
      ref: n,
      onClick: Ue
    }, ie, {
      className: clsx$1(Je.root, lt.className, p, H && "MuiInputBase-readOnly"),
      children: [Q, /* @__PURE__ */ jsxRuntimeExports$1.jsx(FormControlContext.Provider, {
        value: null,
        children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(he, _extends$x({
          ownerState: Be,
          "aria-invalid": ee.error,
          "aria-describedby": u,
          autoComplete: f,
          autoFocus: h,
          defaultValue: w,
          disabled: ee.disabled,
          id: b,
          onAnimationStart: te,
          name: O,
          placeholder: F,
          readOnly: H,
          required: ee.required,
          rows: V,
          value: ne,
          onKeyDown: G,
          onKeyUp: B,
          type: q
        }, ue, !isHostComponent(he) && {
          as: Qe,
          ownerState: _extends$x({}, Be, ue.ownerState)
        }, {
          ref: we,
          className: clsx$1(Je.input, ue.className, H && "MuiInputBase-readOnly"),
          onBlur: Ye,
          onChange: De,
          onFocus: et
        }))
      }), R, W ? W(_extends$x({}, ee, {
        startAdornment: Q
      })) : null]
    }))]
  });
});
process.env.NODE_ENV !== "production" && (InputBase.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * @ignore
   */
  "aria-describedby": PropTypes.string,
  /**
   * This prop helps users to fill forms faster, especially on mobile devices.
   * The name can be confusing, as it's more like an autofill.
   * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
   */
  autoComplete: PropTypes.string,
  /**
   * If `true`, the `input` element is focused during the first mount.
   */
  autoFocus: PropTypes.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: PropTypes.object,
  /**
   * @ignore
   */
  className: PropTypes.string,
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
   * The prop defaults to the value (`'primary'`) inherited from the parent FormControl component.
   */
  color: PropTypes.oneOfType([PropTypes.oneOf(["primary", "secondary", "error", "info", "success", "warning"]), PropTypes.string]),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `slots` prop.
   * It's recommended to use the `slots` prop instead.
   *
   * @default {}
   */
  components: PropTypes.shape({
    Input: PropTypes.elementType,
    Root: PropTypes.elementType
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `slotProps` prop.
   * It's recommended to use the `slotProps` prop instead, as `componentsProps` will be deprecated in the future.
   *
   * @default {}
   */
  componentsProps: PropTypes.shape({
    input: PropTypes.object,
    root: PropTypes.object
  }),
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: PropTypes.any,
  /**
   * If `true`, the component is disabled.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  disabled: PropTypes.bool,
  /**
   * If `true`, GlobalStyles for the auto-fill keyframes will not be injected/removed on mount/unmount. Make sure to inject them at the top of your application.
   * This option is intended to help with boosting the initial rendering performance if you are loading a big amount of Input components at once.
   * @default false
   */
  disableInjectingGlobalStyles: PropTypes.bool,
  /**
   * End `InputAdornment` for this component.
   */
  endAdornment: PropTypes.node,
  /**
   * If `true`, the `input` will indicate an error.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  error: PropTypes.bool,
  /**
   * If `true`, the `input` will take up the full width of its container.
   * @default false
   */
  fullWidth: PropTypes.bool,
  /**
   * The id of the `input` element.
   */
  id: PropTypes.string,
  /**
   * The component used for the `input` element.
   * Either a string to use a HTML element or a component.
   * @default 'input'
   */
  inputComponent: elementTypeAcceptingRef$1,
  /**
   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.
   * @default {}
   */
  inputProps: PropTypes.object,
  /**
   * Pass a ref to the `input` element.
   */
  inputRef: refType,
  /**
   * If `dense`, will adjust vertical spacing. This is normally obtained via context from
   * FormControl.
   * The prop defaults to the value (`'none'`) inherited from the parent FormControl component.
   */
  margin: PropTypes.oneOf(["dense", "none"]),
  /**
   * Maximum number of rows to display when multiline option is set to true.
   */
  maxRows: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  /**
   * Minimum number of rows to display when multiline option is set to true.
   */
  minRows: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  /**
   * If `true`, a [TextareaAutosize](/material-ui/react-textarea-autosize/) element is rendered.
   * @default false
   */
  multiline: PropTypes.bool,
  /**
   * Name attribute of the `input` element.
   */
  name: PropTypes.string,
  /**
   * Callback fired when the `input` is blurred.
   *
   * Notice that the first argument (event) might be undefined.
   */
  onBlur: PropTypes.func,
  /**
   * Callback fired when the value is changed.
   *
   * @param {React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (string).
   */
  onChange: PropTypes.func,
  /**
   * @ignore
   */
  onClick: PropTypes.func,
  /**
   * @ignore
   */
  onFocus: PropTypes.func,
  /**
   * Callback fired when the `input` doesn't satisfy its constraints.
   */
  onInvalid: PropTypes.func,
  /**
   * @ignore
   */
  onKeyDown: PropTypes.func,
  /**
   * @ignore
   */
  onKeyUp: PropTypes.func,
  /**
   * The short hint displayed in the `input` before the user enters a value.
   */
  placeholder: PropTypes.string,
  /**
   * It prevents the user from changing the value of the field
   * (not from interacting with the field).
   */
  readOnly: PropTypes.bool,
  /**
   * @ignore
   */
  renderSuffix: PropTypes.func,
  /**
   * If `true`, the `input` element is required.
   * The prop defaults to the value (`false`) inherited from the parent FormControl component.
   */
  required: PropTypes.bool,
  /**
   * Number of rows to display when multiline option is set to true.
   */
  rows: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  /**
   * The size of the component.
   */
  size: PropTypes.oneOfType([PropTypes.oneOf(["medium", "small"]), PropTypes.string]),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `componentsProps` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slotProps: PropTypes.shape({
    input: PropTypes.object,
    root: PropTypes.object
  }),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `components` prop, which will be deprecated in the future.
   *
   * @default {}
   */
  slots: PropTypes.shape({
    input: PropTypes.elementType,
    root: PropTypes.elementType
  }),
  /**
   * Start `InputAdornment` for this component.
   */
  startAdornment: PropTypes.node,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),
  /**
   * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
   * @default 'text'
   */
  type: PropTypes.string,
  /**
   * The value of the `input` element, required for a controlled component.
   */
  value: PropTypes.any
});
const boxClasses = generateUtilityClasses("MuiBox", ["root"]), defaultTheme = createTheme(), Box = createBox({
  themeId: THEME_ID,
  defaultTheme,
  defaultClassName: boxClasses.root,
  generateClassName: ClassNameGenerator.generate
});
process.env.NODE_ENV !== "production" && (Box.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * @ignore
   */
  children: PropTypes.node,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: PropTypes.elementType,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object])
});
function NoSsr(t) {
  const {
    children: e,
    defer: n = !1,
    fallback: o = null
  } = t, [l, u] = React.useState(!1);
  return useEnhancedEffect(() => {
    n || u(!0);
  }, [n]), React.useEffect(() => {
    n && u(!0);
  }, [n]), /* @__PURE__ */ jsxRuntimeExports$1.jsx(React.Fragment, {
    children: l ? e : o
  });
}
process.env.NODE_ENV !== "production" && (NoSsr.propTypes = {
  // ┌────────────────────────────── Warning ──────────────────────────────┐
  // │ These PropTypes are generated from the TypeScript type definitions. │
  // │ To update them, edit the TypeScript types and run `pnpm proptypes`. │
  // └─────────────────────────────────────────────────────────────────────┘
  /**
   * You can wrap a node.
   */
  children: PropTypes.node,
  /**
   * If `true`, the component will not only prevent server-side rendering.
   * It will also defer the rendering of the children into a different screen frame.
   * @default false
   */
  defer: PropTypes.bool,
  /**
   * The fallback content to display.
   * @default null
   */
  fallback: PropTypes.node
});
process.env.NODE_ENV !== "production" && (NoSsr.propTypes = exactProp(NoSsr.propTypes));
const __vite_import_meta_env__$1 = { BASE_URL: "/", DEV: !1, MODE: "production", PROD: !0, SSR: !1 }, createStoreImpl = (t) => {
  let e;
  const n = /* @__PURE__ */ new Set(), o = (g, w) => {
    const E = typeof g == "function" ? g(e) : g;
    if (!Object.is(E, e)) {
      const T = e;
      e = w ?? (typeof E != "object" || E === null) ? E : Object.assign({}, e, E), n.forEach((R) => R(e, T));
    }
  }, l = () => e, p = { setState: o, getState: l, getInitialState: () => v, subscribe: (g) => (n.add(g), () => n.delete(g)), destroy: () => {
    (__vite_import_meta_env__$1 ? "production" : void 0) !== "production" && console.warn(
      "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
    ), n.clear();
  } }, v = e = t(o, l, p);
  return p;
}, createStore = (t) => t ? createStoreImpl(t) : createStoreImpl;
var withSelector = { exports: {} }, withSelector_production_min = {}, shim = { exports: {} }, useSyncExternalStoreShim_production_min = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredUseSyncExternalStoreShim_production_min;
function requireUseSyncExternalStoreShim_production_min() {
  if (hasRequiredUseSyncExternalStoreShim_production_min) return useSyncExternalStoreShim_production_min;
  hasRequiredUseSyncExternalStoreShim_production_min = 1;
  var t = React__default;
  function e(w, E) {
    return w === E && (w !== 0 || 1 / w === 1 / E) || w !== w && E !== E;
  }
  var n = typeof Object.is == "function" ? Object.is : e, o = t.useState, l = t.useEffect, u = t.useLayoutEffect, f = t.useDebugValue;
  function h(w, E) {
    var T = E(), R = o({ inst: { value: T, getSnapshot: E } }), _ = R[0].inst, b = R[1];
    return u(function() {
      _.value = T, _.getSnapshot = E, p(_) && b({ inst: _ });
    }, [w, T, E]), l(function() {
      return p(_) && b({ inst: _ }), w(function() {
        p(_) && b({ inst: _ });
      });
    }, [w]), f(T), T;
  }
  function p(w) {
    var E = w.getSnapshot;
    w = w.value;
    try {
      var T = E();
      return !n(w, T);
    } catch {
      return !0;
    }
  }
  function v(w, E) {
    return E();
  }
  var g = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? v : h;
  return useSyncExternalStoreShim_production_min.useSyncExternalStore = t.useSyncExternalStore !== void 0 ? t.useSyncExternalStore : g, useSyncExternalStoreShim_production_min;
}
var useSyncExternalStoreShim_development = {};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredUseSyncExternalStoreShim_development;
function requireUseSyncExternalStoreShim_development() {
  return hasRequiredUseSyncExternalStoreShim_development || (hasRequiredUseSyncExternalStoreShim_development = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var t = React__default, e = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function n($) {
      {
        for (var S = arguments.length, C = new Array(S > 1 ? S - 1 : 0), D = 1; D < S; D++)
          C[D - 1] = arguments[D];
        o("error", $, C);
      }
    }
    function o($, S, C) {
      {
        var D = e.ReactDebugCurrentFrame, O = D.getStackAddendum();
        O !== "" && (S += "%s", C = C.concat([O]));
        var N = C.map(function(j) {
          return String(j);
        });
        N.unshift("Warning: " + S), Function.prototype.apply.call(console[$], console, N);
      }
    }
    function l($, S) {
      return $ === S && ($ !== 0 || 1 / $ === 1 / S) || $ !== $ && S !== S;
    }
    var u = typeof Object.is == "function" ? Object.is : l, f = t.useState, h = t.useEffect, p = t.useLayoutEffect, v = t.useDebugValue, g = !1, w = !1;
    function E($, S, C) {
      g || t.startTransition !== void 0 && (g = !0, n("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
      var D = S();
      if (!w) {
        var O = S();
        u(D, O) || (n("The result of getSnapshot should be cached to avoid an infinite loop"), w = !0);
      }
      var N = f({
        inst: {
          value: D,
          getSnapshot: S
        }
      }), j = N[0].inst, L = N[1];
      return p(function() {
        j.value = D, j.getSnapshot = S, T(j) && L({
          inst: j
        });
      }, [$, D, S]), h(function() {
        T(j) && L({
          inst: j
        });
        var z = function() {
          T(j) && L({
            inst: j
          });
        };
        return $(z);
      }, [$]), v(D), D;
    }
    function T($) {
      var S = $.getSnapshot, C = $.value;
      try {
        var D = S();
        return !u(C, D);
      } catch {
        return !0;
      }
    }
    function R($, S, C) {
      return S();
    }
    var _ = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", b = !_, M = b ? R : E, A = t.useSyncExternalStore !== void 0 ? t.useSyncExternalStore : M;
    useSyncExternalStoreShim_development.useSyncExternalStore = A, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), useSyncExternalStoreShim_development;
}
var hasRequiredShim;
function requireShim() {
  return hasRequiredShim || (hasRequiredShim = 1, process.env.NODE_ENV === "production" ? shim.exports = requireUseSyncExternalStoreShim_production_min() : shim.exports = requireUseSyncExternalStoreShim_development()), shim.exports;
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredWithSelector_production_min;
function requireWithSelector_production_min() {
  if (hasRequiredWithSelector_production_min) return withSelector_production_min;
  hasRequiredWithSelector_production_min = 1;
  var t = React__default, e = requireShim();
  function n(v, g) {
    return v === g && (v !== 0 || 1 / v === 1 / g) || v !== v && g !== g;
  }
  var o = typeof Object.is == "function" ? Object.is : n, l = e.useSyncExternalStore, u = t.useRef, f = t.useEffect, h = t.useMemo, p = t.useDebugValue;
  return withSelector_production_min.useSyncExternalStoreWithSelector = function(v, g, w, E, T) {
    var R = u(null);
    if (R.current === null) {
      var _ = { hasValue: !1, value: null };
      R.current = _;
    } else _ = R.current;
    R = h(function() {
      function M(D) {
        if (!A) {
          if (A = !0, $ = D, D = E(D), T !== void 0 && _.hasValue) {
            var O = _.value;
            if (T(O, D)) return S = O;
          }
          return S = D;
        }
        if (O = S, o($, D)) return O;
        var N = E(D);
        return T !== void 0 && T(O, N) ? O : ($ = D, S = N);
      }
      var A = !1, $, S, C = w === void 0 ? null : w;
      return [function() {
        return M(g());
      }, C === null ? void 0 : function() {
        return M(C());
      }];
    }, [g, w, E, T]);
    var b = l(v, R[0], R[1]);
    return f(function() {
      _.hasValue = !0, _.value = b;
    }, [b]), p(b), b;
  }, withSelector_production_min;
}
var withSelector_development = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredWithSelector_development;
function requireWithSelector_development() {
  return hasRequiredWithSelector_development || (hasRequiredWithSelector_development = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var t = React__default, e = requireShim();
    function n(g, w) {
      return g === w && (g !== 0 || 1 / g === 1 / w) || g !== g && w !== w;
    }
    var o = typeof Object.is == "function" ? Object.is : n, l = e.useSyncExternalStore, u = t.useRef, f = t.useEffect, h = t.useMemo, p = t.useDebugValue;
    function v(g, w, E, T, R) {
      var _ = u(null), b;
      _.current === null ? (b = {
        hasValue: !1,
        value: null
      }, _.current = b) : b = _.current;
      var M = h(function() {
        var C = !1, D, O, N = function(G) {
          if (!C) {
            C = !0, D = G;
            var B = T(G);
            if (R !== void 0 && b.hasValue) {
              var F = b.value;
              if (R(F, B))
                return O = F, F;
            }
            return O = B, B;
          }
          var H = D, W = O;
          if (o(H, G))
            return W;
          var V = T(G);
          return R !== void 0 && R(W, V) ? W : (D = G, O = V, V);
        }, j = E === void 0 ? null : E, L = function() {
          return N(w());
        }, z = j === null ? void 0 : function() {
          return N(j());
        };
        return [L, z];
      }, [w, E, T, R]), A = M[0], $ = M[1], S = l(g, A, $);
      return f(function() {
        b.hasValue = !0, b.value = S;
      }, [S]), p(S), S;
    }
    withSelector_development.useSyncExternalStoreWithSelector = v, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), withSelector_development;
}
process.env.NODE_ENV === "production" ? withSelector.exports = requireWithSelector_production_min() : withSelector.exports = requireWithSelector_development();
var withSelectorExports = withSelector.exports;
const useSyncExternalStoreExports = /* @__PURE__ */ getDefaultExportFromCjs(withSelectorExports), __vite_import_meta_env__ = { BASE_URL: "/", DEV: !1, MODE: "production", PROD: !0, SSR: !1 }, { useDebugValue: useDebugValue$1 } = React__default, { useSyncExternalStoreWithSelector: useSyncExternalStoreWithSelector$1 } = useSyncExternalStoreExports;
let didWarnAboutEqualityFn = !1;
const identity$f = (t) => t;
function useStore$1(t, e = identity$f, n) {
  (__vite_import_meta_env__ ? "production" : void 0) !== "production" && n && !didWarnAboutEqualityFn && (console.warn(
    "[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"
  ), didWarnAboutEqualityFn = !0);
  const o = useSyncExternalStoreWithSelector$1(
    t.subscribe,
    t.getState,
    t.getServerState || t.getInitialState,
    e,
    n
  );
  return useDebugValue$1(o), o;
}
const createImpl = (t) => {
  (__vite_import_meta_env__ ? "production" : void 0) !== "production" && typeof t != "function" && console.warn(
    "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
  );
  const e = typeof t == "function" ? createStore(t) : t, n = (o, l) => useStore$1(e, o, l);
  return Object.assign(n, e), n;
}, create$1 = (t) => t ? createImpl(t) : createImpl;
function r(t) {
  var e, n, o = "";
  if (typeof t == "string" || typeof t == "number") o += t;
  else if (typeof t == "object") if (Array.isArray(t)) {
    var l = t.length;
    for (e = 0; e < l; e++) t[e] && (n = r(t[e])) && (o && (o += " "), o += n);
  } else for (n in t) t[n] && (o && (o += " "), o += n);
  return o;
}
function clsx() {
  for (var t, e, n = 0, o = "", l = arguments.length; n < l; n++) (t = arguments[n]) && (e = r(t)) && (o && (o += " "), o += e);
  return o;
}
const lightColorspace = {
  scheme: "Light Theme",
  author: "mac gainor (https://github.com/mac-s-g)",
  base00: "rgba(0, 0, 0, 0)",
  base01: "rgb(245, 245, 245)",
  base02: "rgb(235, 235, 235)",
  base03: "#93a1a1",
  base04: "rgba(0, 0, 0, 0.3)",
  base05: "#586e75",
  base06: "#073642",
  base07: "#002b36",
  base08: "#d33682",
  base09: "#cb4b16",
  base0A: "#ffd500",
  base0B: "#859900",
  base0C: "#6c71c4",
  base0D: "#586e75",
  base0E: "#2aa198",
  base0F: "#268bd2"
}, darkColorspace = {
  scheme: "Dark Theme",
  author: "Chris Kempson (http://chriskempson.com)",
  base00: "#181818",
  base01: "#282828",
  base02: "#383838",
  base03: "#585858",
  base04: "#b8b8b8",
  base05: "#d8d8d8",
  base06: "#e8e8e8",
  base07: "#f8f8f8",
  base08: "#ab4642",
  base09: "#dc9656",
  base0A: "#f7ca88",
  base0B: "#a1b56c",
  base0C: "#86c1b9",
  base0D: "#7cafc2",
  base0E: "#ba8baf",
  base0F: "#a16946"
}, DefaultKeyRenderer = () => null;
DefaultKeyRenderer.when = () => !1;
const createJsonViewerStore = (t) => create$1()((e, n) => {
  var o, l, u, f, h, p, v, g, w, E, T, R, _, b, M, A, $, S, C, D, O, N;
  return {
    // provided by user
    rootName: (o = t.rootName) !== null && o !== void 0 ? o : "root",
    indentWidth: (l = t.indentWidth) !== null && l !== void 0 ? l : 3,
    keyRenderer: (u = t.keyRenderer) !== null && u !== void 0 ? u : DefaultKeyRenderer,
    enableAdd: (f = t.enableAdd) !== null && f !== void 0 ? f : !1,
    enableDelete: (h = t.enableDelete) !== null && h !== void 0 ? h : !1,
    enableClipboard: (p = t.enableClipboard) !== null && p !== void 0 ? p : !0,
    editable: (v = t.editable) !== null && v !== void 0 ? v : !1,
    onChange: (g = t.onChange) !== null && g !== void 0 ? g : () => {
    },
    onCopy: (w = t.onCopy) !== null && w !== void 0 ? w : void 0,
    onSelect: (E = t.onSelect) !== null && E !== void 0 ? E : void 0,
    onAdd: (T = t.onAdd) !== null && T !== void 0 ? T : void 0,
    onDelete: (R = t.onDelete) !== null && R !== void 0 ? R : void 0,
    defaultInspectDepth: (_ = t.defaultInspectDepth) !== null && _ !== void 0 ? _ : 5,
    defaultInspectControl: (b = t.defaultInspectControl) !== null && b !== void 0 ? b : void 0,
    maxDisplayLength: (M = t.maxDisplayLength) !== null && M !== void 0 ? M : 30,
    groupArraysAfterLength: (A = t.groupArraysAfterLength) !== null && A !== void 0 ? A : 100,
    collapseStringsAfterLength: t.collapseStringsAfterLength === !1 ? Number.MAX_VALUE : ($ = t.collapseStringsAfterLength) !== null && $ !== void 0 ? $ : 50,
    objectSortKeys: (S = t.objectSortKeys) !== null && S !== void 0 ? S : !1,
    quotesOnKeys: (C = t.quotesOnKeys) !== null && C !== void 0 ? C : !0,
    displayDataTypes: (D = t.displayDataTypes) !== null && D !== void 0 ? D : !0,
    displaySize: (O = t.displaySize) !== null && O !== void 0 ? O : !0,
    highlightUpdates: (N = t.highlightUpdates) !== null && N !== void 0 ? N : !1,
    // internal state
    inspectCache: {},
    hoverPath: null,
    colorspace: lightColorspace,
    value: t.value,
    prevValue: void 0,
    getInspectCache: (j, L) => {
      const z = L !== void 0 ? j.join(".") + "[".concat(L, "]nt") : j.join(".");
      return n().inspectCache[z];
    },
    setInspectCache: (j, L, z) => {
      const G = z !== void 0 ? j.join(".") + "[".concat(z, "]nt") : j.join(".");
      e((B) => ({
        inspectCache: {
          ...B.inspectCache,
          [G]: typeof L == "function" ? L(B.inspectCache[G]) : L
        }
      }));
    },
    setHover: (j, L) => {
      e({
        hoverPath: j ? {
          path: j,
          nestedIndex: L
        } : null
      });
    }
  };
}), JsonViewerStoreContext = createContext(void 0);
JsonViewerStoreContext.Provider;
const useJsonViewerStore = (t, e) => {
  const n = useContext(JsonViewerStoreContext);
  return useStore$1(n, t, e);
}, useTextColor = () => useJsonViewerStore((t) => t.colorspace.base07), objectCtorString$1 = Object.prototype.constructor.toString();
function isPlainObject$2(t) {
  if (!t || typeof t != "object") return !1;
  const e = Object.getPrototypeOf(t);
  if (e === null) return !0;
  const n = Object.hasOwnProperty.call(e, "constructor") && e.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === objectCtorString$1;
}
const isCycleReference = (t, e, n) => {
  if (t === null || n === null || typeof t != "object" || typeof n != "object")
    return !1;
  if (Object.is(t, n) && e.length !== 0)
    return "";
  const o = [], l = [
    ...e
  ];
  let u = t;
  for (; u !== n || l.length !== 0; ) {
    if (typeof u != "object" || u === null)
      return !1;
    if (Object.is(u, n))
      return o.reduce((h, p, v) => typeof p == "number" ? h + "[".concat(p, "]") : h + "".concat(v === 0 ? "" : ".").concat(p), "");
    const f = l.shift();
    o.push(f), u = u[f];
  }
  return !1;
};
function getValueSize(t) {
  return t === null ? 0 : Array.isArray(t) ? t.length : t instanceof Map || t instanceof Set ? t.size : t instanceof Date ? 1 : typeof t == "object" ? Object.keys(t).length : typeof t == "string" ? t.length : 1;
}
function segmentArray(t, e) {
  const n = [];
  let o = 0;
  for (; o < t.length; )
    n.push(t.slice(o, o + e)), o += e;
  return n;
}
function safeStringify(t, e) {
  const n = [];
  function o(l, u) {
    if (typeof u == "bigint") return u.toString();
    if (u instanceof Map) {
      if ("toJSON" in u && typeof u.toJSON == "function") return u.toJSON();
      if (u.size === 0) return {};
      if (n.includes(u)) return "[Circular]";
      n.push(u);
      const f = Array.from(u.entries());
      return f.every((h) => {
        let [p] = h;
        return typeof p == "string" || typeof p == "number";
      }) ? Object.fromEntries(f) : {};
    }
    if (u instanceof Set)
      return "toJSON" in u && typeof u.toJSON == "function" ? u.toJSON() : n.includes(u) ? "[Circular]" : (n.push(u), Array.from(u.values()));
    if (typeof u == "object" && u !== null && Object.keys(u).length) {
      const f = n.length;
      if (f) {
        for (let h = f - 1; h >= 0 && n[h][l] !== u; --h)
          n.pop();
        if (n.includes(u)) return "[Circular]";
      }
      n.push(u);
    }
    return u;
  }
  return JSON.stringify(t, o, e);
}
async function copyString(t) {
  if ("clipboard" in navigator)
    try {
      await navigator.clipboard.writeText(t);
    } catch {
    }
  copyToClipboard$1(t);
}
function useClipboard() {
  let { timeout: t = 2e3 } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const [e, n] = useState(!1), o = useRef(null), l = useCallback((p) => {
    const v = o.current;
    v && window.clearTimeout(v), o.current = window.setTimeout(() => n(!1), t), n(p);
  }, [
    t
  ]), u = useJsonViewerStore((p) => p.onCopy), f = useCallback(async (p, v) => {
    if (typeof u == "function")
      try {
        await u(p, v, copyString), l(!0);
      } catch (g) {
        console.error("error when copy ".concat(p.length === 0 ? "src" : "src[".concat(p.join(".")), "]"), g);
      }
    else
      try {
        const g = safeStringify(typeof v == "function" ? v.toString() : v, "  ");
        await copyString(g), l(!0);
      } catch (g) {
        console.error("error when copy ".concat(p.length === 0 ? "src" : "src[".concat(p.join(".")), "]"), g);
      }
  }, [
    l,
    u
  ]), h = useCallback(() => {
    n(!1), o.current && clearTimeout(o.current);
  }, []);
  return {
    copy: f,
    reset: h,
    copied: e
  };
}
function useIsCycleReference(t, e) {
  const n = useJsonViewerStore((o) => o.value);
  return useMemo(() => isCycleReference(n, t, e), [
    t,
    e,
    n
  ]);
}
function useInspect(t, e, n) {
  const o = t.length, l = useIsCycleReference(t, e), u = useJsonViewerStore((E) => E.getInspectCache), f = useJsonViewerStore((E) => E.setInspectCache), h = useJsonViewerStore((E) => E.defaultInspectDepth), p = useJsonViewerStore((E) => E.defaultInspectControl);
  useEffect(() => {
    if (u(t, n) !== void 0)
      return;
    if (n !== void 0) {
      f(t, !1, n);
      return;
    }
    const T = l ? !1 : typeof p == "function" ? p(t, e) : o < h;
    f(t, T);
  }, [
    h,
    p,
    o,
    u,
    l,
    n,
    t,
    e,
    f
  ]);
  const [v, g] = useState(() => {
    const E = u(t, n);
    return E !== void 0 ? E : n !== void 0 || l ? !1 : typeof p == "function" ? p(t, e) : o < h;
  }), w = useCallback((E) => {
    g((T) => {
      const R = typeof E == "boolean" ? E : E(T);
      return f(t, R, n), R;
    });
  }, [
    n,
    t,
    f
  ]);
  return [
    v,
    w
  ];
}
const DataBox = (t) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(Box, {
  component: "div",
  ...t,
  sx: {
    display: "inline-block",
    ...t.sx
  }
}), DataTypeLabel = (t) => {
  let { dataType: e, enable: n = !0 } = t;
  return n ? /* @__PURE__ */ jsxRuntimeExports$1.jsx(DataBox, {
    className: "data-type-label",
    sx: {
      mx: 0.5,
      fontSize: "0.7rem",
      opacity: 0.8,
      userSelect: "none"
    },
    children: e
  }) : null;
};
function defineEasyType(t) {
  let { is: e, serialize: n, deserialize: o, type: l, colorKey: u, displayTypeLabel: f = !0, Renderer: h } = t;
  const p = /* @__PURE__ */ memo$1(h), v = (w) => {
    const E = useJsonViewerStore((_) => _.displayDataTypes), T = useJsonViewerStore((_) => _.colorspace[u]), R = useJsonViewerStore((_) => _.onSelect);
    return /* @__PURE__ */ jsxRuntimeExports$1.jsxs(DataBox, {
      onClick: () => R == null ? void 0 : R(w.path, w.value),
      sx: {
        color: T
      },
      children: [
        f && E && /* @__PURE__ */ jsxRuntimeExports$1.jsx(DataTypeLabel, {
          dataType: l
        }),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(DataBox, {
          className: "".concat(l, "-value"),
          children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(p, {
            path: w.path,
            inspect: w.inspect,
            setInspect: w.setInspect,
            value: w.value,
            prevValue: w.prevValue
          })
        })
      ]
    });
  };
  if (v.displayName = "easy-".concat(l, "-type"), !n || !o)
    return {
      is: e,
      Component: v
    };
  const g = (w) => {
    let { value: E, setValue: T, abortEditing: R, commitEditing: _ } = w;
    const b = useJsonViewerStore(($) => $.colorspace[u]), M = useCallback(($) => {
      $.key === "Enter" && ($.preventDefault(), _(E)), $.key === "Escape" && ($.preventDefault(), R());
    }, [
      R,
      _,
      E
    ]), A = useCallback(($) => {
      T($.target.value);
    }, [
      T
    ]);
    return /* @__PURE__ */ jsxRuntimeExports$1.jsx(InputBase, {
      autoFocus: !0,
      value: E,
      onChange: A,
      onKeyDown: M,
      size: "small",
      multiline: !0,
      sx: {
        color: b,
        padding: 0.5,
        borderStyle: "solid",
        borderColor: "black",
        borderWidth: 1,
        fontSize: "0.8rem",
        fontFamily: "monospace",
        display: "inline-flex"
      }
    });
  };
  return g.displayName = "easy-".concat(l, "-type-editor"), {
    is: e,
    serialize: n,
    deserialize: o,
    Component: v,
    Editor: g
  };
}
const booleanType = defineEasyType({
  is: (t) => typeof t == "boolean",
  type: "bool",
  colorKey: "base0E",
  serialize: (t) => t.toString(),
  deserialize: (t) => {
    if (t === "true") return !0;
    if (t === "false") return !1;
    throw new Error("Invalid boolean value");
  },
  Renderer: (t) => {
    let { value: e } = t;
    return /* @__PURE__ */ jsxRuntimeExports$1.jsx(jsxRuntimeExports$1.Fragment, {
      children: e ? "true" : "false"
    });
  }
}), displayOptions = {
  weekday: "short",
  year: "numeric",
  month: "short",
  day: "numeric",
  hour: "2-digit",
  minute: "2-digit"
}, dateType = defineEasyType({
  is: (t) => t instanceof Date,
  type: "date",
  colorKey: "base0D",
  Renderer: (t) => {
    let { value: e } = t;
    return /* @__PURE__ */ jsxRuntimeExports$1.jsx(jsxRuntimeExports$1.Fragment, {
      children: e.toLocaleTimeString("en-us", displayOptions)
    });
  }
}), functionBody = (t) => {
  const e = t.toString();
  let n = !0;
  const o = e.indexOf(")"), l = e.indexOf("=>");
  return l !== -1 && l > o && (n = !1), n ? e.substring(e.indexOf("{", o) + 1, e.lastIndexOf("}")) : e.substring(e.indexOf("=>") + 2);
}, functionName = (t) => {
  const e = t.toString();
  return e.indexOf("function") !== -1 ? e.substring(8, e.indexOf("{")).trim() : e.substring(0, e.indexOf("=>") + 2).trim();
}, lb = "{", rb = "}", PreFunctionType = (t) => /* @__PURE__ */ jsxRuntimeExports$1.jsxs(NoSsr, {
  children: [
    /* @__PURE__ */ jsxRuntimeExports$1.jsx(DataTypeLabel, {
      dataType: "function"
    }),
    /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, {
      component: "span",
      className: "data-function-start",
      sx: {
        letterSpacing: 0.5
      },
      children: [
        functionName(t.value),
        " ",
        lb
      ]
    })
  ]
}), PostFunctionType = () => /* @__PURE__ */ jsxRuntimeExports$1.jsx(NoSsr, {
  children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(Box, {
    component: "span",
    className: "data-function-end",
    children: rb
  })
}), FunctionType = (t) => {
  const e = useJsonViewerStore((n) => n.colorspace.base05);
  return /* @__PURE__ */ jsxRuntimeExports$1.jsx(NoSsr, {
    children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(Box, {
      className: "data-function",
      sx: {
        display: t.inspect ? "block" : "inline-block",
        pl: t.inspect ? 2 : 0,
        color: e
      },
      children: t.inspect ? functionBody(t.value) : /* @__PURE__ */ jsxRuntimeExports$1.jsx(Box, {
        component: "span",
        className: "data-function-body",
        onClick: () => t.setInspect(!0),
        sx: {
          "&:hover": {
            cursor: "pointer"
          },
          padding: 0.5
        },
        children: "…"
      })
    })
  });
}, functionType = {
  is: (t) => typeof t == "function",
  Component: FunctionType,
  PreComponent: PreFunctionType,
  PostComponent: PostFunctionType
}, nullType = defineEasyType({
  is: (t) => t === null,
  type: "null",
  colorKey: "base08",
  displayTypeLabel: !1,
  Renderer: () => {
    const t = useJsonViewerStore((e) => e.colorspace.base02);
    return /* @__PURE__ */ jsxRuntimeExports$1.jsx(Box, {
      sx: {
        fontSize: "0.8rem",
        backgroundColor: t,
        fontWeight: "bold",
        borderRadius: "3px",
        padding: "0.5px 2px"
      },
      children: "NULL"
    });
  }
}), isInt = (t) => t % 1 === 0, nanType = defineEasyType({
  is: (t) => typeof t == "number" && isNaN(t),
  type: "NaN",
  colorKey: "base08",
  displayTypeLabel: !1,
  serialize: () => "NaN",
  // allow deserialize the value back to number
  deserialize: (t) => parseFloat(t),
  Renderer: () => {
    const t = useJsonViewerStore((e) => e.colorspace.base02);
    return /* @__PURE__ */ jsxRuntimeExports$1.jsx(Box, {
      sx: {
        backgroundColor: t,
        fontSize: "0.8rem",
        fontWeight: "bold",
        borderRadius: "3px",
        padding: "0.5px 2px"
      },
      children: "NaN"
    });
  }
}), floatType = defineEasyType({
  is: (t) => typeof t == "number" && !isInt(t) && !isNaN(t),
  type: "float",
  colorKey: "base0B",
  serialize: (t) => t.toString(),
  deserialize: (t) => parseFloat(t),
  Renderer: (t) => {
    let { value: e } = t;
    return /* @__PURE__ */ jsxRuntimeExports$1.jsx(jsxRuntimeExports$1.Fragment, {
      children: e
    });
  }
}), intType = defineEasyType({
  is: (t) => typeof t == "number" && isInt(t),
  type: "int",
  colorKey: "base0F",
  serialize: (t) => t.toString(),
  // allow deserialize the value to float
  deserialize: (t) => parseFloat(t),
  Renderer: (t) => {
    let { value: e } = t;
    return /* @__PURE__ */ jsxRuntimeExports$1.jsx(jsxRuntimeExports$1.Fragment, {
      children: e
    });
  }
}), bigIntType = defineEasyType({
  is: (t) => typeof t == "bigint",
  type: "bigint",
  colorKey: "base0F",
  serialize: (t) => t.toString(),
  deserialize: (t) => BigInt(t.replace(/\D/g, "")),
  Renderer: (t) => {
    let { value: e } = t;
    return /* @__PURE__ */ jsxRuntimeExports$1.jsx(jsxRuntimeExports$1.Fragment, {
      children: "".concat(e, "n")
    });
  }
}), BaseIcon = (t) => {
  let { d: e, ...n } = t;
  return /* @__PURE__ */ jsxRuntimeExports$1.jsx(SvgIcon, {
    ...n,
    children: /* @__PURE__ */ jsxRuntimeExports$1.jsx("path", {
      d: e
    })
  });
}, AddBox = "M19 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2m0 16H5V5h14zm-8-2h2v-4h4v-2h-4V7h-2v4H7v2h4z", Check = "M9 16.17 4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z", ChevronRight = "M10 6 8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z", CircularArrows = "M 12 2 C 10.615 1.998 9.214625 2.2867656 7.890625 2.8847656 L 8.9003906 4.6328125 C 9.9043906 4.2098125 10.957 3.998 12 4 C 15.080783 4 17.738521 5.7633175 19.074219 8.3222656 L 17.125 9 L 21.25 11 L 22.875 7 L 20.998047 7.6523438 C 19.377701 4.3110398 15.95585 2 12 2 z M 6.5097656 4.4882812 L 2.2324219 5.0820312 L 3.734375 6.3808594 C 1.6515335 9.4550558 1.3615962 13.574578 3.3398438 17 C 4.0308437 18.201 4.9801562 19.268234 6.1601562 20.115234 L 7.1699219 18.367188 C 6.3019219 17.710187 5.5922656 16.904 5.0722656 16 C 3.5320014 13.332354 3.729203 10.148679 5.2773438 7.7128906 L 6.8398438 9.0625 L 6.5097656 4.4882812 z M 19.929688 13 C 19.794687 14.08 19.450734 15.098 18.927734 16 C 17.386985 18.668487 14.531361 20.090637 11.646484 19.966797 L 12.035156 17.9375 L 8.2402344 20.511719 L 10.892578 23.917969 L 11.265625 21.966797 C 14.968963 22.233766 18.681899 20.426323 20.660156 17 C 21.355156 15.801 21.805219 14.445 21.949219 13 L 19.929688 13 z", Close = "M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z", ContentCopy = "M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z", Edit = "M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34a.9959.9959 0 0 0-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z", ExpandMore = "M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6z", Delete = "M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6zM8 9h8v10H8zm7.5-5l-1-1h-5l-1 1H5v2h14V4z", AddBoxIcon = (t) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(BaseIcon, {
  d: AddBox,
  ...t
}), CheckIcon = (t) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(BaseIcon, {
  d: Check,
  ...t
}), ChevronRightIcon = (t) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(BaseIcon, {
  d: ChevronRight,
  ...t
}), CircularArrowsIcon = (t) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(BaseIcon, {
  d: CircularArrows,
  ...t
}), CloseIcon = (t) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(BaseIcon, {
  d: Close,
  ...t
}), ContentCopyIcon = (t) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(BaseIcon, {
  d: ContentCopy,
  ...t
}), EditIcon = (t) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(BaseIcon, {
  d: Edit,
  ...t
}), ExpandMoreIcon = (t) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(BaseIcon, {
  d: ExpandMore,
  ...t
}), DeleteIcon = (t) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(BaseIcon, {
  d: Delete,
  ...t
}), objectLb = "{", arrayLb = "[", objectRb = "}", arrayRb = "]";
function inspectMetadata(t) {
  const e = getValueSize(t);
  let n = "";
  return (t instanceof Map || t instanceof Set) && (n = t[Symbol.toStringTag]), Object.prototype.hasOwnProperty.call(t, Symbol.toStringTag) && (n = t[Symbol.toStringTag]), "".concat(e, " Items").concat(n ? " (".concat(n, ")") : "");
}
const PreObjectType = (t) => {
  const e = useJsonViewerStore((v) => v.colorspace.base04), n = useTextColor(), o = useMemo(() => Array.isArray(t.value), [
    t.value
  ]), l = useMemo(() => getValueSize(t.value) === 0, [
    t.value
  ]), u = useMemo(() => inspectMetadata(t.value), [
    t.value
  ]), f = useJsonViewerStore((v) => v.displaySize), h = useMemo(() => typeof f == "function" ? f(t.path, t.value) : f, [
    f,
    t.path,
    t.value
  ]), p = useIsCycleReference(t.path, t.value);
  return /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, {
    component: "span",
    className: "data-object-start",
    sx: {
      letterSpacing: 0.5
    },
    children: [
      o ? arrayLb : objectLb,
      h && t.inspect && !l && /* @__PURE__ */ jsxRuntimeExports$1.jsx(Box, {
        component: "span",
        sx: {
          pl: 0.5,
          fontStyle: "italic",
          color: e,
          userSelect: "none"
        },
        children: u
      }),
      p && !t.inspect && /* @__PURE__ */ jsxRuntimeExports$1.jsxs(jsxRuntimeExports$1.Fragment, {
        children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(CircularArrowsIcon, {
            sx: {
              fontSize: 12,
              color: n,
              mx: 0.5
            }
          }),
          p
        ]
      })
    ]
  });
}, PostObjectType = (t) => {
  const e = useJsonViewerStore((p) => p.colorspace.base04), n = useTextColor(), o = useMemo(() => Array.isArray(t.value), [
    t.value
  ]), l = useMemo(() => getValueSize(t.value) === 0, [
    t.value
  ]), u = useMemo(() => inspectMetadata(t.value), [
    t.value
  ]), f = useJsonViewerStore((p) => p.displaySize), h = useMemo(() => typeof f == "function" ? f(t.path, t.value) : f, [
    f,
    t.path,
    t.value
  ]);
  return /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, {
    component: "span",
    className: "data-object-end",
    sx: {
      lineHeight: 1.5,
      color: n,
      letterSpacing: 0.5,
      opacity: 0.8
    },
    children: [
      o ? arrayRb : objectRb,
      h && (l || !t.inspect) ? /* @__PURE__ */ jsxRuntimeExports$1.jsx(Box, {
        component: "span",
        sx: {
          pl: 0.5,
          fontStyle: "italic",
          color: e,
          userSelect: "none"
        },
        children: u
      }) : null
    ]
  });
};
function getIterator(t) {
  return typeof (t == null ? void 0 : t[Symbol.iterator]) == "function";
}
const ObjectType = (t) => {
  const e = useTextColor(), n = useJsonViewerStore((T) => T.colorspace.base02), o = useJsonViewerStore((T) => T.groupArraysAfterLength), l = useIsCycleReference(t.path, t.value), [u, f] = useState(useJsonViewerStore((T) => T.maxDisplayLength)), h = useJsonViewerStore((T) => T.objectSortKeys), p = useMemo(() => {
    if (!t.inspect)
      return null;
    const T = t.value;
    if (getIterator(T) && !Array.isArray(T)) {
      const M = [];
      if (T instanceof Map)
        T.forEach((A, $) => {
          const S = $.toString(), C = [
            ...t.path,
            S
          ];
          M.push(/* @__PURE__ */ jsxRuntimeExports$1.jsx(DataKeyPair, {
            path: C,
            value: A,
            prevValue: t.prevValue instanceof Map ? t.prevValue.get($) : void 0,
            editable: !1
          }, S));
        });
      else {
        const A = T[Symbol.iterator]();
        let $ = A.next(), S = 0;
        for (; !$.done; )
          M.push(/* @__PURE__ */ jsxRuntimeExports$1.jsx(DataKeyPair, {
            path: [
              ...t.path,
              "iterator:".concat(S)
            ],
            value: $.value,
            nestedIndex: S,
            editable: !1
          }, S)), S++, $ = A.next();
      }
      return M;
    }
    if (Array.isArray(T)) {
      if (T.length <= o) {
        const $ = T.slice(0, u).map((S, C) => {
          const D = t.nestedIndex ? t.nestedIndex * o + C : C, O = [
            ...t.path,
            D
          ];
          return /* @__PURE__ */ jsxRuntimeExports$1.jsx(DataKeyPair, {
            path: O,
            value: S,
            prevValue: Array.isArray(t.prevValue) ? t.prevValue[D] : void 0
          }, D);
        });
        if (T.length > u) {
          const S = T.length - u;
          $.push(/* @__PURE__ */ jsxRuntimeExports$1.jsxs(DataBox, {
            sx: {
              cursor: "pointer",
              lineHeight: 1.5,
              color: e,
              letterSpacing: 0.5,
              opacity: 0.8,
              userSelect: "none"
            },
            onClick: () => f((C) => C * 2),
            children: [
              "hidden ",
              S,
              " items…"
            ]
          }, "last"));
        }
        return $;
      }
      const M = segmentArray(T, o), A = Array.isArray(t.prevValue) ? segmentArray(t.prevValue, o) : void 0;
      return M.map(($, S) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(DataKeyPair, {
        path: t.path,
        value: $,
        nestedIndex: S,
        prevValue: A == null ? void 0 : A[S]
      }, S));
    }
    let _ = Object.entries(T);
    h && (_ = h === !0 ? _.sort((M, A) => {
      let [$] = M, [S] = A;
      return $.localeCompare(S);
    }) : _.sort((M, A) => {
      let [$] = M, [S] = A;
      return h($, S);
    }));
    const b = _.slice(0, u).map((M) => {
      let [A, $] = M;
      var S;
      const C = [
        ...t.path,
        A
      ];
      return /* @__PURE__ */ jsxRuntimeExports$1.jsx(DataKeyPair, {
        path: C,
        value: $,
        prevValue: (S = t.prevValue) === null || S === void 0 ? void 0 : S[A]
      }, A);
    });
    if (_.length > u) {
      const M = _.length - u;
      b.push(/* @__PURE__ */ jsxRuntimeExports$1.jsxs(DataBox, {
        sx: {
          cursor: "pointer",
          lineHeight: 1.5,
          color: e,
          letterSpacing: 0.5,
          opacity: 0.8,
          userSelect: "none"
        },
        onClick: () => f((A) => A * 2),
        children: [
          "hidden ",
          M,
          " items…"
        ]
      }, "last"));
    }
    return b;
  }, [
    t.inspect,
    t.value,
    t.prevValue,
    t.path,
    t.nestedIndex,
    o,
    u,
    e,
    h
  ]), v = t.inspect ? 0.6 : 0, g = useJsonViewerStore((T) => T.indentWidth), w = t.inspect ? g - v : g;
  return useMemo(() => getValueSize(t.value) === 0, [
    t.value
  ]) ? null : /* @__PURE__ */ jsxRuntimeExports$1.jsx(Box, {
    className: "data-object",
    sx: {
      display: t.inspect ? "block" : "inline-block",
      pl: t.inspect ? w - 0.6 : 0,
      marginLeft: v,
      color: e,
      borderLeft: t.inspect ? "1px solid ".concat(n) : "none"
    },
    children: t.inspect ? p : !l && /* @__PURE__ */ jsxRuntimeExports$1.jsx(Box, {
      component: "span",
      className: "data-object-body",
      onClick: () => t.setInspect(!0),
      sx: {
        "&:hover": {
          cursor: "pointer"
        },
        padding: 0.5,
        userSelect: "none"
      },
      children: "…"
    })
  });
}, objectType = {
  is: (t) => typeof t == "object",
  Component: ObjectType,
  PreComponent: PreObjectType,
  PostComponent: PostObjectType
}, stringType = defineEasyType({
  is: (t) => typeof t == "string",
  type: "string",
  colorKey: "base09",
  serialize: (t) => t,
  deserialize: (t) => t,
  Renderer: (t) => {
    const [e, n] = useState(!1), o = useJsonViewerStore((f) => f.collapseStringsAfterLength), l = e ? t.value : t.value.slice(0, o), u = t.value.length > o;
    return /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, {
      component: "span",
      sx: {
        overflowWrap: "anywhere",
        cursor: u ? "pointer" : "inherit"
      },
      onClick: () => {
        var f;
        ((f = window.getSelection()) === null || f === void 0 ? void 0 : f.type) !== "Range" && u && n((h) => !h);
      },
      children: [
        '"',
        l,
        u && !e && /* @__PURE__ */ jsxRuntimeExports$1.jsx(Box, {
          component: "span",
          sx: {
            padding: 0.5
          },
          children: "…"
        }),
        '"'
      ]
    });
  }
}), undefinedType = defineEasyType({
  is: (t) => t === void 0,
  type: "undefined",
  colorKey: "base05",
  displayTypeLabel: !1,
  Renderer: () => {
    const t = useJsonViewerStore((e) => e.colorspace.base02);
    return /* @__PURE__ */ jsxRuntimeExports$1.jsx(Box, {
      sx: {
        fontSize: "0.7rem",
        backgroundColor: t,
        borderRadius: "3px",
        padding: "0.5px 2px"
      },
      children: "undefined"
    });
  }
});
function memorizeDataType(t) {
  function e(n, o) {
    var l, u;
    return Object.is(n.value, o.value) && n.inspect && o.inspect && ((l = n.path) === null || l === void 0 ? void 0 : l.join(".")) === ((u = o.path) === null || u === void 0 ? void 0 : u.join("."));
  }
  return t.Component = /* @__PURE__ */ memo$1(t.Component, e), t.Editor && (t.Editor = /* @__PURE__ */ memo$1(t.Editor, function(o, l) {
    return Object.is(o.value, l.value);
  })), t.PreComponent && (t.PreComponent = /* @__PURE__ */ memo$1(t.PreComponent, e)), t.PostComponent && (t.PostComponent = /* @__PURE__ */ memo$1(t.PostComponent, e)), t;
}
const predefinedTypes = [
  memorizeDataType(booleanType),
  memorizeDataType(dateType),
  memorizeDataType(nullType),
  memorizeDataType(undefinedType),
  memorizeDataType(stringType),
  memorizeDataType(functionType),
  memorizeDataType(nanType),
  memorizeDataType(intType),
  memorizeDataType(floatType),
  memorizeDataType(bigIntType)
], createTypeRegistryStore = () => createStore()((t) => ({
  registry: predefinedTypes,
  registerTypes: (e) => {
    t((n) => ({
      registry: typeof e == "function" ? e(n.registry) : e
    }));
  }
})), TypeRegistryStoreContext = /* @__PURE__ */ createContext(void 0);
TypeRegistryStoreContext.Provider;
const useTypeRegistryStore = (t, e) => {
  const n = useContext(TypeRegistryStoreContext);
  return useStore$1(n, t, e);
};
function matchTypeComponents(t, e, n) {
  let o;
  for (const l of n)
    l.is(t, e) && (o = l);
  if (o === void 0) {
    if (typeof t == "object")
      return objectType;
    throw new Error("No type matched for value: ".concat(t));
  }
  return o;
}
function useTypeComponents(t, e) {
  const n = useTypeRegistryStore((o) => o.registry);
  return useMemo(() => matchTypeComponents(t, e, n), [
    t,
    e,
    n
  ]);
}
const IconBox = (t) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(Box, {
  component: "span",
  ...t,
  sx: {
    cursor: "pointer",
    paddingLeft: "0.7rem",
    ...t.sx
  }
}), DataKeyPair = (t) => {
  const { value: e, prevValue: n, path: o, nestedIndex: l } = t, { Component: u, PreComponent: f, PostComponent: h, Editor: p, serialize: v, deserialize: g } = useTypeComponents(e, o);
  var w;
  const E = (w = t.editable) !== null && w !== void 0 ? w : void 0, T = useJsonViewerStore((Ue) => Ue.editable), R = useMemo(() => T === !1 || E === !1 ? !1 : typeof T == "function" ? !!T(o, e) : T, [
    o,
    E,
    T,
    e
  ]), [_, b] = useState(""), M = o.length, A = o[M - 1], $ = useJsonViewerStore((Ue) => Ue.hoverPath), S = useMemo(() => $ && o.every((Ue, Qe) => Ue === $.path[Qe] && l === $.nestedIndex), [
    $,
    o,
    l
  ]), C = useJsonViewerStore((Ue) => Ue.setHover), D = useJsonViewerStore((Ue) => Ue.value), [O, N] = useInspect(o, e, l), [j, L] = useState(!1), z = useJsonViewerStore((Ue) => Ue.onChange), G = useTextColor(), B = useJsonViewerStore((Ue) => Ue.colorspace.base0C), F = useJsonViewerStore((Ue) => Ue.colorspace.base0A), H = useJsonViewerStore((Ue) => Ue.quotesOnKeys), W = useJsonViewerStore((Ue) => Ue.rootName), V = D === e, X = Number.isInteger(Number(A)), Z = useJsonViewerStore((Ue) => Ue.enableAdd), Q = useJsonViewerStore((Ue) => Ue.onAdd), q = useMemo(() => !Q || l !== void 0 || Z === !1 || E === !1 ? !1 : typeof Z == "function" ? !!Z(o, e) : !!(Array.isArray(e) || isPlainObject$2(e)), [
    Q,
    l,
    o,
    Z,
    E,
    e
  ]), J = useJsonViewerStore((Ue) => Ue.enableDelete), ie = useJsonViewerStore((Ue) => Ue.onDelete), ne = useMemo(() => !ie || l !== void 0 || V || J === !1 || E === !1 ? !1 : typeof J == "function" ? !!J(o, e) : J, [
    ie,
    l,
    V,
    o,
    J,
    E,
    e
  ]), ge = useJsonViewerStore((Ue) => Ue.enableClipboard), { copy: ye, copied: xe } = useClipboard(), we = useJsonViewerStore((Ue) => Ue.highlightUpdates), de = useMemo(() => !we || n === void 0 ? !1 : typeof e != typeof n ? !0 : typeof e == "number" ? isNaN(e) && isNaN(n) ? !1 : e !== n : Array.isArray(e) !== Array.isArray(n) ? !0 : typeof e == "object" || typeof e == "function" ? !1 : e !== n, [
    we,
    n,
    e
  ]), Te = useRef();
  useEffect(() => {
    Te.current && de && "animate" in Te.current && Te.current.animate([
      {
        backgroundColor: F
      },
      {
        backgroundColor: ""
      }
    ], {
      duration: 1e3,
      easing: "ease-in"
    });
  }, [
    F,
    de,
    n,
    e
  ]);
  const Ce = useCallback((Ue) => {
    Ue.preventDefault(), v && b(v(e)), L(!0);
  }, [
    v,
    e
  ]), ee = useCallback(() => {
    L(!1), b("");
  }, [
    L,
    b
  ]), Ae = useCallback((Ue) => {
    if (L(!1), !!g)
      try {
        z(o, e, g(Ue));
      } catch {
      }
  }, [
    L,
    g,
    z,
    o,
    e
  ]), be = useMemo(() => j ? /* @__PURE__ */ jsxRuntimeExports$1.jsxs(jsxRuntimeExports$1.Fragment, {
    children: [
      /* @__PURE__ */ jsxRuntimeExports$1.jsx(IconBox, {
        children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(CloseIcon, {
          sx: {
            fontSize: ".8rem"
          },
          onClick: ee
        })
      }),
      /* @__PURE__ */ jsxRuntimeExports$1.jsx(IconBox, {
        children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(CheckIcon, {
          sx: {
            fontSize: ".8rem"
          },
          onClick: () => Ae(_)
        })
      })
    ]
  }) : /* @__PURE__ */ jsxRuntimeExports$1.jsxs(jsxRuntimeExports$1.Fragment, {
    children: [
      ge && /* @__PURE__ */ jsxRuntimeExports$1.jsx(IconBox, {
        onClick: (Ue) => {
          Ue.preventDefault();
          try {
            ye(o, e, copyString);
          } catch (Qe) {
            console.error(Qe);
          }
        },
        children: xe ? /* @__PURE__ */ jsxRuntimeExports$1.jsx(CheckIcon, {
          sx: {
            fontSize: ".8rem"
          }
        }) : /* @__PURE__ */ jsxRuntimeExports$1.jsx(ContentCopyIcon, {
          sx: {
            fontSize: ".8rem"
          }
        })
      }),
      p && R && v && g && /* @__PURE__ */ jsxRuntimeExports$1.jsx(IconBox, {
        onClick: Ce,
        children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(EditIcon, {
          sx: {
            fontSize: ".8rem"
          }
        })
      }),
      q && /* @__PURE__ */ jsxRuntimeExports$1.jsx(IconBox, {
        onClick: (Ue) => {
          Ue.preventDefault(), Q == null || Q(o);
        },
        children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(AddBoxIcon, {
          sx: {
            fontSize: ".8rem"
          }
        })
      }),
      ne && /* @__PURE__ */ jsxRuntimeExports$1.jsx(IconBox, {
        onClick: (Ue) => {
          Ue.preventDefault(), ie == null || ie(o, e);
        },
        children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(DeleteIcon, {
          sx: {
            fontSize: ".9rem"
          }
        })
      })
    ]
  }), [
    p,
    v,
    g,
    xe,
    ye,
    R,
    j,
    ge,
    q,
    ne,
    _,
    o,
    e,
    Q,
    ie,
    Ce,
    ee,
    Ae
  ]), Fe = useMemo(() => getValueSize(e) === 0, [
    e
  ]), et = !Fe && !!(f && h), Ye = useJsonViewerStore((Ue) => Ue.keyRenderer), De = useMemo(() => ({
    path: o,
    inspect: O,
    setInspect: N,
    value: e,
    prevValue: n,
    nestedIndex: l
  }), [
    O,
    o,
    N,
    e,
    n,
    l
  ]);
  return /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Box, {
    className: "data-key-pair",
    "data-testid": "data-key-pair" + o.join("."),
    sx: {
      userSelect: "text"
    },
    onMouseEnter: useCallback(() => C(o, l), [
      C,
      o,
      l
    ]),
    children: [
      /* @__PURE__ */ jsxRuntimeExports$1.jsxs(DataBox, {
        component: "span",
        className: "data-key",
        sx: {
          lineHeight: 1.5,
          color: G,
          letterSpacing: 0.5,
          opacity: 0.8
        },
        onClick: useCallback((Ue) => {
          Ue.isDefaultPrevented() || Fe || N((Qe) => !Qe);
        }, [
          Fe,
          N
        ]),
        children: [
          et ? O ? /* @__PURE__ */ jsxRuntimeExports$1.jsx(ExpandMoreIcon, {
            sx: {
              fontSize: ".8rem",
              "&:hover": {
                cursor: "pointer"
              }
            }
          }) : /* @__PURE__ */ jsxRuntimeExports$1.jsx(ChevronRightIcon, {
            sx: {
              fontSize: ".8rem",
              "&:hover": {
                cursor: "pointer"
              }
            }
          }) : null,
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(Box, {
            ref: Te,
            component: "span",
            children: V && M === 0 ? W !== !1 ? H ? /* @__PURE__ */ jsxRuntimeExports$1.jsxs(jsxRuntimeExports$1.Fragment, {
              children: [
                '"',
                W,
                '"'
              ]
            }) : /* @__PURE__ */ jsxRuntimeExports$1.jsx(jsxRuntimeExports$1.Fragment, {
              children: W
            }) : null : Ye.when(De) ? /* @__PURE__ */ jsxRuntimeExports$1.jsx(Ye, {
              ...De
            }) : l === void 0 && (X ? /* @__PURE__ */ jsxRuntimeExports$1.jsx(Box, {
              component: "span",
              style: {
                color: B
              },
              children: A
            }) : H ? /* @__PURE__ */ jsxRuntimeExports$1.jsxs(jsxRuntimeExports$1.Fragment, {
              children: [
                '"',
                A,
                '"'
              ]
            }) : /* @__PURE__ */ jsxRuntimeExports$1.jsx(jsxRuntimeExports$1.Fragment, {
              children: A
            }))
          }),
          V ? W !== !1 && /* @__PURE__ */ jsxRuntimeExports$1.jsx(DataBox, {
            sx: {
              mr: 0.5
            },
            children: ":"
          }) : l === void 0 && /* @__PURE__ */ jsxRuntimeExports$1.jsx(DataBox, {
            sx: {
              mr: 0.5
            },
            children: ":"
          }),
          f && /* @__PURE__ */ jsxRuntimeExports$1.jsx(f, {
            ...De
          }),
          S && et && O && be
        ]
      }),
      j && R ? p && /* @__PURE__ */ jsxRuntimeExports$1.jsx(p, {
        value: _,
        setValue: b,
        abortEditing: ee,
        commitEditing: Ae
      }) : u ? /* @__PURE__ */ jsxRuntimeExports$1.jsx(u, {
        ...De
      }) : /* @__PURE__ */ jsxRuntimeExports$1.jsx(Box, {
        component: "span",
        className: "data-value-fallback",
        children: "fallback: ".concat(e)
      }),
      h && /* @__PURE__ */ jsxRuntimeExports$1.jsx(h, {
        ...De
      }),
      S && et && !O && be,
      S && !et && be,
      !S && j && be
    ]
  });
}, query = "(prefers-color-scheme: dark)";
function useThemeDetector() {
  const [t, e] = useState(!1);
  return useEffect(() => {
    const n = (l) => e(l.matches);
    e(window.matchMedia(query).matches);
    const o = window.matchMedia(query);
    return o.addEventListener("change", n), () => o.removeEventListener("change", n);
  }, []), t;
}
function useSetIfNotUndefinedEffect(t, e) {
  const { setState: n } = useContext(JsonViewerStoreContext);
  useEffect(() => {
    e !== void 0 && n({
      [t]: e
    });
  }, [
    t,
    e,
    n
  ]);
}
const JsonViewerInner = (t) => {
  const { setState: e } = useContext(JsonViewerStoreContext);
  useEffect(() => {
    e((g) => ({
      prevValue: g.value,
      value: t.value
    }));
  }, [
    t.value,
    e
  ]), useSetIfNotUndefinedEffect("rootName", t.rootName), useSetIfNotUndefinedEffect("indentWidth", t.indentWidth), useSetIfNotUndefinedEffect("keyRenderer", t.keyRenderer), useSetIfNotUndefinedEffect("enableAdd", t.enableAdd), useSetIfNotUndefinedEffect("enableDelete", t.enableDelete), useSetIfNotUndefinedEffect("enableClipboard", t.enableClipboard), useSetIfNotUndefinedEffect("editable", t.editable), useSetIfNotUndefinedEffect("onChange", t.onChange), useSetIfNotUndefinedEffect("onCopy", t.onCopy), useSetIfNotUndefinedEffect("onSelect", t.onSelect), useSetIfNotUndefinedEffect("onAdd", t.onAdd), useSetIfNotUndefinedEffect("onDelete", t.onDelete), useSetIfNotUndefinedEffect("maxDisplayLength", t.maxDisplayLength), useSetIfNotUndefinedEffect("groupArraysAfterLength", t.groupArraysAfterLength), useSetIfNotUndefinedEffect("displayDataTypes", t.displayDataTypes), useSetIfNotUndefinedEffect("displaySize", t.displaySize), useSetIfNotUndefinedEffect("highlightUpdates", t.highlightUpdates), useEffect(() => {
    t.theme === "light" ? e({
      colorspace: lightColorspace
    }) : t.theme === "dark" ? e({
      colorspace: darkColorspace
    }) : typeof t.theme == "object" && e({
      colorspace: t.theme
    });
  }, [
    e,
    t.theme
  ]);
  const n = useMemo(() => typeof t.theme == "object" ? "json-viewer-theme-custom" : t.theme === "dark" ? "json-viewer-theme-dark" : "json-viewer-theme-light", [
    t.theme
  ]), o = useRef(!0), l = useTypeRegistryStore((g) => g.registerTypes);
  if (o.current) {
    const g = t.valueTypes ? [
      ...predefinedTypes,
      ...t.valueTypes
    ] : [
      ...predefinedTypes
    ];
    l(g), o.current = !1;
  }
  useEffect(() => {
    const g = t.valueTypes ? [
      ...predefinedTypes,
      ...t.valueTypes
    ] : [
      ...predefinedTypes
    ];
    l(g);
  }, [
    t.valueTypes,
    l
  ]);
  const u = useJsonViewerStore((g) => g.value), f = useJsonViewerStore((g) => g.prevValue), h = useMemo(() => [], []), p = useJsonViewerStore((g) => g.setHover), v = useCallback(() => p(null), [
    p
  ]);
  return /* @__PURE__ */ jsxRuntimeExports$1.jsx(Paper, {
    elevation: 0,
    className: clsx(n, t.className),
    style: t.style,
    sx: {
      fontFamily: "monospace",
      userSelect: "none",
      contentVisibility: "auto",
      ...t.sx
    },
    onMouseLeave: v,
    children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(DataKeyPair, {
      value: u,
      prevValue: f,
      path: h
    })
  });
}, JsonViewer = function t(e) {
  process.env.NODE_ENV !== "production" && "displayObjectSize" in e && console.error("`displayObjectSize` is deprecated. Use `displaySize` instead.\nSee https://viewer.textea.io/migration/migration-v3#raname-displayobjectsize-to-displaysize for more information.");
  const n = useThemeDetector(), o = useMemo(() => {
    var p;
    return e.theme === "auto" ? n ? "dark" : "light" : (p = e.theme) !== null && p !== void 0 ? p : "light";
  }, [
    n,
    e.theme
  ]), l = useMemo(() => {
    const p = typeof o == "object" ? o.base00 : o === "dark" ? darkColorspace.base00 : lightColorspace.base00, v = typeof o == "object" ? o.base07 : o === "dark" ? darkColorspace.base07 : lightColorspace.base07;
    return createTheme({
      components: {
        MuiPaper: {
          styleOverrides: {
            root: {
              backgroundColor: p,
              color: v
            }
          }
        }
      },
      palette: {
        mode: o === "dark" ? "dark" : "light",
        background: {
          default: p
        }
      }
    });
  }, [
    o
  ]), u = {
    ...e,
    theme: o
  }, f = useMemo(() => createJsonViewerStore(e), []), h = useMemo(() => createTypeRegistryStore(), []);
  return /* @__PURE__ */ jsxRuntimeExports$1.jsx(ThemeProvider, {
    theme: l,
    children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(TypeRegistryStoreContext.Provider, {
      value: h,
      children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(JsonViewerStoreContext.Provider, {
        value: f,
        children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(JsonViewerInner, {
          ...u
        })
      })
    })
  });
};
var DefaultContext = {
  color: void 0,
  size: void 0,
  className: void 0,
  style: void 0,
  attr: void 0
}, IconContext = React__default.createContext && /* @__PURE__ */ React__default.createContext(DefaultContext), _excluded$j = ["attr", "size", "title"];
function _objectWithoutProperties$j(t, e) {
  if (t == null) return {};
  var n = _objectWithoutPropertiesLoose$k(t, e), o, l;
  if (Object.getOwnPropertySymbols) {
    var u = Object.getOwnPropertySymbols(t);
    for (l = 0; l < u.length; l++)
      o = u[l], !(e.indexOf(o) >= 0) && Object.prototype.propertyIsEnumerable.call(t, o) && (n[o] = t[o]);
  }
  return n;
}
function _objectWithoutPropertiesLoose$k(t, e) {
  if (t == null) return {};
  var n = {};
  for (var o in t)
    if (Object.prototype.hasOwnProperty.call(t, o)) {
      if (e.indexOf(o) >= 0) continue;
      n[o] = t[o];
    }
  return n;
}
function _extends$w() {
  return _extends$w = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }
    return t;
  }, _extends$w.apply(this, arguments);
}
function ownKeys$D(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(l) {
      return Object.getOwnPropertyDescriptor(t, l).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function _objectSpread$C(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ownKeys$D(Object(n), !0).forEach(function(o) {
      _defineProperty$G(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : ownKeys$D(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
function _defineProperty$G(t, e, n) {
  return e = _toPropertyKey$G(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function _toPropertyKey$G(t) {
  var e = _toPrimitive$G(t, "string");
  return typeof e == "symbol" ? e : e + "";
}
function _toPrimitive$G(t, e) {
  if (typeof t != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(t, e || "default");
    if (typeof o != "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function Tree2Element(t) {
  return t && t.map((e, n) => /* @__PURE__ */ React__default.createElement(e.tag, _objectSpread$C({
    key: n
  }, e.attr), Tree2Element(e.child)));
}
function GenIcon(t) {
  return (e) => /* @__PURE__ */ React__default.createElement(IconBase, _extends$w({
    attr: _objectSpread$C({}, t.attr)
  }, e), Tree2Element(t.child));
}
function IconBase(t) {
  var e = (n) => {
    var {
      attr: o,
      size: l,
      title: u
    } = t, f = _objectWithoutProperties$j(t, _excluded$j), h = l || n.size || "1em", p;
    return n.className && (p = n.className), t.className && (p = (p ? p + " " : "") + t.className), /* @__PURE__ */ React__default.createElement("svg", _extends$w({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, n.attr, o, f, {
      className: p,
      style: _objectSpread$C(_objectSpread$C({
        color: t.color || n.color
      }, n.style), t.style),
      height: h,
      width: h,
      xmlns: "http://www.w3.org/2000/svg"
    }), u && /* @__PURE__ */ React__default.createElement("title", null, u), t.children);
  };
  return IconContext !== void 0 ? /* @__PURE__ */ React__default.createElement(IconContext.Consumer, null, (n) => e(n)) : e(DefaultContext);
}
function FaArrowUp(t) {
  return GenIcon({ tag: "svg", attr: { viewBox: "0 0 448 512" }, child: [{ tag: "path", attr: { d: "M34.9 289.5l-22.2-22.2c-9.4-9.4-9.4-24.6 0-33.9L207 39c9.4-9.4 24.6-9.4 33.9 0l194.3 194.3c9.4 9.4 9.4 24.6 0 33.9L413 289.4c-9.5 9.5-25 9.3-34.3-.4L264 168.6V456c0 13.3-10.7 24-24 24h-32c-13.3 0-24-10.7-24-24V168.6L69.2 289.1c-9.3 9.8-24.8 10-34.3.4z" }, child: [] }] })(t);
}
function FaBars(t) {
  return GenIcon({ tag: "svg", attr: { viewBox: "0 0 448 512" }, child: [{ tag: "path", attr: { d: "M16 132h416c8.837 0 16-7.163 16-16V76c0-8.837-7.163-16-16-16H16C7.163 60 0 67.163 0 76v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16z" }, child: [] }] })(t);
}
function FaCheck(t) {
  return GenIcon({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z" }, child: [] }] })(t);
}
function FaChevronRight(t) {
  return GenIcon({ tag: "svg", attr: { viewBox: "0 0 320 512" }, child: [{ tag: "path", attr: { d: "M285.476 272.971L91.132 467.314c-9.373 9.373-24.569 9.373-33.941 0l-22.667-22.667c-9.357-9.357-9.375-24.522-.04-33.901L188.505 256 34.484 101.255c-9.335-9.379-9.317-24.544.04-33.901l22.667-22.667c9.373-9.373 24.569-9.373 33.941 0L285.475 239.03c9.373 9.372 9.373 24.568.001 33.941z" }, child: [] }] })(t);
}
function FaCopy(t) {
  return GenIcon({ tag: "svg", attr: { viewBox: "0 0 448 512" }, child: [{ tag: "path", attr: { d: "M320 448v40c0 13.255-10.745 24-24 24H24c-13.255 0-24-10.745-24-24V120c0-13.255 10.745-24 24-24h72v296c0 30.879 25.121 56 56 56h168zm0-344V0H152c-13.255 0-24 10.745-24 24v368c0 13.255 10.745 24 24 24h272c13.255 0 24-10.745 24-24V128H344c-13.2 0-24-10.8-24-24zm120.971-31.029L375.029 7.029A24 24 0 0 0 358.059 0H352v96h96v-6.059a24 24 0 0 0-7.029-16.97z" }, child: [] }] })(t);
}
function FaDownload(t) {
  return GenIcon({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M216 0h80c13.3 0 24 10.7 24 24v168h87.7c17.8 0 26.7 21.5 14.1 34.1L269.7 378.3c-7.5 7.5-19.8 7.5-27.3 0L90.1 226.1c-12.6-12.6-3.7-34.1 14.1-34.1H192V24c0-13.3 10.7-24 24-24zm296 376v112c0 13.3-10.7 24-24 24H24c-13.3 0-24-10.7-24-24V376c0-13.3 10.7-24 24-24h146.7l49 49c20.1 20.1 52.5 20.1 72.6 0l49-49H488c13.3 0 24 10.7 24 24zm-124 88c0-11-9-20-20-20s-20 9-20 20 9 20 20 20 20-9 20-20zm64 0c0-11-9-20-20-20s-20 9-20 20 9 20 20 20 20-9 20-20z" }, child: [] }] })(t);
}
function FaEyeSlash(t) {
  return GenIcon({ tag: "svg", attr: { viewBox: "0 0 640 512" }, child: [{ tag: "path", attr: { d: "M320 400c-75.85 0-137.25-58.71-142.9-133.11L72.2 185.82c-13.79 17.3-26.48 35.59-36.72 55.59a32.35 32.35 0 0 0 0 29.19C89.71 376.41 197.07 448 320 448c26.91 0 52.87-4 77.89-10.46L346 397.39a144.13 144.13 0 0 1-26 2.61zm313.82 58.1l-110.55-85.44a331.25 331.25 0 0 0 81.25-102.07 32.35 32.35 0 0 0 0-29.19C550.29 135.59 442.93 64 320 64a308.15 308.15 0 0 0-147.32 37.7L45.46 3.37A16 16 0 0 0 23 6.18L3.37 31.45A16 16 0 0 0 6.18 53.9l588.36 454.73a16 16 0 0 0 22.46-2.81l19.64-25.27a16 16 0 0 0-2.82-22.45zm-183.72-142l-39.3-30.38A94.75 94.75 0 0 0 416 256a94.76 94.76 0 0 0-121.31-92.21A47.65 47.65 0 0 1 304 192a46.64 46.64 0 0 1-1.54 10l-73.61-56.89A142.31 142.31 0 0 1 320 112a143.92 143.92 0 0 1 144 144c0 21.63-5.29 41.79-13.9 60.11z" }, child: [] }] })(t);
}
function FaEye(t) {
  return GenIcon({ tag: "svg", attr: { viewBox: "0 0 576 512" }, child: [{ tag: "path", attr: { d: "M572.52 241.4C518.29 135.59 410.93 64 288 64S57.68 135.64 3.48 241.41a32.35 32.35 0 0 0 0 29.19C57.71 376.41 165.07 448 288 448s230.32-71.64 284.52-177.41a32.35 32.35 0 0 0 0-29.19zM288 400a144 144 0 1 1 144-144 143.93 143.93 0 0 1-144 144zm0-240a95.31 95.31 0 0 0-25.31 3.79 47.85 47.85 0 0 1-66.9 66.9A95.78 95.78 0 1 0 288 160z" }, child: [] }] })(t);
}
function FaFileAlt(t) {
  return GenIcon({ tag: "svg", attr: { viewBox: "0 0 384 512" }, child: [{ tag: "path", attr: { d: "M224 136V0H24C10.7 0 0 10.7 0 24v464c0 13.3 10.7 24 24 24h336c13.3 0 24-10.7 24-24V160H248c-13.2 0-24-10.8-24-24zm64 236c0 6.6-5.4 12-12 12H108c-6.6 0-12-5.4-12-12v-8c0-6.6 5.4-12 12-12h168c6.6 0 12 5.4 12 12v8zm0-64c0 6.6-5.4 12-12 12H108c-6.6 0-12-5.4-12-12v-8c0-6.6 5.4-12 12-12h168c6.6 0 12 5.4 12 12v8zm0-72v8c0 6.6-5.4 12-12 12H108c-6.6 0-12-5.4-12-12v-8c0-6.6 5.4-12 12-12h168c6.6 0 12 5.4 12 12zm96-114.1v6.1H256V0h6.1c6.4 0 12.5 2.5 17 7l97.9 98c4.5 4.5 7 10.6 7 16.9z" }, child: [] }] })(t);
}
function FaGlobe(t) {
  return GenIcon({ tag: "svg", attr: { viewBox: "0 0 496 512" }, child: [{ tag: "path", attr: { d: "M336.5 160C322 70.7 287.8 8 248 8s-74 62.7-88.5 152h177zM152 256c0 22.2 1.2 43.5 3.3 64h185.3c2.1-20.5 3.3-41.8 3.3-64s-1.2-43.5-3.3-64H155.3c-2.1 20.5-3.3 41.8-3.3 64zm324.7-96c-28.6-67.9-86.5-120.4-158-141.6 24.4 33.8 41.2 84.7 50 141.6h108zM177.2 18.4C105.8 39.6 47.8 92.1 19.3 160h108c8.7-56.9 25.5-107.8 49.9-141.6zM487.4 192H372.7c2.1 21 3.3 42.5 3.3 64s-1.2 43-3.3 64h114.6c5.5-20.5 8.6-41.8 8.6-64s-3.1-43.5-8.5-64zM120 256c0-21.5 1.2-43 3.3-64H8.6C3.2 212.5 0 233.8 0 256s3.2 43.5 8.6 64h114.6c-2-21-3.2-42.5-3.2-64zm39.5 96c14.5 89.3 48.7 152 88.5 152s74-62.7 88.5-152h-177zm159.3 141.6c71.4-21.2 129.4-73.7 158-141.6h-108c-8.8 56.9-25.6 107.8-50 141.6zM19.3 352c28.6 67.9 86.5 120.4 158 141.6-24.4-33.8-41.2-84.7-50-141.6h-108z" }, child: [] }] })(t);
}
function FaMapMarkerAlt(t) {
  return GenIcon({ tag: "svg", attr: { viewBox: "0 0 384 512" }, child: [{ tag: "path", attr: { d: "M172.268 501.67C26.97 291.031 0 269.413 0 192 0 85.961 85.961 0 192 0s192 85.961 192 192c0 77.413-26.97 99.031-172.268 309.67-9.535 13.774-29.93 13.773-39.464 0zM192 272c44.183 0 80-35.817 80-80s-35.817-80-80-80-80 35.817-80 80 35.817 80 80 80z" }, child: [] }] })(t);
}
function FaShapes(t) {
  return GenIcon({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M128,256A128,128,0,1,0,256,384,128,128,0,0,0,128,256Zm379-54.86L400.07,18.29a37.26,37.26,0,0,0-64.14,0L229,201.14C214.76,225.52,232.58,256,261.09,256H474.91C503.42,256,521.24,225.52,507,201.14ZM480,288H320a32,32,0,0,0-32,32V480a32,32,0,0,0,32,32H480a32,32,0,0,0,32-32V320A32,32,0,0,0,480,288Z" }, child: [] }] })(t);
}
const Attributes = ({ uuid: t, apiUrl: e }) => {
  const [n, o] = useState(null), [l, u] = useState(!0), [f, h] = useState(null), [p, v] = useState(!0), [g, w] = useState(null), [E, T] = useState(null), [R, _] = useState(null), [b, M] = useState(!1), [A, $] = useState(!1), [S, C] = useState(!1), D = useCallback(() => {
    M(!0), setTimeout(() => M(!1), 1e3);
  }, []), O = async () => {
    try {
      const z = await fetch(`${e}/nodes/${t}?attributes=true`);
      if (!z.ok)
        throw new Error("Network response was not ok");
      const G = await z.json();
      console.log("Fetched Node Data:", G.data.nodes[0].attributes), o(G.data.nodes[0].attributes);
    } catch (z) {
      console.error("Error fetching node data:", z), T("Failed to fetch node data");
    } finally {
      u(!1);
    }
  }, N = async () => {
    try {
      const z = await fetch(`${e}/computers/${t}?attributes=true`);
      if (!z.ok)
        throw new Error("Network response was not ok");
      const G = await z.json();
      console.log("Fetched Computer Data:", G.data.computers[0]), h(G.data.computers[0]);
    } catch (z) {
      console.error("Error fetching computer data:", z), _("Failed to fetch computer data");
    } finally {
      v(!1);
    }
  }, j = async () => {
    try {
      const z = await axios.get(`${e}/nodes/${t}/contents/derived_properties/`);
      w(z.data);
    } catch (z) {
      console.error("Error fetching derived properties:", z);
    }
  };
  if (useEffect(() => {
    O(), N(), j();
  }, [t, e]), l || p)
    return /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "loading-animation m-auto flex justify-center text-center", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(ClipLoader, { size: 30, color: "#007bff" }) });
  if (E && R)
    return /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "bg-gray-100 p-4 rounded-lg", children: "Error loading data" });
  const L = () => {
    if (!g || !g.data || !g.data.derived_properties)
      return null;
    const { explicit_kpoints_abs: z, mesh: G, offset: B } = g.data.derived_properties;
    return /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "my-4", children: [
      z && /* @__PURE__ */ jsxRuntimeExports$1.jsxs(jsxRuntimeExports$1.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsx("h2", { className: "text-lg font-mono mt-4 font-bold mb-2", children: "Kpoints (1/Å)" }),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "overflow-y-auto h-96 font-mono", children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs("table", { className: "table-auto w-full text-left border-collapse border border-gray-300 mb-4", children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx("thead", { children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs("tr", { className: "text-orange-800", children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx("th", { className: "border border-gray-300 px-4 py-2", children: "kX" }),
            /* @__PURE__ */ jsxRuntimeExports$1.jsx("th", { className: "border border-gray-300 px-4 py-2", children: "kY" }),
            /* @__PURE__ */ jsxRuntimeExports$1.jsx("th", { className: "border border-gray-300 px-4 py-2", children: "kZ" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx("tbody", { children: z.map((F, H) => /* @__PURE__ */ jsxRuntimeExports$1.jsxs("tr", { className: "text-blue-900", children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx("td", { className: "border border-gray-300 px-4 py-2", children: F[0] }),
            /* @__PURE__ */ jsxRuntimeExports$1.jsx("td", { className: "border border-gray-300 px-4 py-2", children: F[1] }),
            /* @__PURE__ */ jsxRuntimeExports$1.jsx("td", { className: "border border-gray-300 px-4 py-2", children: F[2] })
          ] }, H)) })
        ] }) })
      ] }),
      G && B && /* @__PURE__ */ jsxRuntimeExports$1.jsxs(jsxRuntimeExports$1.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsx("h2", { className: "text-lg mt-4 font-bold font-mono mb-2", children: "Kpoints mesh and offset" }),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "overflow-y-auto h-96 font-mono text-center", children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs("table", { className: "table-auto w-full text-center border-collapse border border-gray-300", children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx("thead", { children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs("tr", { className: "text-orange-800", children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx("th", { className: "border border-gray-300 px-4 py-2", children: "Mesh" }),
            /* @__PURE__ */ jsxRuntimeExports$1.jsx("th", { className: "border border-gray-300 px-4 py-2", children: "Offset" })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx("tbody", { children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs("tr", { className: "text-blue-900", children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx("td", { className: "border border-gray-300 px-4 py-2", children: G.map((F, H) => /* @__PURE__ */ jsxRuntimeExports$1.jsx("span", { className: "block", children: F }, H)) }),
            /* @__PURE__ */ jsxRuntimeExports$1.jsx("td", { className: "border border-gray-300 px-4 py-2", children: B.map((F, H) => /* @__PURE__ */ jsxRuntimeExports$1.jsx("span", { className: "block", children: F }, H)) })
          ] }) })
        ] }) })
      ] })
    ] });
  };
  return A ? /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "loading-animation m-auto flex justify-center text-center", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(ClipLoader, { size: 30, color: "#007bff" }) }) : S ? /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "bg-gray-100 p-4 rounded-lg", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(
    JsonViewer,
    {
      value: {},
      theme: "githubLight",
      displayDataTypes: !1,
      displaySize: !1,
      enableClipboard: !1,
      rootName: !1
    }
  ) }) : /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "relative border-2 border-gray-100 p-3 shadow-lg", children: [
      n && Object.keys(n).length > 0 && /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(
        JsonViewer,
        {
          value: n,
          theme: "githubLight",
          displayDataTypes: !1,
          displaySize: !1,
          enableClipboard: !1,
          rootName: !1
        }
      ) }),
      f && Object.keys(f).length > 0 && /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(
        JsonViewer,
        {
          value: f,
          theme: "githubLight",
          displayDataTypes: !1,
          displaySize: !1,
          enableClipboard: !1,
          rootName: !1
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports$1.jsx(lib.CopyToClipboard, { text: JSON.stringify(n, null, 2), onCopy: D, children: /* @__PURE__ */ jsxRuntimeExports$1.jsx("button", { className: "absolute top-2 right-2 bg-white p-2 rounded-md shadow-md hover:bg-gray-100 transition-colors duration-200", children: b ? /* @__PURE__ */ jsxRuntimeExports$1.jsx(FaCheck, { className: "text-green-600" }) : /* @__PURE__ */ jsxRuntimeExports$1.jsx(FaCopy, { className: "text-gray-600" }) }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { children: L() })
  ] });
}, Files = ({ uuid: t, apiUrl: e }) => {
  const [n, o] = useState([]), [l, u] = useState([]), [f, h] = useState(!1), [p, v] = useState(t), [g, w] = useState(!1), [E, T] = useState([]), [R, _] = useState(null), [b, M] = useState(!1);
  useEffect(() => {
    const O = async () => {
      try {
        const G = (await axios.get(`${e}/calcjobs/${t}/input_files`)).data.data.filter((B) => B.type === "FILE");
        o(G);
      } catch (z) {
        console.error("Error fetching input files:", z), w(!0);
      }
    }, N = async () => {
      try {
        const z = await axios.get(`${e}/calcjobs/${t}/output_files`);
        u(z.data.data);
      } catch (z) {
        console.error("Error fetching output files:", z), w(!0);
      }
    }, j = async () => {
      try {
        const z = await axios.get(`${e}/nodes/${t}/links/outgoing`);
        console.log(z.data.data.outgoing);
        const G = z.data.data.outgoing;
        console.log(G);
        const B = G.find((F) => F.full_type.includes("data.core.folder.FolderData.|"));
        B ? v(B.uuid) : console.error('Folder UUID with full_type "data.core.folder.FolderData.|" not found');
      } catch (z) {
        console.error("Error fetching folder UUID:", z);
      }
    };
    (async () => {
      try {
        const z = await fetch(`${e}/nodes/${t}?attributes=true`);
        if (!z.ok)
          throw new Error("Network response was not ok");
        const G = await z.json();
        T(G.data.nodes[0].attributes);
      } catch (z) {
        w(z.message);
      } finally {
        h(!1);
      }
    })(), j(), O(), N();
  }, [t, e]);
  const [A, $] = useState(!1), S = async (O) => {
    $(!0), M(!0);
    try {
      const N = await axios.get(`${e}/nodes/${t}/repo/contents?filename="${O}"`);
      typeof N.data == "object" ? _(JSON.stringify(N.data, null, 2)) : _(N.data);
    } catch (N) {
      console.error("Error fetching input file content:", N), _("Error loading file content");
    } finally {
      $(!1);
    }
  }, C = async (O) => {
    $(!0), M(!0);
    try {
      if (!p)
        throw new Error("Folder UUID not available");
      const N = await axios.get(`${e}/nodes/${p}/repo/contents?filename="${O}"`);
      typeof N.data == "object" ? _(JSON.stringify(N.data, null, 2)) : _(N.data);
    } catch (N) {
      console.error("Error fetching output file content:", N), _("Error loading file content");
    } finally {
      $(!1);
    }
  }, D = async (O, N = !1) => {
    try {
      const j = N && p ? p : t, L = await axios.get(`${e}/nodes/${j}/repo/contents?filename="${O}"`, {
        responseType: "blob"
      }), z = window.URL.createObjectURL(new Blob([L.data])), G = document.createElement("a");
      G.href = z, G.setAttribute("download", O), document.body.appendChild(G), G.click();
    } catch (j) {
      console.error("Error downloading file:", j);
    }
  };
  return g || n.length === 0 && l.length === 0 ? null : /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "grid grid-cols-2 gap-4", children: [
    /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "col-span-1 bg-gray-100 p-4 overflow-auto", children: [
      /* @__PURE__ */ jsxRuntimeExports$1.jsx("h2", { className: "font-semibold font-mono text-lg mb-2", children: "INFO:" }),
      /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "space-y-2 text-blue-900", children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsxs("p", { className: "font-mono text-sm break-all", children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx("span", { className: "font-semibold text-black", children: "JobID:" }),
          " ",
          E.job_id
        ] }),
        /* @__PURE__ */ jsxRuntimeExports$1.jsxs("p", { className: "font-mono text-sm break-all", children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx("span", { className: "font-semibold text-black", children: "Scheduler State:" }),
          " ",
          E.scheduler_state
        ] }),
        /* @__PURE__ */ jsxRuntimeExports$1.jsxs("p", { className: "font-mono text-sm break-all", children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx("span", { className: "font-semibold text-black", children: "Remote WorkDir:" }),
          " ",
          E.remote_workdir
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "col-span-1 grid grid-rows-2 gap-4", children: [
      /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "row-span-1 bg-gray-100 p-1", children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsx("span", { className: "font-semibold font-mono", children: "Input Files:" }),
        n.length > 0 ? /* @__PURE__ */ jsxRuntimeExports$1.jsx("ul", { className: "list-disc text-wrap pl-5 text-cyan-900", children: n.map((O, N) => /* @__PURE__ */ jsxRuntimeExports$1.jsxs("li", { className: "flex items-center font-mono text-wrap", children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(FaDownload, { className: "cursor-pointer", onClick: () => D(typeof O == "object" ? O.name : O) }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(FaEye, { className: " ml-3 mr-2 cursor-pointer", onClick: () => S(typeof O == "object" ? O.name : O) }),
          typeof O == "object" ? O.name : O
        ] }, N)) }) : /* @__PURE__ */ jsxRuntimeExports$1.jsx("p", { className: "font-mono", children: "No input files found." })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "row-span-1 bg-gray-100 p-1", children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsx("span", { className: "font-semibold font-mono", children: "Output Files:" }),
        l.length > 0 ? /* @__PURE__ */ jsxRuntimeExports$1.jsx("ul", { className: "list-disc text-wrap pl-5 text-cyan-900", children: l.map((O, N) => /* @__PURE__ */ jsxRuntimeExports$1.jsxs("li", { className: "flex items-center font-mono text-wrap", children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(FaDownload, { className: "cursor-pointer", onClick: () => D(typeof O == "object" ? O.name : O, !0) }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(FaEye, { className: "ml-3 mr-2 cursor-pointer", onClick: () => C(typeof O == "object" ? O.name : O) }),
          typeof O == "object" ? O.name : O
        ] }, N)) }) : /* @__PURE__ */ jsxRuntimeExports$1.jsx("p", { className: "font-mono", children: "No output files found." })
      ] })
    ] }),
    b && /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "fixed inset-0 z-50 overflow-auto bg-black bg-opacity-50 flex items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "bg-white rounded-lg w-11/12 md:w-3/4 lg:w-1/2 max-h-[90vh] flex flex-col", children: [
      /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "flex justify-between items-center border-b p-4", children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsx("h3", { className: "text-lg font-semibold", children: "File Content" }),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          "button",
          {
            className: "text-gray-500 hover:text-gray-700",
            onClick: () => M(!1),
            children: /* @__PURE__ */ jsxRuntimeExports$1.jsx("svg", { className: "h-6 w-6", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M6 18L18 6M6 6l12 12" }) })
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "p-4 overflow-auto flex-grow", children: A ? /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "flex justify-center items-center h-full", children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs("svg", { className: "animate-spin h-8 w-8 text-gray-500", xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 24 24", children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsx("circle", { className: "opacity-25", cx: "12", cy: "12", r: "10", stroke: "currentColor", strokeWidth: "4" }),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx("path", { className: "opacity-75", fill: "currentColor", d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" })
      ] }) }) : /* @__PURE__ */ jsxRuntimeExports$1.jsx("pre", { className: "whitespace-pre-wrap break-words", children: R }) })
    ] }) })
  ] });
}, RepoFiles = ({ uuid: t, apiUrl: e }) => {
  const [n, o] = useState([]), [l, u] = useState(!1);
  return useEffect(() => {
    (async () => {
      try {
        const p = (await axios.get(`${e}/nodes/${t}/repo/list/`)).data.data.repo_list, v = await Promise.all(p.map(async (g) => {
          try {
            const w = await axios.get(`${e}/nodes/${t}/repo/contents?filename=${g.name}`);
            return { name: g.name, content: w.data };
          } catch (w) {
            return console.error(`Error fetching content for file ${g.name}:`, w), u(!0), { name: g.name, content: "Error fetching content" };
          }
        }));
        o(v);
      } catch (h) {
        console.error("Error fetching files:", h), u(!0);
      }
    })();
  }, [t]), l || n.length === 0 ? null : /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "col-span-1 mt-2 row-span-2 bg-gray-100 p-1", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx("span", { className: "font-semibold font-mono", children: "Repository Files:" }) }),
    /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "bg-gray-100 p-1", children: n.length > 0 ? /* @__PURE__ */ jsxRuntimeExports$1.jsx("ul", { className: "list-disc text-wrap pl-5 text-cyan-900", children: n.map((f, h) => /* @__PURE__ */ jsxRuntimeExports$1.jsxs("li", { className: "mb-4", children: [
      /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "flex items-center font-mono text-wrap", children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(FaFileAlt, { className: "mr-2" }),
        f.name
      ] }),
      /* @__PURE__ */ jsxRuntimeExports$1.jsx("pre", { className: "bg-gray-200 p-2 mt-1 mr-4 text-sm rounded text-wrap break-words", children: f.content })
    ] }, h)) }) : /* @__PURE__ */ jsxRuntimeExports$1.jsx("p", { className: "font-mono", children: "No repository files found." }) })
  ] });
};
function cc$1(t) {
  if (typeof t == "string" || typeof t == "number") return "" + t;
  let e = "";
  if (Array.isArray(t))
    for (let n = 0, o; n < t.length; n++)
      (o = cc$1(t[n])) !== "" && (e += (e && " ") + o);
  else
    for (let n in t)
      t[n] && (e += (e && " ") + n);
  return e;
}
const { useDebugValue } = React__default, { useSyncExternalStoreWithSelector } = useSyncExternalStoreExports, identity$e = (t) => t;
function useStoreWithEqualityFn(t, e = identity$e, n) {
  const o = useSyncExternalStoreWithSelector(
    t.subscribe,
    t.getState,
    t.getServerState || t.getInitialState,
    e,
    n
  );
  return useDebugValue(o), o;
}
const createWithEqualityFnImpl = (t, e) => {
  const n = createStore(t), o = (l, u = e) => useStoreWithEqualityFn(n, l, u);
  return Object.assign(o, n), o;
}, createWithEqualityFn = (t, e) => t ? createWithEqualityFnImpl(t, e) : createWithEqualityFnImpl;
function shallow$1(t, e) {
  if (Object.is(t, e))
    return !0;
  if (typeof t != "object" || t === null || typeof e != "object" || e === null)
    return !1;
  if (t instanceof Map && e instanceof Map) {
    if (t.size !== e.size) return !1;
    for (const [o, l] of t)
      if (!Object.is(l, e.get(o)))
        return !1;
    return !0;
  }
  if (t instanceof Set && e instanceof Set) {
    if (t.size !== e.size) return !1;
    for (const o of t)
      if (!e.has(o))
        return !1;
    return !0;
  }
  const n = Object.keys(t);
  if (n.length !== Object.keys(e).length)
    return !1;
  for (const o of n)
    if (!Object.prototype.hasOwnProperty.call(e, o) || !Object.is(t[o], e[o]))
      return !1;
  return !0;
}
var noop$4 = { value: () => {
} };
function dispatch() {
  for (var t = 0, e = arguments.length, n = {}, o; t < e; ++t) {
    if (!(o = arguments[t] + "") || o in n || /[\s.]/.test(o)) throw new Error("illegal type: " + o);
    n[o] = [];
  }
  return new Dispatch(n);
}
function Dispatch(t) {
  this._ = t;
}
function parseTypenames$1(t, e) {
  return t.trim().split(/^|\s+/).map(function(n) {
    var o = "", l = n.indexOf(".");
    if (l >= 0 && (o = n.slice(l + 1), n = n.slice(0, l)), n && !e.hasOwnProperty(n)) throw new Error("unknown type: " + n);
    return { type: n, name: o };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(t, e) {
    var n = this._, o = parseTypenames$1(t + "", n), l, u = -1, f = o.length;
    if (arguments.length < 2) {
      for (; ++u < f; ) if ((l = (t = o[u]).type) && (l = get$4(n[l], t.name))) return l;
      return;
    }
    if (e != null && typeof e != "function") throw new Error("invalid callback: " + e);
    for (; ++u < f; )
      if (l = (t = o[u]).type) n[l] = set$2(n[l], t.name, e);
      else if (e == null) for (l in n) n[l] = set$2(n[l], t.name, null);
    return this;
  },
  copy: function() {
    var t = {}, e = this._;
    for (var n in e) t[n] = e[n].slice();
    return new Dispatch(t);
  },
  call: function(t, e) {
    if ((l = arguments.length - 2) > 0) for (var n = new Array(l), o = 0, l, u; o < l; ++o) n[o] = arguments[o + 2];
    if (!this._.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    for (u = this._[t], o = 0, l = u.length; o < l; ++o) u[o].value.apply(e, n);
  },
  apply: function(t, e, n) {
    if (!this._.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    for (var o = this._[t], l = 0, u = o.length; l < u; ++l) o[l].value.apply(e, n);
  }
};
function get$4(t, e) {
  for (var n = 0, o = t.length, l; n < o; ++n)
    if ((l = t[n]).name === e)
      return l.value;
}
function set$2(t, e, n) {
  for (var o = 0, l = t.length; o < l; ++o)
    if (t[o].name === e) {
      t[o] = noop$4, t = t.slice(0, o).concat(t.slice(o + 1));
      break;
    }
  return n != null && t.push({ name: e, value: n }), t;
}
var xhtml = "http://www.w3.org/1999/xhtml";
const namespaces = {
  svg: "http://www.w3.org/2000/svg",
  xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function namespace(t) {
  var e = t += "", n = e.indexOf(":");
  return n >= 0 && (e = t.slice(0, n)) !== "xmlns" && (t = t.slice(n + 1)), namespaces.hasOwnProperty(e) ? { space: namespaces[e], local: t } : t;
}
function creatorInherit(t) {
  return function() {
    var e = this.ownerDocument, n = this.namespaceURI;
    return n === xhtml && e.documentElement.namespaceURI === xhtml ? e.createElement(t) : e.createElementNS(n, t);
  };
}
function creatorFixed(t) {
  return function() {
    return this.ownerDocument.createElementNS(t.space, t.local);
  };
}
function creator(t) {
  var e = namespace(t);
  return (e.local ? creatorFixed : creatorInherit)(e);
}
function none() {
}
function selector$h(t) {
  return t == null ? none : function() {
    return this.querySelector(t);
  };
}
function selection_select(t) {
  typeof t != "function" && (t = selector$h(t));
  for (var e = this._groups, n = e.length, o = new Array(n), l = 0; l < n; ++l)
    for (var u = e[l], f = u.length, h = o[l] = new Array(f), p, v, g = 0; g < f; ++g)
      (p = u[g]) && (v = t.call(p, p.__data__, g, u)) && ("__data__" in p && (v.__data__ = p.__data__), h[g] = v);
  return new Selection$1(o, this._parents);
}
function array$1(t) {
  return t == null ? [] : Array.isArray(t) ? t : Array.from(t);
}
function empty() {
  return [];
}
function selectorAll(t) {
  return t == null ? empty : function() {
    return this.querySelectorAll(t);
  };
}
function arrayAll(t) {
  return function() {
    return array$1(t.apply(this, arguments));
  };
}
function selection_selectAll(t) {
  typeof t == "function" ? t = arrayAll(t) : t = selectorAll(t);
  for (var e = this._groups, n = e.length, o = [], l = [], u = 0; u < n; ++u)
    for (var f = e[u], h = f.length, p, v = 0; v < h; ++v)
      (p = f[v]) && (o.push(t.call(p, p.__data__, v, f)), l.push(p));
  return new Selection$1(o, l);
}
function matcher(t) {
  return function() {
    return this.matches(t);
  };
}
function childMatcher(t) {
  return function(e) {
    return e.matches(t);
  };
}
var find$2 = Array.prototype.find;
function childFind(t) {
  return function() {
    return find$2.call(this.children, t);
  };
}
function childFirst() {
  return this.firstElementChild;
}
function selection_selectChild(t) {
  return this.select(t == null ? childFirst : childFind(typeof t == "function" ? t : childMatcher(t)));
}
var filter = Array.prototype.filter;
function children() {
  return Array.from(this.children);
}
function childrenFilter(t) {
  return function() {
    return filter.call(this.children, t);
  };
}
function selection_selectChildren(t) {
  return this.selectAll(t == null ? children : childrenFilter(typeof t == "function" ? t : childMatcher(t)));
}
function selection_filter(t) {
  typeof t != "function" && (t = matcher(t));
  for (var e = this._groups, n = e.length, o = new Array(n), l = 0; l < n; ++l)
    for (var u = e[l], f = u.length, h = o[l] = [], p, v = 0; v < f; ++v)
      (p = u[v]) && t.call(p, p.__data__, v, u) && h.push(p);
  return new Selection$1(o, this._parents);
}
function sparse(t) {
  return new Array(t.length);
}
function selection_enter() {
  return new Selection$1(this._enter || this._groups.map(sparse), this._parents);
}
function EnterNode(t, e) {
  this.ownerDocument = t.ownerDocument, this.namespaceURI = t.namespaceURI, this._next = null, this._parent = t, this.__data__ = e;
}
EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(t) {
    return this._parent.insertBefore(t, this._next);
  },
  insertBefore: function(t, e) {
    return this._parent.insertBefore(t, e);
  },
  querySelector: function(t) {
    return this._parent.querySelector(t);
  },
  querySelectorAll: function(t) {
    return this._parent.querySelectorAll(t);
  }
};
function constant$6(t) {
  return function() {
    return t;
  };
}
function bindIndex(t, e, n, o, l, u) {
  for (var f = 0, h, p = e.length, v = u.length; f < v; ++f)
    (h = e[f]) ? (h.__data__ = u[f], o[f] = h) : n[f] = new EnterNode(t, u[f]);
  for (; f < p; ++f)
    (h = e[f]) && (l[f] = h);
}
function bindKey(t, e, n, o, l, u, f) {
  var h, p, v = /* @__PURE__ */ new Map(), g = e.length, w = u.length, E = new Array(g), T;
  for (h = 0; h < g; ++h)
    (p = e[h]) && (E[h] = T = f.call(p, p.__data__, h, e) + "", v.has(T) ? l[h] = p : v.set(T, p));
  for (h = 0; h < w; ++h)
    T = f.call(t, u[h], h, u) + "", (p = v.get(T)) ? (o[h] = p, p.__data__ = u[h], v.delete(T)) : n[h] = new EnterNode(t, u[h]);
  for (h = 0; h < g; ++h)
    (p = e[h]) && v.get(E[h]) === p && (l[h] = p);
}
function datum(t) {
  return t.__data__;
}
function selection_data(t, e) {
  if (!arguments.length) return Array.from(this, datum);
  var n = e ? bindKey : bindIndex, o = this._parents, l = this._groups;
  typeof t != "function" && (t = constant$6(t));
  for (var u = l.length, f = new Array(u), h = new Array(u), p = new Array(u), v = 0; v < u; ++v) {
    var g = o[v], w = l[v], E = w.length, T = arraylike(t.call(g, g && g.__data__, v, o)), R = T.length, _ = h[v] = new Array(R), b = f[v] = new Array(R), M = p[v] = new Array(E);
    n(g, w, _, b, M, T, e);
    for (var A = 0, $ = 0, S, C; A < R; ++A)
      if (S = _[A]) {
        for (A >= $ && ($ = A + 1); !(C = b[$]) && ++$ < R; ) ;
        S._next = C || null;
      }
  }
  return f = new Selection$1(f, o), f._enter = h, f._exit = p, f;
}
function arraylike(t) {
  return typeof t == "object" && "length" in t ? t : Array.from(t);
}
function selection_exit() {
  return new Selection$1(this._exit || this._groups.map(sparse), this._parents);
}
function selection_join(t, e, n) {
  var o = this.enter(), l = this, u = this.exit();
  return typeof t == "function" ? (o = t(o), o && (o = o.selection())) : o = o.append(t + ""), e != null && (l = e(l), l && (l = l.selection())), n == null ? u.remove() : n(u), o && l ? o.merge(l).order() : l;
}
function selection_merge(t) {
  for (var e = t.selection ? t.selection() : t, n = this._groups, o = e._groups, l = n.length, u = o.length, f = Math.min(l, u), h = new Array(l), p = 0; p < f; ++p)
    for (var v = n[p], g = o[p], w = v.length, E = h[p] = new Array(w), T, R = 0; R < w; ++R)
      (T = v[R] || g[R]) && (E[R] = T);
  for (; p < l; ++p)
    h[p] = n[p];
  return new Selection$1(h, this._parents);
}
function selection_order() {
  for (var t = this._groups, e = -1, n = t.length; ++e < n; )
    for (var o = t[e], l = o.length - 1, u = o[l], f; --l >= 0; )
      (f = o[l]) && (u && f.compareDocumentPosition(u) ^ 4 && u.parentNode.insertBefore(f, u), u = f);
  return this;
}
function selection_sort(t) {
  t || (t = ascending$1);
  function e(w, E) {
    return w && E ? t(w.__data__, E.__data__) : !w - !E;
  }
  for (var n = this._groups, o = n.length, l = new Array(o), u = 0; u < o; ++u) {
    for (var f = n[u], h = f.length, p = l[u] = new Array(h), v, g = 0; g < h; ++g)
      (v = f[g]) && (p[g] = v);
    p.sort(e);
  }
  return new Selection$1(l, this._parents).order();
}
function ascending$1(t, e) {
  return t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function selection_call() {
  var t = arguments[0];
  return arguments[0] = this, t.apply(null, arguments), this;
}
function selection_nodes() {
  return Array.from(this);
}
function selection_node() {
  for (var t = this._groups, e = 0, n = t.length; e < n; ++e)
    for (var o = t[e], l = 0, u = o.length; l < u; ++l) {
      var f = o[l];
      if (f) return f;
    }
  return null;
}
function selection_size() {
  let t = 0;
  for (const e of this) ++t;
  return t;
}
function selection_empty() {
  return !this.node();
}
function selection_each(t) {
  for (var e = this._groups, n = 0, o = e.length; n < o; ++n)
    for (var l = e[n], u = 0, f = l.length, h; u < f; ++u)
      (h = l[u]) && t.call(h, h.__data__, u, l);
  return this;
}
function attrRemove$1(t) {
  return function() {
    this.removeAttribute(t);
  };
}
function attrRemoveNS$1(t) {
  return function() {
    this.removeAttributeNS(t.space, t.local);
  };
}
function attrConstant$1(t, e) {
  return function() {
    this.setAttribute(t, e);
  };
}
function attrConstantNS$1(t, e) {
  return function() {
    this.setAttributeNS(t.space, t.local, e);
  };
}
function attrFunction$1(t, e) {
  return function() {
    var n = e.apply(this, arguments);
    n == null ? this.removeAttribute(t) : this.setAttribute(t, n);
  };
}
function attrFunctionNS$1(t, e) {
  return function() {
    var n = e.apply(this, arguments);
    n == null ? this.removeAttributeNS(t.space, t.local) : this.setAttributeNS(t.space, t.local, n);
  };
}
function selection_attr(t, e) {
  var n = namespace(t);
  if (arguments.length < 2) {
    var o = this.node();
    return n.local ? o.getAttributeNS(n.space, n.local) : o.getAttribute(n);
  }
  return this.each((e == null ? n.local ? attrRemoveNS$1 : attrRemove$1 : typeof e == "function" ? n.local ? attrFunctionNS$1 : attrFunction$1 : n.local ? attrConstantNS$1 : attrConstant$1)(n, e));
}
function defaultView(t) {
  return t.ownerDocument && t.ownerDocument.defaultView || t.document && t || t.defaultView;
}
function styleRemove$1(t) {
  return function() {
    this.style.removeProperty(t);
  };
}
function styleConstant$1(t, e, n) {
  return function() {
    this.style.setProperty(t, e, n);
  };
}
function styleFunction$1(t, e, n) {
  return function() {
    var o = e.apply(this, arguments);
    o == null ? this.style.removeProperty(t) : this.style.setProperty(t, o, n);
  };
}
function selection_style(t, e, n) {
  return arguments.length > 1 ? this.each((e == null ? styleRemove$1 : typeof e == "function" ? styleFunction$1 : styleConstant$1)(t, e, n ?? "")) : styleValue(this.node(), t);
}
function styleValue(t, e) {
  return t.style.getPropertyValue(e) || defaultView(t).getComputedStyle(t, null).getPropertyValue(e);
}
function propertyRemove(t) {
  return function() {
    delete this[t];
  };
}
function propertyConstant(t, e) {
  return function() {
    this[t] = e;
  };
}
function propertyFunction(t, e) {
  return function() {
    var n = e.apply(this, arguments);
    n == null ? delete this[t] : this[t] = n;
  };
}
function selection_property(t, e) {
  return arguments.length > 1 ? this.each((e == null ? propertyRemove : typeof e == "function" ? propertyFunction : propertyConstant)(t, e)) : this.node()[t];
}
function classArray(t) {
  return t.trim().split(/^|\s+/);
}
function classList(t) {
  return t.classList || new ClassList(t);
}
function ClassList(t) {
  this._node = t, this._names = classArray(t.getAttribute("class") || "");
}
ClassList.prototype = {
  add: function(t) {
    var e = this._names.indexOf(t);
    e < 0 && (this._names.push(t), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(t) {
    var e = this._names.indexOf(t);
    e >= 0 && (this._names.splice(e, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(t) {
    return this._names.indexOf(t) >= 0;
  }
};
function classedAdd(t, e) {
  for (var n = classList(t), o = -1, l = e.length; ++o < l; ) n.add(e[o]);
}
function classedRemove(t, e) {
  for (var n = classList(t), o = -1, l = e.length; ++o < l; ) n.remove(e[o]);
}
function classedTrue(t) {
  return function() {
    classedAdd(this, t);
  };
}
function classedFalse(t) {
  return function() {
    classedRemove(this, t);
  };
}
function classedFunction(t, e) {
  return function() {
    (e.apply(this, arguments) ? classedAdd : classedRemove)(this, t);
  };
}
function selection_classed(t, e) {
  var n = classArray(t + "");
  if (arguments.length < 2) {
    for (var o = classList(this.node()), l = -1, u = n.length; ++l < u; ) if (!o.contains(n[l])) return !1;
    return !0;
  }
  return this.each((typeof e == "function" ? classedFunction : e ? classedTrue : classedFalse)(n, e));
}
function textRemove() {
  this.textContent = "";
}
function textConstant$1(t) {
  return function() {
    this.textContent = t;
  };
}
function textFunction$1(t) {
  return function() {
    var e = t.apply(this, arguments);
    this.textContent = e ?? "";
  };
}
function selection_text(t) {
  return arguments.length ? this.each(t == null ? textRemove : (typeof t == "function" ? textFunction$1 : textConstant$1)(t)) : this.node().textContent;
}
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(t) {
  return function() {
    this.innerHTML = t;
  };
}
function htmlFunction(t) {
  return function() {
    var e = t.apply(this, arguments);
    this.innerHTML = e ?? "";
  };
}
function selection_html(t) {
  return arguments.length ? this.each(t == null ? htmlRemove : (typeof t == "function" ? htmlFunction : htmlConstant)(t)) : this.node().innerHTML;
}
function raise() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function selection_raise() {
  return this.each(raise);
}
function lower() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function selection_lower() {
  return this.each(lower);
}
function selection_append(t) {
  var e = typeof t == "function" ? t : creator(t);
  return this.select(function() {
    return this.appendChild(e.apply(this, arguments));
  });
}
function constantNull() {
  return null;
}
function selection_insert(t, e) {
  var n = typeof t == "function" ? t : creator(t), o = e == null ? constantNull : typeof e == "function" ? e : selector$h(e);
  return this.select(function() {
    return this.insertBefore(n.apply(this, arguments), o.apply(this, arguments) || null);
  });
}
function remove() {
  var t = this.parentNode;
  t && t.removeChild(this);
}
function selection_remove() {
  return this.each(remove);
}
function selection_cloneShallow() {
  var t = this.cloneNode(!1), e = this.parentNode;
  return e ? e.insertBefore(t, this.nextSibling) : t;
}
function selection_cloneDeep() {
  var t = this.cloneNode(!0), e = this.parentNode;
  return e ? e.insertBefore(t, this.nextSibling) : t;
}
function selection_clone(t) {
  return this.select(t ? selection_cloneDeep : selection_cloneShallow);
}
function selection_datum(t) {
  return arguments.length ? this.property("__data__", t) : this.node().__data__;
}
function contextListener(t) {
  return function(e) {
    t.call(this, e, this.__data__);
  };
}
function parseTypenames(t) {
  return t.trim().split(/^|\s+/).map(function(e) {
    var n = "", o = e.indexOf(".");
    return o >= 0 && (n = e.slice(o + 1), e = e.slice(0, o)), { type: e, name: n };
  });
}
function onRemove(t) {
  return function() {
    var e = this.__on;
    if (e) {
      for (var n = 0, o = -1, l = e.length, u; n < l; ++n)
        u = e[n], (!t.type || u.type === t.type) && u.name === t.name ? this.removeEventListener(u.type, u.listener, u.options) : e[++o] = u;
      ++o ? e.length = o : delete this.__on;
    }
  };
}
function onAdd(t, e, n) {
  return function() {
    var o = this.__on, l, u = contextListener(e);
    if (o) {
      for (var f = 0, h = o.length; f < h; ++f)
        if ((l = o[f]).type === t.type && l.name === t.name) {
          this.removeEventListener(l.type, l.listener, l.options), this.addEventListener(l.type, l.listener = u, l.options = n), l.value = e;
          return;
        }
    }
    this.addEventListener(t.type, u, n), l = { type: t.type, name: t.name, value: e, listener: u, options: n }, o ? o.push(l) : this.__on = [l];
  };
}
function selection_on(t, e, n) {
  var o = parseTypenames(t + ""), l, u = o.length, f;
  if (arguments.length < 2) {
    var h = this.node().__on;
    if (h) {
      for (var p = 0, v = h.length, g; p < v; ++p)
        for (l = 0, g = h[p]; l < u; ++l)
          if ((f = o[l]).type === g.type && f.name === g.name)
            return g.value;
    }
    return;
  }
  for (h = e ? onAdd : onRemove, l = 0; l < u; ++l) this.each(h(o[l], e, n));
  return this;
}
function dispatchEvent(t, e, n) {
  var o = defaultView(t), l = o.CustomEvent;
  typeof l == "function" ? l = new l(e, n) : (l = o.document.createEvent("Event"), n ? (l.initEvent(e, n.bubbles, n.cancelable), l.detail = n.detail) : l.initEvent(e, !1, !1)), t.dispatchEvent(l);
}
function dispatchConstant(t, e) {
  return function() {
    return dispatchEvent(this, t, e);
  };
}
function dispatchFunction(t, e) {
  return function() {
    return dispatchEvent(this, t, e.apply(this, arguments));
  };
}
function selection_dispatch(t, e) {
  return this.each((typeof e == "function" ? dispatchFunction : dispatchConstant)(t, e));
}
function* selection_iterator() {
  for (var t = this._groups, e = 0, n = t.length; e < n; ++e)
    for (var o = t[e], l = 0, u = o.length, f; l < u; ++l)
      (f = o[l]) && (yield f);
}
var root$a = [null];
function Selection$1(t, e) {
  this._groups = t, this._parents = e;
}
function selection() {
  return new Selection$1([[document.documentElement]], root$a);
}
function selection_selection() {
  return this;
}
Selection$1.prototype = selection.prototype = {
  constructor: Selection$1,
  select: selection_select,
  selectAll: selection_selectAll,
  selectChild: selection_selectChild,
  selectChildren: selection_selectChildren,
  filter: selection_filter,
  data: selection_data,
  enter: selection_enter,
  exit: selection_exit,
  join: selection_join,
  merge: selection_merge,
  selection: selection_selection,
  order: selection_order,
  sort: selection_sort,
  call: selection_call,
  nodes: selection_nodes,
  node: selection_node,
  size: selection_size,
  empty: selection_empty,
  each: selection_each,
  attr: selection_attr,
  style: selection_style,
  property: selection_property,
  classed: selection_classed,
  text: selection_text,
  html: selection_html,
  raise: selection_raise,
  lower: selection_lower,
  append: selection_append,
  insert: selection_insert,
  remove: selection_remove,
  clone: selection_clone,
  datum: selection_datum,
  on: selection_on,
  dispatch: selection_dispatch,
  [Symbol.iterator]: selection_iterator
};
function select(t) {
  return typeof t == "string" ? new Selection$1([[document.querySelector(t)]], [document.documentElement]) : new Selection$1([[t]], root$a);
}
function sourceEvent(t) {
  let e;
  for (; e = t.sourceEvent; ) t = e;
  return t;
}
function pointer(t, e) {
  if (t = sourceEvent(t), e === void 0 && (e = t.currentTarget), e) {
    var n = e.ownerSVGElement || e;
    if (n.createSVGPoint) {
      var o = n.createSVGPoint();
      return o.x = t.clientX, o.y = t.clientY, o = o.matrixTransform(e.getScreenCTM().inverse()), [o.x, o.y];
    }
    if (e.getBoundingClientRect) {
      var l = e.getBoundingClientRect();
      return [t.clientX - l.left - e.clientLeft, t.clientY - l.top - e.clientTop];
    }
  }
  return [t.pageX, t.pageY];
}
const nonpassive = { passive: !1 }, nonpassivecapture = { capture: !0, passive: !1 };
function nopropagation$1(t) {
  t.stopImmediatePropagation();
}
function noevent$1(t) {
  t.preventDefault(), t.stopImmediatePropagation();
}
function dragDisable(t) {
  var e = t.document.documentElement, n = select(t).on("dragstart.drag", noevent$1, nonpassivecapture);
  "onselectstart" in e ? n.on("selectstart.drag", noevent$1, nonpassivecapture) : (e.__noselect = e.style.MozUserSelect, e.style.MozUserSelect = "none");
}
function yesdrag(t, e) {
  var n = t.document.documentElement, o = select(t).on("dragstart.drag", null);
  e && (o.on("click.drag", noevent$1, nonpassivecapture), setTimeout(function() {
    o.on("click.drag", null);
  }, 0)), "onselectstart" in n ? o.on("selectstart.drag", null) : (n.style.MozUserSelect = n.__noselect, delete n.__noselect);
}
const constant$5 = (t) => () => t;
function DragEvent(t, {
  sourceEvent: e,
  subject: n,
  target: o,
  identifier: l,
  active: u,
  x: f,
  y: h,
  dx: p,
  dy: v,
  dispatch: g
}) {
  Object.defineProperties(this, {
    type: { value: t, enumerable: !0, configurable: !0 },
    sourceEvent: { value: e, enumerable: !0, configurable: !0 },
    subject: { value: n, enumerable: !0, configurable: !0 },
    target: { value: o, enumerable: !0, configurable: !0 },
    identifier: { value: l, enumerable: !0, configurable: !0 },
    active: { value: u, enumerable: !0, configurable: !0 },
    x: { value: f, enumerable: !0, configurable: !0 },
    y: { value: h, enumerable: !0, configurable: !0 },
    dx: { value: p, enumerable: !0, configurable: !0 },
    dy: { value: v, enumerable: !0, configurable: !0 },
    _: { value: g }
  });
}
DragEvent.prototype.on = function() {
  var t = this._.on.apply(this._, arguments);
  return t === this._ ? this : t;
};
function defaultFilter$1(t) {
  return !t.ctrlKey && !t.button;
}
function defaultContainer() {
  return this.parentNode;
}
function defaultSubject(t, e) {
  return e ?? { x: t.x, y: t.y };
}
function defaultTouchable$1() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function drag() {
  var t = defaultFilter$1, e = defaultContainer, n = defaultSubject, o = defaultTouchable$1, l = {}, u = dispatch("start", "drag", "end"), f = 0, h, p, v, g, w = 0;
  function E(S) {
    S.on("mousedown.drag", T).filter(o).on("touchstart.drag", b).on("touchmove.drag", M, nonpassive).on("touchend.drag touchcancel.drag", A).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  function T(S, C) {
    if (!(g || !t.call(this, S, C))) {
      var D = $(this, e.call(this, S, C), S, C, "mouse");
      D && (select(S.view).on("mousemove.drag", R, nonpassivecapture).on("mouseup.drag", _, nonpassivecapture), dragDisable(S.view), nopropagation$1(S), v = !1, h = S.clientX, p = S.clientY, D("start", S));
    }
  }
  function R(S) {
    if (noevent$1(S), !v) {
      var C = S.clientX - h, D = S.clientY - p;
      v = C * C + D * D > w;
    }
    l.mouse("drag", S);
  }
  function _(S) {
    select(S.view).on("mousemove.drag mouseup.drag", null), yesdrag(S.view, v), noevent$1(S), l.mouse("end", S);
  }
  function b(S, C) {
    if (t.call(this, S, C)) {
      var D = S.changedTouches, O = e.call(this, S, C), N = D.length, j, L;
      for (j = 0; j < N; ++j)
        (L = $(this, O, S, C, D[j].identifier, D[j])) && (nopropagation$1(S), L("start", S, D[j]));
    }
  }
  function M(S) {
    var C = S.changedTouches, D = C.length, O, N;
    for (O = 0; O < D; ++O)
      (N = l[C[O].identifier]) && (noevent$1(S), N("drag", S, C[O]));
  }
  function A(S) {
    var C = S.changedTouches, D = C.length, O, N;
    for (g && clearTimeout(g), g = setTimeout(function() {
      g = null;
    }, 500), O = 0; O < D; ++O)
      (N = l[C[O].identifier]) && (nopropagation$1(S), N("end", S, C[O]));
  }
  function $(S, C, D, O, N, j) {
    var L = u.copy(), z = pointer(j || D, C), G, B, F;
    if ((F = n.call(S, new DragEvent("beforestart", {
      sourceEvent: D,
      target: E,
      identifier: N,
      active: f,
      x: z[0],
      y: z[1],
      dx: 0,
      dy: 0,
      dispatch: L
    }), O)) != null)
      return G = F.x - z[0] || 0, B = F.y - z[1] || 0, function H(W, V, X) {
        var Z = z, Q;
        switch (W) {
          case "start":
            l[N] = H, Q = f++;
            break;
          case "end":
            delete l[N], --f;
          case "drag":
            z = pointer(X || V, C), Q = f;
            break;
        }
        L.call(
          W,
          S,
          new DragEvent(W, {
            sourceEvent: V,
            subject: F,
            target: E,
            identifier: N,
            active: Q,
            x: z[0] + G,
            y: z[1] + B,
            dx: z[0] - Z[0],
            dy: z[1] - Z[1],
            dispatch: L
          }),
          O
        );
      };
  }
  return E.filter = function(S) {
    return arguments.length ? (t = typeof S == "function" ? S : constant$5(!!S), E) : t;
  }, E.container = function(S) {
    return arguments.length ? (e = typeof S == "function" ? S : constant$5(S), E) : e;
  }, E.subject = function(S) {
    return arguments.length ? (n = typeof S == "function" ? S : constant$5(S), E) : n;
  }, E.touchable = function(S) {
    return arguments.length ? (o = typeof S == "function" ? S : constant$5(!!S), E) : o;
  }, E.on = function() {
    var S = u.on.apply(u, arguments);
    return S === u ? E : S;
  }, E.clickDistance = function(S) {
    return arguments.length ? (w = (S = +S) * S, E) : Math.sqrt(w);
  }, E;
}
function define(t, e, n) {
  t.prototype = e.prototype = n, n.constructor = t;
}
function extend(t, e) {
  var n = Object.create(t.prototype);
  for (var o in e) n[o] = e[o];
  return n;
}
function Color() {
}
var darker = 0.7, brighter = 1 / darker, reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`), reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`), reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`), reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`), reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`), reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`), named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define(Color, color, {
  copy(t) {
    return Object.assign(new this.constructor(), this, t);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(t) {
  var e, n;
  return t = (t + "").trim().toLowerCase(), (e = reHex.exec(t)) ? (n = e[1].length, e = parseInt(e[1], 16), n === 6 ? rgbn(e) : n === 3 ? new Rgb(e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, (e & 15) << 4 | e & 15, 1) : n === 8 ? rgba(e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, (e & 255) / 255) : n === 4 ? rgba(e >> 12 & 15 | e >> 8 & 240, e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, ((e & 15) << 4 | e & 15) / 255) : null) : (e = reRgbInteger.exec(t)) ? new Rgb(e[1], e[2], e[3], 1) : (e = reRgbPercent.exec(t)) ? new Rgb(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, 1) : (e = reRgbaInteger.exec(t)) ? rgba(e[1], e[2], e[3], e[4]) : (e = reRgbaPercent.exec(t)) ? rgba(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, e[4]) : (e = reHslPercent.exec(t)) ? hsla(e[1], e[2] / 100, e[3] / 100, 1) : (e = reHslaPercent.exec(t)) ? hsla(e[1], e[2] / 100, e[3] / 100, e[4]) : named.hasOwnProperty(t) ? rgbn(named[t]) : t === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(t) {
  return new Rgb(t >> 16 & 255, t >> 8 & 255, t & 255, 1);
}
function rgba(t, e, n, o) {
  return o <= 0 && (t = e = n = NaN), new Rgb(t, e, n, o);
}
function rgbConvert(t) {
  return t instanceof Color || (t = color(t)), t ? (t = t.rgb(), new Rgb(t.r, t.g, t.b, t.opacity)) : new Rgb();
}
function rgb(t, e, n, o) {
  return arguments.length === 1 ? rgbConvert(t) : new Rgb(t, e, n, o ?? 1);
}
function Rgb(t, e, n, o) {
  this.r = +t, this.g = +e, this.b = +n, this.opacity = +o;
}
define(Rgb, rgb, extend(Color, {
  brighter(t) {
    return t = t == null ? brighter : Math.pow(brighter, t), new Rgb(this.r * t, this.g * t, this.b * t, this.opacity);
  },
  darker(t) {
    return t = t == null ? darker : Math.pow(darker, t), new Rgb(this.r * t, this.g * t, this.b * t, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const t = clampa(this.opacity);
  return `${t === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${t === 1 ? ")" : `, ${t})`}`;
}
function clampa(t) {
  return isNaN(t) ? 1 : Math.max(0, Math.min(1, t));
}
function clampi(t) {
  return Math.max(0, Math.min(255, Math.round(t) || 0));
}
function hex(t) {
  return t = clampi(t), (t < 16 ? "0" : "") + t.toString(16);
}
function hsla(t, e, n, o) {
  return o <= 0 ? t = e = n = NaN : n <= 0 || n >= 1 ? t = e = NaN : e <= 0 && (t = NaN), new Hsl(t, e, n, o);
}
function hslConvert(t) {
  if (t instanceof Hsl) return new Hsl(t.h, t.s, t.l, t.opacity);
  if (t instanceof Color || (t = color(t)), !t) return new Hsl();
  if (t instanceof Hsl) return t;
  t = t.rgb();
  var e = t.r / 255, n = t.g / 255, o = t.b / 255, l = Math.min(e, n, o), u = Math.max(e, n, o), f = NaN, h = u - l, p = (u + l) / 2;
  return h ? (e === u ? f = (n - o) / h + (n < o) * 6 : n === u ? f = (o - e) / h + 2 : f = (e - n) / h + 4, h /= p < 0.5 ? u + l : 2 - u - l, f *= 60) : h = p > 0 && p < 1 ? 0 : f, new Hsl(f, h, p, t.opacity);
}
function hsl(t, e, n, o) {
  return arguments.length === 1 ? hslConvert(t) : new Hsl(t, e, n, o ?? 1);
}
function Hsl(t, e, n, o) {
  this.h = +t, this.s = +e, this.l = +n, this.opacity = +o;
}
define(Hsl, hsl, extend(Color, {
  brighter(t) {
    return t = t == null ? brighter : Math.pow(brighter, t), new Hsl(this.h, this.s, this.l * t, this.opacity);
  },
  darker(t) {
    return t = t == null ? darker : Math.pow(darker, t), new Hsl(this.h, this.s, this.l * t, this.opacity);
  },
  rgb() {
    var t = this.h % 360 + (this.h < 0) * 360, e = isNaN(t) || isNaN(this.s) ? 0 : this.s, n = this.l, o = n + (n < 0.5 ? n : 1 - n) * e, l = 2 * n - o;
    return new Rgb(
      hsl2rgb(t >= 240 ? t - 240 : t + 120, l, o),
      hsl2rgb(t, l, o),
      hsl2rgb(t < 120 ? t + 240 : t - 120, l, o),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const t = clampa(this.opacity);
    return `${t === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${t === 1 ? ")" : `, ${t})`}`;
  }
}));
function clamph(t) {
  return t = (t || 0) % 360, t < 0 ? t + 360 : t;
}
function clampt(t) {
  return Math.max(0, Math.min(1, t || 0));
}
function hsl2rgb(t, e, n) {
  return (t < 60 ? e + (n - e) * t / 60 : t < 180 ? n : t < 240 ? e + (n - e) * (240 - t) / 60 : e) * 255;
}
const constant$4 = (t) => () => t;
function linear$1(t, e) {
  return function(n) {
    return t + n * e;
  };
}
function exponential(t, e, n) {
  return t = Math.pow(t, n), e = Math.pow(e, n) - t, n = 1 / n, function(o) {
    return Math.pow(t + o * e, n);
  };
}
function gamma(t) {
  return (t = +t) == 1 ? nogamma : function(e, n) {
    return n - e ? exponential(e, n, t) : constant$4(isNaN(e) ? n : e);
  };
}
function nogamma(t, e) {
  var n = e - t;
  return n ? linear$1(t, n) : constant$4(isNaN(t) ? e : t);
}
const interpolateRgb = function t(e) {
  var n = gamma(e);
  function o(l, u) {
    var f = n((l = rgb(l)).r, (u = rgb(u)).r), h = n(l.g, u.g), p = n(l.b, u.b), v = nogamma(l.opacity, u.opacity);
    return function(g) {
      return l.r = f(g), l.g = h(g), l.b = p(g), l.opacity = v(g), l + "";
    };
  }
  return o.gamma = t, o;
}(1);
function numberArray(t, e) {
  e || (e = []);
  var n = t ? Math.min(e.length, t.length) : 0, o = e.slice(), l;
  return function(u) {
    for (l = 0; l < n; ++l) o[l] = t[l] * (1 - u) + e[l] * u;
    return o;
  };
}
function isNumberArray$1(t) {
  return ArrayBuffer.isView(t) && !(t instanceof DataView);
}
function genericArray(t, e) {
  var n = e ? e.length : 0, o = t ? Math.min(n, t.length) : 0, l = new Array(o), u = new Array(n), f;
  for (f = 0; f < o; ++f) l[f] = interpolate$1(t[f], e[f]);
  for (; f < n; ++f) u[f] = e[f];
  return function(h) {
    for (f = 0; f < o; ++f) u[f] = l[f](h);
    return u;
  };
}
function date$1(t, e) {
  var n = /* @__PURE__ */ new Date();
  return t = +t, e = +e, function(o) {
    return n.setTime(t * (1 - o) + e * o), n;
  };
}
function interpolateNumber$2(t, e) {
  return t = +t, e = +e, function(n) {
    return t * (1 - n) + e * n;
  };
}
function object(t, e) {
  var n = {}, o = {}, l;
  (t === null || typeof t != "object") && (t = {}), (e === null || typeof e != "object") && (e = {});
  for (l in e)
    l in t ? n[l] = interpolate$1(t[l], e[l]) : o[l] = e[l];
  return function(u) {
    for (l in n) o[l] = n[l](u);
    return o;
  };
}
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
function zero$1(t) {
  return function() {
    return t;
  };
}
function one(t) {
  return function(e) {
    return t(e) + "";
  };
}
function interpolateString(t, e) {
  var n = reA.lastIndex = reB.lastIndex = 0, o, l, u, f = -1, h = [], p = [];
  for (t = t + "", e = e + ""; (o = reA.exec(t)) && (l = reB.exec(e)); )
    (u = l.index) > n && (u = e.slice(n, u), h[f] ? h[f] += u : h[++f] = u), (o = o[0]) === (l = l[0]) ? h[f] ? h[f] += l : h[++f] = l : (h[++f] = null, p.push({ i: f, x: interpolateNumber$2(o, l) })), n = reB.lastIndex;
  return n < e.length && (u = e.slice(n), h[f] ? h[f] += u : h[++f] = u), h.length < 2 ? p[0] ? one(p[0].x) : zero$1(e) : (e = p.length, function(v) {
    for (var g = 0, w; g < e; ++g) h[(w = p[g]).i] = w.x(v);
    return h.join("");
  });
}
function interpolate$1(t, e) {
  var n = typeof e, o;
  return e == null || n === "boolean" ? constant$4(e) : (n === "number" ? interpolateNumber$2 : n === "string" ? (o = color(e)) ? (e = o, interpolateRgb) : interpolateString : e instanceof color ? interpolateRgb : e instanceof Date ? date$1 : isNumberArray$1(e) ? numberArray : Array.isArray(e) ? genericArray : typeof e.valueOf != "function" && typeof e.toString != "function" || isNaN(e) ? object : interpolateNumber$2)(t, e);
}
function interpolateRound(t, e) {
  return t = +t, e = +e, function(n) {
    return Math.round(t * (1 - n) + e * n);
  };
}
var degrees = 180 / Math.PI, identity$d = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose(t, e, n, o, l, u) {
  var f, h, p;
  return (f = Math.sqrt(t * t + e * e)) && (t /= f, e /= f), (p = t * n + e * o) && (n -= t * p, o -= e * p), (h = Math.sqrt(n * n + o * o)) && (n /= h, o /= h, p /= h), t * o < e * n && (t = -t, e = -e, p = -p, f = -f), {
    translateX: l,
    translateY: u,
    rotate: Math.atan2(e, t) * degrees,
    skewX: Math.atan(p) * degrees,
    scaleX: f,
    scaleY: h
  };
}
var svgNode;
function parseCss(t) {
  const e = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(t + "");
  return e.isIdentity ? identity$d : decompose(e.a, e.b, e.c, e.d, e.e, e.f);
}
function parseSvg(t) {
  return t == null || (svgNode || (svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g")), svgNode.setAttribute("transform", t), !(t = svgNode.transform.baseVal.consolidate())) ? identity$d : (t = t.matrix, decompose(t.a, t.b, t.c, t.d, t.e, t.f));
}
function interpolateTransform(t, e, n, o) {
  function l(v) {
    return v.length ? v.pop() + " " : "";
  }
  function u(v, g, w, E, T, R) {
    if (v !== w || g !== E) {
      var _ = T.push("translate(", null, e, null, n);
      R.push({ i: _ - 4, x: interpolateNumber$2(v, w) }, { i: _ - 2, x: interpolateNumber$2(g, E) });
    } else (w || E) && T.push("translate(" + w + e + E + n);
  }
  function f(v, g, w, E) {
    v !== g ? (v - g > 180 ? g += 360 : g - v > 180 && (v += 360), E.push({ i: w.push(l(w) + "rotate(", null, o) - 2, x: interpolateNumber$2(v, g) })) : g && w.push(l(w) + "rotate(" + g + o);
  }
  function h(v, g, w, E) {
    v !== g ? E.push({ i: w.push(l(w) + "skewX(", null, o) - 2, x: interpolateNumber$2(v, g) }) : g && w.push(l(w) + "skewX(" + g + o);
  }
  function p(v, g, w, E, T, R) {
    if (v !== w || g !== E) {
      var _ = T.push(l(T) + "scale(", null, ",", null, ")");
      R.push({ i: _ - 4, x: interpolateNumber$2(v, w) }, { i: _ - 2, x: interpolateNumber$2(g, E) });
    } else (w !== 1 || E !== 1) && T.push(l(T) + "scale(" + w + "," + E + ")");
  }
  return function(v, g) {
    var w = [], E = [];
    return v = t(v), g = t(g), u(v.translateX, v.translateY, g.translateX, g.translateY, w, E), f(v.rotate, g.rotate, w, E), h(v.skewX, g.skewX, w, E), p(v.scaleX, v.scaleY, g.scaleX, g.scaleY, w, E), v = g = null, function(T) {
      for (var R = -1, _ = E.length, b; ++R < _; ) w[(b = E[R]).i] = b.x(T);
      return w.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)"), interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")"), epsilon2 = 1e-12;
function cosh(t) {
  return ((t = Math.exp(t)) + 1 / t) / 2;
}
function sinh(t) {
  return ((t = Math.exp(t)) - 1 / t) / 2;
}
function tanh(t) {
  return ((t = Math.exp(2 * t)) - 1) / (t + 1);
}
const interpolateZoom = function t(e, n, o) {
  function l(u, f) {
    var h = u[0], p = u[1], v = u[2], g = f[0], w = f[1], E = f[2], T = g - h, R = w - p, _ = T * T + R * R, b, M;
    if (_ < epsilon2)
      M = Math.log(E / v) / e, b = function(O) {
        return [
          h + O * T,
          p + O * R,
          v * Math.exp(e * O * M)
        ];
      };
    else {
      var A = Math.sqrt(_), $ = (E * E - v * v + o * _) / (2 * v * n * A), S = (E * E - v * v - o * _) / (2 * E * n * A), C = Math.log(Math.sqrt($ * $ + 1) - $), D = Math.log(Math.sqrt(S * S + 1) - S);
      M = (D - C) / e, b = function(O) {
        var N = O * M, j = cosh(C), L = v / (n * A) * (j * tanh(e * N + C) - sinh(C));
        return [
          h + L * T,
          p + L * R,
          v * j / cosh(e * N + C)
        ];
      };
    }
    return b.duration = M * 1e3 * e / Math.SQRT2, b;
  }
  return l.rho = function(u) {
    var f = Math.max(1e-3, +u), h = f * f, p = h * h;
    return t(f, h, p);
  }, l;
}(Math.SQRT2, 2, 4);
function piecewise(t, e) {
  e === void 0 && (e = t, t = interpolate$1);
  for (var n = 0, o = e.length - 1, l = e[0], u = new Array(o < 0 ? 0 : o); n < o; ) u[n] = t(l, l = e[++n]);
  return function(f) {
    var h = Math.max(0, Math.min(o - 1, Math.floor(f *= o)));
    return u[h](f - h);
  };
}
var frame = 0, timeout$1 = 0, interval = 0, pokeDelay = 1e3, taskHead, taskTail, clockLast = 0, clockNow = 0, clockSkew = 0, clock = typeof performance == "object" && performance.now ? performance : Date, setFrame = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(t) {
  setTimeout(t, 17);
};
function now$2() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(t, e, n) {
    if (typeof t != "function") throw new TypeError("callback is not a function");
    n = (n == null ? now$2() : +n) + (e == null ? 0 : +e), !this._next && taskTail !== this && (taskTail ? taskTail._next = this : taskHead = this, taskTail = this), this._call = t, this._time = n, sleep();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, sleep());
  }
};
function timer(t, e, n) {
  var o = new Timer();
  return o.restart(t, e, n), o;
}
function timerFlush() {
  now$2(), ++frame;
  for (var t = taskHead, e; t; )
    (e = clockNow - t._time) >= 0 && t._call.call(void 0, e), t = t._next;
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew, frame = timeout$1 = 0;
  try {
    timerFlush();
  } finally {
    frame = 0, nap(), clockNow = 0;
  }
}
function poke() {
  var t = clock.now(), e = t - clockLast;
  e > pokeDelay && (clockSkew -= e, clockLast = t);
}
function nap() {
  for (var t, e = taskHead, n, o = 1 / 0; e; )
    e._call ? (o > e._time && (o = e._time), t = e, e = e._next) : (n = e._next, e._next = null, e = t ? t._next = n : taskHead = n);
  taskTail = t, sleep(o);
}
function sleep(t) {
  if (!frame) {
    timeout$1 && (timeout$1 = clearTimeout(timeout$1));
    var e = t - clockNow;
    e > 24 ? (t < 1 / 0 && (timeout$1 = setTimeout(wake, t - clock.now() - clockSkew)), interval && (interval = clearInterval(interval))) : (interval || (clockLast = clock.now(), interval = setInterval(poke, pokeDelay)), frame = 1, setFrame(wake));
  }
}
function timeout(t, e, n) {
  var o = new Timer();
  return e = e == null ? 0 : +e, o.restart((l) => {
    o.stop(), t(l + e);
  }, e, n), o;
}
var emptyOn = dispatch("start", "end", "cancel", "interrupt"), emptyTween = [], CREATED = 0, SCHEDULED = 1, STARTING = 2, STARTED = 3, RUNNING = 4, ENDING = 5, ENDED = 6;
function schedule(t, e, n, o, l, u) {
  var f = t.__transition;
  if (!f) t.__transition = {};
  else if (n in f) return;
  create(t, n, {
    name: e,
    index: o,
    // For context during callback.
    group: l,
    // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: u.time,
    delay: u.delay,
    duration: u.duration,
    ease: u.ease,
    timer: null,
    state: CREATED
  });
}
function init(t, e) {
  var n = get$3(t, e);
  if (n.state > CREATED) throw new Error("too late; already scheduled");
  return n;
}
function set$1(t, e) {
  var n = get$3(t, e);
  if (n.state > STARTED) throw new Error("too late; already running");
  return n;
}
function get$3(t, e) {
  var n = t.__transition;
  if (!n || !(n = n[e])) throw new Error("transition not found");
  return n;
}
function create(t, e, n) {
  var o = t.__transition, l;
  o[e] = n, n.timer = timer(u, 0, n.time);
  function u(v) {
    n.state = SCHEDULED, n.timer.restart(f, n.delay, n.time), n.delay <= v && f(v - n.delay);
  }
  function f(v) {
    var g, w, E, T;
    if (n.state !== SCHEDULED) return p();
    for (g in o)
      if (T = o[g], T.name === n.name) {
        if (T.state === STARTED) return timeout(f);
        T.state === RUNNING ? (T.state = ENDED, T.timer.stop(), T.on.call("interrupt", t, t.__data__, T.index, T.group), delete o[g]) : +g < e && (T.state = ENDED, T.timer.stop(), T.on.call("cancel", t, t.__data__, T.index, T.group), delete o[g]);
      }
    if (timeout(function() {
      n.state === STARTED && (n.state = RUNNING, n.timer.restart(h, n.delay, n.time), h(v));
    }), n.state = STARTING, n.on.call("start", t, t.__data__, n.index, n.group), n.state === STARTING) {
      for (n.state = STARTED, l = new Array(E = n.tween.length), g = 0, w = -1; g < E; ++g)
        (T = n.tween[g].value.call(t, t.__data__, n.index, n.group)) && (l[++w] = T);
      l.length = w + 1;
    }
  }
  function h(v) {
    for (var g = v < n.duration ? n.ease.call(null, v / n.duration) : (n.timer.restart(p), n.state = ENDING, 1), w = -1, E = l.length; ++w < E; )
      l[w].call(t, g);
    n.state === ENDING && (n.on.call("end", t, t.__data__, n.index, n.group), p());
  }
  function p() {
    n.state = ENDED, n.timer.stop(), delete o[e];
    for (var v in o) return;
    delete t.__transition;
  }
}
function interrupt(t, e) {
  var n = t.__transition, o, l, u = !0, f;
  if (n) {
    e = e == null ? null : e + "";
    for (f in n) {
      if ((o = n[f]).name !== e) {
        u = !1;
        continue;
      }
      l = o.state > STARTING && o.state < ENDING, o.state = ENDED, o.timer.stop(), o.on.call(l ? "interrupt" : "cancel", t, t.__data__, o.index, o.group), delete n[f];
    }
    u && delete t.__transition;
  }
}
function selection_interrupt(t) {
  return this.each(function() {
    interrupt(this, t);
  });
}
function tweenRemove(t, e) {
  var n, o;
  return function() {
    var l = set$1(this, t), u = l.tween;
    if (u !== n) {
      o = n = u;
      for (var f = 0, h = o.length; f < h; ++f)
        if (o[f].name === e) {
          o = o.slice(), o.splice(f, 1);
          break;
        }
    }
    l.tween = o;
  };
}
function tweenFunction(t, e, n) {
  var o, l;
  if (typeof n != "function") throw new Error();
  return function() {
    var u = set$1(this, t), f = u.tween;
    if (f !== o) {
      l = (o = f).slice();
      for (var h = { name: e, value: n }, p = 0, v = l.length; p < v; ++p)
        if (l[p].name === e) {
          l[p] = h;
          break;
        }
      p === v && l.push(h);
    }
    u.tween = l;
  };
}
function transition_tween(t, e) {
  var n = this._id;
  if (t += "", arguments.length < 2) {
    for (var o = get$3(this.node(), n).tween, l = 0, u = o.length, f; l < u; ++l)
      if ((f = o[l]).name === t)
        return f.value;
    return null;
  }
  return this.each((e == null ? tweenRemove : tweenFunction)(n, t, e));
}
function tweenValue(t, e, n) {
  var o = t._id;
  return t.each(function() {
    var l = set$1(this, o);
    (l.value || (l.value = {}))[e] = n.apply(this, arguments);
  }), function(l) {
    return get$3(l, o).value[e];
  };
}
function interpolate(t, e) {
  var n;
  return (typeof e == "number" ? interpolateNumber$2 : e instanceof color ? interpolateRgb : (n = color(e)) ? (e = n, interpolateRgb) : interpolateString)(t, e);
}
function attrRemove(t) {
  return function() {
    this.removeAttribute(t);
  };
}
function attrRemoveNS(t) {
  return function() {
    this.removeAttributeNS(t.space, t.local);
  };
}
function attrConstant(t, e, n) {
  var o, l = n + "", u;
  return function() {
    var f = this.getAttribute(t);
    return f === l ? null : f === o ? u : u = e(o = f, n);
  };
}
function attrConstantNS(t, e, n) {
  var o, l = n + "", u;
  return function() {
    var f = this.getAttributeNS(t.space, t.local);
    return f === l ? null : f === o ? u : u = e(o = f, n);
  };
}
function attrFunction(t, e, n) {
  var o, l, u;
  return function() {
    var f, h = n(this), p;
    return h == null ? void this.removeAttribute(t) : (f = this.getAttribute(t), p = h + "", f === p ? null : f === o && p === l ? u : (l = p, u = e(o = f, h)));
  };
}
function attrFunctionNS(t, e, n) {
  var o, l, u;
  return function() {
    var f, h = n(this), p;
    return h == null ? void this.removeAttributeNS(t.space, t.local) : (f = this.getAttributeNS(t.space, t.local), p = h + "", f === p ? null : f === o && p === l ? u : (l = p, u = e(o = f, h)));
  };
}
function transition_attr(t, e) {
  var n = namespace(t), o = n === "transform" ? interpolateTransformSvg : interpolate;
  return this.attrTween(t, typeof e == "function" ? (n.local ? attrFunctionNS : attrFunction)(n, o, tweenValue(this, "attr." + t, e)) : e == null ? (n.local ? attrRemoveNS : attrRemove)(n) : (n.local ? attrConstantNS : attrConstant)(n, o, e));
}
function attrInterpolate(t, e) {
  return function(n) {
    this.setAttribute(t, e.call(this, n));
  };
}
function attrInterpolateNS(t, e) {
  return function(n) {
    this.setAttributeNS(t.space, t.local, e.call(this, n));
  };
}
function attrTweenNS(t, e) {
  var n, o;
  function l() {
    var u = e.apply(this, arguments);
    return u !== o && (n = (o = u) && attrInterpolateNS(t, u)), n;
  }
  return l._value = e, l;
}
function attrTween(t, e) {
  var n, o;
  function l() {
    var u = e.apply(this, arguments);
    return u !== o && (n = (o = u) && attrInterpolate(t, u)), n;
  }
  return l._value = e, l;
}
function transition_attrTween(t, e) {
  var n = "attr." + t;
  if (arguments.length < 2) return (n = this.tween(n)) && n._value;
  if (e == null) return this.tween(n, null);
  if (typeof e != "function") throw new Error();
  var o = namespace(t);
  return this.tween(n, (o.local ? attrTweenNS : attrTween)(o, e));
}
function delayFunction(t, e) {
  return function() {
    init(this, t).delay = +e.apply(this, arguments);
  };
}
function delayConstant(t, e) {
  return e = +e, function() {
    init(this, t).delay = e;
  };
}
function transition_delay(t) {
  var e = this._id;
  return arguments.length ? this.each((typeof t == "function" ? delayFunction : delayConstant)(e, t)) : get$3(this.node(), e).delay;
}
function durationFunction(t, e) {
  return function() {
    set$1(this, t).duration = +e.apply(this, arguments);
  };
}
function durationConstant(t, e) {
  return e = +e, function() {
    set$1(this, t).duration = e;
  };
}
function transition_duration(t) {
  var e = this._id;
  return arguments.length ? this.each((typeof t == "function" ? durationFunction : durationConstant)(e, t)) : get$3(this.node(), e).duration;
}
function easeConstant(t, e) {
  if (typeof e != "function") throw new Error();
  return function() {
    set$1(this, t).ease = e;
  };
}
function transition_ease(t) {
  var e = this._id;
  return arguments.length ? this.each(easeConstant(e, t)) : get$3(this.node(), e).ease;
}
function easeVarying(t, e) {
  return function() {
    var n = e.apply(this, arguments);
    if (typeof n != "function") throw new Error();
    set$1(this, t).ease = n;
  };
}
function transition_easeVarying(t) {
  if (typeof t != "function") throw new Error();
  return this.each(easeVarying(this._id, t));
}
function transition_filter(t) {
  typeof t != "function" && (t = matcher(t));
  for (var e = this._groups, n = e.length, o = new Array(n), l = 0; l < n; ++l)
    for (var u = e[l], f = u.length, h = o[l] = [], p, v = 0; v < f; ++v)
      (p = u[v]) && t.call(p, p.__data__, v, u) && h.push(p);
  return new Transition(o, this._parents, this._name, this._id);
}
function transition_merge(t) {
  if (t._id !== this._id) throw new Error();
  for (var e = this._groups, n = t._groups, o = e.length, l = n.length, u = Math.min(o, l), f = new Array(o), h = 0; h < u; ++h)
    for (var p = e[h], v = n[h], g = p.length, w = f[h] = new Array(g), E, T = 0; T < g; ++T)
      (E = p[T] || v[T]) && (w[T] = E);
  for (; h < o; ++h)
    f[h] = e[h];
  return new Transition(f, this._parents, this._name, this._id);
}
function start(t) {
  return (t + "").trim().split(/^|\s+/).every(function(e) {
    var n = e.indexOf(".");
    return n >= 0 && (e = e.slice(0, n)), !e || e === "start";
  });
}
function onFunction(t, e, n) {
  var o, l, u = start(e) ? init : set$1;
  return function() {
    var f = u(this, t), h = f.on;
    h !== o && (l = (o = h).copy()).on(e, n), f.on = l;
  };
}
function transition_on(t, e) {
  var n = this._id;
  return arguments.length < 2 ? get$3(this.node(), n).on.on(t) : this.each(onFunction(n, t, e));
}
function removeFunction(t) {
  return function() {
    var e = this.parentNode;
    for (var n in this.__transition) if (+n !== t) return;
    e && e.removeChild(this);
  };
}
function transition_remove() {
  return this.on("end.remove", removeFunction(this._id));
}
function transition_select(t) {
  var e = this._name, n = this._id;
  typeof t != "function" && (t = selector$h(t));
  for (var o = this._groups, l = o.length, u = new Array(l), f = 0; f < l; ++f)
    for (var h = o[f], p = h.length, v = u[f] = new Array(p), g, w, E = 0; E < p; ++E)
      (g = h[E]) && (w = t.call(g, g.__data__, E, h)) && ("__data__" in g && (w.__data__ = g.__data__), v[E] = w, schedule(v[E], e, n, E, v, get$3(g, n)));
  return new Transition(u, this._parents, e, n);
}
function transition_selectAll(t) {
  var e = this._name, n = this._id;
  typeof t != "function" && (t = selectorAll(t));
  for (var o = this._groups, l = o.length, u = [], f = [], h = 0; h < l; ++h)
    for (var p = o[h], v = p.length, g, w = 0; w < v; ++w)
      if (g = p[w]) {
        for (var E = t.call(g, g.__data__, w, p), T, R = get$3(g, n), _ = 0, b = E.length; _ < b; ++_)
          (T = E[_]) && schedule(T, e, n, _, E, R);
        u.push(E), f.push(g);
      }
  return new Transition(u, f, e, n);
}
var Selection = selection.prototype.constructor;
function transition_selection() {
  return new Selection(this._groups, this._parents);
}
function styleNull(t, e) {
  var n, o, l;
  return function() {
    var u = styleValue(this, t), f = (this.style.removeProperty(t), styleValue(this, t));
    return u === f ? null : u === n && f === o ? l : l = e(n = u, o = f);
  };
}
function styleRemove(t) {
  return function() {
    this.style.removeProperty(t);
  };
}
function styleConstant(t, e, n) {
  var o, l = n + "", u;
  return function() {
    var f = styleValue(this, t);
    return f === l ? null : f === o ? u : u = e(o = f, n);
  };
}
function styleFunction(t, e, n) {
  var o, l, u;
  return function() {
    var f = styleValue(this, t), h = n(this), p = h + "";
    return h == null && (p = h = (this.style.removeProperty(t), styleValue(this, t))), f === p ? null : f === o && p === l ? u : (l = p, u = e(o = f, h));
  };
}
function styleMaybeRemove(t, e) {
  var n, o, l, u = "style." + e, f = "end." + u, h;
  return function() {
    var p = set$1(this, t), v = p.on, g = p.value[u] == null ? h || (h = styleRemove(e)) : void 0;
    (v !== n || l !== g) && (o = (n = v).copy()).on(f, l = g), p.on = o;
  };
}
function transition_style(t, e, n) {
  var o = (t += "") == "transform" ? interpolateTransformCss : interpolate;
  return e == null ? this.styleTween(t, styleNull(t, o)).on("end.style." + t, styleRemove(t)) : typeof e == "function" ? this.styleTween(t, styleFunction(t, o, tweenValue(this, "style." + t, e))).each(styleMaybeRemove(this._id, t)) : this.styleTween(t, styleConstant(t, o, e), n).on("end.style." + t, null);
}
function styleInterpolate(t, e, n) {
  return function(o) {
    this.style.setProperty(t, e.call(this, o), n);
  };
}
function styleTween(t, e, n) {
  var o, l;
  function u() {
    var f = e.apply(this, arguments);
    return f !== l && (o = (l = f) && styleInterpolate(t, f, n)), o;
  }
  return u._value = e, u;
}
function transition_styleTween(t, e, n) {
  var o = "style." + (t += "");
  if (arguments.length < 2) return (o = this.tween(o)) && o._value;
  if (e == null) return this.tween(o, null);
  if (typeof e != "function") throw new Error();
  return this.tween(o, styleTween(t, e, n ?? ""));
}
function textConstant(t) {
  return function() {
    this.textContent = t;
  };
}
function textFunction(t) {
  return function() {
    var e = t(this);
    this.textContent = e ?? "";
  };
}
function transition_text(t) {
  return this.tween("text", typeof t == "function" ? textFunction(tweenValue(this, "text", t)) : textConstant(t == null ? "" : t + ""));
}
function textInterpolate(t) {
  return function(e) {
    this.textContent = t.call(this, e);
  };
}
function textTween(t) {
  var e, n;
  function o() {
    var l = t.apply(this, arguments);
    return l !== n && (e = (n = l) && textInterpolate(l)), e;
  }
  return o._value = t, o;
}
function transition_textTween(t) {
  var e = "text";
  if (arguments.length < 1) return (e = this.tween(e)) && e._value;
  if (t == null) return this.tween(e, null);
  if (typeof t != "function") throw new Error();
  return this.tween(e, textTween(t));
}
function transition_transition() {
  for (var t = this._name, e = this._id, n = newId(), o = this._groups, l = o.length, u = 0; u < l; ++u)
    for (var f = o[u], h = f.length, p, v = 0; v < h; ++v)
      if (p = f[v]) {
        var g = get$3(p, e);
        schedule(p, t, n, v, f, {
          time: g.time + g.delay + g.duration,
          delay: 0,
          duration: g.duration,
          ease: g.ease
        });
      }
  return new Transition(o, this._parents, t, n);
}
function transition_end() {
  var t, e, n = this, o = n._id, l = n.size();
  return new Promise(function(u, f) {
    var h = { value: f }, p = { value: function() {
      --l === 0 && u();
    } };
    n.each(function() {
      var v = set$1(this, o), g = v.on;
      g !== t && (e = (t = g).copy(), e._.cancel.push(h), e._.interrupt.push(h), e._.end.push(p)), v.on = e;
    }), l === 0 && u();
  });
}
var id$1 = 0;
function Transition(t, e, n, o) {
  this._groups = t, this._parents = e, this._name = n, this._id = o;
}
function newId() {
  return ++id$1;
}
var selection_prototype = selection.prototype;
Transition.prototype = {
  constructor: Transition,
  select: transition_select,
  selectAll: transition_selectAll,
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: transition_filter,
  merge: transition_merge,
  selection: transition_selection,
  transition: transition_transition,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: transition_on,
  attr: transition_attr,
  attrTween: transition_attrTween,
  style: transition_style,
  styleTween: transition_styleTween,
  text: transition_text,
  textTween: transition_textTween,
  remove: transition_remove,
  tween: transition_tween,
  delay: transition_delay,
  duration: transition_duration,
  ease: transition_ease,
  easeVarying: transition_easeVarying,
  end: transition_end,
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};
function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}
var defaultTiming = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: cubicInOut
};
function inherit(t, e) {
  for (var n; !(n = t.__transition) || !(n = n[e]); )
    if (!(t = t.parentNode))
      throw new Error(`transition ${e} not found`);
  return n;
}
function selection_transition(t) {
  var e, n;
  t instanceof Transition ? (e = t._id, t = t._name) : (e = newId(), (n = defaultTiming).time = now$2(), t = t == null ? null : t + "");
  for (var o = this._groups, l = o.length, u = 0; u < l; ++u)
    for (var f = o[u], h = f.length, p, v = 0; v < h; ++v)
      (p = f[v]) && schedule(p, t, e, v, f, n || inherit(p, e));
  return new Transition(o, this._parents, t, e);
}
selection.prototype.interrupt = selection_interrupt;
selection.prototype.transition = selection_transition;
const constant$3 = (t) => () => t;
function ZoomEvent(t, {
  sourceEvent: e,
  target: n,
  transform: o,
  dispatch: l
}) {
  Object.defineProperties(this, {
    type: { value: t, enumerable: !0, configurable: !0 },
    sourceEvent: { value: e, enumerable: !0, configurable: !0 },
    target: { value: n, enumerable: !0, configurable: !0 },
    transform: { value: o, enumerable: !0, configurable: !0 },
    _: { value: l }
  });
}
function Transform(t, e, n) {
  this.k = t, this.x = e, this.y = n;
}
Transform.prototype = {
  constructor: Transform,
  scale: function(t) {
    return t === 1 ? this : new Transform(this.k * t, this.x, this.y);
  },
  translate: function(t, e) {
    return t === 0 & e === 0 ? this : new Transform(this.k, this.x + this.k * t, this.y + this.k * e);
  },
  apply: function(t) {
    return [t[0] * this.k + this.x, t[1] * this.k + this.y];
  },
  applyX: function(t) {
    return t * this.k + this.x;
  },
  applyY: function(t) {
    return t * this.k + this.y;
  },
  invert: function(t) {
    return [(t[0] - this.x) / this.k, (t[1] - this.y) / this.k];
  },
  invertX: function(t) {
    return (t - this.x) / this.k;
  },
  invertY: function(t) {
    return (t - this.y) / this.k;
  },
  rescaleX: function(t) {
    return t.copy().domain(t.range().map(this.invertX, this).map(t.invert, t));
  },
  rescaleY: function(t) {
    return t.copy().domain(t.range().map(this.invertY, this).map(t.invert, t));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var identity$c = new Transform(1, 0, 0);
Transform.prototype;
function nopropagation(t) {
  t.stopImmediatePropagation();
}
function noevent(t) {
  t.preventDefault(), t.stopImmediatePropagation();
}
function defaultFilter(t) {
  return (!t.ctrlKey || t.type === "wheel") && !t.button;
}
function defaultExtent() {
  var t = this;
  return t instanceof SVGElement ? (t = t.ownerSVGElement || t, t.hasAttribute("viewBox") ? (t = t.viewBox.baseVal, [[t.x, t.y], [t.x + t.width, t.y + t.height]]) : [[0, 0], [t.width.baseVal.value, t.height.baseVal.value]]) : [[0, 0], [t.clientWidth, t.clientHeight]];
}
function defaultTransform() {
  return this.__zoom || identity$c;
}
function defaultWheelDelta(t) {
  return -t.deltaY * (t.deltaMode === 1 ? 0.05 : t.deltaMode ? 1 : 2e-3) * (t.ctrlKey ? 10 : 1);
}
function defaultTouchable() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function defaultConstrain(t, e, n) {
  var o = t.invertX(e[0][0]) - n[0][0], l = t.invertX(e[1][0]) - n[1][0], u = t.invertY(e[0][1]) - n[0][1], f = t.invertY(e[1][1]) - n[1][1];
  return t.translate(
    l > o ? (o + l) / 2 : Math.min(0, o) || Math.max(0, l),
    f > u ? (u + f) / 2 : Math.min(0, u) || Math.max(0, f)
  );
}
function zoom() {
  var t = defaultFilter, e = defaultExtent, n = defaultConstrain, o = defaultWheelDelta, l = defaultTouchable, u = [0, 1 / 0], f = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]], h = 250, p = interpolateZoom, v = dispatch("start", "zoom", "end"), g, w, E, T = 500, R = 150, _ = 0, b = 10;
  function M(F) {
    F.property("__zoom", defaultTransform).on("wheel.zoom", N, { passive: !1 }).on("mousedown.zoom", j).on("dblclick.zoom", L).filter(l).on("touchstart.zoom", z).on("touchmove.zoom", G).on("touchend.zoom touchcancel.zoom", B).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  M.transform = function(F, H, W, V) {
    var X = F.selection ? F.selection() : F;
    X.property("__zoom", defaultTransform), F !== X ? C(F, H, W, V) : X.interrupt().each(function() {
      D(this, arguments).event(V).start().zoom(null, typeof H == "function" ? H.apply(this, arguments) : H).end();
    });
  }, M.scaleBy = function(F, H, W, V) {
    M.scaleTo(F, function() {
      var X = this.__zoom.k, Z = typeof H == "function" ? H.apply(this, arguments) : H;
      return X * Z;
    }, W, V);
  }, M.scaleTo = function(F, H, W, V) {
    M.transform(F, function() {
      var X = e.apply(this, arguments), Z = this.__zoom, Q = W == null ? S(X) : typeof W == "function" ? W.apply(this, arguments) : W, q = Z.invert(Q), J = typeof H == "function" ? H.apply(this, arguments) : H;
      return n($(A(Z, J), Q, q), X, f);
    }, W, V);
  }, M.translateBy = function(F, H, W, V) {
    M.transform(F, function() {
      return n(this.__zoom.translate(
        typeof H == "function" ? H.apply(this, arguments) : H,
        typeof W == "function" ? W.apply(this, arguments) : W
      ), e.apply(this, arguments), f);
    }, null, V);
  }, M.translateTo = function(F, H, W, V, X) {
    M.transform(F, function() {
      var Z = e.apply(this, arguments), Q = this.__zoom, q = V == null ? S(Z) : typeof V == "function" ? V.apply(this, arguments) : V;
      return n(identity$c.translate(q[0], q[1]).scale(Q.k).translate(
        typeof H == "function" ? -H.apply(this, arguments) : -H,
        typeof W == "function" ? -W.apply(this, arguments) : -W
      ), Z, f);
    }, V, X);
  };
  function A(F, H) {
    return H = Math.max(u[0], Math.min(u[1], H)), H === F.k ? F : new Transform(H, F.x, F.y);
  }
  function $(F, H, W) {
    var V = H[0] - W[0] * F.k, X = H[1] - W[1] * F.k;
    return V === F.x && X === F.y ? F : new Transform(F.k, V, X);
  }
  function S(F) {
    return [(+F[0][0] + +F[1][0]) / 2, (+F[0][1] + +F[1][1]) / 2];
  }
  function C(F, H, W, V) {
    F.on("start.zoom", function() {
      D(this, arguments).event(V).start();
    }).on("interrupt.zoom end.zoom", function() {
      D(this, arguments).event(V).end();
    }).tween("zoom", function() {
      var X = this, Z = arguments, Q = D(X, Z).event(V), q = e.apply(X, Z), J = W == null ? S(q) : typeof W == "function" ? W.apply(X, Z) : W, ie = Math.max(q[1][0] - q[0][0], q[1][1] - q[0][1]), ne = X.__zoom, ge = typeof H == "function" ? H.apply(X, Z) : H, ye = p(ne.invert(J).concat(ie / ne.k), ge.invert(J).concat(ie / ge.k));
      return function(xe) {
        if (xe === 1) xe = ge;
        else {
          var we = ye(xe), de = ie / we[2];
          xe = new Transform(de, J[0] - we[0] * de, J[1] - we[1] * de);
        }
        Q.zoom(null, xe);
      };
    });
  }
  function D(F, H, W) {
    return !W && F.__zooming || new O(F, H);
  }
  function O(F, H) {
    this.that = F, this.args = H, this.active = 0, this.sourceEvent = null, this.extent = e.apply(F, H), this.taps = 0;
  }
  O.prototype = {
    event: function(F) {
      return F && (this.sourceEvent = F), this;
    },
    start: function() {
      return ++this.active === 1 && (this.that.__zooming = this, this.emit("start")), this;
    },
    zoom: function(F, H) {
      return this.mouse && F !== "mouse" && (this.mouse[1] = H.invert(this.mouse[0])), this.touch0 && F !== "touch" && (this.touch0[1] = H.invert(this.touch0[0])), this.touch1 && F !== "touch" && (this.touch1[1] = H.invert(this.touch1[0])), this.that.__zoom = H, this.emit("zoom"), this;
    },
    end: function() {
      return --this.active === 0 && (delete this.that.__zooming, this.emit("end")), this;
    },
    emit: function(F) {
      var H = select(this.that).datum();
      v.call(
        F,
        this.that,
        new ZoomEvent(F, {
          sourceEvent: this.sourceEvent,
          target: M,
          type: F,
          transform: this.that.__zoom,
          dispatch: v
        }),
        H
      );
    }
  };
  function N(F, ...H) {
    if (!t.apply(this, arguments)) return;
    var W = D(this, H).event(F), V = this.__zoom, X = Math.max(u[0], Math.min(u[1], V.k * Math.pow(2, o.apply(this, arguments)))), Z = pointer(F);
    if (W.wheel)
      (W.mouse[0][0] !== Z[0] || W.mouse[0][1] !== Z[1]) && (W.mouse[1] = V.invert(W.mouse[0] = Z)), clearTimeout(W.wheel);
    else {
      if (V.k === X) return;
      W.mouse = [Z, V.invert(Z)], interrupt(this), W.start();
    }
    noevent(F), W.wheel = setTimeout(Q, R), W.zoom("mouse", n($(A(V, X), W.mouse[0], W.mouse[1]), W.extent, f));
    function Q() {
      W.wheel = null, W.end();
    }
  }
  function j(F, ...H) {
    if (E || !t.apply(this, arguments)) return;
    var W = F.currentTarget, V = D(this, H, !0).event(F), X = select(F.view).on("mousemove.zoom", J, !0).on("mouseup.zoom", ie, !0), Z = pointer(F, W), Q = F.clientX, q = F.clientY;
    dragDisable(F.view), nopropagation(F), V.mouse = [Z, this.__zoom.invert(Z)], interrupt(this), V.start();
    function J(ne) {
      if (noevent(ne), !V.moved) {
        var ge = ne.clientX - Q, ye = ne.clientY - q;
        V.moved = ge * ge + ye * ye > _;
      }
      V.event(ne).zoom("mouse", n($(V.that.__zoom, V.mouse[0] = pointer(ne, W), V.mouse[1]), V.extent, f));
    }
    function ie(ne) {
      X.on("mousemove.zoom mouseup.zoom", null), yesdrag(ne.view, V.moved), noevent(ne), V.event(ne).end();
    }
  }
  function L(F, ...H) {
    if (t.apply(this, arguments)) {
      var W = this.__zoom, V = pointer(F.changedTouches ? F.changedTouches[0] : F, this), X = W.invert(V), Z = W.k * (F.shiftKey ? 0.5 : 2), Q = n($(A(W, Z), V, X), e.apply(this, H), f);
      noevent(F), h > 0 ? select(this).transition().duration(h).call(C, Q, V, F) : select(this).call(M.transform, Q, V, F);
    }
  }
  function z(F, ...H) {
    if (t.apply(this, arguments)) {
      var W = F.touches, V = W.length, X = D(this, H, F.changedTouches.length === V).event(F), Z, Q, q, J;
      for (nopropagation(F), Q = 0; Q < V; ++Q)
        q = W[Q], J = pointer(q, this), J = [J, this.__zoom.invert(J), q.identifier], X.touch0 ? !X.touch1 && X.touch0[2] !== J[2] && (X.touch1 = J, X.taps = 0) : (X.touch0 = J, Z = !0, X.taps = 1 + !!g);
      g && (g = clearTimeout(g)), Z && (X.taps < 2 && (w = J[0], g = setTimeout(function() {
        g = null;
      }, T)), interrupt(this), X.start());
    }
  }
  function G(F, ...H) {
    if (this.__zooming) {
      var W = D(this, H).event(F), V = F.changedTouches, X = V.length, Z, Q, q, J;
      for (noevent(F), Z = 0; Z < X; ++Z)
        Q = V[Z], q = pointer(Q, this), W.touch0 && W.touch0[2] === Q.identifier ? W.touch0[0] = q : W.touch1 && W.touch1[2] === Q.identifier && (W.touch1[0] = q);
      if (Q = W.that.__zoom, W.touch1) {
        var ie = W.touch0[0], ne = W.touch0[1], ge = W.touch1[0], ye = W.touch1[1], xe = (xe = ge[0] - ie[0]) * xe + (xe = ge[1] - ie[1]) * xe, we = (we = ye[0] - ne[0]) * we + (we = ye[1] - ne[1]) * we;
        Q = A(Q, Math.sqrt(xe / we)), q = [(ie[0] + ge[0]) / 2, (ie[1] + ge[1]) / 2], J = [(ne[0] + ye[0]) / 2, (ne[1] + ye[1]) / 2];
      } else if (W.touch0) q = W.touch0[0], J = W.touch0[1];
      else return;
      W.zoom("touch", n($(Q, q, J), W.extent, f));
    }
  }
  function B(F, ...H) {
    if (this.__zooming) {
      var W = D(this, H).event(F), V = F.changedTouches, X = V.length, Z, Q;
      for (nopropagation(F), E && clearTimeout(E), E = setTimeout(function() {
        E = null;
      }, T), Z = 0; Z < X; ++Z)
        Q = V[Z], W.touch0 && W.touch0[2] === Q.identifier ? delete W.touch0 : W.touch1 && W.touch1[2] === Q.identifier && delete W.touch1;
      if (W.touch1 && !W.touch0 && (W.touch0 = W.touch1, delete W.touch1), W.touch0) W.touch0[1] = this.__zoom.invert(W.touch0[0]);
      else if (W.end(), W.taps === 2 && (Q = pointer(Q, this), Math.hypot(w[0] - Q[0], w[1] - Q[1]) < b)) {
        var q = select(this).on("dblclick.zoom");
        q && q.apply(this, arguments);
      }
    }
  }
  return M.wheelDelta = function(F) {
    return arguments.length ? (o = typeof F == "function" ? F : constant$3(+F), M) : o;
  }, M.filter = function(F) {
    return arguments.length ? (t = typeof F == "function" ? F : constant$3(!!F), M) : t;
  }, M.touchable = function(F) {
    return arguments.length ? (l = typeof F == "function" ? F : constant$3(!!F), M) : l;
  }, M.extent = function(F) {
    return arguments.length ? (e = typeof F == "function" ? F : constant$3([[+F[0][0], +F[0][1]], [+F[1][0], +F[1][1]]]), M) : e;
  }, M.scaleExtent = function(F) {
    return arguments.length ? (u[0] = +F[0], u[1] = +F[1], M) : [u[0], u[1]];
  }, M.translateExtent = function(F) {
    return arguments.length ? (f[0][0] = +F[0][0], f[1][0] = +F[1][0], f[0][1] = +F[0][1], f[1][1] = +F[1][1], M) : [[f[0][0], f[0][1]], [f[1][0], f[1][1]]];
  }, M.constrain = function(F) {
    return arguments.length ? (n = F, M) : n;
  }, M.duration = function(F) {
    return arguments.length ? (h = +F, M) : h;
  }, M.interpolate = function(F) {
    return arguments.length ? (p = F, M) : p;
  }, M.on = function() {
    var F = v.on.apply(v, arguments);
    return F === v ? M : F;
  }, M.clickDistance = function(F) {
    return arguments.length ? (_ = (F = +F) * F, M) : Math.sqrt(_);
  }, M.tapDistance = function(F) {
    return arguments.length ? (b = +F, M) : b;
  }, M;
}
const StoreContext = createContext(null), Provider$1 = StoreContext.Provider, errorMessages = {
  error001: () => "[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001",
  error002: () => "It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.",
  error003: (t) => `Node type "${t}" not found. Using fallback type "default".`,
  error004: () => "The React Flow parent container needs a width and a height to render the graph.",
  error005: () => "Only child nodes can use a parent extent.",
  error006: () => "Can't create edge. An edge needs a source and a target.",
  error007: (t) => `The old edge with id=${t} does not exist.`,
  error009: (t) => `Marker type "${t}" doesn't exist.`,
  error008: (t, e) => `Couldn't create edge for ${t ? "target" : "source"} handle id: "${t ? e.targetHandle : e.sourceHandle}", edge id: ${e.id}.`,
  error010: () => "Handle: No node id found. Make sure to only use a Handle inside a custom Node.",
  error011: (t) => `Edge type "${t}" not found. Using fallback type "default".`,
  error012: (t) => `Node with id "${t}" does not exist, it may have been removed. This can happen when a node is deleted before the "onNodeClick" handler is called.`
}, zustandErrorMessage = errorMessages.error001();
function useStore(t, e) {
  const n = useContext(StoreContext);
  if (n === null)
    throw new Error(zustandErrorMessage);
  return useStoreWithEqualityFn(n, t, e);
}
const useStoreApi = () => {
  const t = useContext(StoreContext);
  if (t === null)
    throw new Error(zustandErrorMessage);
  return useMemo(() => ({
    getState: t.getState,
    setState: t.setState,
    subscribe: t.subscribe,
    destroy: t.destroy
  }), [t]);
}, selector$g = (t) => t.userSelectionActive ? "none" : "all";
function Panel({ position: t, children: e, className: n, style: o, ...l }) {
  const u = useStore(selector$g), f = `${t}`.split("-");
  return React__default.createElement("div", { className: cc$1(["react-flow__panel", n, ...f]), style: { ...o, pointerEvents: u }, ...l }, e);
}
function Attribution({ proOptions: t, position: e = "bottom-right" }) {
  return t != null && t.hideAttribution ? null : React__default.createElement(
    Panel,
    { position: e, className: "react-flow__attribution", "data-message": "Please only hide this attribution when you are subscribed to React Flow Pro: https://reactflow.dev/pro" },
    React__default.createElement("a", { href: "https://reactflow.dev", target: "_blank", rel: "noopener noreferrer", "aria-label": "React Flow attribution" }, "React Flow")
  );
}
const EdgeText = ({ x: t, y: e, label: n, labelStyle: o = {}, labelShowBg: l = !0, labelBgStyle: u = {}, labelBgPadding: f = [2, 4], labelBgBorderRadius: h = 2, children: p, className: v, ...g }) => {
  const w = useRef(null), [E, T] = useState({ x: 0, y: 0, width: 0, height: 0 }), R = cc$1(["react-flow__edge-textwrapper", v]);
  return useEffect(() => {
    if (w.current) {
      const _ = w.current.getBBox();
      T({
        x: _.x,
        y: _.y,
        width: _.width,
        height: _.height
      });
    }
  }, [n]), typeof n > "u" || !n ? null : React__default.createElement(
    "g",
    { transform: `translate(${t - E.width / 2} ${e - E.height / 2})`, className: R, visibility: E.width ? "visible" : "hidden", ...g },
    l && React__default.createElement("rect", { width: E.width + 2 * f[0], x: -f[0], y: -f[1], height: E.height + 2 * f[1], className: "react-flow__edge-textbg", style: u, rx: h, ry: h }),
    React__default.createElement("text", { className: "react-flow__edge-text", y: E.height / 2, dy: "0.3em", ref: w, style: o }, n),
    p
  );
};
var EdgeText$1 = memo$1(EdgeText);
const getDimensions$1 = (t) => ({
  width: t.offsetWidth,
  height: t.offsetHeight
}), clamp$1 = (t, e = 0, n = 1) => Math.min(Math.max(t, e), n), clampPosition = (t = { x: 0, y: 0 }, e) => ({
  x: clamp$1(t.x, e[0][0], e[1][0]),
  y: clamp$1(t.y, e[0][1], e[1][1])
}), calcAutoPanVelocity = (t, e, n) => t < e ? clamp$1(Math.abs(t - e), 1, 50) / 50 : t > n ? -clamp$1(Math.abs(t - n), 1, 50) / 50 : 0, calcAutoPan = (t, e) => {
  const n = calcAutoPanVelocity(t.x, 35, e.width - 35) * 20, o = calcAutoPanVelocity(t.y, 35, e.height - 35) * 20;
  return [n, o];
}, getHostForElement = (t) => {
  var e;
  return ((e = t.getRootNode) == null ? void 0 : e.call(t)) || (window == null ? void 0 : window.document);
}, getBoundsOfBoxes = (t, e) => ({
  x: Math.min(t.x, e.x),
  y: Math.min(t.y, e.y),
  x2: Math.max(t.x2, e.x2),
  y2: Math.max(t.y2, e.y2)
}), rectToBox = ({ x: t, y: e, width: n, height: o }) => ({
  x: t,
  y: e,
  x2: t + n,
  y2: e + o
}), boxToRect = ({ x: t, y: e, x2: n, y2: o }) => ({
  x: t,
  y: e,
  width: n - t,
  height: o - e
}), nodeToRect = (t) => ({
  ...t.positionAbsolute || { x: 0, y: 0 },
  width: t.width || 0,
  height: t.height || 0
}), getBoundsOfRects = (t, e) => boxToRect(getBoundsOfBoxes(rectToBox(t), rectToBox(e))), getOverlappingArea = (t, e) => {
  const n = Math.max(0, Math.min(t.x + t.width, e.x + e.width) - Math.max(t.x, e.x)), o = Math.max(0, Math.min(t.y + t.height, e.y + e.height) - Math.max(t.y, e.y));
  return Math.ceil(n * o);
}, isRectObject = (t) => isNumeric(t.width) && isNumeric(t.height) && isNumeric(t.x) && isNumeric(t.y), isNumeric = (t) => !isNaN(t) && isFinite(t), internalsSymbol = Symbol.for("internals"), elementSelectionKeys = ["Enter", " ", "Escape"], devWarn = (t, e) => {
  process.env.NODE_ENV === "development" && console.warn(`[React Flow]: ${e} Help: https://reactflow.dev/error#${t}`);
}, isReactKeyboardEvent = (t) => "nativeEvent" in t;
function isInputDOMNode(t) {
  var l, u;
  const e = isReactKeyboardEvent(t) ? t.nativeEvent : t, n = ((u = (l = e.composedPath) == null ? void 0 : l.call(e)) == null ? void 0 : u[0]) || t.target;
  return ["INPUT", "SELECT", "TEXTAREA"].includes(n == null ? void 0 : n.nodeName) || (n == null ? void 0 : n.hasAttribute("contenteditable")) || !!(n != null && n.closest(".nokey"));
}
const isMouseEvent = (t) => "clientX" in t, getEventPosition = (t, e) => {
  var u, f;
  const n = isMouseEvent(t), o = n ? t.clientX : (u = t.touches) == null ? void 0 : u[0].clientX, l = n ? t.clientY : (f = t.touches) == null ? void 0 : f[0].clientY;
  return {
    x: o - ((e == null ? void 0 : e.left) ?? 0),
    y: l - ((e == null ? void 0 : e.top) ?? 0)
  };
}, isMacOs = () => {
  var t;
  return typeof navigator < "u" && ((t = navigator == null ? void 0 : navigator.userAgent) == null ? void 0 : t.indexOf("Mac")) >= 0;
}, BaseEdge = ({ id: t, path: e, labelX: n, labelY: o, label: l, labelStyle: u, labelShowBg: f, labelBgStyle: h, labelBgPadding: p, labelBgBorderRadius: v, style: g, markerEnd: w, markerStart: E, interactionWidth: T = 20 }) => React__default.createElement(
  React__default.Fragment,
  null,
  React__default.createElement("path", { id: t, style: g, d: e, fill: "none", className: "react-flow__edge-path", markerEnd: w, markerStart: E }),
  T && React__default.createElement("path", { d: e, fill: "none", strokeOpacity: 0, strokeWidth: T, className: "react-flow__edge-interaction" }),
  l && isNumeric(n) && isNumeric(o) ? React__default.createElement(EdgeText$1, { x: n, y: o, label: l, labelStyle: u, labelShowBg: f, labelBgStyle: h, labelBgPadding: p, labelBgBorderRadius: v }) : null
);
BaseEdge.displayName = "BaseEdge";
function getMouseHandler$1(t, e, n) {
  return n === void 0 ? n : (o) => {
    const l = e().edges.find((u) => u.id === t);
    l && n(o, { ...l });
  };
}
function getEdgeCenter({ sourceX: t, sourceY: e, targetX: n, targetY: o }) {
  const l = Math.abs(n - t) / 2, u = n < t ? n + l : n - l, f = Math.abs(o - e) / 2, h = o < e ? o + f : o - f;
  return [u, h, l, f];
}
function getBezierEdgeCenter({ sourceX: t, sourceY: e, targetX: n, targetY: o, sourceControlX: l, sourceControlY: u, targetControlX: f, targetControlY: h }) {
  const p = t * 0.125 + l * 0.375 + f * 0.375 + n * 0.125, v = e * 0.125 + u * 0.375 + h * 0.375 + o * 0.125, g = Math.abs(p - t), w = Math.abs(v - e);
  return [p, v, g, w];
}
var ConnectionMode;
(function(t) {
  t.Strict = "strict", t.Loose = "loose";
})(ConnectionMode || (ConnectionMode = {}));
var PanOnScrollMode;
(function(t) {
  t.Free = "free", t.Vertical = "vertical", t.Horizontal = "horizontal";
})(PanOnScrollMode || (PanOnScrollMode = {}));
var SelectionMode;
(function(t) {
  t.Partial = "partial", t.Full = "full";
})(SelectionMode || (SelectionMode = {}));
var ConnectionLineType;
(function(t) {
  t.Bezier = "default", t.Straight = "straight", t.Step = "step", t.SmoothStep = "smoothstep", t.SimpleBezier = "simplebezier";
})(ConnectionLineType || (ConnectionLineType = {}));
var MarkerType;
(function(t) {
  t.Arrow = "arrow", t.ArrowClosed = "arrowclosed";
})(MarkerType || (MarkerType = {}));
var Position;
(function(t) {
  t.Left = "left", t.Top = "top", t.Right = "right", t.Bottom = "bottom";
})(Position || (Position = {}));
function getControl({ pos: t, x1: e, y1: n, x2: o, y2: l }) {
  return t === Position.Left || t === Position.Right ? [0.5 * (e + o), n] : [e, 0.5 * (n + l)];
}
function getSimpleBezierPath({ sourceX: t, sourceY: e, sourcePosition: n = Position.Bottom, targetX: o, targetY: l, targetPosition: u = Position.Top }) {
  const [f, h] = getControl({
    pos: n,
    x1: t,
    y1: e,
    x2: o,
    y2: l
  }), [p, v] = getControl({
    pos: u,
    x1: o,
    y1: l,
    x2: t,
    y2: e
  }), [g, w, E, T] = getBezierEdgeCenter({
    sourceX: t,
    sourceY: e,
    targetX: o,
    targetY: l,
    sourceControlX: f,
    sourceControlY: h,
    targetControlX: p,
    targetControlY: v
  });
  return [
    `M${t},${e} C${f},${h} ${p},${v} ${o},${l}`,
    g,
    w,
    E,
    T
  ];
}
const SimpleBezierEdge = memo$1(({ sourceX: t, sourceY: e, targetX: n, targetY: o, sourcePosition: l = Position.Bottom, targetPosition: u = Position.Top, label: f, labelStyle: h, labelShowBg: p, labelBgStyle: v, labelBgPadding: g, labelBgBorderRadius: w, style: E, markerEnd: T, markerStart: R, interactionWidth: _ }) => {
  const [b, M, A] = getSimpleBezierPath({
    sourceX: t,
    sourceY: e,
    sourcePosition: l,
    targetX: n,
    targetY: o,
    targetPosition: u
  });
  return React__default.createElement(BaseEdge, { path: b, labelX: M, labelY: A, label: f, labelStyle: h, labelShowBg: p, labelBgStyle: v, labelBgPadding: g, labelBgBorderRadius: w, style: E, markerEnd: T, markerStart: R, interactionWidth: _ });
});
SimpleBezierEdge.displayName = "SimpleBezierEdge";
const handleDirections = {
  [Position.Left]: { x: -1, y: 0 },
  [Position.Right]: { x: 1, y: 0 },
  [Position.Top]: { x: 0, y: -1 },
  [Position.Bottom]: { x: 0, y: 1 }
}, getDirection = ({ source: t, sourcePosition: e = Position.Bottom, target: n }) => e === Position.Left || e === Position.Right ? t.x < n.x ? { x: 1, y: 0 } : { x: -1, y: 0 } : t.y < n.y ? { x: 0, y: 1 } : { x: 0, y: -1 }, distance = (t, e) => Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2));
function getPoints({ source: t, sourcePosition: e = Position.Bottom, target: n, targetPosition: o = Position.Top, center: l, offset: u }) {
  const f = handleDirections[e], h = handleDirections[o], p = { x: t.x + f.x * u, y: t.y + f.y * u }, v = { x: n.x + h.x * u, y: n.y + h.y * u }, g = getDirection({
    source: p,
    sourcePosition: e,
    target: v
  }), w = g.x !== 0 ? "x" : "y", E = g[w];
  let T = [], R, _;
  const b = { x: 0, y: 0 }, M = { x: 0, y: 0 }, [A, $, S, C] = getEdgeCenter({
    sourceX: t.x,
    sourceY: t.y,
    targetX: n.x,
    targetY: n.y
  });
  if (f[w] * h[w] === -1) {
    R = l.x ?? A, _ = l.y ?? $;
    const O = [
      { x: R, y: p.y },
      { x: R, y: v.y }
    ], N = [
      { x: p.x, y: _ },
      { x: v.x, y: _ }
    ];
    f[w] === E ? T = w === "x" ? O : N : T = w === "x" ? N : O;
  } else {
    const O = [{ x: p.x, y: v.y }], N = [{ x: v.x, y: p.y }];
    if (w === "x" ? T = f.x === E ? N : O : T = f.y === E ? O : N, e === o) {
      const B = Math.abs(t[w] - n[w]);
      if (B <= u) {
        const F = Math.min(u - 1, u - B);
        f[w] === E ? b[w] = (p[w] > t[w] ? -1 : 1) * F : M[w] = (v[w] > n[w] ? -1 : 1) * F;
      }
    }
    if (e !== o) {
      const B = w === "x" ? "y" : "x", F = f[w] === h[B], H = p[B] > v[B], W = p[B] < v[B];
      (f[w] === 1 && (!F && H || F && W) || f[w] !== 1 && (!F && W || F && H)) && (T = w === "x" ? O : N);
    }
    const j = { x: p.x + b.x, y: p.y + b.y }, L = { x: v.x + M.x, y: v.y + M.y }, z = Math.max(Math.abs(j.x - T[0].x), Math.abs(L.x - T[0].x)), G = Math.max(Math.abs(j.y - T[0].y), Math.abs(L.y - T[0].y));
    z >= G ? (R = (j.x + L.x) / 2, _ = T[0].y) : (R = T[0].x, _ = (j.y + L.y) / 2);
  }
  return [[
    t,
    { x: p.x + b.x, y: p.y + b.y },
    ...T,
    { x: v.x + M.x, y: v.y + M.y },
    n
  ], R, _, S, C];
}
function getBend(t, e, n, o) {
  const l = Math.min(distance(t, e) / 2, distance(e, n) / 2, o), { x: u, y: f } = e;
  if (t.x === u && u === n.x || t.y === f && f === n.y)
    return `L${u} ${f}`;
  if (t.y === f) {
    const v = t.x < n.x ? -1 : 1, g = t.y < n.y ? 1 : -1;
    return `L ${u + l * v},${f}Q ${u},${f} ${u},${f + l * g}`;
  }
  const h = t.x < n.x ? 1 : -1, p = t.y < n.y ? -1 : 1;
  return `L ${u},${f + l * p}Q ${u},${f} ${u + l * h},${f}`;
}
function getSmoothStepPath({ sourceX: t, sourceY: e, sourcePosition: n = Position.Bottom, targetX: o, targetY: l, targetPosition: u = Position.Top, borderRadius: f = 5, centerX: h, centerY: p, offset: v = 20 }) {
  const [g, w, E, T, R] = getPoints({
    source: { x: t, y: e },
    sourcePosition: n,
    target: { x: o, y: l },
    targetPosition: u,
    center: { x: h, y: p },
    offset: v
  });
  return [g.reduce((b, M, A) => {
    let $ = "";
    return A > 0 && A < g.length - 1 ? $ = getBend(g[A - 1], M, g[A + 1], f) : $ = `${A === 0 ? "M" : "L"}${M.x} ${M.y}`, b += $, b;
  }, ""), w, E, T, R];
}
const SmoothStepEdge = memo$1(({ sourceX: t, sourceY: e, targetX: n, targetY: o, label: l, labelStyle: u, labelShowBg: f, labelBgStyle: h, labelBgPadding: p, labelBgBorderRadius: v, style: g, sourcePosition: w = Position.Bottom, targetPosition: E = Position.Top, markerEnd: T, markerStart: R, pathOptions: _, interactionWidth: b }) => {
  const [M, A, $] = getSmoothStepPath({
    sourceX: t,
    sourceY: e,
    sourcePosition: w,
    targetX: n,
    targetY: o,
    targetPosition: E,
    borderRadius: _ == null ? void 0 : _.borderRadius,
    offset: _ == null ? void 0 : _.offset
  });
  return React__default.createElement(BaseEdge, { path: M, labelX: A, labelY: $, label: l, labelStyle: u, labelShowBg: f, labelBgStyle: h, labelBgPadding: p, labelBgBorderRadius: v, style: g, markerEnd: T, markerStart: R, interactionWidth: b });
});
SmoothStepEdge.displayName = "SmoothStepEdge";
const StepEdge = memo$1((t) => {
  var e;
  return React__default.createElement(SmoothStepEdge, { ...t, pathOptions: useMemo(() => {
    var n;
    return { borderRadius: 0, offset: (n = t.pathOptions) == null ? void 0 : n.offset };
  }, [(e = t.pathOptions) == null ? void 0 : e.offset]) });
});
StepEdge.displayName = "StepEdge";
function getStraightPath({ sourceX: t, sourceY: e, targetX: n, targetY: o }) {
  const [l, u, f, h] = getEdgeCenter({
    sourceX: t,
    sourceY: e,
    targetX: n,
    targetY: o
  });
  return [`M ${t},${e}L ${n},${o}`, l, u, f, h];
}
const StraightEdge = memo$1(({ sourceX: t, sourceY: e, targetX: n, targetY: o, label: l, labelStyle: u, labelShowBg: f, labelBgStyle: h, labelBgPadding: p, labelBgBorderRadius: v, style: g, markerEnd: w, markerStart: E, interactionWidth: T }) => {
  const [R, _, b] = getStraightPath({ sourceX: t, sourceY: e, targetX: n, targetY: o });
  return React__default.createElement(BaseEdge, { path: R, labelX: _, labelY: b, label: l, labelStyle: u, labelShowBg: f, labelBgStyle: h, labelBgPadding: p, labelBgBorderRadius: v, style: g, markerEnd: w, markerStart: E, interactionWidth: T });
});
StraightEdge.displayName = "StraightEdge";
function calculateControlOffset(t, e) {
  return t >= 0 ? 0.5 * t : e * 25 * Math.sqrt(-t);
}
function getControlWithCurvature({ pos: t, x1: e, y1: n, x2: o, y2: l, c: u }) {
  switch (t) {
    case Position.Left:
      return [e - calculateControlOffset(e - o, u), n];
    case Position.Right:
      return [e + calculateControlOffset(o - e, u), n];
    case Position.Top:
      return [e, n - calculateControlOffset(n - l, u)];
    case Position.Bottom:
      return [e, n + calculateControlOffset(l - n, u)];
  }
}
function getBezierPath({ sourceX: t, sourceY: e, sourcePosition: n = Position.Bottom, targetX: o, targetY: l, targetPosition: u = Position.Top, curvature: f = 0.25 }) {
  const [h, p] = getControlWithCurvature({
    pos: n,
    x1: t,
    y1: e,
    x2: o,
    y2: l,
    c: f
  }), [v, g] = getControlWithCurvature({
    pos: u,
    x1: o,
    y1: l,
    x2: t,
    y2: e,
    c: f
  }), [w, E, T, R] = getBezierEdgeCenter({
    sourceX: t,
    sourceY: e,
    targetX: o,
    targetY: l,
    sourceControlX: h,
    sourceControlY: p,
    targetControlX: v,
    targetControlY: g
  });
  return [
    `M${t},${e} C${h},${p} ${v},${g} ${o},${l}`,
    w,
    E,
    T,
    R
  ];
}
const BezierEdge = memo$1(({ sourceX: t, sourceY: e, targetX: n, targetY: o, sourcePosition: l = Position.Bottom, targetPosition: u = Position.Top, label: f, labelStyle: h, labelShowBg: p, labelBgStyle: v, labelBgPadding: g, labelBgBorderRadius: w, style: E, markerEnd: T, markerStart: R, pathOptions: _, interactionWidth: b }) => {
  const [M, A, $] = getBezierPath({
    sourceX: t,
    sourceY: e,
    sourcePosition: l,
    targetX: n,
    targetY: o,
    targetPosition: u,
    curvature: _ == null ? void 0 : _.curvature
  });
  return React__default.createElement(BaseEdge, { path: M, labelX: A, labelY: $, label: f, labelStyle: h, labelShowBg: p, labelBgStyle: v, labelBgPadding: g, labelBgBorderRadius: w, style: E, markerEnd: T, markerStart: R, interactionWidth: b });
});
BezierEdge.displayName = "BezierEdge";
const NodeIdContext = createContext(null), Provider = NodeIdContext.Provider;
NodeIdContext.Consumer;
const useNodeId = () => useContext(NodeIdContext), isEdge = (t) => "id" in t && "source" in t && "target" in t, getEdgeId = ({ source: t, sourceHandle: e, target: n, targetHandle: o }) => `reactflow__edge-${t}${e || ""}-${n}${o || ""}`, getMarkerId = (t, e) => typeof t > "u" ? "" : typeof t == "string" ? t : `${e ? `${e}__` : ""}${Object.keys(t).sort().map((o) => `${o}=${t[o]}`).join("&")}`, connectionExists = (t, e) => e.some((n) => n.source === t.source && n.target === t.target && (n.sourceHandle === t.sourceHandle || !n.sourceHandle && !t.sourceHandle) && (n.targetHandle === t.targetHandle || !n.targetHandle && !t.targetHandle)), addEdge = (t, e) => {
  if (!t.source || !t.target)
    return devWarn("006", errorMessages.error006()), e;
  let n;
  return isEdge(t) ? n = { ...t } : n = {
    ...t,
    id: getEdgeId(t)
  }, connectionExists(n, e) ? e : e.concat(n);
}, pointToRendererPoint = ({ x: t, y: e }, [n, o, l], u, [f, h]) => {
  const p = {
    x: (t - n) / l,
    y: (e - o) / l
  };
  return u ? {
    x: f * Math.round(p.x / f),
    y: h * Math.round(p.y / h)
  } : p;
}, rendererPointToPoint = ({ x: t, y: e }, [n, o, l]) => ({
  x: t * l + n,
  y: e * l + o
}), getNodePositionWithOrigin = (t, e = [0, 0]) => {
  if (!t)
    return {
      x: 0,
      y: 0,
      positionAbsolute: {
        x: 0,
        y: 0
      }
    };
  const n = (t.width ?? 0) * e[0], o = (t.height ?? 0) * e[1], l = {
    x: t.position.x - n,
    y: t.position.y - o
  };
  return {
    ...l,
    positionAbsolute: t.positionAbsolute ? {
      x: t.positionAbsolute.x - n,
      y: t.positionAbsolute.y - o
    } : l
  };
}, getNodesBounds = (t, e = [0, 0]) => {
  if (t.length === 0)
    return { x: 0, y: 0, width: 0, height: 0 };
  const n = t.reduce((o, l) => {
    const { x: u, y: f } = getNodePositionWithOrigin(l, e).positionAbsolute;
    return getBoundsOfBoxes(o, rectToBox({
      x: u,
      y: f,
      width: l.width || 0,
      height: l.height || 0
    }));
  }, { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 });
  return boxToRect(n);
}, getNodesInside = (t, e, [n, o, l] = [0, 0, 1], u = !1, f = !1, h = [0, 0]) => {
  const p = {
    x: (e.x - n) / l,
    y: (e.y - o) / l,
    width: e.width / l,
    height: e.height / l
  }, v = [];
  return t.forEach((g) => {
    const { width: w, height: E, selectable: T = !0, hidden: R = !1 } = g;
    if (f && !T || R)
      return !1;
    const { positionAbsolute: _ } = getNodePositionWithOrigin(g, h), b = {
      x: _.x,
      y: _.y,
      width: w || 0,
      height: E || 0
    }, M = getOverlappingArea(p, b), A = typeof w > "u" || typeof E > "u" || w === null || E === null, $ = u && M > 0, S = (w || 0) * (E || 0);
    (A || $ || M >= S || g.dragging) && v.push(g);
  }), v;
}, getConnectedEdges = (t, e) => {
  const n = t.map((o) => o.id);
  return e.filter((o) => n.includes(o.source) || n.includes(o.target));
}, getViewportForBounds = (t, e, n, o, l, u = 0.1) => {
  const f = e / (t.width * (1 + u)), h = n / (t.height * (1 + u)), p = Math.min(f, h), v = clamp$1(p, o, l), g = t.x + t.width / 2, w = t.y + t.height / 2, E = e / 2 - g * v, T = n / 2 - w * v;
  return { x: E, y: T, zoom: v };
}, getD3Transition = (t, e = 0) => t.transition().duration(e);
function getHandles(t, e, n, o) {
  return (e[n] || []).reduce((l, u) => {
    var f, h;
    return `${t.id}-${u.id}-${n}` !== o && l.push({
      id: u.id || null,
      type: n,
      nodeId: t.id,
      x: (((f = t.positionAbsolute) == null ? void 0 : f.x) ?? 0) + u.x + u.width / 2,
      y: (((h = t.positionAbsolute) == null ? void 0 : h.y) ?? 0) + u.y + u.height / 2
    }), l;
  }, []);
}
function getClosestHandle(t, e, n, o, l, u) {
  const { x: f, y: h } = getEventPosition(t), v = e.elementsFromPoint(f, h).find((R) => R.classList.contains("react-flow__handle"));
  if (v) {
    const R = v.getAttribute("data-nodeid");
    if (R) {
      const _ = getHandleType(void 0, v), b = v.getAttribute("data-handleid"), M = u({ nodeId: R, id: b, type: _ });
      if (M) {
        const A = l.find(($) => $.nodeId === R && $.type === _ && $.id === b);
        return {
          handle: {
            id: b,
            type: _,
            nodeId: R,
            x: (A == null ? void 0 : A.x) || n.x,
            y: (A == null ? void 0 : A.y) || n.y
          },
          validHandleResult: M
        };
      }
    }
  }
  let g = [], w = 1 / 0;
  if (l.forEach((R) => {
    const _ = Math.sqrt((R.x - n.x) ** 2 + (R.y - n.y) ** 2);
    if (_ <= o) {
      const b = u(R);
      _ <= w && (_ < w ? g = [{ handle: R, validHandleResult: b }] : _ === w && g.push({
        handle: R,
        validHandleResult: b
      }), w = _);
    }
  }), !g.length)
    return { handle: null, validHandleResult: defaultResult() };
  if (g.length === 1)
    return g[0];
  const E = g.some(({ validHandleResult: R }) => R.isValid), T = g.some(({ handle: R }) => R.type === "target");
  return g.find(({ handle: R, validHandleResult: _ }) => T ? R.type === "target" : E ? _.isValid : !0) || g[0];
}
const nullConnection = { source: null, target: null, sourceHandle: null, targetHandle: null }, defaultResult = () => ({
  handleDomNode: null,
  isValid: !1,
  connection: nullConnection,
  endHandle: null
});
function isValidHandle(t, e, n, o, l, u, f) {
  const h = l === "target", p = f.querySelector(`.react-flow__handle[data-id="${t == null ? void 0 : t.nodeId}-${t == null ? void 0 : t.id}-${t == null ? void 0 : t.type}"]`), v = {
    ...defaultResult(),
    handleDomNode: p
  };
  if (p) {
    const g = getHandleType(void 0, p), w = p.getAttribute("data-nodeid"), E = p.getAttribute("data-handleid"), T = p.classList.contains("connectable"), R = p.classList.contains("connectableend"), _ = {
      source: h ? w : n,
      sourceHandle: h ? E : o,
      target: h ? n : w,
      targetHandle: h ? o : E
    };
    v.connection = _, T && R && (e === ConnectionMode.Strict ? h && g === "source" || !h && g === "target" : w !== n || E !== o) && (v.endHandle = {
      nodeId: w,
      handleId: E,
      type: g
    }, v.isValid = u(_));
  }
  return v;
}
function getHandleLookup({ nodes: t, nodeId: e, handleId: n, handleType: o }) {
  return t.reduce((l, u) => {
    if (u[internalsSymbol]) {
      const { handleBounds: f } = u[internalsSymbol];
      let h = [], p = [];
      f && (h = getHandles(u, f, "source", `${e}-${n}-${o}`), p = getHandles(u, f, "target", `${e}-${n}-${o}`)), l.push(...h, ...p);
    }
    return l;
  }, []);
}
function getHandleType(t, e) {
  return t || (e != null && e.classList.contains("target") ? "target" : e != null && e.classList.contains("source") ? "source" : null);
}
function resetRecentHandle(t) {
  t == null || t.classList.remove("valid", "connecting", "react-flow__handle-valid", "react-flow__handle-connecting");
}
function getConnectionStatus(t, e) {
  let n = null;
  return e ? n = "valid" : t && !e && (n = "invalid"), n;
}
function handlePointerDown({ event: t, handleId: e, nodeId: n, onConnect: o, isTarget: l, getState: u, setState: f, isValidConnection: h, edgeUpdaterType: p, onReconnectEnd: v }) {
  const g = getHostForElement(t.target), { connectionMode: w, domNode: E, autoPanOnConnect: T, connectionRadius: R, onConnectStart: _, panBy: b, getNodes: M, cancelConnection: A } = u();
  let $ = 0, S;
  const { x: C, y: D } = getEventPosition(t), O = g == null ? void 0 : g.elementFromPoint(C, D), N = getHandleType(p, O), j = E == null ? void 0 : E.getBoundingClientRect();
  if (!j || !N)
    return;
  let L, z = getEventPosition(t, j), G = !1, B = null, F = !1, H = null;
  const W = getHandleLookup({
    nodes: M(),
    nodeId: n,
    handleId: e,
    handleType: N
  }), V = () => {
    if (!T)
      return;
    const [Q, q] = calcAutoPan(z, j);
    b({ x: Q, y: q }), $ = requestAnimationFrame(V);
  };
  f({
    connectionPosition: z,
    connectionStatus: null,
    // connectionNodeId etc will be removed in the next major in favor of connectionStartHandle
    connectionNodeId: n,
    connectionHandleId: e,
    connectionHandleType: N,
    connectionStartHandle: {
      nodeId: n,
      handleId: e,
      type: N
    },
    connectionEndHandle: null
  }), _ == null || _(t, { nodeId: n, handleId: e, handleType: N });
  function X(Q) {
    const { transform: q } = u();
    z = getEventPosition(Q, j);
    const { handle: J, validHandleResult: ie } = getClosestHandle(Q, g, pointToRendererPoint(z, q, !1, [1, 1]), R, W, (ne) => isValidHandle(ne, w, n, e, l ? "target" : "source", h, g));
    if (S = J, G || (V(), G = !0), H = ie.handleDomNode, B = ie.connection, F = ie.isValid, f({
      connectionPosition: S && F ? rendererPointToPoint({
        x: S.x,
        y: S.y
      }, q) : z,
      connectionStatus: getConnectionStatus(!!S, F),
      connectionEndHandle: ie.endHandle
    }), !S && !F && !H)
      return resetRecentHandle(L);
    B.source !== B.target && H && (resetRecentHandle(L), L = H, H.classList.add("connecting", "react-flow__handle-connecting"), H.classList.toggle("valid", F), H.classList.toggle("react-flow__handle-valid", F));
  }
  function Z(Q) {
    var q, J;
    (S || H) && B && F && (o == null || o(B)), (J = (q = u()).onConnectEnd) == null || J.call(q, Q), p && (v == null || v(Q)), resetRecentHandle(L), A(), cancelAnimationFrame($), G = !1, F = !1, B = null, H = null, g.removeEventListener("mousemove", X), g.removeEventListener("mouseup", Z), g.removeEventListener("touchmove", X), g.removeEventListener("touchend", Z);
  }
  g.addEventListener("mousemove", X), g.addEventListener("mouseup", Z), g.addEventListener("touchmove", X), g.addEventListener("touchend", Z);
}
const alwaysValid = () => !0, selector$f = (t) => ({
  connectionStartHandle: t.connectionStartHandle,
  connectOnClick: t.connectOnClick,
  noPanClassName: t.noPanClassName
}), connectingSelector = (t, e, n) => (o) => {
  const { connectionStartHandle: l, connectionEndHandle: u, connectionClickStartHandle: f } = o;
  return {
    connecting: (l == null ? void 0 : l.nodeId) === t && (l == null ? void 0 : l.handleId) === e && (l == null ? void 0 : l.type) === n || (u == null ? void 0 : u.nodeId) === t && (u == null ? void 0 : u.handleId) === e && (u == null ? void 0 : u.type) === n,
    clickConnecting: (f == null ? void 0 : f.nodeId) === t && (f == null ? void 0 : f.handleId) === e && (f == null ? void 0 : f.type) === n
  };
}, Handle = forwardRef(({ type: t = "source", position: e = Position.Top, isValidConnection: n, isConnectable: o = !0, isConnectableStart: l = !0, isConnectableEnd: u = !0, id: f, onConnect: h, children: p, className: v, onMouseDown: g, onTouchStart: w, ...E }, T) => {
  var j, L;
  const R = f || null, _ = t === "target", b = useStoreApi(), M = useNodeId(), { connectOnClick: A, noPanClassName: $ } = useStore(selector$f, shallow$1), { connecting: S, clickConnecting: C } = useStore(connectingSelector(M, R, t), shallow$1);
  M || (L = (j = b.getState()).onError) == null || L.call(j, "010", errorMessages.error010());
  const D = (z) => {
    const { defaultEdgeOptions: G, onConnect: B, hasDefaultEdges: F } = b.getState(), H = {
      ...G,
      ...z
    };
    if (F) {
      const { edges: W, setEdges: V } = b.getState();
      V(addEdge(H, W));
    }
    B == null || B(H), h == null || h(H);
  }, O = (z) => {
    if (!M)
      return;
    const G = isMouseEvent(z);
    l && (G && z.button === 0 || !G) && handlePointerDown({
      event: z,
      handleId: R,
      nodeId: M,
      onConnect: D,
      isTarget: _,
      getState: b.getState,
      setState: b.setState,
      isValidConnection: n || b.getState().isValidConnection || alwaysValid
    }), G ? g == null || g(z) : w == null || w(z);
  }, N = (z) => {
    const { onClickConnectStart: G, onClickConnectEnd: B, connectionClickStartHandle: F, connectionMode: H, isValidConnection: W } = b.getState();
    if (!M || !F && !l)
      return;
    if (!F) {
      G == null || G(z, { nodeId: M, handleId: R, handleType: t }), b.setState({ connectionClickStartHandle: { nodeId: M, type: t, handleId: R } });
      return;
    }
    const V = getHostForElement(z.target), X = n || W || alwaysValid, { connection: Z, isValid: Q } = isValidHandle({
      nodeId: M,
      id: R,
      type: t
    }, H, F.nodeId, F.handleId || null, F.type, X, V);
    Q && D(Z), B == null || B(z), b.setState({ connectionClickStartHandle: null });
  };
  return React__default.createElement("div", { "data-handleid": R, "data-nodeid": M, "data-handlepos": e, "data-id": `${M}-${R}-${t}`, className: cc$1([
    "react-flow__handle",
    `react-flow__handle-${e}`,
    "nodrag",
    $,
    v,
    {
      source: !_,
      target: _,
      connectable: o,
      connectablestart: l,
      connectableend: u,
      connecting: C,
      // this class is used to style the handle when the user is connecting
      connectionindicator: o && (l && !S || u && S)
    }
  ]), onMouseDown: O, onTouchStart: O, onClick: A ? N : void 0, ref: T, ...E }, p);
});
Handle.displayName = "Handle";
var Handle$1 = memo$1(Handle);
const DefaultNode = ({ data: t, isConnectable: e, targetPosition: n = Position.Top, sourcePosition: o = Position.Bottom }) => React__default.createElement(
  React__default.Fragment,
  null,
  React__default.createElement(Handle$1, { type: "target", position: n, isConnectable: e }),
  t == null ? void 0 : t.label,
  React__default.createElement(Handle$1, { type: "source", position: o, isConnectable: e })
);
DefaultNode.displayName = "DefaultNode";
var DefaultNode$1 = memo$1(DefaultNode);
const InputNode = ({ data: t, isConnectable: e, sourcePosition: n = Position.Bottom }) => React__default.createElement(
  React__default.Fragment,
  null,
  t == null ? void 0 : t.label,
  React__default.createElement(Handle$1, { type: "source", position: n, isConnectable: e })
);
InputNode.displayName = "InputNode";
var InputNode$1 = memo$1(InputNode);
const OutputNode = ({ data: t, isConnectable: e, targetPosition: n = Position.Top }) => React__default.createElement(
  React__default.Fragment,
  null,
  React__default.createElement(Handle$1, { type: "target", position: n, isConnectable: e }),
  t == null ? void 0 : t.label
);
OutputNode.displayName = "OutputNode";
var OutputNode$1 = memo$1(OutputNode);
const GroupNode = () => null;
GroupNode.displayName = "GroupNode";
const selector$e = (t) => ({
  selectedNodes: t.getNodes().filter((e) => e.selected),
  selectedEdges: t.edges.filter((e) => e.selected).map((e) => ({ ...e }))
}), selectId = (t) => t.id;
function areEqual(t, e) {
  return shallow$1(t.selectedNodes.map(selectId), e.selectedNodes.map(selectId)) && shallow$1(t.selectedEdges.map(selectId), e.selectedEdges.map(selectId));
}
const SelectionListener = memo$1(({ onSelectionChange: t }) => {
  const e = useStoreApi(), { selectedNodes: n, selectedEdges: o } = useStore(selector$e, areEqual);
  return useEffect(() => {
    const l = { nodes: n, edges: o };
    t == null || t(l), e.getState().onSelectionChange.forEach((u) => u(l));
  }, [n, o, t]), null;
});
SelectionListener.displayName = "SelectionListener";
const changeSelector = (t) => !!t.onSelectionChange;
function Wrapper$1({ onSelectionChange: t }) {
  const e = useStore(changeSelector);
  return t || e ? React__default.createElement(SelectionListener, { onSelectionChange: t }) : null;
}
const selector$d = (t) => ({
  setNodes: t.setNodes,
  setEdges: t.setEdges,
  setDefaultNodesAndEdges: t.setDefaultNodesAndEdges,
  setMinZoom: t.setMinZoom,
  setMaxZoom: t.setMaxZoom,
  setTranslateExtent: t.setTranslateExtent,
  setNodeExtent: t.setNodeExtent,
  reset: t.reset
});
function useStoreUpdater(t, e) {
  useEffect(() => {
    typeof t < "u" && e(t);
  }, [t]);
}
function useDirectStoreUpdater(t, e, n) {
  useEffect(() => {
    typeof e < "u" && n({ [t]: e });
  }, [e]);
}
const StoreUpdater = ({ nodes: t, edges: e, defaultNodes: n, defaultEdges: o, onConnect: l, onConnectStart: u, onConnectEnd: f, onClickConnectStart: h, onClickConnectEnd: p, nodesDraggable: v, nodesConnectable: g, nodesFocusable: w, edgesFocusable: E, edgesUpdatable: T, elevateNodesOnSelect: R, minZoom: _, maxZoom: b, nodeExtent: M, onNodesChange: A, onEdgesChange: $, elementsSelectable: S, connectionMode: C, snapGrid: D, snapToGrid: O, translateExtent: N, connectOnClick: j, defaultEdgeOptions: L, fitView: z, fitViewOptions: G, onNodesDelete: B, onEdgesDelete: F, onNodeDrag: H, onNodeDragStart: W, onNodeDragStop: V, onSelectionDrag: X, onSelectionDragStart: Z, onSelectionDragStop: Q, noPanClassName: q, nodeOrigin: J, rfId: ie, autoPanOnConnect: ne, autoPanOnNodeDrag: ge, onError: ye, connectionRadius: xe, isValidConnection: we, nodeDragThreshold: de }) => {
  const { setNodes: Te, setEdges: Ce, setDefaultNodesAndEdges: ee, setMinZoom: Ae, setMaxZoom: be, setTranslateExtent: Fe, setNodeExtent: et, reset: Ye } = useStore(selector$d, shallow$1), De = useStoreApi();
  return useEffect(() => {
    const Ue = o == null ? void 0 : o.map((Qe) => ({ ...Qe, ...L }));
    return ee(n, Ue), () => {
      Ye();
    };
  }, []), useDirectStoreUpdater("defaultEdgeOptions", L, De.setState), useDirectStoreUpdater("connectionMode", C, De.setState), useDirectStoreUpdater("onConnect", l, De.setState), useDirectStoreUpdater("onConnectStart", u, De.setState), useDirectStoreUpdater("onConnectEnd", f, De.setState), useDirectStoreUpdater("onClickConnectStart", h, De.setState), useDirectStoreUpdater("onClickConnectEnd", p, De.setState), useDirectStoreUpdater("nodesDraggable", v, De.setState), useDirectStoreUpdater("nodesConnectable", g, De.setState), useDirectStoreUpdater("nodesFocusable", w, De.setState), useDirectStoreUpdater("edgesFocusable", E, De.setState), useDirectStoreUpdater("edgesUpdatable", T, De.setState), useDirectStoreUpdater("elementsSelectable", S, De.setState), useDirectStoreUpdater("elevateNodesOnSelect", R, De.setState), useDirectStoreUpdater("snapToGrid", O, De.setState), useDirectStoreUpdater("snapGrid", D, De.setState), useDirectStoreUpdater("onNodesChange", A, De.setState), useDirectStoreUpdater("onEdgesChange", $, De.setState), useDirectStoreUpdater("connectOnClick", j, De.setState), useDirectStoreUpdater("fitViewOnInit", z, De.setState), useDirectStoreUpdater("fitViewOnInitOptions", G, De.setState), useDirectStoreUpdater("onNodesDelete", B, De.setState), useDirectStoreUpdater("onEdgesDelete", F, De.setState), useDirectStoreUpdater("onNodeDrag", H, De.setState), useDirectStoreUpdater("onNodeDragStart", W, De.setState), useDirectStoreUpdater("onNodeDragStop", V, De.setState), useDirectStoreUpdater("onSelectionDrag", X, De.setState), useDirectStoreUpdater("onSelectionDragStart", Z, De.setState), useDirectStoreUpdater("onSelectionDragStop", Q, De.setState), useDirectStoreUpdater("noPanClassName", q, De.setState), useDirectStoreUpdater("nodeOrigin", J, De.setState), useDirectStoreUpdater("rfId", ie, De.setState), useDirectStoreUpdater("autoPanOnConnect", ne, De.setState), useDirectStoreUpdater("autoPanOnNodeDrag", ge, De.setState), useDirectStoreUpdater("onError", ye, De.setState), useDirectStoreUpdater("connectionRadius", xe, De.setState), useDirectStoreUpdater("isValidConnection", we, De.setState), useDirectStoreUpdater("nodeDragThreshold", de, De.setState), useStoreUpdater(t, Te), useStoreUpdater(e, Ce), useStoreUpdater(_, Ae), useStoreUpdater(b, be), useStoreUpdater(N, Fe), useStoreUpdater(M, et), null;
}, style = { display: "none" }, ariaLiveStyle = {
  position: "absolute",
  width: 1,
  height: 1,
  margin: -1,
  border: 0,
  padding: 0,
  overflow: "hidden",
  clip: "rect(0px, 0px, 0px, 0px)",
  clipPath: "inset(100%)"
}, ARIA_NODE_DESC_KEY = "react-flow__node-desc", ARIA_EDGE_DESC_KEY = "react-flow__edge-desc", ARIA_LIVE_MESSAGE = "react-flow__aria-live", selector$c = (t) => t.ariaLiveMessage;
function AriaLiveMessage({ rfId: t }) {
  const e = useStore(selector$c);
  return React__default.createElement("div", { id: `${ARIA_LIVE_MESSAGE}-${t}`, "aria-live": "assertive", "aria-atomic": "true", style: ariaLiveStyle }, e);
}
function A11yDescriptions({ rfId: t, disableKeyboardA11y: e }) {
  return React__default.createElement(
    React__default.Fragment,
    null,
    React__default.createElement(
      "div",
      { id: `${ARIA_NODE_DESC_KEY}-${t}`, style },
      "Press enter or space to select a node.",
      !e && "You can then use the arrow keys to move the node around.",
      " Press delete to remove it and escape to cancel.",
      " "
    ),
    React__default.createElement("div", { id: `${ARIA_EDGE_DESC_KEY}-${t}`, style }, "Press enter or space to select an edge. You can then press delete to remove it or escape to cancel."),
    !e && React__default.createElement(AriaLiveMessage, { rfId: t })
  );
}
var useKeyPress = (t = null, e = { actInsideInputWithModifier: !0 }) => {
  const [n, o] = useState(!1), l = useRef(!1), u = useRef(/* @__PURE__ */ new Set([])), [f, h] = useMemo(() => {
    if (t !== null) {
      const v = (Array.isArray(t) ? t : [t]).filter((w) => typeof w == "string").map((w) => w.split("+")), g = v.reduce((w, E) => w.concat(...E), []);
      return [v, g];
    }
    return [[], []];
  }, [t]);
  return useEffect(() => {
    const p = typeof document < "u" ? document : null, v = (e == null ? void 0 : e.target) || p;
    if (t !== null) {
      const g = (T) => {
        if (l.current = T.ctrlKey || T.metaKey || T.shiftKey, (!l.current || l.current && !e.actInsideInputWithModifier) && isInputDOMNode(T))
          return !1;
        const _ = useKeyOrCode(T.code, h);
        u.current.add(T[_]), isMatchingKey(f, u.current, !1) && (T.preventDefault(), o(!0));
      }, w = (T) => {
        if ((!l.current || l.current && !e.actInsideInputWithModifier) && isInputDOMNode(T))
          return !1;
        const _ = useKeyOrCode(T.code, h);
        isMatchingKey(f, u.current, !0) ? (o(!1), u.current.clear()) : u.current.delete(T[_]), T.key === "Meta" && u.current.clear(), l.current = !1;
      }, E = () => {
        u.current.clear(), o(!1);
      };
      return v == null || v.addEventListener("keydown", g), v == null || v.addEventListener("keyup", w), window.addEventListener("blur", E), () => {
        v == null || v.removeEventListener("keydown", g), v == null || v.removeEventListener("keyup", w), window.removeEventListener("blur", E);
      };
    }
  }, [t, o]), n;
};
function isMatchingKey(t, e, n) {
  return t.filter((o) => n || o.length === e.size).some((o) => o.every((l) => e.has(l)));
}
function useKeyOrCode(t, e) {
  return e.includes(t) ? "code" : "key";
}
function calculateXYZPosition(t, e, n, o) {
  var h, p;
  const l = t.parentNode || t.parentId;
  if (!l)
    return n;
  const u = e.get(l), f = getNodePositionWithOrigin(u, o);
  return calculateXYZPosition(u, e, {
    x: (n.x ?? 0) + f.x,
    y: (n.y ?? 0) + f.y,
    z: (((h = u[internalsSymbol]) == null ? void 0 : h.z) ?? 0) > (n.z ?? 0) ? ((p = u[internalsSymbol]) == null ? void 0 : p.z) ?? 0 : n.z ?? 0
  }, o);
}
function updateAbsoluteNodePositions(t, e, n) {
  t.forEach((o) => {
    var u;
    const l = o.parentNode || o.parentId;
    if (l && !t.has(l))
      throw new Error(`Parent node ${l} not found`);
    if (l || n != null && n[o.id]) {
      const { x: f, y: h, z: p } = calculateXYZPosition(o, t, {
        ...o.position,
        z: ((u = o[internalsSymbol]) == null ? void 0 : u.z) ?? 0
      }, e);
      o.positionAbsolute = {
        x: f,
        y: h
      }, o[internalsSymbol].z = p, n != null && n[o.id] && (o[internalsSymbol].isParent = !0);
    }
  });
}
function createNodeInternals(t, e, n, o) {
  const l = /* @__PURE__ */ new Map(), u = {}, f = o ? 1e3 : 0;
  return t.forEach((h) => {
    var T;
    const p = (isNumeric(h.zIndex) ? h.zIndex : 0) + (h.selected ? f : 0), v = e.get(h.id), g = {
      ...h,
      positionAbsolute: {
        x: h.position.x,
        y: h.position.y
      }
    }, w = h.parentNode || h.parentId;
    w && (u[w] = !0);
    const E = (v == null ? void 0 : v.type) && (v == null ? void 0 : v.type) !== h.type;
    Object.defineProperty(g, internalsSymbol, {
      enumerable: !1,
      value: {
        handleBounds: E || (T = v == null ? void 0 : v[internalsSymbol]) == null ? void 0 : T.handleBounds,
        z: p
      }
    }), l.set(h.id, g);
  }), updateAbsoluteNodePositions(l, n, u), l;
}
function fitView(t, e = {}) {
  const { getNodes: n, width: o, height: l, minZoom: u, maxZoom: f, d3Zoom: h, d3Selection: p, fitViewOnInitDone: v, fitViewOnInit: g, nodeOrigin: w } = t(), E = e.initial && !v && g;
  if (h && p && (E || !e.initial)) {
    const R = n().filter((b) => {
      var A;
      const M = e.includeHiddenNodes ? b.width && b.height : !b.hidden;
      return (A = e.nodes) != null && A.length ? M && e.nodes.some(($) => $.id === b.id) : M;
    }), _ = R.every((b) => b.width && b.height);
    if (R.length > 0 && _) {
      const b = getNodesBounds(R, w), { x: M, y: A, zoom: $ } = getViewportForBounds(b, o, l, e.minZoom ?? u, e.maxZoom ?? f, e.padding ?? 0.1), S = identity$c.translate(M, A).scale($);
      return typeof e.duration == "number" && e.duration > 0 ? h.transform(getD3Transition(p, e.duration), S) : h.transform(p, S), !0;
    }
  }
  return !1;
}
function handleControlledNodeSelectionChange(t, e) {
  return t.forEach((n) => {
    const o = e.get(n.id);
    o && e.set(o.id, {
      ...o,
      [internalsSymbol]: o[internalsSymbol],
      selected: n.selected
    });
  }), new Map(e);
}
function handleControlledEdgeSelectionChange(t, e) {
  return e.map((n) => {
    const o = t.find((l) => l.id === n.id);
    return o && (n.selected = o.selected), n;
  });
}
function updateNodesAndEdgesSelections({ changedNodes: t, changedEdges: e, get: n, set: o }) {
  const { nodeInternals: l, edges: u, onNodesChange: f, onEdgesChange: h, hasDefaultNodes: p, hasDefaultEdges: v } = n();
  t != null && t.length && (p && o({ nodeInternals: handleControlledNodeSelectionChange(t, l) }), f == null || f(t)), e != null && e.length && (v && o({ edges: handleControlledEdgeSelectionChange(e, u) }), h == null || h(e));
}
const noop$3 = () => {
}, initialViewportHelper = {
  zoomIn: noop$3,
  zoomOut: noop$3,
  zoomTo: noop$3,
  getZoom: () => 1,
  setViewport: noop$3,
  getViewport: () => ({ x: 0, y: 0, zoom: 1 }),
  fitView: () => !1,
  setCenter: noop$3,
  fitBounds: noop$3,
  project: (t) => t,
  screenToFlowPosition: (t) => t,
  flowToScreenPosition: (t) => t,
  viewportInitialized: !1
}, selector$b = (t) => ({
  d3Zoom: t.d3Zoom,
  d3Selection: t.d3Selection
}), useViewportHelper = () => {
  const t = useStoreApi(), { d3Zoom: e, d3Selection: n } = useStore(selector$b, shallow$1);
  return useMemo(() => n && e ? {
    zoomIn: (l) => e.scaleBy(getD3Transition(n, l == null ? void 0 : l.duration), 1.2),
    zoomOut: (l) => e.scaleBy(getD3Transition(n, l == null ? void 0 : l.duration), 1 / 1.2),
    zoomTo: (l, u) => e.scaleTo(getD3Transition(n, u == null ? void 0 : u.duration), l),
    getZoom: () => t.getState().transform[2],
    setViewport: (l, u) => {
      const [f, h, p] = t.getState().transform, v = identity$c.translate(l.x ?? f, l.y ?? h).scale(l.zoom ?? p);
      e.transform(getD3Transition(n, u == null ? void 0 : u.duration), v);
    },
    getViewport: () => {
      const [l, u, f] = t.getState().transform;
      return { x: l, y: u, zoom: f };
    },
    fitView: (l) => fitView(t.getState, l),
    setCenter: (l, u, f) => {
      const { width: h, height: p, maxZoom: v } = t.getState(), g = typeof (f == null ? void 0 : f.zoom) < "u" ? f.zoom : v, w = h / 2 - l * g, E = p / 2 - u * g, T = identity$c.translate(w, E).scale(g);
      e.transform(getD3Transition(n, f == null ? void 0 : f.duration), T);
    },
    fitBounds: (l, u) => {
      const { width: f, height: h, minZoom: p, maxZoom: v } = t.getState(), { x: g, y: w, zoom: E } = getViewportForBounds(l, f, h, p, v, (u == null ? void 0 : u.padding) ?? 0.1), T = identity$c.translate(g, w).scale(E);
      e.transform(getD3Transition(n, u == null ? void 0 : u.duration), T);
    },
    // @deprecated Use `screenToFlowPosition`.
    project: (l) => {
      const { transform: u, snapToGrid: f, snapGrid: h } = t.getState();
      return console.warn("[DEPRECATED] `project` is deprecated. Instead use `screenToFlowPosition`. There is no need to subtract the react flow bounds anymore! https://reactflow.dev/api-reference/types/react-flow-instance#screen-to-flow-position"), pointToRendererPoint(l, u, f, h);
    },
    screenToFlowPosition: (l) => {
      const { transform: u, snapToGrid: f, snapGrid: h, domNode: p } = t.getState();
      if (!p)
        return l;
      const { x: v, y: g } = p.getBoundingClientRect(), w = {
        x: l.x - v,
        y: l.y - g
      };
      return pointToRendererPoint(w, u, f, h);
    },
    flowToScreenPosition: (l) => {
      const { transform: u, domNode: f } = t.getState();
      if (!f)
        return l;
      const { x: h, y: p } = f.getBoundingClientRect(), v = rendererPointToPoint(l, u);
      return {
        x: v.x + h,
        y: v.y + p
      };
    },
    viewportInitialized: !0
  } : initialViewportHelper, [e, n]);
};
function useReactFlow() {
  const t = useViewportHelper(), e = useStoreApi(), n = useCallback(() => e.getState().getNodes().map((_) => ({ ..._ })), []), o = useCallback((_) => e.getState().nodeInternals.get(_), []), l = useCallback(() => {
    const { edges: _ = [] } = e.getState();
    return _.map((b) => ({ ...b }));
  }, []), u = useCallback((_) => {
    const { edges: b = [] } = e.getState();
    return b.find((M) => M.id === _);
  }, []), f = useCallback((_) => {
    const { getNodes: b, setNodes: M, hasDefaultNodes: A, onNodesChange: $ } = e.getState(), S = b(), C = typeof _ == "function" ? _(S) : _;
    if (A)
      M(C);
    else if ($) {
      const D = C.length === 0 ? S.map((O) => ({ type: "remove", id: O.id })) : C.map((O) => ({ item: O, type: "reset" }));
      $(D);
    }
  }, []), h = useCallback((_) => {
    const { edges: b = [], setEdges: M, hasDefaultEdges: A, onEdgesChange: $ } = e.getState(), S = typeof _ == "function" ? _(b) : _;
    if (A)
      M(S);
    else if ($) {
      const C = S.length === 0 ? b.map((D) => ({ type: "remove", id: D.id })) : S.map((D) => ({ item: D, type: "reset" }));
      $(C);
    }
  }, []), p = useCallback((_) => {
    const b = Array.isArray(_) ? _ : [_], { getNodes: M, setNodes: A, hasDefaultNodes: $, onNodesChange: S } = e.getState();
    if ($) {
      const D = [...M(), ...b];
      A(D);
    } else if (S) {
      const C = b.map((D) => ({ item: D, type: "add" }));
      S(C);
    }
  }, []), v = useCallback((_) => {
    const b = Array.isArray(_) ? _ : [_], { edges: M = [], setEdges: A, hasDefaultEdges: $, onEdgesChange: S } = e.getState();
    if ($)
      A([...M, ...b]);
    else if (S) {
      const C = b.map((D) => ({ item: D, type: "add" }));
      S(C);
    }
  }, []), g = useCallback(() => {
    const { getNodes: _, edges: b = [], transform: M } = e.getState(), [A, $, S] = M;
    return {
      nodes: _().map((C) => ({ ...C })),
      edges: b.map((C) => ({ ...C })),
      viewport: {
        x: A,
        y: $,
        zoom: S
      }
    };
  }, []), w = useCallback(({ nodes: _, edges: b }) => {
    const { nodeInternals: M, getNodes: A, edges: $, hasDefaultNodes: S, hasDefaultEdges: C, onNodesDelete: D, onEdgesDelete: O, onNodesChange: N, onEdgesChange: j } = e.getState(), L = (_ || []).map((H) => H.id), z = (b || []).map((H) => H.id), G = A().reduce((H, W) => {
      const V = W.parentNode || W.parentId, X = !L.includes(W.id) && V && H.find((Q) => Q.id === V);
      return (typeof W.deletable == "boolean" ? W.deletable : !0) && (L.includes(W.id) || X) && H.push(W), H;
    }, []), B = $.filter((H) => typeof H.deletable == "boolean" ? H.deletable : !0), F = B.filter((H) => z.includes(H.id));
    if (G || F) {
      const H = getConnectedEdges(G, B), W = [...F, ...H], V = W.reduce((X, Z) => (X.includes(Z.id) || X.push(Z.id), X), []);
      if ((C || S) && (C && e.setState({
        edges: $.filter((X) => !V.includes(X.id))
      }), S && (G.forEach((X) => {
        M.delete(X.id);
      }), e.setState({
        nodeInternals: new Map(M)
      }))), V.length > 0 && (O == null || O(W), j && j(V.map((X) => ({
        id: X,
        type: "remove"
      })))), G.length > 0 && (D == null || D(G), N)) {
        const X = G.map((Z) => ({ id: Z.id, type: "remove" }));
        N(X);
      }
    }
  }, []), E = useCallback((_) => {
    const b = isRectObject(_), M = b ? null : e.getState().nodeInternals.get(_.id);
    return !b && !M ? [null, null, b] : [b ? _ : nodeToRect(M), M, b];
  }, []), T = useCallback((_, b = !0, M) => {
    const [A, $, S] = E(_);
    return A ? (M || e.getState().getNodes()).filter((C) => {
      if (!S && (C.id === $.id || !C.positionAbsolute))
        return !1;
      const D = nodeToRect(C), O = getOverlappingArea(D, A);
      return b && O > 0 || O >= A.width * A.height;
    }) : [];
  }, []), R = useCallback((_, b, M = !0) => {
    const [A] = E(_);
    if (!A)
      return !1;
    const $ = getOverlappingArea(A, b);
    return M && $ > 0 || $ >= A.width * A.height;
  }, []);
  return useMemo(() => ({
    ...t,
    getNodes: n,
    getNode: o,
    getEdges: l,
    getEdge: u,
    setNodes: f,
    setEdges: h,
    addNodes: p,
    addEdges: v,
    toObject: g,
    deleteElements: w,
    getIntersectingNodes: T,
    isNodeIntersecting: R
  }), [
    t,
    n,
    o,
    l,
    u,
    f,
    h,
    p,
    v,
    g,
    w,
    T,
    R
  ]);
}
const deleteKeyOptions = { actInsideInputWithModifier: !1 };
var useGlobalKeyHandler = ({ deleteKeyCode: t, multiSelectionKeyCode: e }) => {
  const n = useStoreApi(), { deleteElements: o } = useReactFlow(), l = useKeyPress(t, deleteKeyOptions), u = useKeyPress(e);
  useEffect(() => {
    if (l) {
      const { edges: f, getNodes: h } = n.getState(), p = h().filter((g) => g.selected), v = f.filter((g) => g.selected);
      o({ nodes: p, edges: v }), n.setState({ nodesSelectionActive: !1 });
    }
  }, [l]), useEffect(() => {
    n.setState({ multiSelectionActive: u });
  }, [u]);
};
function useResizeHandler(t) {
  const e = useStoreApi();
  useEffect(() => {
    let n;
    const o = () => {
      var u, f;
      if (!t.current)
        return;
      const l = getDimensions$1(t.current);
      (l.height === 0 || l.width === 0) && ((f = (u = e.getState()).onError) == null || f.call(u, "004", errorMessages.error004())), e.setState({ width: l.width || 500, height: l.height || 500 });
    };
    return o(), window.addEventListener("resize", o), t.current && (n = new ResizeObserver(() => o()), n.observe(t.current)), () => {
      window.removeEventListener("resize", o), n && t.current && n.unobserve(t.current);
    };
  }, []);
}
const containerStyle = {
  position: "absolute",
  width: "100%",
  height: "100%",
  top: 0,
  left: 0
}, viewChanged = (t, e) => t.x !== e.x || t.y !== e.y || t.zoom !== e.k, eventToFlowTransform = (t) => ({
  x: t.x,
  y: t.y,
  zoom: t.k
}), isWrappedWithClass = (t, e) => t.target.closest(`.${e}`), isRightClickPan = (t, e) => e === 2 && Array.isArray(t) && t.includes(2), wheelDelta = (t) => {
  const e = t.ctrlKey && isMacOs() ? 10 : 1;
  return -t.deltaY * (t.deltaMode === 1 ? 0.05 : t.deltaMode ? 1 : 2e-3) * e;
}, selector$a = (t) => ({
  d3Zoom: t.d3Zoom,
  d3Selection: t.d3Selection,
  d3ZoomHandler: t.d3ZoomHandler,
  userSelectionActive: t.userSelectionActive
}), ZoomPane = ({ onMove: t, onMoveStart: e, onMoveEnd: n, onPaneContextMenu: o, zoomOnScroll: l = !0, zoomOnPinch: u = !0, panOnScroll: f = !1, panOnScrollSpeed: h = 0.5, panOnScrollMode: p = PanOnScrollMode.Free, zoomOnDoubleClick: v = !0, elementsSelectable: g, panOnDrag: w = !0, defaultViewport: E, translateExtent: T, minZoom: R, maxZoom: _, zoomActivationKeyCode: b, preventScrolling: M = !0, children: A, noWheelClassName: $, noPanClassName: S }) => {
  const C = useRef(), D = useStoreApi(), O = useRef(!1), N = useRef(!1), j = useRef(null), L = useRef({ x: 0, y: 0, zoom: 0 }), { d3Zoom: z, d3Selection: G, d3ZoomHandler: B, userSelectionActive: F } = useStore(selector$a, shallow$1), H = useKeyPress(b), W = useRef(0), V = useRef(!1), X = useRef();
  return useResizeHandler(j), useEffect(() => {
    if (j.current) {
      const Z = j.current.getBoundingClientRect(), Q = zoom().scaleExtent([R, _]).translateExtent(T), q = select(j.current).call(Q), J = identity$c.translate(E.x, E.y).scale(clamp$1(E.zoom, R, _)), ie = [
        [0, 0],
        [Z.width, Z.height]
      ], ne = Q.constrain()(J, ie, T);
      Q.transform(q, ne), Q.wheelDelta(wheelDelta), D.setState({
        d3Zoom: Q,
        d3Selection: q,
        d3ZoomHandler: q.on("wheel.zoom"),
        // we need to pass transform because zoom handler is not registered when we set the initial transform
        transform: [ne.x, ne.y, ne.k],
        domNode: j.current.closest(".react-flow")
      });
    }
  }, []), useEffect(() => {
    G && z && (f && !H && !F ? G.on("wheel.zoom", (Z) => {
      if (isWrappedWithClass(Z, $))
        return !1;
      Z.preventDefault(), Z.stopImmediatePropagation();
      const Q = G.property("__zoom").k || 1;
      if (Z.ctrlKey && u) {
        const we = pointer(Z), de = wheelDelta(Z), Te = Q * Math.pow(2, de);
        z.scaleTo(G, Te, we, Z);
        return;
      }
      const q = Z.deltaMode === 1 ? 20 : 1;
      let J = p === PanOnScrollMode.Vertical ? 0 : Z.deltaX * q, ie = p === PanOnScrollMode.Horizontal ? 0 : Z.deltaY * q;
      !isMacOs() && Z.shiftKey && p !== PanOnScrollMode.Vertical && (J = Z.deltaY * q, ie = 0), z.translateBy(
        G,
        -(J / Q) * h,
        -(ie / Q) * h,
        // @ts-ignore
        { internal: !0 }
      );
      const ne = eventToFlowTransform(G.property("__zoom")), { onViewportChangeStart: ge, onViewportChange: ye, onViewportChangeEnd: xe } = D.getState();
      clearTimeout(X.current), V.current || (V.current = !0, e == null || e(Z, ne), ge == null || ge(ne)), V.current && (t == null || t(Z, ne), ye == null || ye(ne), X.current = setTimeout(() => {
        n == null || n(Z, ne), xe == null || xe(ne), V.current = !1;
      }, 150));
    }, { passive: !1 }) : typeof B < "u" && G.on("wheel.zoom", function(Z, Q) {
      if (!M && Z.type === "wheel" && !Z.ctrlKey || isWrappedWithClass(Z, $))
        return null;
      Z.preventDefault(), B.call(this, Z, Q);
    }, { passive: !1 }));
  }, [
    F,
    f,
    p,
    G,
    z,
    B,
    H,
    u,
    M,
    $,
    e,
    t,
    n
  ]), useEffect(() => {
    z && z.on("start", (Z) => {
      var J, ie;
      if (!Z.sourceEvent || Z.sourceEvent.internal)
        return null;
      W.current = (J = Z.sourceEvent) == null ? void 0 : J.button;
      const { onViewportChangeStart: Q } = D.getState(), q = eventToFlowTransform(Z.transform);
      O.current = !0, L.current = q, ((ie = Z.sourceEvent) == null ? void 0 : ie.type) === "mousedown" && D.setState({ paneDragging: !0 }), Q == null || Q(q), e == null || e(Z.sourceEvent, q);
    });
  }, [z, e]), useEffect(() => {
    z && (F && !O.current ? z.on("zoom", null) : F || z.on("zoom", (Z) => {
      var q;
      const { onViewportChange: Q } = D.getState();
      if (D.setState({ transform: [Z.transform.x, Z.transform.y, Z.transform.k] }), N.current = !!(o && isRightClickPan(w, W.current ?? 0)), (t || Q) && !((q = Z.sourceEvent) != null && q.internal)) {
        const J = eventToFlowTransform(Z.transform);
        Q == null || Q(J), t == null || t(Z.sourceEvent, J);
      }
    }));
  }, [F, z, t, w, o]), useEffect(() => {
    z && z.on("end", (Z) => {
      if (!Z.sourceEvent || Z.sourceEvent.internal)
        return null;
      const { onViewportChangeEnd: Q } = D.getState();
      if (O.current = !1, D.setState({ paneDragging: !1 }), o && isRightClickPan(w, W.current ?? 0) && !N.current && o(Z.sourceEvent), N.current = !1, (n || Q) && viewChanged(L.current, Z.transform)) {
        const q = eventToFlowTransform(Z.transform);
        L.current = q, clearTimeout(C.current), C.current = setTimeout(() => {
          Q == null || Q(q), n == null || n(Z.sourceEvent, q);
        }, f ? 150 : 0);
      }
    });
  }, [z, f, w, n, o]), useEffect(() => {
    z && z.filter((Z) => {
      const Q = H || l, q = u && Z.ctrlKey;
      if ((w === !0 || Array.isArray(w) && w.includes(1)) && Z.button === 1 && Z.type === "mousedown" && (isWrappedWithClass(Z, "react-flow__node") || isWrappedWithClass(Z, "react-flow__edge")))
        return !0;
      if (!w && !Q && !f && !v && !u || F || !v && Z.type === "dblclick" || isWrappedWithClass(Z, $) && Z.type === "wheel" || isWrappedWithClass(Z, S) && (Z.type !== "wheel" || f && Z.type === "wheel" && !H) || !u && Z.ctrlKey && Z.type === "wheel" || !Q && !f && !q && Z.type === "wheel" || !w && (Z.type === "mousedown" || Z.type === "touchstart") || Array.isArray(w) && !w.includes(Z.button) && Z.type === "mousedown")
        return !1;
      const J = Array.isArray(w) && w.includes(Z.button) || !Z.button || Z.button <= 1;
      return (!Z.ctrlKey || Z.type === "wheel") && J;
    });
  }, [
    F,
    z,
    l,
    u,
    f,
    v,
    w,
    g,
    H
  ]), React__default.createElement("div", { className: "react-flow__renderer", ref: j, style: containerStyle }, A);
}, selector$9 = (t) => ({
  userSelectionActive: t.userSelectionActive,
  userSelectionRect: t.userSelectionRect
});
function UserSelection() {
  const { userSelectionActive: t, userSelectionRect: e } = useStore(selector$9, shallow$1);
  return t && e ? React__default.createElement("div", { className: "react-flow__selection react-flow__container", style: {
    width: e.width,
    height: e.height,
    transform: `translate(${e.x}px, ${e.y}px)`
  } }) : null;
}
function handleParentExpand(t, e) {
  const n = e.parentNode || e.parentId, o = t.find((l) => l.id === n);
  if (o) {
    const l = e.position.x + e.width - o.width, u = e.position.y + e.height - o.height;
    if (l > 0 || u > 0 || e.position.x < 0 || e.position.y < 0) {
      if (o.style = { ...o.style }, o.style.width = o.style.width ?? o.width, o.style.height = o.style.height ?? o.height, l > 0 && (o.style.width += l), u > 0 && (o.style.height += u), e.position.x < 0) {
        const f = Math.abs(e.position.x);
        o.position.x = o.position.x - f, o.style.width += f, e.position.x = 0;
      }
      if (e.position.y < 0) {
        const f = Math.abs(e.position.y);
        o.position.y = o.position.y - f, o.style.height += f, e.position.y = 0;
      }
      o.width = o.style.width, o.height = o.style.height;
    }
  }
}
function applyChanges(t, e) {
  if (t.some((o) => o.type === "reset"))
    return t.filter((o) => o.type === "reset").map((o) => o.item);
  const n = t.filter((o) => o.type === "add").map((o) => o.item);
  return e.reduce((o, l) => {
    const u = t.filter((h) => h.id === l.id);
    if (u.length === 0)
      return o.push(l), o;
    const f = { ...l };
    for (const h of u)
      if (h)
        switch (h.type) {
          case "select": {
            f.selected = h.selected;
            break;
          }
          case "position": {
            typeof h.position < "u" && (f.position = h.position), typeof h.positionAbsolute < "u" && (f.positionAbsolute = h.positionAbsolute), typeof h.dragging < "u" && (f.dragging = h.dragging), f.expandParent && handleParentExpand(o, f);
            break;
          }
          case "dimensions": {
            typeof h.dimensions < "u" && (f.width = h.dimensions.width, f.height = h.dimensions.height), typeof h.updateStyle < "u" && (f.style = { ...f.style || {}, ...h.dimensions }), typeof h.resizing == "boolean" && (f.resizing = h.resizing), f.expandParent && handleParentExpand(o, f);
            break;
          }
          case "remove":
            return o;
        }
    return o.push(f), o;
  }, n);
}
function applyNodeChanges(t, e) {
  return applyChanges(t, e);
}
function applyEdgeChanges(t, e) {
  return applyChanges(t, e);
}
const createSelectionChange = (t, e) => ({
  id: t,
  type: "select",
  selected: e
});
function getSelectionChanges(t, e) {
  return t.reduce((n, o) => {
    const l = e.includes(o.id);
    return !o.selected && l ? (o.selected = !0, n.push(createSelectionChange(o.id, !0))) : o.selected && !l && (o.selected = !1, n.push(createSelectionChange(o.id, !1))), n;
  }, []);
}
const wrapHandler = (t, e) => (n) => {
  n.target === e.current && (t == null || t(n));
}, selector$8 = (t) => ({
  userSelectionActive: t.userSelectionActive,
  elementsSelectable: t.elementsSelectable,
  dragging: t.paneDragging
}), Pane = memo$1(({ isSelecting: t, selectionMode: e = SelectionMode.Full, panOnDrag: n, onSelectionStart: o, onSelectionEnd: l, onPaneClick: u, onPaneContextMenu: f, onPaneScroll: h, onPaneMouseEnter: p, onPaneMouseMove: v, onPaneMouseLeave: g, children: w }) => {
  const E = useRef(null), T = useStoreApi(), R = useRef(0), _ = useRef(0), b = useRef(), { userSelectionActive: M, elementsSelectable: A, dragging: $ } = useStore(selector$8, shallow$1), S = () => {
    T.setState({ userSelectionActive: !1, userSelectionRect: null }), R.current = 0, _.current = 0;
  }, C = (B) => {
    u == null || u(B), T.getState().resetSelectedElements(), T.setState({ nodesSelectionActive: !1 });
  }, D = (B) => {
    if (Array.isArray(n) && (n != null && n.includes(2))) {
      B.preventDefault();
      return;
    }
    f == null || f(B);
  }, O = h ? (B) => h(B) : void 0, N = (B) => {
    const { resetSelectedElements: F, domNode: H } = T.getState();
    if (b.current = H == null ? void 0 : H.getBoundingClientRect(), !A || !t || B.button !== 0 || B.target !== E.current || !b.current)
      return;
    const { x: W, y: V } = getEventPosition(B, b.current);
    F(), T.setState({
      userSelectionRect: {
        width: 0,
        height: 0,
        startX: W,
        startY: V,
        x: W,
        y: V
      }
    }), o == null || o(B);
  }, j = (B) => {
    const { userSelectionRect: F, nodeInternals: H, edges: W, transform: V, onNodesChange: X, onEdgesChange: Z, nodeOrigin: Q, getNodes: q } = T.getState();
    if (!t || !b.current || !F)
      return;
    T.setState({ userSelectionActive: !0, nodesSelectionActive: !1 });
    const J = getEventPosition(B, b.current), ie = F.startX ?? 0, ne = F.startY ?? 0, ge = {
      ...F,
      x: J.x < ie ? J.x : ie,
      y: J.y < ne ? J.y : ne,
      width: Math.abs(J.x - ie),
      height: Math.abs(J.y - ne)
    }, ye = q(), xe = getNodesInside(H, ge, V, e === SelectionMode.Partial, !0, Q), we = getConnectedEdges(xe, W).map((Te) => Te.id), de = xe.map((Te) => Te.id);
    if (R.current !== de.length) {
      R.current = de.length;
      const Te = getSelectionChanges(ye, de);
      Te.length && (X == null || X(Te));
    }
    if (_.current !== we.length) {
      _.current = we.length;
      const Te = getSelectionChanges(W, we);
      Te.length && (Z == null || Z(Te));
    }
    T.setState({
      userSelectionRect: ge
    });
  }, L = (B) => {
    if (B.button !== 0)
      return;
    const { userSelectionRect: F } = T.getState();
    !M && F && B.target === E.current && (C == null || C(B)), T.setState({ nodesSelectionActive: R.current > 0 }), S(), l == null || l(B);
  }, z = (B) => {
    M && (T.setState({ nodesSelectionActive: R.current > 0 }), l == null || l(B)), S();
  }, G = A && (t || M);
  return React__default.createElement(
    "div",
    { className: cc$1(["react-flow__pane", { dragging: $, selection: t }]), onClick: G ? void 0 : wrapHandler(C, E), onContextMenu: wrapHandler(D, E), onWheel: wrapHandler(O, E), onMouseEnter: G ? void 0 : p, onMouseDown: G ? N : void 0, onMouseMove: G ? j : v, onMouseUp: G ? L : void 0, onMouseLeave: G ? z : g, ref: E, style: containerStyle },
    w,
    React__default.createElement(UserSelection, null)
  );
});
Pane.displayName = "Pane";
function isParentSelected(t, e) {
  const n = t.parentNode || t.parentId;
  if (!n)
    return !1;
  const o = e.get(n);
  return o ? o.selected ? !0 : isParentSelected(o, e) : !1;
}
function hasSelector(t, e, n) {
  let o = t;
  do {
    if (o != null && o.matches(e))
      return !0;
    if (o === n.current)
      return !1;
    o = o.parentElement;
  } while (o);
  return !1;
}
function getDragItems(t, e, n, o) {
  return Array.from(t.values()).filter((l) => (l.selected || l.id === o) && (!l.parentNode || l.parentId || !isParentSelected(l, t)) && (l.draggable || e && typeof l.draggable > "u")).map((l) => {
    var u, f;
    return {
      id: l.id,
      position: l.position || { x: 0, y: 0 },
      positionAbsolute: l.positionAbsolute || { x: 0, y: 0 },
      distance: {
        x: n.x - (((u = l.positionAbsolute) == null ? void 0 : u.x) ?? 0),
        y: n.y - (((f = l.positionAbsolute) == null ? void 0 : f.y) ?? 0)
      },
      delta: {
        x: 0,
        y: 0
      },
      extent: l.extent,
      parentNode: l.parentNode || l.parentId,
      parentId: l.parentNode || l.parentId,
      width: l.width,
      height: l.height,
      expandParent: l.expandParent
    };
  });
}
function clampNodeExtent(t, e) {
  return !e || e === "parent" ? e : [e[0], [e[1][0] - (t.width || 0), e[1][1] - (t.height || 0)]];
}
function calcNextPosition(t, e, n, o, l = [0, 0], u) {
  const f = clampNodeExtent(t, t.extent || o);
  let h = f;
  const p = t.parentNode || t.parentId;
  if (t.extent === "parent" && !t.expandParent)
    if (p && t.width && t.height) {
      const w = n.get(p), { x: E, y: T } = getNodePositionWithOrigin(w, l).positionAbsolute;
      h = w && isNumeric(E) && isNumeric(T) && isNumeric(w.width) && isNumeric(w.height) ? [
        [E + t.width * l[0], T + t.height * l[1]],
        [
          E + w.width - t.width + t.width * l[0],
          T + w.height - t.height + t.height * l[1]
        ]
      ] : h;
    } else
      u == null || u("005", errorMessages.error005()), h = f;
  else if (t.extent && p && t.extent !== "parent") {
    const w = n.get(p), { x: E, y: T } = getNodePositionWithOrigin(w, l).positionAbsolute;
    h = [
      [t.extent[0][0] + E, t.extent[0][1] + T],
      [t.extent[1][0] + E, t.extent[1][1] + T]
    ];
  }
  let v = { x: 0, y: 0 };
  if (p) {
    const w = n.get(p);
    v = getNodePositionWithOrigin(w, l).positionAbsolute;
  }
  const g = h && h !== "parent" ? clampPosition(e, h) : e;
  return {
    position: {
      x: g.x - v.x,
      y: g.y - v.y
    },
    positionAbsolute: g
  };
}
function getEventHandlerParams({ nodeId: t, dragItems: e, nodeInternals: n }) {
  const o = e.map((l) => ({
    ...n.get(l.id),
    position: l.position,
    positionAbsolute: l.positionAbsolute
  }));
  return [t ? o.find((l) => l.id === t) : o[0], o];
}
const getHandleBounds = (t, e, n, o) => {
  const l = e.querySelectorAll(t);
  if (!l || !l.length)
    return null;
  const u = Array.from(l), f = e.getBoundingClientRect(), h = {
    x: f.width * o[0],
    y: f.height * o[1]
  };
  return u.map((p) => {
    const v = p.getBoundingClientRect();
    return {
      id: p.getAttribute("data-handleid"),
      position: p.getAttribute("data-handlepos"),
      x: (v.left - f.left - h.x) / n,
      y: (v.top - f.top - h.y) / n,
      ...getDimensions$1(p)
    };
  });
};
function getMouseHandler(t, e, n) {
  return n === void 0 ? n : (o) => {
    const l = e().nodeInternals.get(t);
    l && n(o, { ...l });
  };
}
function handleNodeClick({ id: t, store: e, unselect: n = !1, nodeRef: o }) {
  const { addSelectedNodes: l, unselectNodesAndEdges: u, multiSelectionActive: f, nodeInternals: h, onError: p } = e.getState(), v = h.get(t);
  if (!v) {
    p == null || p("012", errorMessages.error012(t));
    return;
  }
  e.setState({ nodesSelectionActive: !1 }), v.selected ? (n || v.selected && f) && (u({ nodes: [v], edges: [] }), requestAnimationFrame(() => {
    var g;
    return (g = o == null ? void 0 : o.current) == null ? void 0 : g.blur();
  })) : l([t]);
}
function useGetPointerPosition() {
  const t = useStoreApi();
  return useCallback(({ sourceEvent: n }) => {
    const { transform: o, snapGrid: l, snapToGrid: u } = t.getState(), f = n.touches ? n.touches[0].clientX : n.clientX, h = n.touches ? n.touches[0].clientY : n.clientY, p = {
      x: (f - o[0]) / o[2],
      y: (h - o[1]) / o[2]
    };
    return {
      xSnapped: u ? l[0] * Math.round(p.x / l[0]) : p.x,
      ySnapped: u ? l[1] * Math.round(p.y / l[1]) : p.y,
      ...p
    };
  }, []);
}
function wrapSelectionDragFunc(t) {
  return (e, n, o) => t == null ? void 0 : t(e, o);
}
function useDrag({ nodeRef: t, disabled: e = !1, noDragClassName: n, handleSelector: o, nodeId: l, isSelectable: u, selectNodesOnDrag: f }) {
  const h = useStoreApi(), [p, v] = useState(!1), g = useRef([]), w = useRef({ x: null, y: null }), E = useRef(0), T = useRef(null), R = useRef({ x: 0, y: 0 }), _ = useRef(null), b = useRef(!1), M = useRef(!1), A = useRef(!1), $ = useGetPointerPosition();
  return useEffect(() => {
    if (t != null && t.current) {
      const S = select(t.current), C = ({ x: N, y: j }) => {
        const { nodeInternals: L, onNodeDrag: z, onSelectionDrag: G, updateNodePositions: B, nodeExtent: F, snapGrid: H, snapToGrid: W, nodeOrigin: V, onError: X } = h.getState();
        w.current = { x: N, y: j };
        let Z = !1, Q = { x: 0, y: 0, x2: 0, y2: 0 };
        if (g.current.length > 1 && F) {
          const J = getNodesBounds(g.current, V);
          Q = rectToBox(J);
        }
        if (g.current = g.current.map((J) => {
          const ie = { x: N - J.distance.x, y: j - J.distance.y };
          W && (ie.x = H[0] * Math.round(ie.x / H[0]), ie.y = H[1] * Math.round(ie.y / H[1]));
          const ne = [
            [F[0][0], F[0][1]],
            [F[1][0], F[1][1]]
          ];
          g.current.length > 1 && F && !J.extent && (ne[0][0] = J.positionAbsolute.x - Q.x + F[0][0], ne[1][0] = J.positionAbsolute.x + (J.width ?? 0) - Q.x2 + F[1][0], ne[0][1] = J.positionAbsolute.y - Q.y + F[0][1], ne[1][1] = J.positionAbsolute.y + (J.height ?? 0) - Q.y2 + F[1][1]);
          const ge = calcNextPosition(J, ie, L, ne, V, X);
          return Z = Z || J.position.x !== ge.position.x || J.position.y !== ge.position.y, J.position = ge.position, J.positionAbsolute = ge.positionAbsolute, J;
        }), !Z)
          return;
        B(g.current, !0, !0), v(!0);
        const q = l ? z : wrapSelectionDragFunc(G);
        if (q && _.current) {
          const [J, ie] = getEventHandlerParams({
            nodeId: l,
            dragItems: g.current,
            nodeInternals: L
          });
          q(_.current, J, ie);
        }
      }, D = () => {
        if (!T.current)
          return;
        const [N, j] = calcAutoPan(R.current, T.current);
        if (N !== 0 || j !== 0) {
          const { transform: L, panBy: z } = h.getState();
          w.current.x = (w.current.x ?? 0) - N / L[2], w.current.y = (w.current.y ?? 0) - j / L[2], z({ x: N, y: j }) && C(w.current);
        }
        E.current = requestAnimationFrame(D);
      }, O = (N) => {
        var V;
        const { nodeInternals: j, multiSelectionActive: L, nodesDraggable: z, unselectNodesAndEdges: G, onNodeDragStart: B, onSelectionDragStart: F } = h.getState();
        M.current = !0;
        const H = l ? B : wrapSelectionDragFunc(F);
        (!f || !u) && !L && l && ((V = j.get(l)) != null && V.selected || G()), l && u && f && handleNodeClick({
          id: l,
          store: h,
          nodeRef: t
        });
        const W = $(N);
        if (w.current = W, g.current = getDragItems(j, z, W, l), H && g.current) {
          const [X, Z] = getEventHandlerParams({
            nodeId: l,
            dragItems: g.current,
            nodeInternals: j
          });
          H(N.sourceEvent, X, Z);
        }
      };
      if (e)
        S.on(".drag", null);
      else {
        const N = drag().on("start", (j) => {
          const { domNode: L, nodeDragThreshold: z } = h.getState();
          z === 0 && O(j), A.current = !1;
          const G = $(j);
          w.current = G, T.current = (L == null ? void 0 : L.getBoundingClientRect()) || null, R.current = getEventPosition(j.sourceEvent, T.current);
        }).on("drag", (j) => {
          var B, F;
          const L = $(j), { autoPanOnNodeDrag: z, nodeDragThreshold: G } = h.getState();
          if (j.sourceEvent.type === "touchmove" && j.sourceEvent.touches.length > 1 && (A.current = !0), !A.current) {
            if (!b.current && M.current && z && (b.current = !0, D()), !M.current) {
              const H = L.xSnapped - (((B = w == null ? void 0 : w.current) == null ? void 0 : B.x) ?? 0), W = L.ySnapped - (((F = w == null ? void 0 : w.current) == null ? void 0 : F.y) ?? 0);
              Math.sqrt(H * H + W * W) > G && O(j);
            }
            (w.current.x !== L.xSnapped || w.current.y !== L.ySnapped) && g.current && M.current && (_.current = j.sourceEvent, R.current = getEventPosition(j.sourceEvent, T.current), C(L));
          }
        }).on("end", (j) => {
          if (!(!M.current || A.current) && (v(!1), b.current = !1, M.current = !1, cancelAnimationFrame(E.current), g.current)) {
            const { updateNodePositions: L, nodeInternals: z, onNodeDragStop: G, onSelectionDragStop: B } = h.getState(), F = l ? G : wrapSelectionDragFunc(B);
            if (L(g.current, !1, !1), F) {
              const [H, W] = getEventHandlerParams({
                nodeId: l,
                dragItems: g.current,
                nodeInternals: z
              });
              F(j.sourceEvent, H, W);
            }
          }
        }).filter((j) => {
          const L = j.target;
          return !j.button && (!n || !hasSelector(L, `.${n}`, t)) && (!o || hasSelector(L, o, t));
        });
        return S.call(N), () => {
          S.on(".drag", null);
        };
      }
    }
  }, [
    t,
    e,
    n,
    o,
    u,
    h,
    l,
    f,
    $
  ]), p;
}
function useUpdateNodePositions() {
  const t = useStoreApi();
  return useCallback((n) => {
    const { nodeInternals: o, nodeExtent: l, updateNodePositions: u, getNodes: f, snapToGrid: h, snapGrid: p, onError: v, nodesDraggable: g } = t.getState(), w = f().filter((A) => A.selected && (A.draggable || g && typeof A.draggable > "u")), E = h ? p[0] : 5, T = h ? p[1] : 5, R = n.isShiftPressed ? 4 : 1, _ = n.x * E * R, b = n.y * T * R, M = w.map((A) => {
      if (A.positionAbsolute) {
        const $ = { x: A.positionAbsolute.x + _, y: A.positionAbsolute.y + b };
        h && ($.x = p[0] * Math.round($.x / p[0]), $.y = p[1] * Math.round($.y / p[1]));
        const { positionAbsolute: S, position: C } = calcNextPosition(A, $, o, l, void 0, v);
        A.position = C, A.positionAbsolute = S;
      }
      return A;
    });
    u(M, !0, !1);
  }, []);
}
const arrowKeyDiffs = {
  ArrowUp: { x: 0, y: -1 },
  ArrowDown: { x: 0, y: 1 },
  ArrowLeft: { x: -1, y: 0 },
  ArrowRight: { x: 1, y: 0 }
};
var wrapNode = (t) => {
  const e = ({ id: n, type: o, data: l, xPos: u, yPos: f, xPosOrigin: h, yPosOrigin: p, selected: v, onClick: g, onMouseEnter: w, onMouseMove: E, onMouseLeave: T, onContextMenu: R, onDoubleClick: _, style: b, className: M, isDraggable: A, isSelectable: $, isConnectable: S, isFocusable: C, selectNodesOnDrag: D, sourcePosition: O, targetPosition: N, hidden: j, resizeObserver: L, dragHandle: z, zIndex: G, isParent: B, noDragClassName: F, noPanClassName: H, initialized: W, disableKeyboardA11y: V, ariaLabel: X, rfId: Z, hasHandleBounds: Q }) => {
    const q = useStoreApi(), J = useRef(null), ie = useRef(null), ne = useRef(O), ge = useRef(N), ye = useRef(o), xe = $ || A || g || w || E || T, we = useUpdateNodePositions(), de = getMouseHandler(n, q.getState, w), Te = getMouseHandler(n, q.getState, E), Ce = getMouseHandler(n, q.getState, T), ee = getMouseHandler(n, q.getState, R), Ae = getMouseHandler(n, q.getState, _), be = (Ye) => {
      const { nodeDragThreshold: De } = q.getState();
      if ($ && (!D || !A || De > 0) && handleNodeClick({
        id: n,
        store: q,
        nodeRef: J
      }), g) {
        const Ue = q.getState().nodeInternals.get(n);
        Ue && g(Ye, { ...Ue });
      }
    }, Fe = (Ye) => {
      if (!isInputDOMNode(Ye) && !V)
        if (elementSelectionKeys.includes(Ye.key) && $) {
          const De = Ye.key === "Escape";
          handleNodeClick({
            id: n,
            store: q,
            unselect: De,
            nodeRef: J
          });
        } else A && v && Object.prototype.hasOwnProperty.call(arrowKeyDiffs, Ye.key) && (q.setState({
          ariaLiveMessage: `Moved selected node ${Ye.key.replace("Arrow", "").toLowerCase()}. New position, x: ${~~u}, y: ${~~f}`
        }), we({
          x: arrowKeyDiffs[Ye.key].x,
          y: arrowKeyDiffs[Ye.key].y,
          isShiftPressed: Ye.shiftKey
        }));
    };
    useEffect(() => () => {
      ie.current && (L == null || L.unobserve(ie.current), ie.current = null);
    }, []), useEffect(() => {
      if (J.current && !j) {
        const Ye = J.current;
        (!W || !Q || ie.current !== Ye) && (ie.current && (L == null || L.unobserve(ie.current)), L == null || L.observe(Ye), ie.current = Ye);
      }
    }, [j, W, Q]), useEffect(() => {
      const Ye = ye.current !== o, De = ne.current !== O, Ue = ge.current !== N;
      J.current && (Ye || De || Ue) && (Ye && (ye.current = o), De && (ne.current = O), Ue && (ge.current = N), q.getState().updateNodeDimensions([{ id: n, nodeElement: J.current, forceUpdate: !0 }]));
    }, [n, o, O, N]);
    const et = useDrag({
      nodeRef: J,
      disabled: j || !A,
      noDragClassName: F,
      handleSelector: z,
      nodeId: n,
      isSelectable: $,
      selectNodesOnDrag: D
    });
    return j ? null : React__default.createElement(
      "div",
      { className: cc$1([
        "react-flow__node",
        `react-flow__node-${o}`,
        {
          // this is overwritable by passing `nopan` as a class name
          [H]: A
        },
        M,
        {
          selected: v,
          selectable: $,
          parent: B,
          dragging: et
        }
      ]), ref: J, style: {
        zIndex: G,
        transform: `translate(${h}px,${p}px)`,
        pointerEvents: xe ? "all" : "none",
        visibility: W ? "visible" : "hidden",
        ...b
      }, "data-id": n, "data-testid": `rf__node-${n}`, onMouseEnter: de, onMouseMove: Te, onMouseLeave: Ce, onContextMenu: ee, onClick: be, onDoubleClick: Ae, onKeyDown: C ? Fe : void 0, tabIndex: C ? 0 : void 0, role: C ? "button" : void 0, "aria-describedby": V ? void 0 : `${ARIA_NODE_DESC_KEY}-${Z}`, "aria-label": X },
      React__default.createElement(
        Provider,
        { value: n },
        React__default.createElement(t, { id: n, data: l, type: o, xPos: u, yPos: f, selected: v, isConnectable: S, sourcePosition: O, targetPosition: N, dragging: et, dragHandle: z, zIndex: G })
      )
    );
  };
  return e.displayName = "NodeWrapper", memo$1(e);
};
const selector$7 = (t) => {
  const e = t.getNodes().filter((n) => n.selected);
  return {
    ...getNodesBounds(e, t.nodeOrigin),
    transformString: `translate(${t.transform[0]}px,${t.transform[1]}px) scale(${t.transform[2]})`,
    userSelectionActive: t.userSelectionActive
  };
};
function NodesSelection({ onSelectionContextMenu: t, noPanClassName: e, disableKeyboardA11y: n }) {
  const o = useStoreApi(), { width: l, height: u, x: f, y: h, transformString: p, userSelectionActive: v } = useStore(selector$7, shallow$1), g = useUpdateNodePositions(), w = useRef(null);
  if (useEffect(() => {
    var R;
    n || (R = w.current) == null || R.focus({
      preventScroll: !0
    });
  }, [n]), useDrag({
    nodeRef: w
  }), v || !l || !u)
    return null;
  const E = t ? (R) => {
    const _ = o.getState().getNodes().filter((b) => b.selected);
    t(R, _);
  } : void 0, T = (R) => {
    Object.prototype.hasOwnProperty.call(arrowKeyDiffs, R.key) && g({
      x: arrowKeyDiffs[R.key].x,
      y: arrowKeyDiffs[R.key].y,
      isShiftPressed: R.shiftKey
    });
  };
  return React__default.createElement(
    "div",
    { className: cc$1(["react-flow__nodesselection", "react-flow__container", e]), style: {
      transform: p
    } },
    React__default.createElement("div", { ref: w, className: "react-flow__nodesselection-rect", onContextMenu: E, tabIndex: n ? void 0 : -1, onKeyDown: n ? void 0 : T, style: {
      width: l,
      height: u,
      top: h,
      left: f
    } })
  );
}
var NodesSelection$1 = memo$1(NodesSelection);
const selector$6 = (t) => t.nodesSelectionActive, FlowRenderer = ({ children: t, onPaneClick: e, onPaneMouseEnter: n, onPaneMouseMove: o, onPaneMouseLeave: l, onPaneContextMenu: u, onPaneScroll: f, deleteKeyCode: h, onMove: p, onMoveStart: v, onMoveEnd: g, selectionKeyCode: w, selectionOnDrag: E, selectionMode: T, onSelectionStart: R, onSelectionEnd: _, multiSelectionKeyCode: b, panActivationKeyCode: M, zoomActivationKeyCode: A, elementsSelectable: $, zoomOnScroll: S, zoomOnPinch: C, panOnScroll: D, panOnScrollSpeed: O, panOnScrollMode: N, zoomOnDoubleClick: j, panOnDrag: L, defaultViewport: z, translateExtent: G, minZoom: B, maxZoom: F, preventScrolling: H, onSelectionContextMenu: W, noWheelClassName: V, noPanClassName: X, disableKeyboardA11y: Z }) => {
  const Q = useStore(selector$6), q = useKeyPress(w), J = useKeyPress(M), ie = J || L, ne = J || D, ge = q || E && ie !== !0;
  return useGlobalKeyHandler({ deleteKeyCode: h, multiSelectionKeyCode: b }), React__default.createElement(
    ZoomPane,
    { onMove: p, onMoveStart: v, onMoveEnd: g, onPaneContextMenu: u, elementsSelectable: $, zoomOnScroll: S, zoomOnPinch: C, panOnScroll: ne, panOnScrollSpeed: O, panOnScrollMode: N, zoomOnDoubleClick: j, panOnDrag: !q && ie, defaultViewport: z, translateExtent: G, minZoom: B, maxZoom: F, zoomActivationKeyCode: A, preventScrolling: H, noWheelClassName: V, noPanClassName: X },
    React__default.createElement(
      Pane,
      { onSelectionStart: R, onSelectionEnd: _, onPaneClick: e, onPaneMouseEnter: n, onPaneMouseMove: o, onPaneMouseLeave: l, onPaneContextMenu: u, onPaneScroll: f, panOnDrag: ie, isSelecting: !!ge, selectionMode: T },
      t,
      Q && React__default.createElement(NodesSelection$1, { onSelectionContextMenu: W, noPanClassName: X, disableKeyboardA11y: Z })
    )
  );
};
FlowRenderer.displayName = "FlowRenderer";
var FlowRenderer$1 = memo$1(FlowRenderer);
function useVisibleNodes(t) {
  return useStore(useCallback((n) => t ? getNodesInside(n.nodeInternals, { x: 0, y: 0, width: n.width, height: n.height }, n.transform, !0) : n.getNodes(), [t]));
}
function createNodeTypes(t) {
  const e = {
    input: wrapNode(t.input || InputNode$1),
    default: wrapNode(t.default || DefaultNode$1),
    output: wrapNode(t.output || OutputNode$1),
    group: wrapNode(t.group || GroupNode)
  }, n = {}, o = Object.keys(t).filter((l) => !["input", "default", "output", "group"].includes(l)).reduce((l, u) => (l[u] = wrapNode(t[u] || DefaultNode$1), l), n);
  return {
    ...e,
    ...o
  };
}
const getPositionWithOrigin = ({ x: t, y: e, width: n, height: o, origin: l }) => !n || !o ? { x: t, y: e } : l[0] < 0 || l[1] < 0 || l[0] > 1 || l[1] > 1 ? { x: t, y: e } : {
  x: t - n * l[0],
  y: e - o * l[1]
}, selector$5 = (t) => ({
  nodesDraggable: t.nodesDraggable,
  nodesConnectable: t.nodesConnectable,
  nodesFocusable: t.nodesFocusable,
  elementsSelectable: t.elementsSelectable,
  updateNodeDimensions: t.updateNodeDimensions,
  onError: t.onError
}), NodeRenderer = (t) => {
  const { nodesDraggable: e, nodesConnectable: n, nodesFocusable: o, elementsSelectable: l, updateNodeDimensions: u, onError: f } = useStore(selector$5, shallow$1), h = useVisibleNodes(t.onlyRenderVisibleElements), p = useRef(), v = useMemo(() => {
    if (typeof ResizeObserver > "u")
      return null;
    const g = new ResizeObserver((w) => {
      const E = w.map((T) => ({
        id: T.target.getAttribute("data-id"),
        nodeElement: T.target,
        forceUpdate: !0
      }));
      u(E);
    });
    return p.current = g, g;
  }, []);
  return useEffect(() => () => {
    var g;
    (g = p == null ? void 0 : p.current) == null || g.disconnect();
  }, []), React__default.createElement("div", { className: "react-flow__nodes", style: containerStyle }, h.map((g) => {
    var C, D, O;
    let w = g.type || "default";
    t.nodeTypes[w] || (f == null || f("003", errorMessages.error003(w)), w = "default");
    const E = t.nodeTypes[w] || t.nodeTypes.default, T = !!(g.draggable || e && typeof g.draggable > "u"), R = !!(g.selectable || l && typeof g.selectable > "u"), _ = !!(g.connectable || n && typeof g.connectable > "u"), b = !!(g.focusable || o && typeof g.focusable > "u"), M = t.nodeExtent ? clampPosition(g.positionAbsolute, t.nodeExtent) : g.positionAbsolute, A = (M == null ? void 0 : M.x) ?? 0, $ = (M == null ? void 0 : M.y) ?? 0, S = getPositionWithOrigin({
      x: A,
      y: $,
      width: g.width ?? 0,
      height: g.height ?? 0,
      origin: t.nodeOrigin
    });
    return React__default.createElement(E, { key: g.id, id: g.id, className: g.className, style: g.style, type: w, data: g.data, sourcePosition: g.sourcePosition || Position.Bottom, targetPosition: g.targetPosition || Position.Top, hidden: g.hidden, xPos: A, yPos: $, xPosOrigin: S.x, yPosOrigin: S.y, selectNodesOnDrag: t.selectNodesOnDrag, onClick: t.onNodeClick, onMouseEnter: t.onNodeMouseEnter, onMouseMove: t.onNodeMouseMove, onMouseLeave: t.onNodeMouseLeave, onContextMenu: t.onNodeContextMenu, onDoubleClick: t.onNodeDoubleClick, selected: !!g.selected, isDraggable: T, isSelectable: R, isConnectable: _, isFocusable: b, resizeObserver: v, dragHandle: g.dragHandle, zIndex: ((C = g[internalsSymbol]) == null ? void 0 : C.z) ?? 0, isParent: !!((D = g[internalsSymbol]) != null && D.isParent), noDragClassName: t.noDragClassName, noPanClassName: t.noPanClassName, initialized: !!g.width && !!g.height, rfId: t.rfId, disableKeyboardA11y: t.disableKeyboardA11y, ariaLabel: g.ariaLabel, hasHandleBounds: !!((O = g[internalsSymbol]) != null && O.handleBounds) });
  }));
};
NodeRenderer.displayName = "NodeRenderer";
var NodeRenderer$1 = memo$1(NodeRenderer);
const shiftX = (t, e, n) => n === Position.Left ? t - e : n === Position.Right ? t + e : t, shiftY = (t, e, n) => n === Position.Top ? t - e : n === Position.Bottom ? t + e : t, EdgeUpdaterClassName = "react-flow__edgeupdater", EdgeAnchor = ({ position: t, centerX: e, centerY: n, radius: o = 10, onMouseDown: l, onMouseEnter: u, onMouseOut: f, type: h }) => React__default.createElement("circle", { onMouseDown: l, onMouseEnter: u, onMouseOut: f, className: cc$1([EdgeUpdaterClassName, `${EdgeUpdaterClassName}-${h}`]), cx: shiftX(e, o, t), cy: shiftY(n, o, t), r: o, stroke: "transparent", fill: "transparent" }), alwaysValidConnection = () => !0;
var wrapEdge = (t) => {
  const e = ({ id: n, className: o, type: l, data: u, onClick: f, onEdgeDoubleClick: h, selected: p, animated: v, label: g, labelStyle: w, labelShowBg: E, labelBgStyle: T, labelBgPadding: R, labelBgBorderRadius: _, style: b, source: M, target: A, sourceX: $, sourceY: S, targetX: C, targetY: D, sourcePosition: O, targetPosition: N, elementsSelectable: j, hidden: L, sourceHandleId: z, targetHandleId: G, onContextMenu: B, onMouseEnter: F, onMouseMove: H, onMouseLeave: W, reconnectRadius: V, onReconnect: X, onReconnectStart: Z, onReconnectEnd: Q, markerEnd: q, markerStart: J, rfId: ie, ariaLabel: ne, isFocusable: ge, isReconnectable: ye, pathOptions: xe, interactionWidth: we, disableKeyboardA11y: de }) => {
    const Te = useRef(null), [Ce, ee] = useState(!1), [Ae, be] = useState(!1), Fe = useStoreApi(), et = useMemo(() => `url('#${getMarkerId(J, ie)}')`, [J, ie]), Ye = useMemo(() => `url('#${getMarkerId(q, ie)}')`, [q, ie]);
    if (L)
      return null;
    const De = (Oe) => {
      var me;
      const { edges: We, addSelectedEdges: Ct, unselectNodesAndEdges: le, multiSelectionActive: ke } = Fe.getState(), Ke = We.find((Ee) => Ee.id === n);
      Ke && (j && (Fe.setState({ nodesSelectionActive: !1 }), Ke.selected && ke ? (le({ nodes: [], edges: [Ke] }), (me = Te.current) == null || me.blur()) : Ct([n])), f && f(Oe, Ke));
    }, Ue = getMouseHandler$1(n, Fe.getState, h), Qe = getMouseHandler$1(n, Fe.getState, B), ue = getMouseHandler$1(n, Fe.getState, F), te = getMouseHandler$1(n, Fe.getState, H), Be = getMouseHandler$1(n, Fe.getState, W), Je = (Oe, We) => {
      if (Oe.button !== 0)
        return;
      const { edges: Ct, isValidConnection: le } = Fe.getState(), ke = We ? A : M, Ke = (We ? G : z) || null, me = We ? "target" : "source", Ee = le || alwaysValidConnection, tt = We, ce = Ct.find((K) => K.id === n);
      be(!0), Z == null || Z(Oe, ce, me);
      const _e = (K) => {
        be(!1), Q == null || Q(K, ce, me);
      };
      handlePointerDown({
        event: Oe,
        handleId: Ke,
        nodeId: ke,
        onConnect: (K) => X == null ? void 0 : X(ce, K),
        isTarget: tt,
        getState: Fe.getState,
        setState: Fe.setState,
        isValidConnection: Ee,
        edgeUpdaterType: me,
        onReconnectEnd: _e
      });
    }, ft = (Oe) => Je(Oe, !0), lt = (Oe) => Je(Oe, !1), he = () => ee(!0), ae = () => ee(!1), se = !j && !f, Re = (Oe) => {
      var We;
      if (!de && elementSelectionKeys.includes(Oe.key) && j) {
        const { unselectNodesAndEdges: Ct, addSelectedEdges: le, edges: ke } = Fe.getState();
        Oe.key === "Escape" ? ((We = Te.current) == null || We.blur(), Ct({ edges: [ke.find((me) => me.id === n)] })) : le([n]);
      }
    };
    return React__default.createElement(
      "g",
      { className: cc$1([
        "react-flow__edge",
        `react-flow__edge-${l}`,
        o,
        { selected: p, animated: v, inactive: se, updating: Ce }
      ]), onClick: De, onDoubleClick: Ue, onContextMenu: Qe, onMouseEnter: ue, onMouseMove: te, onMouseLeave: Be, onKeyDown: ge ? Re : void 0, tabIndex: ge ? 0 : void 0, role: ge ? "button" : "img", "data-testid": `rf__edge-${n}`, "aria-label": ne === null ? void 0 : ne || `Edge from ${M} to ${A}`, "aria-describedby": ge ? `${ARIA_EDGE_DESC_KEY}-${ie}` : void 0, ref: Te },
      !Ae && React__default.createElement(t, { id: n, source: M, target: A, selected: p, animated: v, label: g, labelStyle: w, labelShowBg: E, labelBgStyle: T, labelBgPadding: R, labelBgBorderRadius: _, data: u, style: b, sourceX: $, sourceY: S, targetX: C, targetY: D, sourcePosition: O, targetPosition: N, sourceHandleId: z, targetHandleId: G, markerStart: et, markerEnd: Ye, pathOptions: xe, interactionWidth: we }),
      ye && React__default.createElement(
        React__default.Fragment,
        null,
        (ye === "source" || ye === !0) && React__default.createElement(EdgeAnchor, { position: O, centerX: $, centerY: S, radius: V, onMouseDown: ft, onMouseEnter: he, onMouseOut: ae, type: "source" }),
        (ye === "target" || ye === !0) && React__default.createElement(EdgeAnchor, { position: N, centerX: C, centerY: D, radius: V, onMouseDown: lt, onMouseEnter: he, onMouseOut: ae, type: "target" })
      )
    );
  };
  return e.displayName = "EdgeWrapper", memo$1(e);
};
function createEdgeTypes(t) {
  const e = {
    default: wrapEdge(t.default || BezierEdge),
    straight: wrapEdge(t.bezier || StraightEdge),
    step: wrapEdge(t.step || StepEdge),
    smoothstep: wrapEdge(t.step || SmoothStepEdge),
    simplebezier: wrapEdge(t.simplebezier || SimpleBezierEdge)
  }, n = {}, o = Object.keys(t).filter((l) => !["default", "bezier"].includes(l)).reduce((l, u) => (l[u] = wrapEdge(t[u] || BezierEdge), l), n);
  return {
    ...e,
    ...o
  };
}
function getHandlePosition(t, e, n = null) {
  const o = ((n == null ? void 0 : n.x) || 0) + e.x, l = ((n == null ? void 0 : n.y) || 0) + e.y, u = (n == null ? void 0 : n.width) || e.width, f = (n == null ? void 0 : n.height) || e.height;
  switch (t) {
    case Position.Top:
      return {
        x: o + u / 2,
        y: l
      };
    case Position.Right:
      return {
        x: o + u,
        y: l + f / 2
      };
    case Position.Bottom:
      return {
        x: o + u / 2,
        y: l + f
      };
    case Position.Left:
      return {
        x: o,
        y: l + f / 2
      };
  }
}
function getHandle(t, e) {
  return t ? t.length === 1 || !e ? t[0] : e && t.find((n) => n.id === e) || null : null;
}
const getEdgePositions = (t, e, n, o, l, u) => {
  const f = getHandlePosition(n, t, e), h = getHandlePosition(u, o, l);
  return {
    sourceX: f.x,
    sourceY: f.y,
    targetX: h.x,
    targetY: h.y
  };
};
function isEdgeVisible({ sourcePos: t, targetPos: e, sourceWidth: n, sourceHeight: o, targetWidth: l, targetHeight: u, width: f, height: h, transform: p }) {
  const v = {
    x: Math.min(t.x, e.x),
    y: Math.min(t.y, e.y),
    x2: Math.max(t.x + n, e.x + l),
    y2: Math.max(t.y + o, e.y + u)
  };
  v.x === v.x2 && (v.x2 += 1), v.y === v.y2 && (v.y2 += 1);
  const g = rectToBox({
    x: (0 - p[0]) / p[2],
    y: (0 - p[1]) / p[2],
    width: f / p[2],
    height: h / p[2]
  }), w = Math.max(0, Math.min(g.x2, v.x2) - Math.max(g.x, v.x)), E = Math.max(0, Math.min(g.y2, v.y2) - Math.max(g.y, v.y));
  return Math.ceil(w * E) > 0;
}
function getNodeData(t) {
  var o, l, u, f, h;
  const e = ((o = t == null ? void 0 : t[internalsSymbol]) == null ? void 0 : o.handleBounds) || null, n = e && (t == null ? void 0 : t.width) && (t == null ? void 0 : t.height) && typeof ((l = t == null ? void 0 : t.positionAbsolute) == null ? void 0 : l.x) < "u" && typeof ((u = t == null ? void 0 : t.positionAbsolute) == null ? void 0 : u.y) < "u";
  return [
    {
      x: ((f = t == null ? void 0 : t.positionAbsolute) == null ? void 0 : f.x) || 0,
      y: ((h = t == null ? void 0 : t.positionAbsolute) == null ? void 0 : h.y) || 0,
      width: (t == null ? void 0 : t.width) || 0,
      height: (t == null ? void 0 : t.height) || 0
    },
    e,
    !!n
  ];
}
const defaultEdgeTree = [{ level: 0, isMaxLevel: !0, edges: [] }];
function groupEdgesByZLevel(t, e, n = !1) {
  let o = -1;
  const l = t.reduce((f, h) => {
    var g, w;
    const p = isNumeric(h.zIndex);
    let v = p ? h.zIndex : 0;
    if (n) {
      const E = e.get(h.target), T = e.get(h.source), R = h.selected || (E == null ? void 0 : E.selected) || (T == null ? void 0 : T.selected), _ = Math.max(((g = T == null ? void 0 : T[internalsSymbol]) == null ? void 0 : g.z) || 0, ((w = E == null ? void 0 : E[internalsSymbol]) == null ? void 0 : w.z) || 0, 1e3);
      v = (p ? h.zIndex : 0) + (R ? _ : 0);
    }
    return f[v] ? f[v].push(h) : f[v] = [h], o = v > o ? v : o, f;
  }, {}), u = Object.entries(l).map(([f, h]) => {
    const p = +f;
    return {
      edges: h,
      level: p,
      isMaxLevel: p === o
    };
  });
  return u.length === 0 ? defaultEdgeTree : u;
}
function useVisibleEdges(t, e, n) {
  const o = useStore(useCallback((l) => t ? l.edges.filter((u) => {
    const f = e.get(u.source), h = e.get(u.target);
    return (f == null ? void 0 : f.width) && (f == null ? void 0 : f.height) && (h == null ? void 0 : h.width) && (h == null ? void 0 : h.height) && isEdgeVisible({
      sourcePos: f.positionAbsolute || { x: 0, y: 0 },
      targetPos: h.positionAbsolute || { x: 0, y: 0 },
      sourceWidth: f.width,
      sourceHeight: f.height,
      targetWidth: h.width,
      targetHeight: h.height,
      width: l.width,
      height: l.height,
      transform: l.transform
    });
  }) : l.edges, [t, e]));
  return groupEdgesByZLevel(o, e, n);
}
const ArrowSymbol = ({ color: t = "none", strokeWidth: e = 1 }) => React__default.createElement("polyline", { style: {
  stroke: t,
  strokeWidth: e
}, strokeLinecap: "round", strokeLinejoin: "round", fill: "none", points: "-5,-4 0,0 -5,4" }), ArrowClosedSymbol = ({ color: t = "none", strokeWidth: e = 1 }) => React__default.createElement("polyline", { style: {
  stroke: t,
  fill: t,
  strokeWidth: e
}, strokeLinecap: "round", strokeLinejoin: "round", points: "-5,-4 0,0 -5,4 -5,-4" }), MarkerSymbols = {
  [MarkerType.Arrow]: ArrowSymbol,
  [MarkerType.ArrowClosed]: ArrowClosedSymbol
};
function useMarkerSymbol(t) {
  const e = useStoreApi();
  return useMemo(() => {
    var l, u;
    return Object.prototype.hasOwnProperty.call(MarkerSymbols, t) ? MarkerSymbols[t] : ((u = (l = e.getState()).onError) == null || u.call(l, "009", errorMessages.error009(t)), null);
  }, [t]);
}
const Marker = ({ id: t, type: e, color: n, width: o = 12.5, height: l = 12.5, markerUnits: u = "strokeWidth", strokeWidth: f, orient: h = "auto-start-reverse" }) => {
  const p = useMarkerSymbol(e);
  return p ? React__default.createElement(
    "marker",
    { className: "react-flow__arrowhead", id: t, markerWidth: `${o}`, markerHeight: `${l}`, viewBox: "-10 -10 20 20", markerUnits: u, orient: h, refX: "0", refY: "0" },
    React__default.createElement(p, { color: n, strokeWidth: f })
  ) : null;
}, markerSelector = ({ defaultColor: t, rfId: e }) => (n) => {
  const o = [];
  return n.edges.reduce((l, u) => ([u.markerStart, u.markerEnd].forEach((f) => {
    if (f && typeof f == "object") {
      const h = getMarkerId(f, e);
      o.includes(h) || (l.push({ id: h, color: f.color || t, ...f }), o.push(h));
    }
  }), l), []).sort((l, u) => l.id.localeCompare(u.id));
}, MarkerDefinitions = ({ defaultColor: t, rfId: e }) => {
  const n = useStore(
    useCallback(markerSelector({ defaultColor: t, rfId: e }), [t, e]),
    // the id includes all marker options, so we just need to look at that part of the marker
    (o, l) => !(o.length !== l.length || o.some((u, f) => u.id !== l[f].id))
  );
  return React__default.createElement("defs", null, n.map((o) => React__default.createElement(Marker, { id: o.id, key: o.id, type: o.type, color: o.color, width: o.width, height: o.height, markerUnits: o.markerUnits, strokeWidth: o.strokeWidth, orient: o.orient })));
};
MarkerDefinitions.displayName = "MarkerDefinitions";
var MarkerDefinitions$1 = memo$1(MarkerDefinitions);
const selector$4 = (t) => ({
  nodesConnectable: t.nodesConnectable,
  edgesFocusable: t.edgesFocusable,
  edgesUpdatable: t.edgesUpdatable,
  elementsSelectable: t.elementsSelectable,
  width: t.width,
  height: t.height,
  connectionMode: t.connectionMode,
  nodeInternals: t.nodeInternals,
  onError: t.onError
}), EdgeRenderer = ({ defaultMarkerColor: t, onlyRenderVisibleElements: e, elevateEdgesOnSelect: n, rfId: o, edgeTypes: l, noPanClassName: u, onEdgeContextMenu: f, onEdgeMouseEnter: h, onEdgeMouseMove: p, onEdgeMouseLeave: v, onEdgeClick: g, onEdgeDoubleClick: w, onReconnect: E, onReconnectStart: T, onReconnectEnd: R, reconnectRadius: _, children: b, disableKeyboardA11y: M }) => {
  const { edgesFocusable: A, edgesUpdatable: $, elementsSelectable: S, width: C, height: D, connectionMode: O, nodeInternals: N, onError: j } = useStore(selector$4, shallow$1), L = useVisibleEdges(e, N, n);
  return C ? React__default.createElement(
    React__default.Fragment,
    null,
    L.map(({ level: z, edges: G, isMaxLevel: B }) => React__default.createElement(
      "svg",
      { key: z, style: { zIndex: z }, width: C, height: D, className: "react-flow__edges react-flow__container" },
      B && React__default.createElement(MarkerDefinitions$1, { defaultColor: t, rfId: o }),
      React__default.createElement("g", null, G.map((F) => {
        const [H, W, V] = getNodeData(N.get(F.source)), [X, Z, Q] = getNodeData(N.get(F.target));
        if (!V || !Q)
          return null;
        let q = F.type || "default";
        l[q] || (j == null || j("011", errorMessages.error011(q)), q = "default");
        const J = l[q] || l.default, ie = O === ConnectionMode.Strict ? Z.target : (Z.target ?? []).concat(Z.source ?? []), ne = getHandle(W.source, F.sourceHandle), ge = getHandle(ie, F.targetHandle), ye = (ne == null ? void 0 : ne.position) || Position.Bottom, xe = (ge == null ? void 0 : ge.position) || Position.Top, we = !!(F.focusable || A && typeof F.focusable > "u"), de = F.reconnectable || F.updatable, Te = typeof E < "u" && (de || $ && typeof de > "u");
        if (!ne || !ge)
          return j == null || j("008", errorMessages.error008(ne, F)), null;
        const { sourceX: Ce, sourceY: ee, targetX: Ae, targetY: be } = getEdgePositions(H, ne, ye, X, ge, xe);
        return React__default.createElement(J, { key: F.id, id: F.id, className: cc$1([F.className, u]), type: q, data: F.data, selected: !!F.selected, animated: !!F.animated, hidden: !!F.hidden, label: F.label, labelStyle: F.labelStyle, labelShowBg: F.labelShowBg, labelBgStyle: F.labelBgStyle, labelBgPadding: F.labelBgPadding, labelBgBorderRadius: F.labelBgBorderRadius, style: F.style, source: F.source, target: F.target, sourceHandleId: F.sourceHandle, targetHandleId: F.targetHandle, markerEnd: F.markerEnd, markerStart: F.markerStart, sourceX: Ce, sourceY: ee, targetX: Ae, targetY: be, sourcePosition: ye, targetPosition: xe, elementsSelectable: S, onContextMenu: f, onMouseEnter: h, onMouseMove: p, onMouseLeave: v, onClick: g, onEdgeDoubleClick: w, onReconnect: E, onReconnectStart: T, onReconnectEnd: R, reconnectRadius: _, rfId: o, ariaLabel: F.ariaLabel, isFocusable: we, isReconnectable: Te, pathOptions: "pathOptions" in F ? F.pathOptions : void 0, interactionWidth: F.interactionWidth, disableKeyboardA11y: M });
      }))
    )),
    b
  ) : null;
};
EdgeRenderer.displayName = "EdgeRenderer";
var EdgeRenderer$1 = memo$1(EdgeRenderer);
const selector$3 = (t) => `translate(${t.transform[0]}px,${t.transform[1]}px) scale(${t.transform[2]})`;
function Viewport({ children: t }) {
  const e = useStore(selector$3);
  return React__default.createElement("div", { className: "react-flow__viewport react-flow__container", style: { transform: e } }, t);
}
function useOnInitHandler(t) {
  const e = useReactFlow(), n = useRef(!1);
  useEffect(() => {
    !n.current && e.viewportInitialized && t && (setTimeout(() => t(e), 1), n.current = !0);
  }, [t, e.viewportInitialized]);
}
const oppositePosition = {
  [Position.Left]: Position.Right,
  [Position.Right]: Position.Left,
  [Position.Top]: Position.Bottom,
  [Position.Bottom]: Position.Top
}, ConnectionLine = ({ nodeId: t, handleType: e, style: n, type: o = ConnectionLineType.Bezier, CustomComponent: l, connectionStatus: u }) => {
  var D, O, N;
  const { fromNode: f, handleId: h, toX: p, toY: v, connectionMode: g } = useStore(useCallback((j) => ({
    fromNode: j.nodeInternals.get(t),
    handleId: j.connectionHandleId,
    toX: (j.connectionPosition.x - j.transform[0]) / j.transform[2],
    toY: (j.connectionPosition.y - j.transform[1]) / j.transform[2],
    connectionMode: j.connectionMode
  }), [t]), shallow$1), w = (D = f == null ? void 0 : f[internalsSymbol]) == null ? void 0 : D.handleBounds;
  let E = w == null ? void 0 : w[e];
  if (g === ConnectionMode.Loose && (E = E || (w == null ? void 0 : w[e === "source" ? "target" : "source"])), !f || !E)
    return null;
  const T = h ? E.find((j) => j.id === h) : E[0], R = T ? T.x + T.width / 2 : (f.width ?? 0) / 2, _ = T ? T.y + T.height / 2 : f.height ?? 0, b = (((O = f.positionAbsolute) == null ? void 0 : O.x) ?? 0) + R, M = (((N = f.positionAbsolute) == null ? void 0 : N.y) ?? 0) + _, A = T == null ? void 0 : T.position, $ = A ? oppositePosition[A] : null;
  if (!A || !$)
    return null;
  if (l)
    return React__default.createElement(l, { connectionLineType: o, connectionLineStyle: n, fromNode: f, fromHandle: T, fromX: b, fromY: M, toX: p, toY: v, fromPosition: A, toPosition: $, connectionStatus: u });
  let S = "";
  const C = {
    sourceX: b,
    sourceY: M,
    sourcePosition: A,
    targetX: p,
    targetY: v,
    targetPosition: $
  };
  return o === ConnectionLineType.Bezier ? [S] = getBezierPath(C) : o === ConnectionLineType.Step ? [S] = getSmoothStepPath({
    ...C,
    borderRadius: 0
  }) : o === ConnectionLineType.SmoothStep ? [S] = getSmoothStepPath(C) : o === ConnectionLineType.SimpleBezier ? [S] = getSimpleBezierPath(C) : S = `M${b},${M} ${p},${v}`, React__default.createElement("path", { d: S, fill: "none", className: "react-flow__connection-path", style: n });
};
ConnectionLine.displayName = "ConnectionLine";
const selector$2$1 = (t) => ({
  nodeId: t.connectionNodeId,
  handleType: t.connectionHandleType,
  nodesConnectable: t.nodesConnectable,
  connectionStatus: t.connectionStatus,
  width: t.width,
  height: t.height
});
function ConnectionLineWrapper({ containerStyle: t, style: e, type: n, component: o }) {
  const { nodeId: l, handleType: u, nodesConnectable: f, width: h, height: p, connectionStatus: v } = useStore(selector$2$1, shallow$1);
  return !(l && u && h && f) ? null : React__default.createElement(
    "svg",
    { style: t, width: h, height: p, className: "react-flow__edges react-flow__connectionline react-flow__container" },
    React__default.createElement(
      "g",
      { className: cc$1(["react-flow__connection", v]) },
      React__default.createElement(ConnectionLine, { nodeId: l, handleType: u, style: e, type: n, CustomComponent: o, connectionStatus: v })
    )
  );
}
function useNodeOrEdgeTypes(t, e) {
  const n = useRef(null), o = useStoreApi();
  return useMemo(() => {
    var u, f;
    if (process.env.NODE_ENV === "development") {
      const h = Object.keys(t);
      shallow$1(n.current, h) && ((f = (u = o.getState()).onError) == null || f.call(u, "002", errorMessages.error002())), n.current = h;
    }
    return e(t);
  }, [t]);
}
const GraphView = ({ nodeTypes: t, edgeTypes: e, onMove: n, onMoveStart: o, onMoveEnd: l, onInit: u, onNodeClick: f, onEdgeClick: h, onNodeDoubleClick: p, onEdgeDoubleClick: v, onNodeMouseEnter: g, onNodeMouseMove: w, onNodeMouseLeave: E, onNodeContextMenu: T, onSelectionContextMenu: R, onSelectionStart: _, onSelectionEnd: b, connectionLineType: M, connectionLineStyle: A, connectionLineComponent: $, connectionLineContainerStyle: S, selectionKeyCode: C, selectionOnDrag: D, selectionMode: O, multiSelectionKeyCode: N, panActivationKeyCode: j, zoomActivationKeyCode: L, deleteKeyCode: z, onlyRenderVisibleElements: G, elementsSelectable: B, selectNodesOnDrag: F, defaultViewport: H, translateExtent: W, minZoom: V, maxZoom: X, preventScrolling: Z, defaultMarkerColor: Q, zoomOnScroll: q, zoomOnPinch: J, panOnScroll: ie, panOnScrollSpeed: ne, panOnScrollMode: ge, zoomOnDoubleClick: ye, panOnDrag: xe, onPaneClick: we, onPaneMouseEnter: de, onPaneMouseMove: Te, onPaneMouseLeave: Ce, onPaneScroll: ee, onPaneContextMenu: Ae, onEdgeContextMenu: be, onEdgeMouseEnter: Fe, onEdgeMouseMove: et, onEdgeMouseLeave: Ye, onReconnect: De, onReconnectStart: Ue, onReconnectEnd: Qe, reconnectRadius: ue, noDragClassName: te, noWheelClassName: Be, noPanClassName: Je, elevateEdgesOnSelect: ft, disableKeyboardA11y: lt, nodeOrigin: he, nodeExtent: ae, rfId: se }) => {
  const Re = useNodeOrEdgeTypes(t, createNodeTypes), Oe = useNodeOrEdgeTypes(e, createEdgeTypes);
  return useOnInitHandler(u), React__default.createElement(
    FlowRenderer$1,
    { onPaneClick: we, onPaneMouseEnter: de, onPaneMouseMove: Te, onPaneMouseLeave: Ce, onPaneContextMenu: Ae, onPaneScroll: ee, deleteKeyCode: z, selectionKeyCode: C, selectionOnDrag: D, selectionMode: O, onSelectionStart: _, onSelectionEnd: b, multiSelectionKeyCode: N, panActivationKeyCode: j, zoomActivationKeyCode: L, elementsSelectable: B, onMove: n, onMoveStart: o, onMoveEnd: l, zoomOnScroll: q, zoomOnPinch: J, zoomOnDoubleClick: ye, panOnScroll: ie, panOnScrollSpeed: ne, panOnScrollMode: ge, panOnDrag: xe, defaultViewport: H, translateExtent: W, minZoom: V, maxZoom: X, onSelectionContextMenu: R, preventScrolling: Z, noDragClassName: te, noWheelClassName: Be, noPanClassName: Je, disableKeyboardA11y: lt },
    React__default.createElement(
      Viewport,
      null,
      React__default.createElement(
        EdgeRenderer$1,
        { edgeTypes: Oe, onEdgeClick: h, onEdgeDoubleClick: v, onlyRenderVisibleElements: G, onEdgeContextMenu: be, onEdgeMouseEnter: Fe, onEdgeMouseMove: et, onEdgeMouseLeave: Ye, onReconnect: De, onReconnectStart: Ue, onReconnectEnd: Qe, reconnectRadius: ue, defaultMarkerColor: Q, noPanClassName: Je, elevateEdgesOnSelect: !!ft, disableKeyboardA11y: lt, rfId: se },
        React__default.createElement(ConnectionLineWrapper, { style: A, type: M, component: $, containerStyle: S })
      ),
      React__default.createElement("div", { className: "react-flow__edgelabel-renderer" }),
      React__default.createElement(NodeRenderer$1, { nodeTypes: Re, onNodeClick: f, onNodeDoubleClick: p, onNodeMouseEnter: g, onNodeMouseMove: w, onNodeMouseLeave: E, onNodeContextMenu: T, selectNodesOnDrag: F, onlyRenderVisibleElements: G, noPanClassName: Je, noDragClassName: te, disableKeyboardA11y: lt, nodeOrigin: he, nodeExtent: ae, rfId: se })
    )
  );
};
GraphView.displayName = "GraphView";
var GraphView$1 = memo$1(GraphView);
const infiniteExtent = [
  [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],
  [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]
], initialState = {
  rfId: "1",
  width: 0,
  height: 0,
  transform: [0, 0, 1],
  nodeInternals: /* @__PURE__ */ new Map(),
  edges: [],
  onNodesChange: null,
  onEdgesChange: null,
  hasDefaultNodes: !1,
  hasDefaultEdges: !1,
  d3Zoom: null,
  d3Selection: null,
  d3ZoomHandler: void 0,
  minZoom: 0.5,
  maxZoom: 2,
  translateExtent: infiniteExtent,
  nodeExtent: infiniteExtent,
  nodesSelectionActive: !1,
  userSelectionActive: !1,
  userSelectionRect: null,
  connectionNodeId: null,
  connectionHandleId: null,
  connectionHandleType: "source",
  connectionPosition: { x: 0, y: 0 },
  connectionStatus: null,
  connectionMode: ConnectionMode.Strict,
  domNode: null,
  paneDragging: !1,
  noPanClassName: "nopan",
  nodeOrigin: [0, 0],
  nodeDragThreshold: 0,
  snapGrid: [15, 15],
  snapToGrid: !1,
  nodesDraggable: !0,
  nodesConnectable: !0,
  nodesFocusable: !0,
  edgesFocusable: !0,
  edgesUpdatable: !0,
  elementsSelectable: !0,
  elevateNodesOnSelect: !0,
  fitViewOnInit: !1,
  fitViewOnInitDone: !1,
  fitViewOnInitOptions: void 0,
  onSelectionChange: [],
  multiSelectionActive: !1,
  connectionStartHandle: null,
  connectionEndHandle: null,
  connectionClickStartHandle: null,
  connectOnClick: !0,
  ariaLiveMessage: "",
  autoPanOnConnect: !0,
  autoPanOnNodeDrag: !0,
  connectionRadius: 20,
  onError: devWarn,
  isValidConnection: void 0
}, createRFStore = () => createWithEqualityFn((t, e) => ({
  ...initialState,
  setNodes: (n) => {
    const { nodeInternals: o, nodeOrigin: l, elevateNodesOnSelect: u } = e();
    t({ nodeInternals: createNodeInternals(n, o, l, u) });
  },
  getNodes: () => Array.from(e().nodeInternals.values()),
  setEdges: (n) => {
    const { defaultEdgeOptions: o = {} } = e();
    t({ edges: n.map((l) => ({ ...o, ...l })) });
  },
  setDefaultNodesAndEdges: (n, o) => {
    const l = typeof n < "u", u = typeof o < "u", f = l ? createNodeInternals(n, /* @__PURE__ */ new Map(), e().nodeOrigin, e().elevateNodesOnSelect) : /* @__PURE__ */ new Map();
    t({ nodeInternals: f, edges: u ? o : [], hasDefaultNodes: l, hasDefaultEdges: u });
  },
  updateNodeDimensions: (n) => {
    const { onNodesChange: o, nodeInternals: l, fitViewOnInit: u, fitViewOnInitDone: f, fitViewOnInitOptions: h, domNode: p, nodeOrigin: v } = e(), g = p == null ? void 0 : p.querySelector(".react-flow__viewport");
    if (!g)
      return;
    const w = window.getComputedStyle(g), { m22: E } = new window.DOMMatrixReadOnly(w.transform), T = n.reduce((_, b) => {
      const M = l.get(b.id);
      if (M != null && M.hidden)
        l.set(M.id, {
          ...M,
          [internalsSymbol]: {
            ...M[internalsSymbol],
            // we need to reset the handle bounds when the node is hidden
            // in order to force a new observation when the node is shown again
            handleBounds: void 0
          }
        });
      else if (M) {
        const A = getDimensions$1(b.nodeElement);
        !!(A.width && A.height && (M.width !== A.width || M.height !== A.height || b.forceUpdate)) && (l.set(M.id, {
          ...M,
          [internalsSymbol]: {
            ...M[internalsSymbol],
            handleBounds: {
              source: getHandleBounds(".source", b.nodeElement, E, v),
              target: getHandleBounds(".target", b.nodeElement, E, v)
            }
          },
          ...A
        }), _.push({
          id: M.id,
          type: "dimensions",
          dimensions: A
        }));
      }
      return _;
    }, []);
    updateAbsoluteNodePositions(l, v);
    const R = f || u && !f && fitView(e, { initial: !0, ...h });
    t({ nodeInternals: new Map(l), fitViewOnInitDone: R }), (T == null ? void 0 : T.length) > 0 && (o == null || o(T));
  },
  updateNodePositions: (n, o = !0, l = !1) => {
    const { triggerNodeChanges: u } = e(), f = n.map((h) => {
      const p = {
        id: h.id,
        type: "position",
        dragging: l
      };
      return o && (p.positionAbsolute = h.positionAbsolute, p.position = h.position), p;
    });
    u(f);
  },
  triggerNodeChanges: (n) => {
    const { onNodesChange: o, nodeInternals: l, hasDefaultNodes: u, nodeOrigin: f, getNodes: h, elevateNodesOnSelect: p } = e();
    if (n != null && n.length) {
      if (u) {
        const v = applyNodeChanges(n, h()), g = createNodeInternals(v, l, f, p);
        t({ nodeInternals: g });
      }
      o == null || o(n);
    }
  },
  addSelectedNodes: (n) => {
    const { multiSelectionActive: o, edges: l, getNodes: u } = e();
    let f, h = null;
    o ? f = n.map((p) => createSelectionChange(p, !0)) : (f = getSelectionChanges(u(), n), h = getSelectionChanges(l, [])), updateNodesAndEdgesSelections({
      changedNodes: f,
      changedEdges: h,
      get: e,
      set: t
    });
  },
  addSelectedEdges: (n) => {
    const { multiSelectionActive: o, edges: l, getNodes: u } = e();
    let f, h = null;
    o ? f = n.map((p) => createSelectionChange(p, !0)) : (f = getSelectionChanges(l, n), h = getSelectionChanges(u(), [])), updateNodesAndEdgesSelections({
      changedNodes: h,
      changedEdges: f,
      get: e,
      set: t
    });
  },
  unselectNodesAndEdges: ({ nodes: n, edges: o } = {}) => {
    const { edges: l, getNodes: u } = e(), f = n || u(), h = o || l, p = f.map((g) => (g.selected = !1, createSelectionChange(g.id, !1))), v = h.map((g) => createSelectionChange(g.id, !1));
    updateNodesAndEdgesSelections({
      changedNodes: p,
      changedEdges: v,
      get: e,
      set: t
    });
  },
  setMinZoom: (n) => {
    const { d3Zoom: o, maxZoom: l } = e();
    o == null || o.scaleExtent([n, l]), t({ minZoom: n });
  },
  setMaxZoom: (n) => {
    const { d3Zoom: o, minZoom: l } = e();
    o == null || o.scaleExtent([l, n]), t({ maxZoom: n });
  },
  setTranslateExtent: (n) => {
    var o;
    (o = e().d3Zoom) == null || o.translateExtent(n), t({ translateExtent: n });
  },
  resetSelectedElements: () => {
    const { edges: n, getNodes: o } = e(), u = o().filter((h) => h.selected).map((h) => createSelectionChange(h.id, !1)), f = n.filter((h) => h.selected).map((h) => createSelectionChange(h.id, !1));
    updateNodesAndEdgesSelections({
      changedNodes: u,
      changedEdges: f,
      get: e,
      set: t
    });
  },
  setNodeExtent: (n) => {
    const { nodeInternals: o } = e();
    o.forEach((l) => {
      l.positionAbsolute = clampPosition(l.position, n);
    }), t({
      nodeExtent: n,
      nodeInternals: new Map(o)
    });
  },
  panBy: (n) => {
    const { transform: o, width: l, height: u, d3Zoom: f, d3Selection: h, translateExtent: p } = e();
    if (!f || !h || !n.x && !n.y)
      return !1;
    const v = identity$c.translate(o[0] + n.x, o[1] + n.y).scale(o[2]), g = [
      [0, 0],
      [l, u]
    ], w = f == null ? void 0 : f.constrain()(v, g, p);
    return f.transform(h, w), o[0] !== w.x || o[1] !== w.y || o[2] !== w.k;
  },
  cancelConnection: () => t({
    connectionNodeId: initialState.connectionNodeId,
    connectionHandleId: initialState.connectionHandleId,
    connectionHandleType: initialState.connectionHandleType,
    connectionStatus: initialState.connectionStatus,
    connectionStartHandle: initialState.connectionStartHandle,
    connectionEndHandle: initialState.connectionEndHandle
  }),
  reset: () => t({ ...initialState })
}), Object.is), ReactFlowProvider = ({ children: t }) => {
  const e = useRef(null);
  return e.current || (e.current = createRFStore()), React__default.createElement(Provider$1, { value: e.current }, t);
};
ReactFlowProvider.displayName = "ReactFlowProvider";
const Wrapper = ({ children: t }) => useContext(StoreContext) ? React__default.createElement(React__default.Fragment, null, t) : React__default.createElement(ReactFlowProvider, null, t);
Wrapper.displayName = "ReactFlowWrapper";
const defaultNodeTypes = {
  input: InputNode$1,
  default: DefaultNode$1,
  output: OutputNode$1,
  group: GroupNode
}, defaultEdgeTypes = {
  default: BezierEdge,
  straight: StraightEdge,
  step: StepEdge,
  smoothstep: SmoothStepEdge,
  simplebezier: SimpleBezierEdge
}, initNodeOrigin = [0, 0], initSnapGrid = [15, 15], initDefaultViewport = { x: 0, y: 0, zoom: 1 }, wrapperStyle = {
  width: "100%",
  height: "100%",
  overflow: "hidden",
  position: "relative",
  zIndex: 0
}, ReactFlow = forwardRef(({ nodes: t, edges: e, defaultNodes: n, defaultEdges: o, className: l, nodeTypes: u = defaultNodeTypes, edgeTypes: f = defaultEdgeTypes, onNodeClick: h, onEdgeClick: p, onInit: v, onMove: g, onMoveStart: w, onMoveEnd: E, onConnect: T, onConnectStart: R, onConnectEnd: _, onClickConnectStart: b, onClickConnectEnd: M, onNodeMouseEnter: A, onNodeMouseMove: $, onNodeMouseLeave: S, onNodeContextMenu: C, onNodeDoubleClick: D, onNodeDragStart: O, onNodeDrag: N, onNodeDragStop: j, onNodesDelete: L, onEdgesDelete: z, onSelectionChange: G, onSelectionDragStart: B, onSelectionDrag: F, onSelectionDragStop: H, onSelectionContextMenu: W, onSelectionStart: V, onSelectionEnd: X, connectionMode: Z = ConnectionMode.Strict, connectionLineType: Q = ConnectionLineType.Bezier, connectionLineStyle: q, connectionLineComponent: J, connectionLineContainerStyle: ie, deleteKeyCode: ne = "Backspace", selectionKeyCode: ge = "Shift", selectionOnDrag: ye = !1, selectionMode: xe = SelectionMode.Full, panActivationKeyCode: we = "Space", multiSelectionKeyCode: de = isMacOs() ? "Meta" : "Control", zoomActivationKeyCode: Te = isMacOs() ? "Meta" : "Control", snapToGrid: Ce = !1, snapGrid: ee = initSnapGrid, onlyRenderVisibleElements: Ae = !1, selectNodesOnDrag: be = !0, nodesDraggable: Fe, nodesConnectable: et, nodesFocusable: Ye, nodeOrigin: De = initNodeOrigin, edgesFocusable: Ue, edgesUpdatable: Qe, elementsSelectable: ue, defaultViewport: te = initDefaultViewport, minZoom: Be = 0.5, maxZoom: Je = 2, translateExtent: ft = infiniteExtent, preventScrolling: lt = !0, nodeExtent: he, defaultMarkerColor: ae = "#b1b1b7", zoomOnScroll: se = !0, zoomOnPinch: Re = !0, panOnScroll: Oe = !1, panOnScrollSpeed: We = 0.5, panOnScrollMode: Ct = PanOnScrollMode.Free, zoomOnDoubleClick: le = !0, panOnDrag: ke = !0, onPaneClick: Ke, onPaneMouseEnter: me, onPaneMouseMove: Ee, onPaneMouseLeave: tt, onPaneScroll: ce, onPaneContextMenu: _e, children: Ht, onEdgeContextMenu: K, onEdgeDoubleClick: Ve, onEdgeMouseEnter: Ne, onEdgeMouseMove: pe, onEdgeMouseLeave: Le, onEdgeUpdate: bt, onEdgeUpdateStart: yi, onEdgeUpdateEnd: _n, onReconnect: Do, onReconnectStart: ms, onReconnectEnd: Bp, reconnectRadius: Sp = 10, edgeUpdaterRadius: Tp = 10, onNodesChange: Pp, onEdgesChange: Xe, noDragClassName: Se = "nodrag", noWheelClassName: pr = "nowheel", noPanClassName: mn = "nopan", fitView: Si = !1, fitViewOptions: Io, connectOnClick: ve = !0, attributionPosition: He, proOptions: nt, defaultEdgeOptions: dr, elevateNodesOnSelect: dt = !0, elevateEdgesOnSelect: ci = !1, disableKeyboardA11y: Uo = !1, autoPanOnConnect: xs = !0, autoPanOnNodeDrag: vs = !0, connectionRadius: bp = 20, isValidConnection: Ep, onError: Ap, style: wp, id: jp, nodeDragThreshold: Vp, ...Qp }, zp) => {
  const Mp = jp || "1";
  return React__default.createElement(
    "div",
    { ...Qp, style: { ...wp, ...wrapperStyle }, ref: zp, className: cc$1(["react-flow", l]), "data-testid": "rf__wrapper", id: jp },
    React__default.createElement(
      Wrapper,
      null,
      React__default.createElement(GraphView$1, { onInit: v, onMove: g, onMoveStart: w, onMoveEnd: E, onNodeClick: h, onEdgeClick: p, onNodeMouseEnter: A, onNodeMouseMove: $, onNodeMouseLeave: S, onNodeContextMenu: C, onNodeDoubleClick: D, nodeTypes: u, edgeTypes: f, connectionLineType: Q, connectionLineStyle: q, connectionLineComponent: J, connectionLineContainerStyle: ie, selectionKeyCode: ge, selectionOnDrag: ye, selectionMode: xe, deleteKeyCode: ne, multiSelectionKeyCode: de, panActivationKeyCode: we, zoomActivationKeyCode: Te, onlyRenderVisibleElements: Ae, selectNodesOnDrag: be, defaultViewport: te, translateExtent: ft, minZoom: Be, maxZoom: Je, preventScrolling: lt, zoomOnScroll: se, zoomOnPinch: Re, zoomOnDoubleClick: le, panOnScroll: Oe, panOnScrollSpeed: We, panOnScrollMode: Ct, panOnDrag: ke, onPaneClick: Ke, onPaneMouseEnter: me, onPaneMouseMove: Ee, onPaneMouseLeave: tt, onPaneScroll: ce, onPaneContextMenu: _e, onSelectionContextMenu: W, onSelectionStart: V, onSelectionEnd: X, onEdgeContextMenu: K, onEdgeDoubleClick: Ve, onEdgeMouseEnter: Ne, onEdgeMouseMove: pe, onEdgeMouseLeave: Le, onReconnect: Do ?? bt, onReconnectStart: ms ?? yi, onReconnectEnd: Bp ?? _n, reconnectRadius: Sp ?? Tp, defaultMarkerColor: ae, noDragClassName: Se, noWheelClassName: pr, noPanClassName: mn, elevateEdgesOnSelect: ci, rfId: Mp, disableKeyboardA11y: Uo, nodeOrigin: De, nodeExtent: he }),
      React__default.createElement(StoreUpdater, { nodes: t, edges: e, defaultNodes: n, defaultEdges: o, onConnect: T, onConnectStart: R, onConnectEnd: _, onClickConnectStart: b, onClickConnectEnd: M, nodesDraggable: Fe, nodesConnectable: et, nodesFocusable: Ye, edgesFocusable: Ue, edgesUpdatable: Qe, elementsSelectable: ue, elevateNodesOnSelect: dt, minZoom: Be, maxZoom: Je, nodeExtent: he, onNodesChange: Pp, onEdgesChange: Xe, snapToGrid: Ce, snapGrid: ee, connectionMode: Z, translateExtent: ft, connectOnClick: ve, defaultEdgeOptions: dr, fitView: Si, fitViewOptions: Io, onNodesDelete: L, onEdgesDelete: z, onNodeDragStart: O, onNodeDrag: N, onNodeDragStop: j, onSelectionDrag: F, onSelectionDragStart: B, onSelectionDragStop: H, noPanClassName: mn, nodeOrigin: De, rfId: Mp, autoPanOnConnect: xs, autoPanOnNodeDrag: vs, onError: Ap, connectionRadius: bp, isValidConnection: Ep, nodeDragThreshold: Vp }),
      React__default.createElement(Wrapper$1, { onSelectionChange: G }),
      Ht,
      React__default.createElement(Attribution, { proOptions: nt, position: He }),
      React__default.createElement(A11yDescriptions, { rfId: Mp, disableKeyboardA11y: Uo })
    )
  );
});
ReactFlow.displayName = "ReactFlow";
function createUseItemsState(t) {
  return (e) => {
    const [n, o] = useState(e), l = useCallback((u) => o((f) => t(u, f)), []);
    return [n, o, l];
  };
}
const useNodesState = createUseItemsState(applyNodeChanges), useEdgesState = createUseItemsState(applyEdgeChanges), MiniMapNode = ({ id: t, x: e, y: n, width: o, height: l, style: u, color: f, strokeColor: h, strokeWidth: p, className: v, borderRadius: g, shapeRendering: w, onClick: E, selected: T }) => {
  const { background: R, backgroundColor: _ } = u || {}, b = f || R || _;
  return React__default.createElement("rect", { className: cc$1(["react-flow__minimap-node", { selected: T }, v]), x: e, y: n, rx: g, ry: g, width: o, height: l, fill: b, stroke: h, strokeWidth: p, shapeRendering: w, onClick: E ? (M) => E(M, t) : void 0 });
};
MiniMapNode.displayName = "MiniMapNode";
var MiniMapNode$1 = memo$1(MiniMapNode);
const selector$1$1 = (t) => t.nodeOrigin, selectorNodes = (t) => t.getNodes().filter((e) => !e.hidden && e.width && e.height), getAttrFunction = (t) => t instanceof Function ? t : () => t;
function MiniMapNodes({
  nodeStrokeColor: t = "transparent",
  nodeColor: e = "#e2e2e2",
  nodeClassName: n = "",
  nodeBorderRadius: o = 5,
  nodeStrokeWidth: l = 2,
  // We need to rename the prop to be `CapitalCase` so that JSX will render it as
  // a component properly.
  nodeComponent: u = MiniMapNode$1,
  onClick: f
}) {
  const h = useStore(selectorNodes, shallow$1), p = useStore(selector$1$1), v = getAttrFunction(e), g = getAttrFunction(t), w = getAttrFunction(n), E = typeof window > "u" || window.chrome ? "crispEdges" : "geometricPrecision";
  return React__default.createElement(React__default.Fragment, null, h.map((T) => {
    const { x: R, y: _ } = getNodePositionWithOrigin(T, p).positionAbsolute;
    return React__default.createElement(u, { key: T.id, x: R, y: _, width: T.width, height: T.height, style: T.style, selected: T.selected, className: w(T), color: v(T), borderRadius: o, strokeColor: g(T), strokeWidth: l, shapeRendering: E, onClick: f, id: T.id });
  }));
}
var MiniMapNodes$1 = memo$1(MiniMapNodes);
const defaultWidth = 200, defaultHeight = 150, selector$2 = (t) => {
  const e = t.getNodes(), n = {
    x: -t.transform[0] / t.transform[2],
    y: -t.transform[1] / t.transform[2],
    width: t.width / t.transform[2],
    height: t.height / t.transform[2]
  };
  return {
    viewBB: n,
    boundingRect: e.length > 0 ? getBoundsOfRects(getNodesBounds(e, t.nodeOrigin), n) : n,
    rfId: t.rfId
  };
}, ARIA_LABEL_KEY = "react-flow__minimap-desc";
function MiniMap({
  style: t,
  className: e,
  nodeStrokeColor: n = "transparent",
  nodeColor: o = "#e2e2e2",
  nodeClassName: l = "",
  nodeBorderRadius: u = 5,
  nodeStrokeWidth: f = 2,
  // We need to rename the prop to be `CapitalCase` so that JSX will render it as
  // a component properly.
  nodeComponent: h,
  maskColor: p = "rgb(240, 240, 240, 0.6)",
  maskStrokeColor: v = "none",
  maskStrokeWidth: g = 1,
  position: w = "bottom-right",
  onClick: E,
  onNodeClick: T,
  pannable: R = !1,
  zoomable: _ = !1,
  ariaLabel: b = "React Flow mini map",
  inversePan: M = !1,
  zoomStep: A = 10,
  offsetScale: $ = 5
}) {
  const S = useStoreApi(), C = useRef(null), { boundingRect: D, viewBB: O, rfId: N } = useStore(selector$2, shallow$1), j = (t == null ? void 0 : t.width) ?? defaultWidth, L = (t == null ? void 0 : t.height) ?? defaultHeight, z = D.width / j, G = D.height / L, B = Math.max(z, G), F = B * j, H = B * L, W = $ * B, V = D.x - (F - D.width) / 2 - W, X = D.y - (H - D.height) / 2 - W, Z = F + W * 2, Q = H + W * 2, q = `${ARIA_LABEL_KEY}-${N}`, J = useRef(0);
  J.current = B, useEffect(() => {
    if (C.current) {
      const ge = select(C.current), ye = (de) => {
        const { transform: Te, d3Selection: Ce, d3Zoom: ee } = S.getState();
        if (de.sourceEvent.type !== "wheel" || !Ce || !ee)
          return;
        const Ae = -de.sourceEvent.deltaY * (de.sourceEvent.deltaMode === 1 ? 0.05 : de.sourceEvent.deltaMode ? 1 : 2e-3) * A, be = Te[2] * Math.pow(2, Ae);
        ee.scaleTo(Ce, be);
      }, xe = (de) => {
        const { transform: Te, d3Selection: Ce, d3Zoom: ee, translateExtent: Ae, width: be, height: Fe } = S.getState();
        if (de.sourceEvent.type !== "mousemove" || !Ce || !ee)
          return;
        const et = J.current * Math.max(1, Te[2]) * (M ? -1 : 1), Ye = {
          x: Te[0] - de.sourceEvent.movementX * et,
          y: Te[1] - de.sourceEvent.movementY * et
        }, De = [
          [0, 0],
          [be, Fe]
        ], Ue = identity$c.translate(Ye.x, Ye.y).scale(Te[2]), Qe = ee.constrain()(Ue, De, Ae);
        ee.transform(Ce, Qe);
      }, we = zoom().on("zoom", R ? xe : null).on("zoom.wheel", _ ? ye : null);
      return ge.call(we), () => {
        ge.on("zoom", null);
      };
    }
  }, [R, _, M, A]);
  const ie = E ? (ge) => {
    const ye = pointer(ge);
    E(ge, { x: ye[0], y: ye[1] });
  } : void 0, ne = T ? (ge, ye) => {
    const xe = S.getState().nodeInternals.get(ye);
    T(ge, xe);
  } : void 0;
  return React__default.createElement(
    Panel,
    { position: w, style: t, className: cc$1(["react-flow__minimap", e]), "data-testid": "rf__minimap" },
    React__default.createElement(
      "svg",
      { width: j, height: L, viewBox: `${V} ${X} ${Z} ${Q}`, role: "img", "aria-labelledby": q, ref: C, onClick: ie },
      b && React__default.createElement("title", { id: q }, b),
      React__default.createElement(MiniMapNodes$1, { onClick: ne, nodeColor: o, nodeStrokeColor: n, nodeBorderRadius: u, nodeClassName: l, nodeStrokeWidth: f, nodeComponent: h }),
      React__default.createElement("path", { className: "react-flow__minimap-mask", d: `M${V - W},${X - W}h${Z + W * 2}v${Q + W * 2}h${-Z - W * 2}z
        M${O.x},${O.y}h${O.width}v${O.height}h${-O.width}z`, fill: p, fillRule: "evenodd", stroke: v, strokeWidth: g, pointerEvents: "none" })
    )
  );
}
MiniMap.displayName = "MiniMap";
var MiniMap$1 = memo$1(MiniMap);
function PlusIcon() {
  return React__default.createElement(
    "svg",
    { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32" },
    React__default.createElement("path", { d: "M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z" })
  );
}
function MinusIcon() {
  return React__default.createElement(
    "svg",
    { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 5" },
    React__default.createElement("path", { d: "M0 0h32v4.2H0z" })
  );
}
function FitViewIcon() {
  return React__default.createElement(
    "svg",
    { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 30" },
    React__default.createElement("path", { d: "M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z" })
  );
}
function LockIcon() {
  return React__default.createElement(
    "svg",
    { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 25 32" },
    React__default.createElement("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z" })
  );
}
function UnlockIcon() {
  return React__default.createElement(
    "svg",
    { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 25 32" },
    React__default.createElement("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z" })
  );
}
const ControlButton = ({ children: t, className: e, ...n }) => React__default.createElement("button", { type: "button", className: cc$1(["react-flow__controls-button", e]), ...n }, t);
ControlButton.displayName = "ControlButton";
const selector$1 = (t) => ({
  isInteractive: t.nodesDraggable || t.nodesConnectable || t.elementsSelectable,
  minZoomReached: t.transform[2] <= t.minZoom,
  maxZoomReached: t.transform[2] >= t.maxZoom
}), Controls = ({ style: t, showZoom: e = !0, showFitView: n = !0, showInteractive: o = !0, fitViewOptions: l, onZoomIn: u, onZoomOut: f, onFitView: h, onInteractiveChange: p, className: v, children: g, position: w = "bottom-left" }) => {
  const E = useStoreApi(), [T, R] = useState(!1), { isInteractive: _, minZoomReached: b, maxZoomReached: M } = useStore(selector$1, shallow$1), { zoomIn: A, zoomOut: $, fitView: S } = useReactFlow();
  if (useEffect(() => {
    R(!0);
  }, []), !T)
    return null;
  const C = () => {
    A(), u == null || u();
  }, D = () => {
    $(), f == null || f();
  }, O = () => {
    S(l), h == null || h();
  }, N = () => {
    E.setState({
      nodesDraggable: !_,
      nodesConnectable: !_,
      elementsSelectable: !_
    }), p == null || p(!_);
  };
  return React__default.createElement(
    Panel,
    { className: cc$1(["react-flow__controls", v]), position: w, style: t, "data-testid": "rf__controls" },
    e && React__default.createElement(
      React__default.Fragment,
      null,
      React__default.createElement(
        ControlButton,
        { onClick: C, className: "react-flow__controls-zoomin", title: "zoom in", "aria-label": "zoom in", disabled: M },
        React__default.createElement(PlusIcon, null)
      ),
      React__default.createElement(
        ControlButton,
        { onClick: D, className: "react-flow__controls-zoomout", title: "zoom out", "aria-label": "zoom out", disabled: b },
        React__default.createElement(MinusIcon, null)
      )
    ),
    n && React__default.createElement(
      ControlButton,
      { className: "react-flow__controls-fitview", onClick: O, title: "fit view", "aria-label": "fit view" },
      React__default.createElement(FitViewIcon, null)
    ),
    o && React__default.createElement(ControlButton, { className: "react-flow__controls-interactive", onClick: N, title: "toggle interactivity", "aria-label": "toggle interactivity" }, _ ? React__default.createElement(UnlockIcon, null) : React__default.createElement(LockIcon, null)),
    g
  );
};
Controls.displayName = "Controls";
var Controls$1 = memo$1(Controls), BackgroundVariant;
(function(t) {
  t.Lines = "lines", t.Dots = "dots", t.Cross = "cross";
})(BackgroundVariant || (BackgroundVariant = {}));
function LinePattern({ color: t, dimensions: e, lineWidth: n }) {
  return React__default.createElement("path", { stroke: t, strokeWidth: n, d: `M${e[0] / 2} 0 V${e[1]} M0 ${e[1] / 2} H${e[0]}` });
}
function DotPattern({ color: t, radius: e }) {
  return React__default.createElement("circle", { cx: e, cy: e, r: e, fill: t });
}
const defaultColor = {
  [BackgroundVariant.Dots]: "#91919a",
  [BackgroundVariant.Lines]: "#eee",
  [BackgroundVariant.Cross]: "#e2e2e2"
}, defaultSize = {
  [BackgroundVariant.Dots]: 1,
  [BackgroundVariant.Lines]: 1,
  [BackgroundVariant.Cross]: 6
}, selector = (t) => ({ transform: t.transform, patternId: `pattern-${t.rfId}` });
function Background$1({
  id: t,
  variant: e = BackgroundVariant.Dots,
  // only used for dots and cross
  gap: n = 20,
  // only used for lines and cross
  size: o,
  lineWidth: l = 1,
  offset: u = 2,
  color: f,
  style: h,
  className: p
}) {
  const v = useRef(null), { transform: g, patternId: w } = useStore(selector, shallow$1), E = f || defaultColor[e], T = o || defaultSize[e], R = e === BackgroundVariant.Dots, _ = e === BackgroundVariant.Cross, b = Array.isArray(n) ? n : [n, n], M = [b[0] * g[2] || 1, b[1] * g[2] || 1], A = T * g[2], $ = _ ? [A, A] : M, S = R ? [A / u, A / u] : [$[0] / u, $[1] / u];
  return React__default.createElement(
    "svg",
    { className: cc$1(["react-flow__background", p]), style: {
      ...h,
      position: "absolute",
      width: "100%",
      height: "100%",
      top: 0,
      left: 0
    }, ref: v, "data-testid": "rf__background" },
    React__default.createElement("pattern", { id: w + t, x: g[0] % M[0], y: g[1] % M[1], width: M[0], height: M[1], patternUnits: "userSpaceOnUse", patternTransform: `translate(-${S[0]},-${S[1]})` }, R ? React__default.createElement(DotPattern, { color: E, radius: A / u }) : React__default.createElement(LinePattern, { dimensions: $, color: E, lineWidth: l })),
    React__default.createElement("rect", { x: "0", y: "0", width: "100%", height: "100%", fill: `url(#${w + t})` })
  );
}
Background$1.displayName = "Background";
var Background$1$1 = memo$1(Background$1);
const dataCache = {}, Tooltip$1 = ({ details: t, position: e, containerRef: n, apiUrl: o }) => {
  const [l, u] = useState({ x: 0, y: 0 }), [f, h] = useState(null), [p, v] = useState(!1), [g, w] = useState(null);
  useEffect(() => {
    if (n.current && e) {
      const T = n.current.getBoundingClientRect(), R = e.x - T.left + 40, _ = e.y - T.top;
      u({ x: R, y: _ });
    }
  }, [e]);
  const E = useCallback(async (T) => {
    if (dataCache[T]) {
      h(dataCache[T]);
      return;
    }
    v(!0);
    try {
      const b = (await (await fetch(`${o}/nodes/${T}`)).json()).data.nodes[0];
      dataCache[T] = b, h(b);
    } catch (R) {
      w(R);
    } finally {
      v(!1);
    }
  }, [o]);
  return useEffect(() => {
    t && t.uuid && E(t.uuid);
  }, [t, E]), t ? /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
    "div",
    {
      className: "absolute bg-white z-50 text-gray-800 border border-gray-200 rounded-lg shadow-md p-4 text-sm",
      style: { top: l.y, left: l.x },
      children: [
        p && /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { children: "Loading..." }),
        g && /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { children: [
          "Error: ",
          g.message
        ] }),
        f && /* @__PURE__ */ jsxRuntimeExports$1.jsxs(jsxRuntimeExports$1.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "mb-2 flex items-center", children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "h-3 w-3 rounded-full bg-blue-500 mr-2" }),
            /* @__PURE__ */ jsxRuntimeExports$1.jsx("span", { className: "font-semibold", children: "ID : " }),
            " ",
            f.id
          ] }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "mb-2 flex items-center", children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "h-3 w-3 rounded-full bg-green-500 mr-2" }),
            /* @__PURE__ */ jsxRuntimeExports$1.jsx("span", { className: "font-semibold", children: "UUID : " }),
            " ",
            f.uuid
          ] }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "mb-2 flex items-center", children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "h-3 w-3 rounded-full bg-orange-500 mr-2" }),
            /* @__PURE__ */ jsxRuntimeExports$1.jsx("span", { className: "font-semibold", children: "Type : " }),
            " ",
            f.node_type
          ] }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "mb-2 flex items-center", children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "h-3 w-3 rounded-full bg-red-500 mr-2" }),
            /* @__PURE__ */ jsxRuntimeExports$1.jsx("span", { className: "font-semibold", children: "Created : " }),
            " ",
            f.ctime
          ] }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "mb-2 flex items-center", children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "h-3 w-3 rounded-full bg-gray-500 mr-2" }),
            /* @__PURE__ */ jsxRuntimeExports$1.jsx("span", { className: "font-semibold", children: "Modified : " }),
            " ",
            f.mtime
          ] }),
          f.process_type && /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "flex items-center", children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "h-3 w-3 rounded-full bg-indigo-500 mr-2" }),
            /* @__PURE__ */ jsxRuntimeExports$1.jsx("span", { className: "font-semibold", children: "Process Type : " }),
            " ",
            f.process_type
          ] })
        ] })
      ]
    }
  ) : null;
}, CustomEdge = ({
  id: t,
  sourceX: e,
  sourceY: n,
  targetX: o,
  targetY: l,
  sourcePosition: u,
  targetPosition: f,
  style: h = {},
  data: p,
  markerEnd: v
}) => {
  const [g, w] = useState(!1), [E, T] = useState(!1);
  useEffect(() => {
    e != null && n != null && o != null && l != null && w(!0);
  }, [e, n, o, l]);
  const R = useCallback(() => {
    T(!0);
  }, []), _ = useCallback(() => {
    T(!1);
  }, []);
  if (!g)
    return /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      "path",
      {
        id: t,
        style: { ...h, strokeWidth: 1, stroke: "#d1d5db" },
        d: `M${e},${n} L${o},${l}`
      }
    );
  const [b] = getSmoothStepPath({
    sourceX: e,
    sourceY: n,
    sourcePosition: u,
    targetX: o,
    targetY: l,
    targetPosition: f
  });
  let M = e + 60, A = n;
  p.index && (M = o - 60, A = l);
  const $ = p != null && p.label ? p.label.length * 6 : 0, S = 14, C = 4, D = (p == null ? void 0 : p.showLabel) || E, O = p.isPreviouslySelected ? "blue" : "#d1d5db";
  return /* @__PURE__ */ jsxRuntimeExports$1.jsxs(jsxRuntimeExports$1.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      "path",
      {
        d: b,
        fill: "none",
        stroke: "transparent",
        strokeWidth: 20,
        onMouseEnter: R,
        onMouseLeave: _
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      "path",
      {
        id: t,
        style: { ...h, strokeWidth: p.isPreviouslySelected ? 3 : 1, stroke: O, transition: "all 0.3s ease-in-out" },
        className: "react-flow__edge-path",
        d: b,
        markerEnd: v
      }
    ),
    D && (p == null ? void 0 : p.label) && /* @__PURE__ */ jsxRuntimeExports$1.jsxs("g", { transform: `translate(${M}, ${A})`, children: [
      /* @__PURE__ */ jsxRuntimeExports$1.jsx(
        "rect",
        {
          x: -$ / 2 - C,
          y: -S / 2 - C,
          width: $ + 2 * C,
          height: S + 2 * C,
          fill: "white",
          stroke: "#d1d5db",
          strokeWidth: "1",
          rx: "4",
          ry: "4"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports$1.jsx(
        "text",
        {
          x: 0,
          y: 0,
          className: "react-flow__edge-text",
          textAnchor: "middle",
          dominantBaseline: "middle",
          style: { fontSize: 12, fill: "#374151" },
          children: p.label
        }
      )
    ] })
  ] });
}, apiCache = {}, getNodeStyle = (t, e) => {
  if (!t)
    return {
      background: "#FFCC80",
      borderRadius: "4px",
      width: "150px",
      height: "60px",
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      border: e ? "2px solid blue" : "1px solid #000",
      transition: "all 0.3s ease-in-out",
      overflow: "hidden"
    };
  switch (t.toLowerCase()) {
    case "calcjobnode":
      return {
        background: "#F5B1CD",
        borderRadius: "4px",
        width: "170px",
        height: "80px",
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        border: e ? "2px solid blue" : "1px solid #000",
        transition: "all 0.3s ease-in-out",
        overflow: "hidden"
      };
    case "workchainnode":
      return {
        background: "#f5b7b1",
        borderRadius: "4px",
        width: "170px",
        height: "80px",
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        border: e ? "2px solid blue" : "1px solid #000",
        transition: "all 0.3s ease-in-out",
        overflow: "hidden"
      };
    default:
      return {
        background: "#82e0aa",
        borderRadius: "4px",
        width: "150px",
        height: "60px",
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        border: e ? "2px solid blue" : "1px solid #000",
        transition: "all 0.3s ease-in-out",
        overflow: "hidden"
      };
  }
}, CustomNode = ({ data: t }) => {
  const [e, n] = useState(""), [o, l] = useState(t.label);
  useState(!1), useState({ x: 0, y: 0 });
  const u = useRef(null), f = (h) => {
    if (!h) return "";
    const p = h.split(".");
    return p[p.length - 2];
  };
  return useEffect(() => {
    (async () => {
      var p, v, g, w, E, T, R;
      try {
        if (apiCache[t.uuid]) {
          const _ = apiCache[t.uuid];
          l(_.label), n(_.subtitle);
        } else {
          const [_, b, M] = await Promise.all([
            fetch(`https://aiida.materialscloud.org/mc3d/api/v4/nodes/${t.uuid}`),
            fetch(`https://aiida.materialscloud.org/mc3d/api/v4/nodes/${t.uuid}/contents/attributes`),
            fetch(`https://aiida.materialscloud.org/mc3d/api/v4/nodes/${t.uuid}/contents/derived_properties`)
          ]);
          let A = "";
          if (M.ok) {
            const C = (v = (p = (await M.json()).data) == null ? void 0 : p.derived_properties) == null ? void 0 : v.formula;
            C && (A = C);
          }
          if (!A && b.ok) {
            const C = (w = (g = (await b.json()).data) == null ? void 0 : g.attributes) == null ? void 0 : w.value;
            C != null && (A = String(C));
          }
          if (_.ok) {
            const S = await _.json(), C = f(S.data.nodes[0].node_type);
            l(C);
            const D = (R = (T = (E = S.data) == null ? void 0 : E.nodes) == null ? void 0 : T[0]) == null ? void 0 : R.process_type;
            if (D) {
              const O = D.split(":");
              A = O.length > 1 ? O[1] : D;
            }
          }
          const $ = { subtitle: A, label: t.label };
          apiCache[t.uuid] = $, n(A);
        }
      } catch (_) {
        console.error("Error fetching node data:", _), n("");
      }
    })();
  }, [t.uuid, t.label]), console.log("labelRe:", o), /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
    "div",
    {
      ref: u,
      style: getNodeStyle(t.label),
      children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          Handle$1,
          {
            type: "target",
            position: Position.Left,
            style: { background: "#555" },
            onConnect: (h) => console.log("handle onConnect", h)
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "flex-col", children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "text-sm text-center whitespace-nowrap overflow-hidden overflow-ellipsis", children: o }),
          e && /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "text-xs font-thin text-center whitespace-nowrap overflow-hidden overflow-ellipsis mt-1", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx("i", { children: e }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          Handle$1,
          {
            type: "source",
            position: Position.Right,
            style: { background: "#555" },
            onConnect: (h) => console.log("handle onConnect", h)
          }
        )
      ]
    }
  );
}, CustomNode$1 = memo$1(CustomNode), CENTRAL_X = 600, CENTRAL_Y = 300, INPUT_X = 200, OUTPUT_X = 1e3, LoadMoreNode = ({ data: t }) => /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
  "div",
  {
    className: "load-more-node",
    style: {
      background: "#f0f0f0",
      border: "1px solid #ccc",
      borderRadius: "8px",
      padding: "16px",
      textAlign: "center",
      cursor: "pointer"
    },
    onClick: () => t.onClick(t.type),
    children: [
      "Load More (",
      t.count,
      ")"
    ]
  }
), labelNode = ({ data: t }) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(
  "div",
  {
    className: "px-3 text-center font-mono text-emerald-700 flex justify-center text-xl",
    style: {
      background: "transparent",
      border: "1px solid #ccf",
      color: "black",
      textAlign: "center",
      cursor: "default"
    },
    children: t.label.toUpperCase()
  }
), nodeTypes = {
  custom: React__default.memo(CustomNode$1),
  loadMore: LoadMoreNode,
  label: labelNode
}, edgeTypes = {
  custom: CustomEdge
}, GraphBrowser = ({ apiUrl: t }) => {
  const e = useNavigate(), { uuid: n } = useParams(), [o, l, u] = useNodesState([]), [f, h, p] = useEdgesState([]), [v, g] = useState({}), [w, E] = useState([]), [T, R] = useState(null), [_, b] = useState({ x: null, y: null }), M = useRef(null), A = useRef(null), [$, S] = useState(!1), [C, D] = useState(!0), [O, N] = useState(!1), [j, L] = useState(null), [z, G] = useState(!1), [B, F] = useState("idle"), [H, W] = useState(null), [V, X] = useState([]), Z = `${t}`, Q = useCallback((Ye) => {
    l((De) => {
      const Ue = De.findIndex((se) => se.id === `loadMore-${Ye}`);
      if (Ue === -1) return De;
      const Qe = De[Ue], { remainingNodes: ue } = Qe.data, te = ue.slice(0, 10), Be = ue.slice(10);
      let Je = Qe.position.y;
      const ft = Ye.includes("Logical") ? 70 : 100, lt = Ye.includes("input") ? INPUT_X : OUTPUT_X, he = te.map((se) => (Je += ft, ye(se, lt, Je))), ae = te.map(
        (se, Re) => xe(
          Ye.includes("input") ? se.uuid : n,
          Ye.includes("input") ? n : se.uuid,
          se.link_label,
          !Ye.includes("input"),
          De.filter((Oe) => Oe.type === "custom").length + Re
        )
      );
      return h((se) => [...se, ...ae]), Be.length > 0 ? [
        ...De.slice(0, Ue),
        ...he,
        {
          ...Qe,
          data: {
            ...Qe.data,
            count: Be.length,
            remainingNodes: Be
          },
          position: { x: lt, y: Je + ft }
        },
        ...De.slice(Ue + 1)
      ] : [
        ...De.slice(0, Ue),
        ...he,
        ...De.slice(Ue + 1)
      ];
    });
  }, [n, l, h]), q = (Ye) => {
    if (!Ye) return "";
    const De = Ye.split(".");
    return De[De.length - 2];
  }, J = async (Ye) => {
    try {
      const Qe = (await (await fetch(`${Z}/nodes/${Ye}`)).json()).data.nodes[0], ue = Qe.node_type, te = Qe.label || q(ue);
      return console.log(`Fetched central node: ${Ye}, Label: ${te}, Type: ${ue}`), { nodeType: ue, label: te };
    } catch (De) {
      return console.error("Error fetching central node:", De), null;
    }
  };
  useEffect(() => {
    (async () => {
      if (n) {
        const De = await J(n);
        De && (L(De.label), console.log(De.label, "-->Central"));
      }
    })();
  }, [n]);
  const ie = async (Ye, De, Ue = "incoming", Qe = 0) => {
    let ue = `${Z}/nodes/${Ye}/links/${Ue}`;
    ue += `?orderby=+ctime&full_type="${De}"`;
    try {
      console.log("Fetching URL:", ue);
      const te = await fetch(ue), Be = await te.json();
      return {
        totalCount: te.headers.get("X-Total-Count"),
        links: Ue === "incoming" ? Be.data.incoming : Be.data.outgoing
      };
    } catch (te) {
      return console.error("Error:", te), { totalCount: 0, links: [] };
    }
  }, ne = async (Ye) => {
    try {
      const De = await ie(Ye, "process.%25%7C%25", "incoming"), Ue = await ie(Ye, "data.%25%7C%25", "incoming"), Qe = await ie(Ye, "process.%25%7C%25", "outgoing"), ue = await ie(Ye, "data.%25%7C%25", "outgoing");
      return {
        inputLogical: De,
        inputData: Ue,
        outputLogical: Qe,
        outputData: ue
      };
    } catch (De) {
      return console.error("Error:", De), null;
    }
  }, ge = (Ye = "id") => `${Ye}-${Math.random().toString(36).substr(2, 9)}`;
  useEffect(() => {
    (async () => {
      if (n) {
        const De = await J(n);
        De && (L(De.label), console.log(De.label, "-->Central"), l(
          (Ue) => Ue.map(
            (Qe) => Qe.id === n ? { ...Qe, data: { ...Qe.data, label: De.label } } : Qe
          )
        ));
      }
    })();
  }, [n]);
  const ye = useCallback((Ye, De, Ue, Qe = {}) => {
    const ue = Ye.uuid === n, te = Ye.uuid === H;
    let Be;
    return ue ? Be = Ye.label || j || q(Ye.node_type) : Be = q(Ye.node_type), ue && !Be && (Be = "Central Node"), console.log(`Creating node: ${Ye.uuid}, Label: ${Be}, IsCentral: ${ue}`), {
      id: Ye.uuid,
      type: "custom",
      data: {
        label: Be,
        uuid: Ye.uuid,
        isPreviouslySelected: te,
        isCentralNode: ue
      },
      position: { x: De, y: Ue },
      sourcePosition: "right",
      targetPosition: "left",
      style: Qe
    };
  }, [n, j, H]), xe = useCallback((Ye, De, Ue, Qe, ue) => ({
    id: ge(`e${Ye}-${De}`),
    source: Ye,
    target: De,
    type: "custom",
    data: {
      label: Ue,
      showLabel: C,
      index: Qe ? ue + 1 : void 0,
      isPreviouslySelected: Ye === H || De === H
    },
    markerEnd: {
      type: MarkerType.ArrowClosed,
      width: 20,
      height: 20,
      color: "#808080"
    },
    style: {
      strokeWidth: 1,
      stroke: "#808080"
    }
  }), [C, H]), we = async (Ye) => {
    if (v[Ye]) {
      console.log("Using cached data for", Ye), de(Ye);
      return;
    }
    try {
      console.log("Fetching data for", Ye);
      const De = await ne(Ye);
      if (console.log("Received data:", De), !De) {
        console.log("No data received");
        return;
      }
      const Ue = { ...v };
      Ue[Ye] = De, g(Ue), Te(De, Ye);
    } catch (De) {
      console.error("Error fetching nodes:", De);
    }
  }, de = (Ye) => {
    const De = v[Ye];
    Te(De, Ye);
  }, Te = (Ye, De) => {
    const Ue = [], Qe = [], ue = o.find((ft) => ft.id === De), te = ue ? ue.data.label : null, Be = ye({ uuid: De, node_type: "central", label: te }, CENTRAL_X, CENTRAL_Y + 100);
    Ue.push(Be);
    const Je = (ft, lt, he, ae, se, Re = !1) => {
      if (ft.length === 0) return;
      let Oe = he;
      const We = Re ? ft.slice().reverse() : ft, Ct = {
        id: `dummy-${se}`,
        type: "label",
        data: { label: se },
        position: { x: lt, y: he - ae },
        style: {
          backgroundColor: "transparent",
          border: "none",
          color: "transparent"
        }
      };
      if (Ue.push(Ct), Qe.push(xe(Ct.id, Ct.id, "", !1, 0)), We.slice(0, 10).forEach((le, ke) => {
        const Ke = ye(le, lt, Oe);
        Ue.push(Ke), Ke.originalPosition = { x: lt, y: Oe }, Qe.push(xe(
          se.includes("input") ? le.uuid : De,
          se.includes("input") ? De : le.uuid,
          le.link_label,
          !se.includes("input"),
          ke
        )), Oe += ae;
      }), ft.length > 10) {
        const le = {
          id: `loadMore-${se}`,
          type: "loadMore",
          data: {
            count: ft.length - 10,
            type: se,
            onClick: Q,
            remainingNodes: ft.slice(10)
          },
          position: { x: lt, y: Oe }
        }, ke = {
          id: `loadEdge-${se}`,
          type: "custom",
          source: `loadMore-${se}`,
          target: Be,
          data: {
            count: ft.length - 10,
            type: se,
            onClick: Q,
            remainingNodes: ft.slice(10)
          },
          position: { x: lt, y: Oe }
        };
        Ue.push(le), Qe.push(ke);
      }
    };
    Je(Ye.inputLogical.links, INPUT_X, CENTRAL_Y - 300, 100, "logical Input", !0), Je(Ye.inputData.links, INPUT_X, CENTRAL_Y, 100, "input Data"), Je(Ye.outputLogical.links, OUTPUT_X, CENTRAL_Y - 300, 100, "logical Output", !0), Je(Ye.outputData.links, OUTPUT_X, CENTRAL_Y, 100, "output Data"), l(Ue), h(Qe);
  };
  useEffect(() => {
    we(n);
  }, [n]);
  const Ce = useCallback((Ye, De) => {
    if (De.type === "loadMore") {
      Q(De.data.type);
      return;
    }
    const { uuid: Ue } = De.data;
    W(Ue), E((Qe) => [...Qe, Ue]), G(!0), F("shrinking"), X((Qe) => [
      ...Qe,
      { nodes: o, edges: f, centralNode: Ue, label: De.data.label }
    ].slice(-5)), l(
      (Qe) => Qe.map((ue) => ({
        ...ue,
        position: { x: CENTRAL_X, y: CENTRAL_Y },
        style: { ...ue.style, transition: "all 0.5s ease-in-out" },
        data: { ...ue.data, label: ue.data.label }
      }))
    ), h(
      (Qe) => Qe.map((ue) => ({
        ...ue,
        style: { ...ue.style, opacity: 0, transition: "opacity 0.5s ease-in-out" }
      }))
    ), setTimeout(() => {
      we(Ue), F("expanding"), setTimeout(() => {
        l(
          (Qe) => Qe.map((ue) => ({
            ...ue,
            position: ue.position,
            style: { ...ue.style, transition: "all 0.5s ease-in-out" }
          }))
        ), h(
          (Qe) => Qe.map((ue) => ({
            ...ue,
            style: { ...ue.style, opacity: 1, transition: "opacity 0.5s ease-in-out" }
          }))
        ), setTimeout(() => {
          G(!1), F("idle");
        }, 500);
      }, 100);
    }, 500), e(`/mc3d/details/${Ue}`);
  }, [e, t, we]);
  useCallback((Ye) => {
    const { nodes: De, edges: Ue, centralNode: Qe } = V[Ye];
    W(Qe), l(De.map((ue) => ({
      ...ue,
      data: { ...ue.data, isPreviouslySelected: ue.id === Qe }
    }))), h(Ue.map((ue) => ({
      ...ue,
      data: { ...ue.data, isPreviouslySelected: ue.source === Qe || ue.target === Qe }
    }))), e(`/mc3d/details/${Qe}`), X(V.slice(0, Ye + 1));
  }, [V, e]);
  const ee = (Ye, De) => {
    clearTimeout(M.current), console.log(De), R(De.data);
    const Ue = A.current.getBoundingClientRect();
    b({ x: Ye.clientX, y: Ye.clientY - Ue.top });
  }, Ae = () => {
    M.current = setTimeout(() => {
      R(null);
    }, 500);
  }, be = () => S(!$), Fe = () => {
    D((Ye) => !Ye), h(
      (Ye) => Ye.map((De) => ({
        ...De,
        data: {
          ...De.data,
          showLabel: !C
        }
      }))
    );
  }, et = () => N(!O);
  return /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { ref: A, className: "h-full relative", children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs(ReactFlowProvider, { children: [
    /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
      ReactFlow,
      {
        nodes: o,
        edges: f,
        onNodesChange: u,
        onEdgesChange: p,
        onNodeClick: Ce,
        onNodeMouseEnter: ee,
        onNodeMouseLeave: Ae,
        nodeTypes,
        edgeTypes,
        nodesDraggable: !1,
        nodesConnectable: !1,
        fitView: !0,
        children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(MiniMap$1, {}),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(Controls$1, { style: { backgroundColor: "#fff" }, children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(
            "button",
            {
              className: "m-auto  bg-slate-300",
              title: "Show/Hide Buttons",
              onClick: be,
              style: { backgroundColor: "transparent", color: "black" },
              children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(FaArrowUp, { className: "p-auto text-orange-700 items-center flex justify-center m-1 mt-2 mb-0" })
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(Background$1$1, {})
        ]
      }
    ),
    T && /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      Tooltip$1,
      {
        apiUrl: t,
        details: T,
        position: _,
        containerRef: A
      }
    ),
    $ && /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "fixed bottom-16 right-1/4 transform translate-x-1/2 flex justify-between items-center w-full max-w-xs bg-white p-4 rounded-lg shadow-lg", children: [
      /* @__PURE__ */ jsxRuntimeExports$1.jsx(
        "button",
        {
          onClick: Fe,
          className: "bg-green-200 hover:bg-green-300 text-green-700 font-bold py-2 px-4 rounded-full ml-2",
          children: C ? /* @__PURE__ */ jsxRuntimeExports$1.jsx(FaEyeSlash, {}) : /* @__PURE__ */ jsxRuntimeExports$1.jsx(FaEye, {})
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports$1.jsx(
        "button",
        {
          onClick: et,
          className: "bg-red-200 hover:bg-red-300 text-red-700 font-bold py-2 px-4 rounded-full ml-2",
          children: O ? /* @__PURE__ */ jsxRuntimeExports$1.jsx(FaEyeSlash, {}) : /* @__PURE__ */ jsxRuntimeExports$1.jsx(FaShapes, {})
        }
      )
    ] }),
    O && /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "absolute w-full bottom-24 bg-blue-200 p-2 rounded-lg shadow-lg", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "flex items-center space-x-2", children: w.map((Ye, De) => /* @__PURE__ */ jsxRuntimeExports$1.jsxs("span", { className: "text-blue-700 text-xs", children: [
      Ye,
      De < w.length - 1 && /* @__PURE__ */ jsxRuntimeExports$1.jsx("span", { className: "mx-1", children: "->" })
    ] }, Ye)) }) })
  ] }) });
}, BrowserSelection = ({ uuid: t, apiUrl: e }) => {
  const [n, o] = useState(!0), [l, u] = useState("local"), f = () => {
    o(!n);
  };
  return /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "flex z-50 h-full ", children: [
    /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "flex-1 overflow-y-auto", children: l === "local" ? /* @__PURE__ */ jsxRuntimeExports$1.jsx(GraphBrowser, { uuid: t, apiUrl: e }) : /* @__PURE__ */ jsxRuntimeExports$1.jsx(GraphBrowser, { uuid: t, apiUrl: e }) }),
    /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: `relative flex flex-col items-center p-2 transition-all duration-300 ${n ? "w-0" : "w-20 bg-gray-200 text-gray-800"}`, children: [
      !n && /* @__PURE__ */ jsxRuntimeExports$1.jsxs(jsxRuntimeExports$1.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          "button",
          {
            onClick: () => u("local"),
            className: `flex items-center justify-center w-full px-4 py-2 mb-4  transition-colors duration-300 ${l === "local" ? "bg-blue-100 border-[1px] border-gray-400" : "bg-blue-50 text-gray-800 hover:bg-blue-200"}`,
            children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(FaMapMarkerAlt, {})
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          "button",
          {
            onClick: () => u("global"),
            className: `flex items-center justify-center w-full px-4 py-2 mb-4 transition-colors duration-300 ${l === "global" ? "bg-blue-100" : "bg-blue-50 text-gray-800 hover:bg-blue-200"}`,
            children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(FaGlobe, {})
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports$1.jsx(
        "button",
        {
          className: `absolute top-1/2 transform -translate-y-1/2 transition-transform duration-300 ${n ? "translate-x-full" : "translate-x-0"}`,
          onClick: f,
          children: n ? /* @__PURE__ */ jsxRuntimeExports$1.jsx(FaBars, { className: "text-gray-800 " }) : /* @__PURE__ */ jsxRuntimeExports$1.jsx(FaChevronRight, { className: "text-gray-800" })
        }
      )
    ] })
  ] });
}, ExtraContent = ({ uuid: t, apiUrl: e }) => {
  const [n, o] = useState(null), [l, u] = useState(null);
  return useEffect(() => {
    fetch(`${e}/nodes/${t}/contents/extras`).then((f) => {
      if (!f.ok)
        throw new Error("Network response was not ok");
      return f.json();
    }).then((f) => o(f)).catch((f) => u(f.message));
  }, [e, t]), l ? /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { children: [
    "Error: ",
    l
  ] }) : n ? /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "p-2 border-2 border-gray-50 rounded shadow-md", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(
    JsonViewer,
    {
      value: n.data.extras,
      theme: "githubLight",
      displayDataTypes: !1,
      displayObjectSize: !1,
      enableClipboard: !1,
      rootName: !1
    }
  ) }) : /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", {});
}, Search = ({ apiUrl: t, uuid: e }) => {
  const [n, o] = useState(""), l = useLocation(), u = useNavigate(), f = () => {
    if (n.trim() !== "") {
      const h = l.pathname, p = h.indexOf("/details/");
      let v;
      p !== -1 ? v = `${h.substring(0, p + 9)}${n}` : v = `${h}/${n}`, u(v);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "bg-gray-100", children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "flex mt-4 items-center border-2 border-gray-300 hover:border-gray-600 rounded-md shadow-md bg-white", children: [
    /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      "input",
      {
        type: "search",
        placeholder: e,
        className: "flex-grow p-1 border-0 outline-none rounded-l-md",
        value: n,
        onChange: (h) => o(h.target.value),
        onKeyDown: (h) => {
          h.key === "Enter" && n.trim() !== "" && f();
        }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: `p-2 ${n.trim() === "" ? "bg-gray-400" : "bg-blue-500"} text-white rounded-r-md`, children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      "button",
      {
        onClick: f,
        disabled: n.trim() === "",
        className: "disabled:cursor-not-allowed",
        children: "Explore"
      }
    ) })
  ] }) });
};
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const os = "162", Dn = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, Un = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, No = 0, Ms = 1, Fo = 2, Qa = 1, Oo = 2, qt = 3, hn = 0, Et = 1, jt = 2, ln$1 = 0, Qn = 1, Ss = 2, Es = 3, ys = 4, Bo = 5, Tn = 100, zo = 101, Go = 102, Ts = 103, bs = 104, Ho = 200, Vo = 201, ko = 202, Wo = 203, Jr = 204, Qr = 205, Xo = 206, Yo = 207, qo = 208, jo = 209, Ko = 210, Zo = 211, $o = 212, Jo = 213, Qo = 214, el = 0, tl = 1, nl = 2, Qi = 3, il = 4, rl = 5, sl = 6, al = 7, eo = 0, ol = 1, ll = 2, cn = 0, cl = 1, ul = 2, hl = 3, fl = 4, dl = 5, pl = 6, ml = 7, to = 300, ii = 301, ri = 302, es = 303, ts = 304, lr = 306, ns = 1e3, Nt = 1001, is = 1002, xt = 1003, As = 1004, ui = 1005, St = 1006, gr = 1007, An = 1008, un = 1009, _l = 1010, gl = 1011, ls = 1012, no = 1013, on = 1014, Kt = 1015, _i = 1016, io = 1017, ro = 1018, wn = 1020, vl = 1021, Ft = 1023, xl = 1024, Ml = 1025, Rn = 1026, si = 1027, Sl = 1028, so = 1029, El = 1030, ao = 1031, oo = 1033, vr = 33776, xr = 33777, Mr = 33778, Sr = 33779, ws = 35840, Rs = 35841, Cs = 35842, Ps = 35843, lo = 36196, Ls = 37492, Ds = 37496, Us = 37808, Is = 37809, Ns = 37810, Fs = 37811, Os = 37812, Bs = 37813, zs = 37814, Gs = 37815, Hs = 37816, Vs = 37817, ks = 37818, Ws = 37819, Xs = 37820, Ys = 37821, Er = 36492, qs = 36494, js = 36495, yl = 36283, Ks = 36284, Zs = 36285, $s = 36286, Tl = 3200, bl = 3201, Al = 0, wl = 1, an = "", Bt = "srgb", dn = "srgb-linear", cs = "display-p3", cr = "display-p3-linear", er = "linear", $e = "srgb", tr = "rec709", nr = "p3", In = 7680, Js = 519, Rl = 512, Cl = 513, Pl = 514, co = 515, Ll = 516, Dl = 517, Ul = 518, Il = 519, Qs = 35044, ea = "300 es", rs = 1035, Zt = 2e3, ir = 2001;
class Ln {
  addEventListener(e, n) {
    this._listeners === void 0 && (this._listeners = {});
    const o = this._listeners;
    o[e] === void 0 && (o[e] = []), o[e].indexOf(n) === -1 && o[e].push(n);
  }
  hasEventListener(e, n) {
    if (this._listeners === void 0)
      return !1;
    const o = this._listeners;
    return o[e] !== void 0 && o[e].indexOf(n) !== -1;
  }
  removeEventListener(e, n) {
    if (this._listeners === void 0)
      return;
    const o = this._listeners[e];
    if (o !== void 0) {
      const l = o.indexOf(n);
      l !== -1 && o.splice(l, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0)
      return;
    const n = this._listeners[e.type];
    if (n !== void 0) {
      e.target = this;
      const o = n.slice(0);
      for (let l = 0, u = o.length; l < u; l++)
        o[l].call(this, e);
      e.target = null;
    }
  }
}
const pt = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let ta = 1234567;
const ei = Math.PI / 180, gi = 180 / Math.PI;
function oi() {
  const t = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0, o = Math.random() * 4294967295 | 0;
  return (pt[t & 255] + pt[t >> 8 & 255] + pt[t >> 16 & 255] + pt[t >> 24 & 255] + "-" + pt[e & 255] + pt[e >> 8 & 255] + "-" + pt[e >> 16 & 15 | 64] + pt[e >> 24 & 255] + "-" + pt[n & 63 | 128] + pt[n >> 8 & 255] + "-" + pt[n >> 16 & 255] + pt[n >> 24 & 255] + pt[o & 255] + pt[o >> 8 & 255] + pt[o >> 16 & 255] + pt[o >> 24 & 255]).toLowerCase();
}
function _t(t, e, n) {
  return Math.max(e, Math.min(n, t));
}
function us(t, e) {
  return (t % e + e) % e;
}
function Nl(t, e, n, o, l) {
  return o + (t - e) * (l - o) / (n - e);
}
function Fl(t, e, n) {
  return t !== e ? (n - t) / (e - t) : 0;
}
function mi(t, e, n) {
  return (1 - n) * t + n * e;
}
function Ol(t, e, n, o) {
  return mi(t, e, 1 - Math.exp(-n * o));
}
function Bl(t, e = 1) {
  return e - Math.abs(us(t, e * 2) - e);
}
function zl(t, e, n) {
  return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e), t * t * (3 - 2 * t));
}
function Gl(t, e, n) {
  return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e), t * t * t * (t * (t * 6 - 15) + 10));
}
function Hl(t, e) {
  return t + Math.floor(Math.random() * (e - t + 1));
}
function Vl(t, e) {
  return t + Math.random() * (e - t);
}
function kl(t) {
  return t * (0.5 - Math.random());
}
function Wl(t) {
  t !== void 0 && (ta = t);
  let e = ta += 1831565813;
  return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
}
function Xl(t) {
  return t * ei;
}
function Yl(t) {
  return t * gi;
}
function ss(t) {
  return (t & t - 1) === 0 && t !== 0;
}
function ql(t) {
  return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
}
function rr(t) {
  return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
}
function jl(t, e, n, o, l) {
  const u = Math.cos, f = Math.sin, h = u(n / 2), p = f(n / 2), v = u((e + o) / 2), g = f((e + o) / 2), w = u((e - o) / 2), E = f((e - o) / 2), T = u((o - e) / 2), R = f((o - e) / 2);
  switch (l) {
    case "XYX":
      t.set(h * g, p * w, p * E, h * v);
      break;
    case "YZY":
      t.set(p * E, h * g, p * w, h * v);
      break;
    case "ZXZ":
      t.set(p * w, p * E, h * g, h * v);
      break;
    case "XZX":
      t.set(h * g, p * R, p * T, h * v);
      break;
    case "YXY":
      t.set(p * T, h * g, p * R, h * v);
      break;
    case "ZYZ":
      t.set(p * R, p * T, h * g, h * v);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + l);
  }
}
function Zn(t, e) {
  switch (e.constructor) {
    case Float32Array:
      return t;
    case Uint32Array:
      return t / 4294967295;
    case Uint16Array:
      return t / 65535;
    case Uint8Array:
      return t / 255;
    case Int32Array:
      return Math.max(t / 2147483647, -1);
    case Int16Array:
      return Math.max(t / 32767, -1);
    case Int8Array:
      return Math.max(t / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function gt(t, e) {
  switch (e.constructor) {
    case Float32Array:
      return t;
    case Uint32Array:
      return Math.round(t * 4294967295);
    case Uint16Array:
      return Math.round(t * 65535);
    case Uint8Array:
      return Math.round(t * 255);
    case Int32Array:
      return Math.round(t * 2147483647);
    case Int16Array:
      return Math.round(t * 32767);
    case Int8Array:
      return Math.round(t * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const Kl = {
  DEG2RAD: ei,
  RAD2DEG: gi,
  generateUUID: oi,
  clamp: _t,
  euclideanModulo: us,
  mapLinear: Nl,
  inverseLerp: Fl,
  lerp: mi,
  damp: Ol,
  pingpong: Bl,
  smoothstep: zl,
  smootherstep: Gl,
  randInt: Hl,
  randFloat: Vl,
  randFloatSpread: kl,
  seededRandom: Wl,
  degToRad: Xl,
  radToDeg: Yl,
  isPowerOfTwo: ss,
  ceilPowerOfTwo: ql,
  floorPowerOfTwo: rr,
  setQuaternionFromProperEuler: jl,
  normalize: gt,
  denormalize: Zn
};
class Ie {
  constructor(e = 0, n = 0) {
    Ie.prototype.isVector2 = !0, this.x = e, this.y = n;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, n) {
    return this.x = e, this.y = n, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, n) {
    return this.x = e.x + n.x, this.y = e.y + n.y, this;
  }
  addScaledVector(e, n) {
    return this.x += e.x * n, this.y += e.y * n, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, n) {
    return this.x = e.x - n.x, this.y = e.y - n.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const n = this.x, o = this.y, l = e.elements;
    return this.x = l[0] * n + l[3] * o + l[6], this.y = l[1] * n + l[4] * o + l[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, n) {
    return this.x = Math.max(e.x, Math.min(n.x, this.x)), this.y = Math.max(e.y, Math.min(n.y, this.y)), this;
  }
  clampScalar(e, n) {
    return this.x = Math.max(e, Math.min(n, this.x)), this.y = Math.max(e, Math.min(n, this.y)), this;
  }
  clampLength(e, n) {
    const o = this.length();
    return this.divideScalar(o || 1).multiplyScalar(Math.max(e, Math.min(n, o)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const n = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (n === 0)
      return Math.PI / 2;
    const o = this.dot(e) / n;
    return Math.acos(_t(o, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const n = this.x - e.x, o = this.y - e.y;
    return n * n + o * o;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, n) {
    return this.x += (e.x - this.x) * n, this.y += (e.y - this.y) * n, this;
  }
  lerpVectors(e, n, o) {
    return this.x = e.x + (n.x - e.x) * o, this.y = e.y + (n.y - e.y) * o, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, n = 0) {
    return this.x = e[n], this.y = e[n + 1], this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this.x, e[n + 1] = this.y, e;
  }
  fromBufferAttribute(e, n) {
    return this.x = e.getX(n), this.y = e.getY(n), this;
  }
  rotateAround(e, n) {
    const o = Math.cos(n), l = Math.sin(n), u = this.x - e.x, f = this.y - e.y;
    return this.x = u * o - f * l + e.x, this.y = u * l + f * o + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Ge {
  constructor(e, n, o, l, u, f, h, p, v) {
    Ge.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, n, o, l, u, f, h, p, v);
  }
  set(e, n, o, l, u, f, h, p, v) {
    const g = this.elements;
    return g[0] = e, g[1] = l, g[2] = h, g[3] = n, g[4] = u, g[5] = p, g[6] = o, g[7] = f, g[8] = v, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(e) {
    const n = this.elements, o = e.elements;
    return n[0] = o[0], n[1] = o[1], n[2] = o[2], n[3] = o[3], n[4] = o[4], n[5] = o[5], n[6] = o[6], n[7] = o[7], n[8] = o[8], this;
  }
  extractBasis(e, n, o) {
    return e.setFromMatrix3Column(this, 0), n.setFromMatrix3Column(this, 1), o.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const n = e.elements;
    return this.set(
      n[0],
      n[4],
      n[8],
      n[1],
      n[5],
      n[9],
      n[2],
      n[6],
      n[10]
    ), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, n) {
    const o = e.elements, l = n.elements, u = this.elements, f = o[0], h = o[3], p = o[6], v = o[1], g = o[4], w = o[7], E = o[2], T = o[5], R = o[8], _ = l[0], b = l[3], M = l[6], A = l[1], $ = l[4], S = l[7], C = l[2], D = l[5], O = l[8];
    return u[0] = f * _ + h * A + p * C, u[3] = f * b + h * $ + p * D, u[6] = f * M + h * S + p * O, u[1] = v * _ + g * A + w * C, u[4] = v * b + g * $ + w * D, u[7] = v * M + g * S + w * O, u[2] = E * _ + T * A + R * C, u[5] = E * b + T * $ + R * D, u[8] = E * M + T * S + R * O, this;
  }
  multiplyScalar(e) {
    const n = this.elements;
    return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= e, n[4] *= e, n[7] *= e, n[2] *= e, n[5] *= e, n[8] *= e, this;
  }
  determinant() {
    const e = this.elements, n = e[0], o = e[1], l = e[2], u = e[3], f = e[4], h = e[5], p = e[6], v = e[7], g = e[8];
    return n * f * g - n * h * v - o * u * g + o * h * p + l * u * v - l * f * p;
  }
  invert() {
    const e = this.elements, n = e[0], o = e[1], l = e[2], u = e[3], f = e[4], h = e[5], p = e[6], v = e[7], g = e[8], w = g * f - h * v, E = h * p - g * u, T = v * u - f * p, R = n * w + o * E + l * T;
    if (R === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const _ = 1 / R;
    return e[0] = w * _, e[1] = (l * v - g * o) * _, e[2] = (h * o - l * f) * _, e[3] = E * _, e[4] = (g * n - l * p) * _, e[5] = (l * u - h * n) * _, e[6] = T * _, e[7] = (o * p - v * n) * _, e[8] = (f * n - o * u) * _, this;
  }
  transpose() {
    let e;
    const n = this.elements;
    return e = n[1], n[1] = n[3], n[3] = e, e = n[2], n[2] = n[6], n[6] = e, e = n[5], n[5] = n[7], n[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const n = this.elements;
    return e[0] = n[0], e[1] = n[3], e[2] = n[6], e[3] = n[1], e[4] = n[4], e[5] = n[7], e[6] = n[2], e[7] = n[5], e[8] = n[8], this;
  }
  setUvTransform(e, n, o, l, u, f, h) {
    const p = Math.cos(u), v = Math.sin(u);
    return this.set(
      o * p,
      o * v,
      -o * (p * f + v * h) + f + e,
      -l * v,
      l * p,
      -l * (-v * f + p * h) + h + n,
      0,
      0,
      1
    ), this;
  }
  //
  scale(e, n) {
    return this.premultiply(yr.makeScale(e, n)), this;
  }
  rotate(e) {
    return this.premultiply(yr.makeRotation(-e)), this;
  }
  translate(e, n) {
    return this.premultiply(yr.makeTranslation(e, n)), this;
  }
  // for 2D Transforms
  makeTranslation(e, n) {
    return e.isVector2 ? this.set(
      1,
      0,
      e.x,
      0,
      1,
      e.y,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      e,
      0,
      1,
      n,
      0,
      0,
      1
    ), this;
  }
  makeRotation(e) {
    const n = Math.cos(e), o = Math.sin(e);
    return this.set(
      n,
      -o,
      0,
      o,
      n,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, n) {
    return this.set(
      e,
      0,
      0,
      0,
      n,
      0,
      0,
      0,
      1
    ), this;
  }
  //
  equals(e) {
    const n = this.elements, o = e.elements;
    for (let l = 0; l < 9; l++)
      if (n[l] !== o[l])
        return !1;
    return !0;
  }
  fromArray(e, n = 0) {
    for (let o = 0; o < 9; o++)
      this.elements[o] = e[o + n];
    return this;
  }
  toArray(e = [], n = 0) {
    const o = this.elements;
    return e[n] = o[0], e[n + 1] = o[1], e[n + 2] = o[2], e[n + 3] = o[3], e[n + 4] = o[4], e[n + 5] = o[5], e[n + 6] = o[6], e[n + 7] = o[7], e[n + 8] = o[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const yr = /* @__PURE__ */ new Ge();
function uo(t) {
  for (let e = t.length - 1; e >= 0; --e)
    if (t[e] >= 65535)
      return !0;
  return !1;
}
function sr(t) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", t);
}
function Zl() {
  const t = sr("canvas");
  return t.style.display = "block", t;
}
const na = {};
function $l(t) {
  t in na || (na[t] = !0, console.warn(t));
}
const ia = /* @__PURE__ */ new Ge().set(
  0.8224621,
  0.177538,
  0,
  0.0331941,
  0.9668058,
  0,
  0.0170827,
  0.0723974,
  0.9105199
), ra = /* @__PURE__ */ new Ge().set(
  1.2249401,
  -0.2249404,
  0,
  -0.0420569,
  1.0420571,
  0,
  -0.0196376,
  -0.0786361,
  1.0982735
), Ti = {
  [dn]: {
    transfer: er,
    primaries: tr,
    toReference: (t) => t,
    fromReference: (t) => t
  },
  [Bt]: {
    transfer: $e,
    primaries: tr,
    toReference: (t) => t.convertSRGBToLinear(),
    fromReference: (t) => t.convertLinearToSRGB()
  },
  [cr]: {
    transfer: er,
    primaries: nr,
    toReference: (t) => t.applyMatrix3(ra),
    fromReference: (t) => t.applyMatrix3(ia)
  },
  [cs]: {
    transfer: $e,
    primaries: nr,
    toReference: (t) => t.convertSRGBToLinear().applyMatrix3(ra),
    fromReference: (t) => t.applyMatrix3(ia).convertLinearToSRGB()
  }
}, Jl = /* @__PURE__ */ new Set([dn, cr]), je = {
  enabled: !0,
  _workingColorSpace: dn,
  get workingColorSpace() {
    return this._workingColorSpace;
  },
  set workingColorSpace(t) {
    if (!Jl.has(t))
      throw new Error(`Unsupported working color space, "${t}".`);
    this._workingColorSpace = t;
  },
  convert: function(t, e, n) {
    if (this.enabled === !1 || e === n || !e || !n)
      return t;
    const o = Ti[e].toReference, l = Ti[n].fromReference;
    return l(o(t));
  },
  fromWorkingColorSpace: function(t, e) {
    return this.convert(t, this._workingColorSpace, e);
  },
  toWorkingColorSpace: function(t, e) {
    return this.convert(t, e, this._workingColorSpace);
  },
  getPrimaries: function(t) {
    return Ti[t].primaries;
  },
  getTransfer: function(t) {
    return t === an ? er : Ti[t].transfer;
  }
};
function ti(t) {
  return t < 0.04045 ? t * 0.0773993808 : Math.pow(t * 0.9478672986 + 0.0521327014, 2.4);
}
function Tr(t) {
  return t < 31308e-7 ? t * 12.92 : 1.055 * Math.pow(t, 0.41666) - 0.055;
}
let Nn;
class ho {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
      return e.src;
    let n;
    if (e instanceof HTMLCanvasElement)
      n = e;
    else {
      Nn === void 0 && (Nn = sr("canvas")), Nn.width = e.width, Nn.height = e.height;
      const o = Nn.getContext("2d");
      e instanceof ImageData ? o.putImageData(e, 0, 0) : o.drawImage(e, 0, 0, e.width, e.height), n = Nn;
    }
    return n.width > 2048 || n.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), n.toDataURL("image/jpeg", 0.6)) : n.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
      const n = sr("canvas");
      n.width = e.width, n.height = e.height;
      const o = n.getContext("2d");
      o.drawImage(e, 0, 0, e.width, e.height);
      const l = o.getImageData(0, 0, e.width, e.height), u = l.data;
      for (let f = 0; f < u.length; f++)
        u[f] = ti(u[f] / 255) * 255;
      return o.putImageData(l, 0, 0), n;
    } else if (e.data) {
      const n = e.data.slice(0);
      for (let o = 0; o < n.length; o++)
        n instanceof Uint8Array || n instanceof Uint8ClampedArray ? n[o] = Math.floor(ti(n[o] / 255) * 255) : n[o] = ti(n[o]);
      return {
        data: n,
        width: e.width,
        height: e.height
      };
    } else
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
  }
}
let Ql = 0;
class fo {
  constructor(e = null) {
    this.isSource = !0, Object.defineProperty(this, "id", { value: Ql++ }), this.uuid = oi(), this.data = e, this.dataReady = !0, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string";
    if (!n && e.images[this.uuid] !== void 0)
      return e.images[this.uuid];
    const o = {
      uuid: this.uuid,
      url: ""
    }, l = this.data;
    if (l !== null) {
      let u;
      if (Array.isArray(l)) {
        u = [];
        for (let f = 0, h = l.length; f < h; f++)
          l[f].isDataTexture ? u.push(br(l[f].image)) : u.push(br(l[f]));
      } else
        u = br(l);
      o.url = u;
    }
    return n || (e.images[this.uuid] = o), o;
  }
}
function br(t) {
  return typeof HTMLImageElement < "u" && t instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && t instanceof ImageBitmap ? ho.getDataURL(t) : t.data ? {
    data: Array.from(t.data),
    width: t.width,
    height: t.height,
    type: t.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let ec = 0;
class yt extends Ln {
  constructor(e = yt.DEFAULT_IMAGE, n = yt.DEFAULT_MAPPING, o = Nt, l = Nt, u = St, f = An, h = Ft, p = un, v = yt.DEFAULT_ANISOTROPY, g = an) {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: ec++ }), this.uuid = oi(), this.name = "", this.source = new fo(e), this.mipmaps = [], this.mapping = n, this.channel = 0, this.wrapS = o, this.wrapT = l, this.magFilter = u, this.minFilter = f, this.anisotropy = v, this.format = h, this.internalFormat = null, this.type = p, this.offset = new Ie(0, 0), this.repeat = new Ie(1, 1), this.center = new Ie(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Ge(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = g, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1;
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string";
    if (!n && e.textures[this.uuid] !== void 0)
      return e.textures[this.uuid];
    const o = {
      metadata: {
        version: 4.6,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    return Object.keys(this.userData).length > 0 && (o.userData = this.userData), n || (e.textures[this.uuid] = o), o;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== to)
      return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
      switch (this.wrapS) {
        case ns:
          e.x = e.x - Math.floor(e.x);
          break;
        case Nt:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case is:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case ns:
          e.y = e.y - Math.floor(e.y);
          break;
        case Nt:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case is:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, this.source.needsUpdate = !0);
  }
}
yt.DEFAULT_IMAGE = null;
yt.DEFAULT_MAPPING = to;
yt.DEFAULT_ANISOTROPY = 1;
class ht {
  constructor(e = 0, n = 0, o = 0, l = 1) {
    ht.prototype.isVector4 = !0, this.x = e, this.y = n, this.z = o, this.w = l;
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, n, o, l) {
    return this.x = e, this.y = n, this.z = o, this.w = l, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setW(e) {
    return this.w = e, this;
  }
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      case 2:
        this.z = n;
        break;
      case 3:
        this.w = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  addVectors(e, n) {
    return this.x = e.x + n.x, this.y = e.y + n.y, this.z = e.z + n.z, this.w = e.w + n.w, this;
  }
  addScaledVector(e, n) {
    return this.x += e.x * n, this.y += e.y * n, this.z += e.z * n, this.w += e.w * n, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  subVectors(e, n) {
    return this.x = e.x - n.x, this.y = e.y - n.y, this.z = e.z - n.z, this.w = e.w - n.w, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  applyMatrix4(e) {
    const n = this.x, o = this.y, l = this.z, u = this.w, f = e.elements;
    return this.x = f[0] * n + f[4] * o + f[8] * l + f[12] * u, this.y = f[1] * n + f[5] * o + f[9] * l + f[13] * u, this.z = f[2] * n + f[6] * o + f[10] * l + f[14] * u, this.w = f[3] * n + f[7] * o + f[11] * l + f[15] * u, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const n = Math.sqrt(1 - e.w * e.w);
    return n < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / n, this.y = e.y / n, this.z = e.z / n), this;
  }
  setAxisAngleFromRotationMatrix(e) {
    let n, o, l, u;
    const f = e.elements, h = f[0], p = f[4], v = f[8], g = f[1], w = f[5], E = f[9], T = f[2], R = f[6], _ = f[10];
    if (Math.abs(p - g) < 0.01 && Math.abs(v - T) < 0.01 && Math.abs(E - R) < 0.01) {
      if (Math.abs(p + g) < 0.1 && Math.abs(v + T) < 0.1 && Math.abs(E + R) < 0.1 && Math.abs(h + w + _ - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      n = Math.PI;
      const M = (h + 1) / 2, A = (w + 1) / 2, $ = (_ + 1) / 2, S = (p + g) / 4, C = (v + T) / 4, D = (E + R) / 4;
      return M > A && M > $ ? M < 0.01 ? (o = 0, l = 0.707106781, u = 0.707106781) : (o = Math.sqrt(M), l = S / o, u = C / o) : A > $ ? A < 0.01 ? (o = 0.707106781, l = 0, u = 0.707106781) : (l = Math.sqrt(A), o = S / l, u = D / l) : $ < 0.01 ? (o = 0.707106781, l = 0.707106781, u = 0) : (u = Math.sqrt($), o = C / u, l = D / u), this.set(o, l, u, n), this;
    }
    let b = Math.sqrt((R - E) * (R - E) + (v - T) * (v - T) + (g - p) * (g - p));
    return Math.abs(b) < 1e-3 && (b = 1), this.x = (R - E) / b, this.y = (v - T) / b, this.z = (g - p) / b, this.w = Math.acos((h + w + _ - 1) / 2), this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  clamp(e, n) {
    return this.x = Math.max(e.x, Math.min(n.x, this.x)), this.y = Math.max(e.y, Math.min(n.y, this.y)), this.z = Math.max(e.z, Math.min(n.z, this.z)), this.w = Math.max(e.w, Math.min(n.w, this.w)), this;
  }
  clampScalar(e, n) {
    return this.x = Math.max(e, Math.min(n, this.x)), this.y = Math.max(e, Math.min(n, this.y)), this.z = Math.max(e, Math.min(n, this.z)), this.w = Math.max(e, Math.min(n, this.w)), this;
  }
  clampLength(e, n) {
    const o = this.length();
    return this.divideScalar(o || 1).multiplyScalar(Math.max(e, Math.min(n, o)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, n) {
    return this.x += (e.x - this.x) * n, this.y += (e.y - this.y) * n, this.z += (e.z - this.z) * n, this.w += (e.w - this.w) * n, this;
  }
  lerpVectors(e, n, o) {
    return this.x = e.x + (n.x - e.x) * o, this.y = e.y + (n.y - e.y) * o, this.z = e.z + (n.z - e.z) * o, this.w = e.w + (n.w - e.w) * o, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, n = 0) {
    return this.x = e[n], this.y = e[n + 1], this.z = e[n + 2], this.w = e[n + 3], this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this.x, e[n + 1] = this.y, e[n + 2] = this.z, e[n + 3] = this.w, e;
  }
  fromBufferAttribute(e, n) {
    return this.x = e.getX(n), this.y = e.getY(n), this.z = e.getZ(n), this.w = e.getW(n), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class tc extends Ln {
  constructor(e = 1, n = 1, o = {}) {
    super(), this.isRenderTarget = !0, this.width = e, this.height = n, this.depth = 1, this.scissor = new ht(0, 0, e, n), this.scissorTest = !1, this.viewport = new ht(0, 0, e, n);
    const l = { width: e, height: n, depth: 1 };
    o = Object.assign({
      generateMipmaps: !1,
      internalFormat: null,
      minFilter: St,
      depthBuffer: !0,
      stencilBuffer: !1,
      depthTexture: null,
      samples: 0,
      count: 1
    }, o);
    const u = new yt(l, o.mapping, o.wrapS, o.wrapT, o.magFilter, o.minFilter, o.format, o.type, o.anisotropy, o.colorSpace);
    u.flipY = !1, u.generateMipmaps = o.generateMipmaps, u.internalFormat = o.internalFormat, this.textures = [];
    const f = o.count;
    for (let h = 0; h < f; h++)
      this.textures[h] = u.clone(), this.textures[h].isRenderTargetTexture = !0;
    this.depthBuffer = o.depthBuffer, this.stencilBuffer = o.stencilBuffer, this.depthTexture = o.depthTexture, this.samples = o.samples;
  }
  get texture() {
    return this.textures[0];
  }
  set texture(e) {
    this.textures[0] = e;
  }
  setSize(e, n, o = 1) {
    if (this.width !== e || this.height !== n || this.depth !== o) {
      this.width = e, this.height = n, this.depth = o;
      for (let l = 0, u = this.textures.length; l < u; l++)
        this.textures[l].image.width = e, this.textures[l].image.height = n, this.textures[l].image.depth = o;
      this.dispose();
    }
    this.viewport.set(0, 0, e, n), this.scissor.set(0, 0, e, n);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0;
    for (let o = 0, l = e.textures.length; o < l; o++)
      this.textures[o] = e.textures[o].clone(), this.textures[o].isRenderTargetTexture = !0;
    const n = Object.assign({}, e.texture.image);
    return this.texture.source = new fo(n), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class Cn extends tc {
  constructor(e = 1, n = 1, o = {}) {
    super(e, n, o), this.isWebGLRenderTarget = !0;
  }
}
class po extends yt {
  constructor(e = null, n = 1, o = 1, l = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: n, height: o, depth: l }, this.magFilter = xt, this.minFilter = xt, this.wrapR = Nt, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class nc extends yt {
  constructor(e = null, n = 1, o = 1, l = 1) {
    super(null), this.isData3DTexture = !0, this.image = { data: e, width: n, height: o, depth: l }, this.magFilter = xt, this.minFilter = xt, this.wrapR = Nt, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class Pn {
  constructor(e = 0, n = 0, o = 0, l = 1) {
    this.isQuaternion = !0, this._x = e, this._y = n, this._z = o, this._w = l;
  }
  static slerpFlat(e, n, o, l, u, f, h) {
    let p = o[l + 0], v = o[l + 1], g = o[l + 2], w = o[l + 3];
    const E = u[f + 0], T = u[f + 1], R = u[f + 2], _ = u[f + 3];
    if (h === 0) {
      e[n + 0] = p, e[n + 1] = v, e[n + 2] = g, e[n + 3] = w;
      return;
    }
    if (h === 1) {
      e[n + 0] = E, e[n + 1] = T, e[n + 2] = R, e[n + 3] = _;
      return;
    }
    if (w !== _ || p !== E || v !== T || g !== R) {
      let b = 1 - h;
      const M = p * E + v * T + g * R + w * _, A = M >= 0 ? 1 : -1, $ = 1 - M * M;
      if ($ > Number.EPSILON) {
        const C = Math.sqrt($), D = Math.atan2(C, M * A);
        b = Math.sin(b * D) / C, h = Math.sin(h * D) / C;
      }
      const S = h * A;
      if (p = p * b + E * S, v = v * b + T * S, g = g * b + R * S, w = w * b + _ * S, b === 1 - h) {
        const C = 1 / Math.sqrt(p * p + v * v + g * g + w * w);
        p *= C, v *= C, g *= C, w *= C;
      }
    }
    e[n] = p, e[n + 1] = v, e[n + 2] = g, e[n + 3] = w;
  }
  static multiplyQuaternionsFlat(e, n, o, l, u, f) {
    const h = o[l], p = o[l + 1], v = o[l + 2], g = o[l + 3], w = u[f], E = u[f + 1], T = u[f + 2], R = u[f + 3];
    return e[n] = h * R + g * w + p * T - v * E, e[n + 1] = p * R + g * E + v * w - h * T, e[n + 2] = v * R + g * T + h * E - p * w, e[n + 3] = g * R - h * w - p * E - v * T, e;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  set(e, n, o, l) {
    return this._x = e, this._y = n, this._z = o, this._w = l, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  setFromEuler(e, n = !0) {
    const o = e._x, l = e._y, u = e._z, f = e._order, h = Math.cos, p = Math.sin, v = h(o / 2), g = h(l / 2), w = h(u / 2), E = p(o / 2), T = p(l / 2), R = p(u / 2);
    switch (f) {
      case "XYZ":
        this._x = E * g * w + v * T * R, this._y = v * T * w - E * g * R, this._z = v * g * R + E * T * w, this._w = v * g * w - E * T * R;
        break;
      case "YXZ":
        this._x = E * g * w + v * T * R, this._y = v * T * w - E * g * R, this._z = v * g * R - E * T * w, this._w = v * g * w + E * T * R;
        break;
      case "ZXY":
        this._x = E * g * w - v * T * R, this._y = v * T * w + E * g * R, this._z = v * g * R + E * T * w, this._w = v * g * w - E * T * R;
        break;
      case "ZYX":
        this._x = E * g * w - v * T * R, this._y = v * T * w + E * g * R, this._z = v * g * R - E * T * w, this._w = v * g * w + E * T * R;
        break;
      case "YZX":
        this._x = E * g * w + v * T * R, this._y = v * T * w + E * g * R, this._z = v * g * R - E * T * w, this._w = v * g * w - E * T * R;
        break;
      case "XZY":
        this._x = E * g * w - v * T * R, this._y = v * T * w - E * g * R, this._z = v * g * R + E * T * w, this._w = v * g * w + E * T * R;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + f);
    }
    return n === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, n) {
    const o = n / 2, l = Math.sin(o);
    return this._x = e.x * l, this._y = e.y * l, this._z = e.z * l, this._w = Math.cos(o), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e) {
    const n = e.elements, o = n[0], l = n[4], u = n[8], f = n[1], h = n[5], p = n[9], v = n[2], g = n[6], w = n[10], E = o + h + w;
    if (E > 0) {
      const T = 0.5 / Math.sqrt(E + 1);
      this._w = 0.25 / T, this._x = (g - p) * T, this._y = (u - v) * T, this._z = (f - l) * T;
    } else if (o > h && o > w) {
      const T = 2 * Math.sqrt(1 + o - h - w);
      this._w = (g - p) / T, this._x = 0.25 * T, this._y = (l + f) / T, this._z = (u + v) / T;
    } else if (h > w) {
      const T = 2 * Math.sqrt(1 + h - o - w);
      this._w = (u - v) / T, this._x = (l + f) / T, this._y = 0.25 * T, this._z = (p + g) / T;
    } else {
      const T = 2 * Math.sqrt(1 + w - o - h);
      this._w = (f - l) / T, this._x = (u + v) / T, this._y = (p + g) / T, this._z = 0.25 * T;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, n) {
    let o = e.dot(n) + 1;
    return o < Number.EPSILON ? (o = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = o) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = o)) : (this._x = e.y * n.z - e.z * n.y, this._y = e.z * n.x - e.x * n.z, this._z = e.x * n.y - e.y * n.x, this._w = o), this.normalize();
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(_t(this.dot(e), -1, 1)));
  }
  rotateTowards(e, n) {
    const o = this.angleTo(e);
    if (o === 0)
      return this;
    const l = Math.min(1, n / o);
    return this.slerp(e, l), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, n) {
    const o = e._x, l = e._y, u = e._z, f = e._w, h = n._x, p = n._y, v = n._z, g = n._w;
    return this._x = o * g + f * h + l * v - u * p, this._y = l * g + f * p + u * h - o * v, this._z = u * g + f * v + o * p - l * h, this._w = f * g - o * h - l * p - u * v, this._onChangeCallback(), this;
  }
  slerp(e, n) {
    if (n === 0)
      return this;
    if (n === 1)
      return this.copy(e);
    const o = this._x, l = this._y, u = this._z, f = this._w;
    let h = f * e._w + o * e._x + l * e._y + u * e._z;
    if (h < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, h = -h) : this.copy(e), h >= 1)
      return this._w = f, this._x = o, this._y = l, this._z = u, this;
    const p = 1 - h * h;
    if (p <= Number.EPSILON) {
      const T = 1 - n;
      return this._w = T * f + n * this._w, this._x = T * o + n * this._x, this._y = T * l + n * this._y, this._z = T * u + n * this._z, this.normalize(), this;
    }
    const v = Math.sqrt(p), g = Math.atan2(v, h), w = Math.sin((1 - n) * g) / v, E = Math.sin(n * g) / v;
    return this._w = f * w + this._w * E, this._x = o * w + this._x * E, this._y = l * w + this._y * E, this._z = u * w + this._z * E, this._onChangeCallback(), this;
  }
  slerpQuaternions(e, n, o) {
    return this.copy(e).slerp(n, o);
  }
  random() {
    const e = 2 * Math.PI * Math.random(), n = 2 * Math.PI * Math.random(), o = Math.random(), l = Math.sqrt(1 - o), u = Math.sqrt(o);
    return this.set(
      l * Math.sin(e),
      l * Math.cos(e),
      u * Math.sin(n),
      u * Math.cos(n)
    );
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  fromArray(e, n = 0) {
    return this._x = e[n], this._y = e[n + 1], this._z = e[n + 2], this._w = e[n + 3], this._onChangeCallback(), this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this._x, e[n + 1] = this._y, e[n + 2] = this._z, e[n + 3] = this._w, e;
  }
  fromBufferAttribute(e, n) {
    return this._x = e.getX(n), this._y = e.getY(n), this._z = e.getZ(n), this._w = e.getW(n), this._onChangeCallback(), this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class I {
  constructor(e = 0, n = 0, o = 0) {
    I.prototype.isVector3 = !0, this.x = e, this.y = n, this.z = o;
  }
  set(e, n, o) {
    return o === void 0 && (o = this.z), this.x = e, this.y = n, this.z = o, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      case 2:
        this.z = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, n) {
    return this.x = e.x + n.x, this.y = e.y + n.y, this.z = e.z + n.z, this;
  }
  addScaledVector(e, n) {
    return this.x += e.x * n, this.y += e.y * n, this.z += e.z * n, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, n) {
    return this.x = e.x - n.x, this.y = e.y - n.y, this.z = e.z - n.z, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, n) {
    return this.x = e.x * n.x, this.y = e.y * n.y, this.z = e.z * n.z, this;
  }
  applyEuler(e) {
    return this.applyQuaternion(sa.setFromEuler(e));
  }
  applyAxisAngle(e, n) {
    return this.applyQuaternion(sa.setFromAxisAngle(e, n));
  }
  applyMatrix3(e) {
    const n = this.x, o = this.y, l = this.z, u = e.elements;
    return this.x = u[0] * n + u[3] * o + u[6] * l, this.y = u[1] * n + u[4] * o + u[7] * l, this.z = u[2] * n + u[5] * o + u[8] * l, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const n = this.x, o = this.y, l = this.z, u = e.elements, f = 1 / (u[3] * n + u[7] * o + u[11] * l + u[15]);
    return this.x = (u[0] * n + u[4] * o + u[8] * l + u[12]) * f, this.y = (u[1] * n + u[5] * o + u[9] * l + u[13]) * f, this.z = (u[2] * n + u[6] * o + u[10] * l + u[14]) * f, this;
  }
  applyQuaternion(e) {
    const n = this.x, o = this.y, l = this.z, u = e.x, f = e.y, h = e.z, p = e.w, v = 2 * (f * l - h * o), g = 2 * (h * n - u * l), w = 2 * (u * o - f * n);
    return this.x = n + p * v + f * w - h * g, this.y = o + p * g + h * v - u * w, this.z = l + p * w + u * g - f * v, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const n = this.x, o = this.y, l = this.z, u = e.elements;
    return this.x = u[0] * n + u[4] * o + u[8] * l, this.y = u[1] * n + u[5] * o + u[9] * l, this.z = u[2] * n + u[6] * o + u[10] * l, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, n) {
    return this.x = Math.max(e.x, Math.min(n.x, this.x)), this.y = Math.max(e.y, Math.min(n.y, this.y)), this.z = Math.max(e.z, Math.min(n.z, this.z)), this;
  }
  clampScalar(e, n) {
    return this.x = Math.max(e, Math.min(n, this.x)), this.y = Math.max(e, Math.min(n, this.y)), this.z = Math.max(e, Math.min(n, this.z)), this;
  }
  clampLength(e, n) {
    const o = this.length();
    return this.divideScalar(o || 1).multiplyScalar(Math.max(e, Math.min(n, o)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, n) {
    return this.x += (e.x - this.x) * n, this.y += (e.y - this.y) * n, this.z += (e.z - this.z) * n, this;
  }
  lerpVectors(e, n, o) {
    return this.x = e.x + (n.x - e.x) * o, this.y = e.y + (n.y - e.y) * o, this.z = e.z + (n.z - e.z) * o, this;
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, n) {
    const o = e.x, l = e.y, u = e.z, f = n.x, h = n.y, p = n.z;
    return this.x = l * p - u * h, this.y = u * f - o * p, this.z = o * h - l * f, this;
  }
  projectOnVector(e) {
    const n = e.lengthSq();
    if (n === 0)
      return this.set(0, 0, 0);
    const o = e.dot(this) / n;
    return this.copy(e).multiplyScalar(o);
  }
  projectOnPlane(e) {
    return Ar.copy(this).projectOnVector(e), this.sub(Ar);
  }
  reflect(e) {
    return this.sub(Ar.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const n = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (n === 0)
      return Math.PI / 2;
    const o = this.dot(e) / n;
    return Math.acos(_t(o, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const n = this.x - e.x, o = this.y - e.y, l = this.z - e.z;
    return n * n + o * o + l * l;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, n, o) {
    const l = Math.sin(n) * e;
    return this.x = l * Math.sin(o), this.y = Math.cos(n) * e, this.z = l * Math.cos(o), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, n, o) {
    return this.x = e * Math.sin(n), this.y = o, this.z = e * Math.cos(n), this;
  }
  setFromMatrixPosition(e) {
    const n = e.elements;
    return this.x = n[12], this.y = n[13], this.z = n[14], this;
  }
  setFromMatrixScale(e) {
    const n = this.setFromMatrixColumn(e, 0).length(), o = this.setFromMatrixColumn(e, 1).length(), l = this.setFromMatrixColumn(e, 2).length();
    return this.x = n, this.y = o, this.z = l, this;
  }
  setFromMatrixColumn(e, n) {
    return this.fromArray(e.elements, n * 4);
  }
  setFromMatrix3Column(e, n) {
    return this.fromArray(e.elements, n * 3);
  }
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  setFromColor(e) {
    return this.x = e.r, this.y = e.g, this.z = e.b, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, n = 0) {
    return this.x = e[n], this.y = e[n + 1], this.z = e[n + 2], this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this.x, e[n + 1] = this.y, e[n + 2] = this.z, e;
  }
  fromBufferAttribute(e, n) {
    return this.x = e.getX(n), this.y = e.getY(n), this.z = e.getZ(n), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const e = Math.random() * Math.PI * 2, n = Math.random() * 2 - 1, o = Math.sqrt(1 - n * n);
    return this.x = o * Math.cos(e), this.y = n, this.z = o * Math.sin(e), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const Ar = /* @__PURE__ */ new I(), sa = /* @__PURE__ */ new Pn();
class vi {
  constructor(e = new I(1 / 0, 1 / 0, 1 / 0), n = new I(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = e, this.max = n;
  }
  set(e, n) {
    return this.min.copy(e), this.max.copy(n), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let n = 0, o = e.length; n < o; n += 3)
      this.expandByPoint(Dt.fromArray(e, n));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let n = 0, o = e.count; n < o; n++)
      this.expandByPoint(Dt.fromBufferAttribute(e, n));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let n = 0, o = e.length; n < o; n++)
      this.expandByPoint(e[n]);
    return this;
  }
  setFromCenterAndSize(e, n) {
    const o = Dt.copy(n).multiplyScalar(0.5);
    return this.min.copy(e).sub(o), this.max.copy(e).add(o), this;
  }
  setFromObject(e, n = !1) {
    return this.makeEmpty(), this.expandByObject(e, n);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, n = !1) {
    e.updateWorldMatrix(!1, !1);
    const o = e.geometry;
    if (o !== void 0) {
      const u = o.getAttribute("position");
      if (n === !0 && u !== void 0 && e.isInstancedMesh !== !0)
        for (let f = 0, h = u.count; f < h; f++)
          e.isMesh === !0 ? e.getVertexPosition(f, Dt) : Dt.fromBufferAttribute(u, f), Dt.applyMatrix4(e.matrixWorld), this.expandByPoint(Dt);
      else
        e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), bi.copy(e.boundingBox)) : (o.boundingBox === null && o.computeBoundingBox(), bi.copy(o.boundingBox)), bi.applyMatrix4(e.matrixWorld), this.union(bi);
    }
    const l = e.children;
    for (let u = 0, f = l.length; u < f; u++)
      this.expandByObject(l[u], n);
    return this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  getParameter(e, n) {
    return n.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z);
  }
  intersectsSphere(e) {
    return this.clampPoint(e.center, Dt), Dt.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  intersectsPlane(e) {
    let n, o;
    return e.normal.x > 0 ? (n = e.normal.x * this.min.x, o = e.normal.x * this.max.x) : (n = e.normal.x * this.max.x, o = e.normal.x * this.min.x), e.normal.y > 0 ? (n += e.normal.y * this.min.y, o += e.normal.y * this.max.y) : (n += e.normal.y * this.max.y, o += e.normal.y * this.min.y), e.normal.z > 0 ? (n += e.normal.z * this.min.z, o += e.normal.z * this.max.z) : (n += e.normal.z * this.max.z, o += e.normal.z * this.min.z), n <= -e.constant && o >= -e.constant;
  }
  intersectsTriangle(e) {
    if (this.isEmpty())
      return !1;
    this.getCenter(hi), Ai.subVectors(this.max, hi), Fn.subVectors(e.a, hi), On.subVectors(e.b, hi), Bn.subVectors(e.c, hi), Jt.subVectors(On, Fn), Qt.subVectors(Bn, On), gn.subVectors(Fn, Bn);
    let n = [
      0,
      -Jt.z,
      Jt.y,
      0,
      -Qt.z,
      Qt.y,
      0,
      -gn.z,
      gn.y,
      Jt.z,
      0,
      -Jt.x,
      Qt.z,
      0,
      -Qt.x,
      gn.z,
      0,
      -gn.x,
      -Jt.y,
      Jt.x,
      0,
      -Qt.y,
      Qt.x,
      0,
      -gn.y,
      gn.x,
      0
    ];
    return !wr(n, Fn, On, Bn, Ai) || (n = [1, 0, 0, 0, 1, 0, 0, 0, 1], !wr(n, Fn, On, Bn, Ai)) ? !1 : (wi.crossVectors(Jt, Qt), n = [wi.x, wi.y, wi.z], wr(n, Fn, On, Bn, Ai));
  }
  clampPoint(e, n) {
    return n.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, Dt).distanceTo(e);
  }
  getBoundingSphere(e) {
    return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(Dt).length() * 0.5), e;
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty() ? this : (Vt[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Vt[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Vt[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Vt[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Vt[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Vt[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Vt[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Vt[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Vt), this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Vt = [
  /* @__PURE__ */ new I(),
  /* @__PURE__ */ new I(),
  /* @__PURE__ */ new I(),
  /* @__PURE__ */ new I(),
  /* @__PURE__ */ new I(),
  /* @__PURE__ */ new I(),
  /* @__PURE__ */ new I(),
  /* @__PURE__ */ new I()
], Dt = /* @__PURE__ */ new I(), bi = /* @__PURE__ */ new vi(), Fn = /* @__PURE__ */ new I(), On = /* @__PURE__ */ new I(), Bn = /* @__PURE__ */ new I(), Jt = /* @__PURE__ */ new I(), Qt = /* @__PURE__ */ new I(), gn = /* @__PURE__ */ new I(), hi = /* @__PURE__ */ new I(), Ai = /* @__PURE__ */ new I(), wi = /* @__PURE__ */ new I(), vn = /* @__PURE__ */ new I();
function wr(t, e, n, o, l) {
  for (let u = 0, f = t.length - 3; u <= f; u += 3) {
    vn.fromArray(t, u);
    const h = l.x * Math.abs(vn.x) + l.y * Math.abs(vn.y) + l.z * Math.abs(vn.z), p = e.dot(vn), v = n.dot(vn), g = o.dot(vn);
    if (Math.max(-Math.max(p, v, g), Math.min(p, v, g)) > h)
      return !1;
  }
  return !0;
}
const ic = /* @__PURE__ */ new vi(), fi = /* @__PURE__ */ new I(), Rr = /* @__PURE__ */ new I();
class ur {
  constructor(e = new I(), n = -1) {
    this.isSphere = !0, this.center = e, this.radius = n;
  }
  set(e, n) {
    return this.center.copy(e), this.radius = n, this;
  }
  setFromPoints(e, n) {
    const o = this.center;
    n !== void 0 ? o.copy(n) : ic.setFromPoints(e).getCenter(o);
    let l = 0;
    for (let u = 0, f = e.length; u < f; u++)
      l = Math.max(l, o.distanceToSquared(e[u]));
    return this.radius = Math.sqrt(l), this;
  }
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const n = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= n * n;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, n) {
    const o = this.center.distanceToSquared(e);
    return n.copy(e), o > this.radius * this.radius && (n.sub(this.center).normalize(), n.multiplyScalar(this.radius).add(this.center)), n;
  }
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty())
      return this.center.copy(e), this.radius = 0, this;
    fi.subVectors(e, this.center);
    const n = fi.lengthSq();
    if (n > this.radius * this.radius) {
      const o = Math.sqrt(n), l = (o - this.radius) * 0.5;
      this.center.addScaledVector(fi, l / o), this.radius += l;
    }
    return this;
  }
  union(e) {
    return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (Rr.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(fi.copy(e.center).add(Rr)), this.expandByPoint(fi.copy(e.center).sub(Rr))), this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const kt = /* @__PURE__ */ new I(), Cr = /* @__PURE__ */ new I(), Ri = /* @__PURE__ */ new I(), en = /* @__PURE__ */ new I(), Pr = /* @__PURE__ */ new I(), Ci = /* @__PURE__ */ new I(), Lr = /* @__PURE__ */ new I();
class hs {
  constructor(e = new I(), n = new I(0, 0, -1)) {
    this.origin = e, this.direction = n;
  }
  set(e, n) {
    return this.origin.copy(e), this.direction.copy(n), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, n) {
    return n.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, kt)), this;
  }
  closestPointToPoint(e, n) {
    n.subVectors(e, this.origin);
    const o = n.dot(this.direction);
    return o < 0 ? n.copy(this.origin) : n.copy(this.origin).addScaledVector(this.direction, o);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const n = kt.subVectors(e, this.origin).dot(this.direction);
    return n < 0 ? this.origin.distanceToSquared(e) : (kt.copy(this.origin).addScaledVector(this.direction, n), kt.distanceToSquared(e));
  }
  distanceSqToSegment(e, n, o, l) {
    Cr.copy(e).add(n).multiplyScalar(0.5), Ri.copy(n).sub(e).normalize(), en.copy(this.origin).sub(Cr);
    const u = e.distanceTo(n) * 0.5, f = -this.direction.dot(Ri), h = en.dot(this.direction), p = -en.dot(Ri), v = en.lengthSq(), g = Math.abs(1 - f * f);
    let w, E, T, R;
    if (g > 0)
      if (w = f * p - h, E = f * h - p, R = u * g, w >= 0)
        if (E >= -R)
          if (E <= R) {
            const _ = 1 / g;
            w *= _, E *= _, T = w * (w + f * E + 2 * h) + E * (f * w + E + 2 * p) + v;
          } else
            E = u, w = Math.max(0, -(f * E + h)), T = -w * w + E * (E + 2 * p) + v;
        else
          E = -u, w = Math.max(0, -(f * E + h)), T = -w * w + E * (E + 2 * p) + v;
      else
        E <= -R ? (w = Math.max(0, -(-f * u + h)), E = w > 0 ? -u : Math.min(Math.max(-u, -p), u), T = -w * w + E * (E + 2 * p) + v) : E <= R ? (w = 0, E = Math.min(Math.max(-u, -p), u), T = E * (E + 2 * p) + v) : (w = Math.max(0, -(f * u + h)), E = w > 0 ? u : Math.min(Math.max(-u, -p), u), T = -w * w + E * (E + 2 * p) + v);
    else
      E = f > 0 ? -u : u, w = Math.max(0, -(f * E + h)), T = -w * w + E * (E + 2 * p) + v;
    return o && o.copy(this.origin).addScaledVector(this.direction, w), l && l.copy(Cr).addScaledVector(Ri, E), T;
  }
  intersectSphere(e, n) {
    kt.subVectors(e.center, this.origin);
    const o = kt.dot(this.direction), l = kt.dot(kt) - o * o, u = e.radius * e.radius;
    if (l > u)
      return null;
    const f = Math.sqrt(u - l), h = o - f, p = o + f;
    return p < 0 ? null : h < 0 ? this.at(p, n) : this.at(h, n);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const n = e.normal.dot(this.direction);
    if (n === 0)
      return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const o = -(this.origin.dot(e.normal) + e.constant) / n;
    return o >= 0 ? o : null;
  }
  intersectPlane(e, n) {
    const o = this.distanceToPlane(e);
    return o === null ? null : this.at(o, n);
  }
  intersectsPlane(e) {
    const n = e.distanceToPoint(this.origin);
    return n === 0 || e.normal.dot(this.direction) * n < 0;
  }
  intersectBox(e, n) {
    let o, l, u, f, h, p;
    const v = 1 / this.direction.x, g = 1 / this.direction.y, w = 1 / this.direction.z, E = this.origin;
    return v >= 0 ? (o = (e.min.x - E.x) * v, l = (e.max.x - E.x) * v) : (o = (e.max.x - E.x) * v, l = (e.min.x - E.x) * v), g >= 0 ? (u = (e.min.y - E.y) * g, f = (e.max.y - E.y) * g) : (u = (e.max.y - E.y) * g, f = (e.min.y - E.y) * g), o > f || u > l || ((u > o || isNaN(o)) && (o = u), (f < l || isNaN(l)) && (l = f), w >= 0 ? (h = (e.min.z - E.z) * w, p = (e.max.z - E.z) * w) : (h = (e.max.z - E.z) * w, p = (e.min.z - E.z) * w), o > p || h > l) || ((h > o || o !== o) && (o = h), (p < l || l !== l) && (l = p), l < 0) ? null : this.at(o >= 0 ? o : l, n);
  }
  intersectsBox(e) {
    return this.intersectBox(e, kt) !== null;
  }
  intersectTriangle(e, n, o, l, u) {
    Pr.subVectors(n, e), Ci.subVectors(o, e), Lr.crossVectors(Pr, Ci);
    let f = this.direction.dot(Lr), h;
    if (f > 0) {
      if (l)
        return null;
      h = 1;
    } else if (f < 0)
      h = -1, f = -f;
    else
      return null;
    en.subVectors(this.origin, e);
    const p = h * this.direction.dot(Ci.crossVectors(en, Ci));
    if (p < 0)
      return null;
    const v = h * this.direction.dot(Pr.cross(en));
    if (v < 0 || p + v > f)
      return null;
    const g = -h * en.dot(Lr);
    return g < 0 ? null : this.at(g / f, u);
  }
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class st {
  constructor(e, n, o, l, u, f, h, p, v, g, w, E, T, R, _, b) {
    st.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, n, o, l, u, f, h, p, v, g, w, E, T, R, _, b);
  }
  set(e, n, o, l, u, f, h, p, v, g, w, E, T, R, _, b) {
    const M = this.elements;
    return M[0] = e, M[4] = n, M[8] = o, M[12] = l, M[1] = u, M[5] = f, M[9] = h, M[13] = p, M[2] = v, M[6] = g, M[10] = w, M[14] = E, M[3] = T, M[7] = R, M[11] = _, M[15] = b, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new st().fromArray(this.elements);
  }
  copy(e) {
    const n = this.elements, o = e.elements;
    return n[0] = o[0], n[1] = o[1], n[2] = o[2], n[3] = o[3], n[4] = o[4], n[5] = o[5], n[6] = o[6], n[7] = o[7], n[8] = o[8], n[9] = o[9], n[10] = o[10], n[11] = o[11], n[12] = o[12], n[13] = o[13], n[14] = o[14], n[15] = o[15], this;
  }
  copyPosition(e) {
    const n = this.elements, o = e.elements;
    return n[12] = o[12], n[13] = o[13], n[14] = o[14], this;
  }
  setFromMatrix3(e) {
    const n = e.elements;
    return this.set(
      n[0],
      n[3],
      n[6],
      0,
      n[1],
      n[4],
      n[7],
      0,
      n[2],
      n[5],
      n[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractBasis(e, n, o) {
    return e.setFromMatrixColumn(this, 0), n.setFromMatrixColumn(this, 1), o.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, n, o) {
    return this.set(
      e.x,
      n.x,
      o.x,
      0,
      e.y,
      n.y,
      o.y,
      0,
      e.z,
      n.z,
      o.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(e) {
    const n = this.elements, o = e.elements, l = 1 / zn.setFromMatrixColumn(e, 0).length(), u = 1 / zn.setFromMatrixColumn(e, 1).length(), f = 1 / zn.setFromMatrixColumn(e, 2).length();
    return n[0] = o[0] * l, n[1] = o[1] * l, n[2] = o[2] * l, n[3] = 0, n[4] = o[4] * u, n[5] = o[5] * u, n[6] = o[6] * u, n[7] = 0, n[8] = o[8] * f, n[9] = o[9] * f, n[10] = o[10] * f, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    const n = this.elements, o = e.x, l = e.y, u = e.z, f = Math.cos(o), h = Math.sin(o), p = Math.cos(l), v = Math.sin(l), g = Math.cos(u), w = Math.sin(u);
    if (e.order === "XYZ") {
      const E = f * g, T = f * w, R = h * g, _ = h * w;
      n[0] = p * g, n[4] = -p * w, n[8] = v, n[1] = T + R * v, n[5] = E - _ * v, n[9] = -h * p, n[2] = _ - E * v, n[6] = R + T * v, n[10] = f * p;
    } else if (e.order === "YXZ") {
      const E = p * g, T = p * w, R = v * g, _ = v * w;
      n[0] = E + _ * h, n[4] = R * h - T, n[8] = f * v, n[1] = f * w, n[5] = f * g, n[9] = -h, n[2] = T * h - R, n[6] = _ + E * h, n[10] = f * p;
    } else if (e.order === "ZXY") {
      const E = p * g, T = p * w, R = v * g, _ = v * w;
      n[0] = E - _ * h, n[4] = -f * w, n[8] = R + T * h, n[1] = T + R * h, n[5] = f * g, n[9] = _ - E * h, n[2] = -f * v, n[6] = h, n[10] = f * p;
    } else if (e.order === "ZYX") {
      const E = f * g, T = f * w, R = h * g, _ = h * w;
      n[0] = p * g, n[4] = R * v - T, n[8] = E * v + _, n[1] = p * w, n[5] = _ * v + E, n[9] = T * v - R, n[2] = -v, n[6] = h * p, n[10] = f * p;
    } else if (e.order === "YZX") {
      const E = f * p, T = f * v, R = h * p, _ = h * v;
      n[0] = p * g, n[4] = _ - E * w, n[8] = R * w + T, n[1] = w, n[5] = f * g, n[9] = -h * g, n[2] = -v * g, n[6] = T * w + R, n[10] = E - _ * w;
    } else if (e.order === "XZY") {
      const E = f * p, T = f * v, R = h * p, _ = h * v;
      n[0] = p * g, n[4] = -w, n[8] = v * g, n[1] = E * w + _, n[5] = f * g, n[9] = T * w - R, n[2] = R * w - T, n[6] = h * g, n[10] = _ * w + E;
    }
    return n[3] = 0, n[7] = 0, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(rc, e, sc);
  }
  lookAt(e, n, o) {
    const l = this.elements;
    return At.subVectors(e, n), At.lengthSq() === 0 && (At.z = 1), At.normalize(), tn.crossVectors(o, At), tn.lengthSq() === 0 && (Math.abs(o.z) === 1 ? At.x += 1e-4 : At.z += 1e-4, At.normalize(), tn.crossVectors(o, At)), tn.normalize(), Pi.crossVectors(At, tn), l[0] = tn.x, l[4] = Pi.x, l[8] = At.x, l[1] = tn.y, l[5] = Pi.y, l[9] = At.y, l[2] = tn.z, l[6] = Pi.z, l[10] = At.z, this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, n) {
    const o = e.elements, l = n.elements, u = this.elements, f = o[0], h = o[4], p = o[8], v = o[12], g = o[1], w = o[5], E = o[9], T = o[13], R = o[2], _ = o[6], b = o[10], M = o[14], A = o[3], $ = o[7], S = o[11], C = o[15], D = l[0], O = l[4], N = l[8], j = l[12], L = l[1], z = l[5], G = l[9], B = l[13], F = l[2], H = l[6], W = l[10], V = l[14], X = l[3], Z = l[7], Q = l[11], q = l[15];
    return u[0] = f * D + h * L + p * F + v * X, u[4] = f * O + h * z + p * H + v * Z, u[8] = f * N + h * G + p * W + v * Q, u[12] = f * j + h * B + p * V + v * q, u[1] = g * D + w * L + E * F + T * X, u[5] = g * O + w * z + E * H + T * Z, u[9] = g * N + w * G + E * W + T * Q, u[13] = g * j + w * B + E * V + T * q, u[2] = R * D + _ * L + b * F + M * X, u[6] = R * O + _ * z + b * H + M * Z, u[10] = R * N + _ * G + b * W + M * Q, u[14] = R * j + _ * B + b * V + M * q, u[3] = A * D + $ * L + S * F + C * X, u[7] = A * O + $ * z + S * H + C * Z, u[11] = A * N + $ * G + S * W + C * Q, u[15] = A * j + $ * B + S * V + C * q, this;
  }
  multiplyScalar(e) {
    const n = this.elements;
    return n[0] *= e, n[4] *= e, n[8] *= e, n[12] *= e, n[1] *= e, n[5] *= e, n[9] *= e, n[13] *= e, n[2] *= e, n[6] *= e, n[10] *= e, n[14] *= e, n[3] *= e, n[7] *= e, n[11] *= e, n[15] *= e, this;
  }
  determinant() {
    const e = this.elements, n = e[0], o = e[4], l = e[8], u = e[12], f = e[1], h = e[5], p = e[9], v = e[13], g = e[2], w = e[6], E = e[10], T = e[14], R = e[3], _ = e[7], b = e[11], M = e[15];
    return R * (+u * p * w - l * v * w - u * h * E + o * v * E + l * h * T - o * p * T) + _ * (+n * p * T - n * v * E + u * f * E - l * f * T + l * v * g - u * p * g) + b * (+n * v * w - n * h * T - u * f * w + o * f * T + u * h * g - o * v * g) + M * (-l * h * g - n * p * w + n * h * E + l * f * w - o * f * E + o * p * g);
  }
  transpose() {
    const e = this.elements;
    let n;
    return n = e[1], e[1] = e[4], e[4] = n, n = e[2], e[2] = e[8], e[8] = n, n = e[6], e[6] = e[9], e[9] = n, n = e[3], e[3] = e[12], e[12] = n, n = e[7], e[7] = e[13], e[13] = n, n = e[11], e[11] = e[14], e[14] = n, this;
  }
  setPosition(e, n, o) {
    const l = this.elements;
    return e.isVector3 ? (l[12] = e.x, l[13] = e.y, l[14] = e.z) : (l[12] = e, l[13] = n, l[14] = o), this;
  }
  invert() {
    const e = this.elements, n = e[0], o = e[1], l = e[2], u = e[3], f = e[4], h = e[5], p = e[6], v = e[7], g = e[8], w = e[9], E = e[10], T = e[11], R = e[12], _ = e[13], b = e[14], M = e[15], A = w * b * v - _ * E * v + _ * p * T - h * b * T - w * p * M + h * E * M, $ = R * E * v - g * b * v - R * p * T + f * b * T + g * p * M - f * E * M, S = g * _ * v - R * w * v + R * h * T - f * _ * T - g * h * M + f * w * M, C = R * w * p - g * _ * p - R * h * E + f * _ * E + g * h * b - f * w * b, D = n * A + o * $ + l * S + u * C;
    if (D === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const O = 1 / D;
    return e[0] = A * O, e[1] = (_ * E * u - w * b * u - _ * l * T + o * b * T + w * l * M - o * E * M) * O, e[2] = (h * b * u - _ * p * u + _ * l * v - o * b * v - h * l * M + o * p * M) * O, e[3] = (w * p * u - h * E * u - w * l * v + o * E * v + h * l * T - o * p * T) * O, e[4] = $ * O, e[5] = (g * b * u - R * E * u + R * l * T - n * b * T - g * l * M + n * E * M) * O, e[6] = (R * p * u - f * b * u - R * l * v + n * b * v + f * l * M - n * p * M) * O, e[7] = (f * E * u - g * p * u + g * l * v - n * E * v - f * l * T + n * p * T) * O, e[8] = S * O, e[9] = (R * w * u - g * _ * u - R * o * T + n * _ * T + g * o * M - n * w * M) * O, e[10] = (f * _ * u - R * h * u + R * o * v - n * _ * v - f * o * M + n * h * M) * O, e[11] = (g * h * u - f * w * u - g * o * v + n * w * v + f * o * T - n * h * T) * O, e[12] = C * O, e[13] = (g * _ * l - R * w * l + R * o * E - n * _ * E - g * o * b + n * w * b) * O, e[14] = (R * h * l - f * _ * l - R * o * p + n * _ * p + f * o * b - n * h * b) * O, e[15] = (f * w * l - g * h * l + g * o * p - n * w * p - f * o * E + n * h * E) * O, this;
  }
  scale(e) {
    const n = this.elements, o = e.x, l = e.y, u = e.z;
    return n[0] *= o, n[4] *= l, n[8] *= u, n[1] *= o, n[5] *= l, n[9] *= u, n[2] *= o, n[6] *= l, n[10] *= u, n[3] *= o, n[7] *= l, n[11] *= u, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, n = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], o = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], l = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(n, o, l));
  }
  makeTranslation(e, n, o) {
    return e.isVector3 ? this.set(
      1,
      0,
      0,
      e.x,
      0,
      1,
      0,
      e.y,
      0,
      0,
      1,
      e.z,
      0,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      n,
      0,
      0,
      1,
      o,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(e) {
    const n = Math.cos(e), o = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      n,
      -o,
      0,
      0,
      o,
      n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(e) {
    const n = Math.cos(e), o = Math.sin(e);
    return this.set(
      n,
      0,
      o,
      0,
      0,
      1,
      0,
      0,
      -o,
      0,
      n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(e) {
    const n = Math.cos(e), o = Math.sin(e);
    return this.set(
      n,
      -o,
      0,
      0,
      o,
      n,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(e, n) {
    const o = Math.cos(n), l = Math.sin(n), u = 1 - o, f = e.x, h = e.y, p = e.z, v = u * f, g = u * h;
    return this.set(
      v * f + o,
      v * h - l * p,
      v * p + l * h,
      0,
      v * h + l * p,
      g * h + o,
      g * p - l * f,
      0,
      v * p - l * h,
      g * p + l * f,
      u * p * p + o,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, n, o) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      n,
      0,
      0,
      0,
      0,
      o,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(e, n, o, l, u, f) {
    return this.set(
      1,
      o,
      u,
      0,
      e,
      1,
      f,
      0,
      n,
      l,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(e, n, o) {
    const l = this.elements, u = n._x, f = n._y, h = n._z, p = n._w, v = u + u, g = f + f, w = h + h, E = u * v, T = u * g, R = u * w, _ = f * g, b = f * w, M = h * w, A = p * v, $ = p * g, S = p * w, C = o.x, D = o.y, O = o.z;
    return l[0] = (1 - (_ + M)) * C, l[1] = (T + S) * C, l[2] = (R - $) * C, l[3] = 0, l[4] = (T - S) * D, l[5] = (1 - (E + M)) * D, l[6] = (b + A) * D, l[7] = 0, l[8] = (R + $) * O, l[9] = (b - A) * O, l[10] = (1 - (E + _)) * O, l[11] = 0, l[12] = e.x, l[13] = e.y, l[14] = e.z, l[15] = 1, this;
  }
  decompose(e, n, o) {
    const l = this.elements;
    let u = zn.set(l[0], l[1], l[2]).length();
    const f = zn.set(l[4], l[5], l[6]).length(), h = zn.set(l[8], l[9], l[10]).length();
    this.determinant() < 0 && (u = -u), e.x = l[12], e.y = l[13], e.z = l[14], Ut.copy(this);
    const p = 1 / u, v = 1 / f, g = 1 / h;
    return Ut.elements[0] *= p, Ut.elements[1] *= p, Ut.elements[2] *= p, Ut.elements[4] *= v, Ut.elements[5] *= v, Ut.elements[6] *= v, Ut.elements[8] *= g, Ut.elements[9] *= g, Ut.elements[10] *= g, n.setFromRotationMatrix(Ut), o.x = u, o.y = f, o.z = h, this;
  }
  makePerspective(e, n, o, l, u, f, h = Zt) {
    const p = this.elements, v = 2 * u / (n - e), g = 2 * u / (o - l), w = (n + e) / (n - e), E = (o + l) / (o - l);
    let T, R;
    if (h === Zt)
      T = -(f + u) / (f - u), R = -2 * f * u / (f - u);
    else if (h === ir)
      T = -f / (f - u), R = -f * u / (f - u);
    else
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + h);
    return p[0] = v, p[4] = 0, p[8] = w, p[12] = 0, p[1] = 0, p[5] = g, p[9] = E, p[13] = 0, p[2] = 0, p[6] = 0, p[10] = T, p[14] = R, p[3] = 0, p[7] = 0, p[11] = -1, p[15] = 0, this;
  }
  makeOrthographic(e, n, o, l, u, f, h = Zt) {
    const p = this.elements, v = 1 / (n - e), g = 1 / (o - l), w = 1 / (f - u), E = (n + e) * v, T = (o + l) * g;
    let R, _;
    if (h === Zt)
      R = (f + u) * w, _ = -2 * w;
    else if (h === ir)
      R = u * w, _ = -1 * w;
    else
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + h);
    return p[0] = 2 * v, p[4] = 0, p[8] = 0, p[12] = -E, p[1] = 0, p[5] = 2 * g, p[9] = 0, p[13] = -T, p[2] = 0, p[6] = 0, p[10] = _, p[14] = -R, p[3] = 0, p[7] = 0, p[11] = 0, p[15] = 1, this;
  }
  equals(e) {
    const n = this.elements, o = e.elements;
    for (let l = 0; l < 16; l++)
      if (n[l] !== o[l])
        return !1;
    return !0;
  }
  fromArray(e, n = 0) {
    for (let o = 0; o < 16; o++)
      this.elements[o] = e[o + n];
    return this;
  }
  toArray(e = [], n = 0) {
    const o = this.elements;
    return e[n] = o[0], e[n + 1] = o[1], e[n + 2] = o[2], e[n + 3] = o[3], e[n + 4] = o[4], e[n + 5] = o[5], e[n + 6] = o[6], e[n + 7] = o[7], e[n + 8] = o[8], e[n + 9] = o[9], e[n + 10] = o[10], e[n + 11] = o[11], e[n + 12] = o[12], e[n + 13] = o[13], e[n + 14] = o[14], e[n + 15] = o[15], e;
  }
}
const zn = /* @__PURE__ */ new I(), Ut = /* @__PURE__ */ new st(), rc = /* @__PURE__ */ new I(0, 0, 0), sc = /* @__PURE__ */ new I(1, 1, 1), tn = /* @__PURE__ */ new I(), Pi = /* @__PURE__ */ new I(), At = /* @__PURE__ */ new I(), aa = /* @__PURE__ */ new st(), oa = /* @__PURE__ */ new Pn();
class $t {
  constructor(e = 0, n = 0, o = 0, l = $t.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = e, this._y = n, this._z = o, this._order = l;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, n, o, l = this._order) {
    return this._x = e, this._y = n, this._z = o, this._order = l, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, n = this._order, o = !0) {
    const l = e.elements, u = l[0], f = l[4], h = l[8], p = l[1], v = l[5], g = l[9], w = l[2], E = l[6], T = l[10];
    switch (n) {
      case "XYZ":
        this._y = Math.asin(_t(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._x = Math.atan2(-g, T), this._z = Math.atan2(-f, u)) : (this._x = Math.atan2(E, v), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-_t(g, -1, 1)), Math.abs(g) < 0.9999999 ? (this._y = Math.atan2(h, T), this._z = Math.atan2(p, v)) : (this._y = Math.atan2(-w, u), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(_t(E, -1, 1)), Math.abs(E) < 0.9999999 ? (this._y = Math.atan2(-w, T), this._z = Math.atan2(-f, v)) : (this._y = 0, this._z = Math.atan2(p, u));
        break;
      case "ZYX":
        this._y = Math.asin(-_t(w, -1, 1)), Math.abs(w) < 0.9999999 ? (this._x = Math.atan2(E, T), this._z = Math.atan2(p, u)) : (this._x = 0, this._z = Math.atan2(-f, v));
        break;
      case "YZX":
        this._z = Math.asin(_t(p, -1, 1)), Math.abs(p) < 0.9999999 ? (this._x = Math.atan2(-g, v), this._y = Math.atan2(-w, u)) : (this._x = 0, this._y = Math.atan2(h, T));
        break;
      case "XZY":
        this._z = Math.asin(-_t(f, -1, 1)), Math.abs(f) < 0.9999999 ? (this._x = Math.atan2(E, v), this._y = Math.atan2(h, u)) : (this._x = Math.atan2(-g, T), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + n);
    }
    return this._order = n, o === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, n, o) {
    return aa.makeRotationFromQuaternion(e), this.setFromRotationMatrix(aa, n, o);
  }
  setFromVector3(e, n = this._order) {
    return this.set(e.x, e.y, e.z, n);
  }
  reorder(e) {
    return oa.setFromEuler(this), this.setFromQuaternion(oa, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this._x, e[n + 1] = this._y, e[n + 2] = this._z, e[n + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
$t.DEFAULT_ORDER = "XYZ";
class mo {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = (1 << e | 0) >>> 0;
  }
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & (1 << e | 0)) !== 0;
  }
}
let ac = 0;
const la = /* @__PURE__ */ new I(), Gn = /* @__PURE__ */ new Pn(), Wt = /* @__PURE__ */ new st(), Li = /* @__PURE__ */ new I(), di = /* @__PURE__ */ new I(), oc = /* @__PURE__ */ new I(), lc = /* @__PURE__ */ new Pn(), ca = /* @__PURE__ */ new I(1, 0, 0), ua = /* @__PURE__ */ new I(0, 1, 0), ha = /* @__PURE__ */ new I(0, 0, 1), cc = { type: "added" }, uc = { type: "removed" }, Dr = { type: "childadded", child: null }, Ur = { type: "childremoved", child: null };
class Mt extends Ln {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: ac++ }), this.uuid = oi(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Mt.DEFAULT_UP.clone();
    const e = new I(), n = new $t(), o = new Pn(), l = new I(1, 1, 1);
    function u() {
      o.setFromEuler(n, !1);
    }
    function f() {
      n.setFromQuaternion(o, void 0, !1);
    }
    n._onChange(u), o._onChange(f), Object.defineProperties(this, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: n
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: o
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: l
      },
      modelViewMatrix: {
        value: new st()
      },
      normalMatrix: {
        value: new Ge()
      }
    }), this.matrix = new st(), this.matrixWorld = new st(), this.matrixAutoUpdate = Mt.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = Mt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new mo(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeShadow() {
  }
  onAfterShadow() {
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, n) {
    this.quaternion.setFromAxisAngle(e, n);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, n) {
    return Gn.setFromAxisAngle(e, n), this.quaternion.multiply(Gn), this;
  }
  rotateOnWorldAxis(e, n) {
    return Gn.setFromAxisAngle(e, n), this.quaternion.premultiply(Gn), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(ca, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(ua, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(ha, e);
  }
  translateOnAxis(e, n) {
    return la.copy(e).applyQuaternion(this.quaternion), this.position.add(la.multiplyScalar(n)), this;
  }
  translateX(e) {
    return this.translateOnAxis(ca, e);
  }
  translateY(e) {
    return this.translateOnAxis(ua, e);
  }
  translateZ(e) {
    return this.translateOnAxis(ha, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(Wt.copy(this.matrixWorld).invert());
  }
  lookAt(e, n, o) {
    e.isVector3 ? Li.copy(e) : Li.set(e, n, o);
    const l = this.parent;
    this.updateWorldMatrix(!0, !1), di.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Wt.lookAt(di, Li, this.up) : Wt.lookAt(Li, di, this.up), this.quaternion.setFromRotationMatrix(Wt), l && (Wt.extractRotation(l.matrixWorld), Gn.setFromRotationMatrix(Wt), this.quaternion.premultiply(Gn.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++)
        this.add(arguments[n]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(cc), Dr.child = e, this.dispatchEvent(Dr), Dr.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let o = 0; o < arguments.length; o++)
        this.remove(arguments[o]);
      return this;
    }
    const n = this.children.indexOf(e);
    return n !== -1 && (e.parent = null, this.children.splice(n, 1), e.dispatchEvent(uc), Ur.child = e, this.dispatchEvent(Ur), Ur.child = null), this;
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return this.updateWorldMatrix(!0, !1), Wt.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), Wt.multiply(e.parent.matrixWorld)), e.applyMatrix4(Wt), this.add(e), e.updateWorldMatrix(!1, !0), this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, n) {
    if (this[e] === n)
      return this;
    for (let o = 0, l = this.children.length; o < l; o++) {
      const u = this.children[o].getObjectByProperty(e, n);
      if (u !== void 0)
        return u;
    }
  }
  getObjectsByProperty(e, n, o = []) {
    this[e] === n && o.push(this);
    const l = this.children;
    for (let u = 0, f = l.length; u < f; u++)
      l[u].getObjectsByProperty(e, n, o);
    return o;
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(di, e, oc), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(di, lc, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const n = this.matrixWorld.elements;
    return e.set(n[8], n[9], n[10]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const n = this.children;
    for (let o = 0, l = n.length; o < l; o++)
      n[o].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1)
      return;
    e(this);
    const n = this.children;
    for (let o = 0, l = n.length; o < l; o++)
      n[o].traverseVisible(e);
  }
  traverseAncestors(e) {
    const n = this.parent;
    n !== null && (e(n), n.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
    const n = this.children;
    for (let o = 0, l = n.length; o < l; o++) {
      const u = n[o];
      (u.matrixWorldAutoUpdate === !0 || e === !0) && u.updateMatrixWorld(e);
    }
  }
  updateWorldMatrix(e, n) {
    const o = this.parent;
    if (e === !0 && o !== null && o.matrixWorldAutoUpdate === !0 && o.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), n === !0) {
      const l = this.children;
      for (let u = 0, f = l.length; u < f; u++) {
        const h = l[u];
        h.matrixWorldAutoUpdate === !0 && h.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string", o = {};
    n && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, o.metadata = {
      version: 4.6,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const l = {};
    l.uuid = this.uuid, l.type = this.type, this.name !== "" && (l.name = this.name), this.castShadow === !0 && (l.castShadow = !0), this.receiveShadow === !0 && (l.receiveShadow = !0), this.visible === !1 && (l.visible = !1), this.frustumCulled === !1 && (l.frustumCulled = !1), this.renderOrder !== 0 && (l.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (l.userData = this.userData), l.layers = this.layers.mask, l.matrix = this.matrix.toArray(), l.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (l.matrixAutoUpdate = !1), this.isInstancedMesh && (l.type = "InstancedMesh", l.count = this.count, l.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (l.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (l.type = "BatchedMesh", l.perObjectFrustumCulled = this.perObjectFrustumCulled, l.sortObjects = this.sortObjects, l.drawRanges = this._drawRanges, l.reservedRanges = this._reservedRanges, l.visibility = this._visibility, l.active = this._active, l.bounds = this._bounds.map((h) => ({
      boxInitialized: h.boxInitialized,
      boxMin: h.box.min.toArray(),
      boxMax: h.box.max.toArray(),
      sphereInitialized: h.sphereInitialized,
      sphereRadius: h.sphere.radius,
      sphereCenter: h.sphere.center.toArray()
    })), l.maxGeometryCount = this._maxGeometryCount, l.maxVertexCount = this._maxVertexCount, l.maxIndexCount = this._maxIndexCount, l.geometryInitialized = this._geometryInitialized, l.geometryCount = this._geometryCount, l.matricesTexture = this._matricesTexture.toJSON(e), this.boundingSphere !== null && (l.boundingSphere = {
      center: l.boundingSphere.center.toArray(),
      radius: l.boundingSphere.radius
    }), this.boundingBox !== null && (l.boundingBox = {
      min: l.boundingBox.min.toArray(),
      max: l.boundingBox.max.toArray()
    }));
    function u(h, p) {
      return h[p.uuid] === void 0 && (h[p.uuid] = p.toJSON(e)), p.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? l.background = this.background.toJSON() : this.background.isTexture && (l.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (l.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      l.geometry = u(e.geometries, this.geometry);
      const h = this.geometry.parameters;
      if (h !== void 0 && h.shapes !== void 0) {
        const p = h.shapes;
        if (Array.isArray(p))
          for (let v = 0, g = p.length; v < g; v++) {
            const w = p[v];
            u(e.shapes, w);
          }
        else
          u(e.shapes, p);
      }
    }
    if (this.isSkinnedMesh && (l.bindMode = this.bindMode, l.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (u(e.skeletons, this.skeleton), l.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const h = [];
        for (let p = 0, v = this.material.length; p < v; p++)
          h.push(u(e.materials, this.material[p]));
        l.material = h;
      } else
        l.material = u(e.materials, this.material);
    if (this.children.length > 0) {
      l.children = [];
      for (let h = 0; h < this.children.length; h++)
        l.children.push(this.children[h].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      l.animations = [];
      for (let h = 0; h < this.animations.length; h++) {
        const p = this.animations[h];
        l.animations.push(u(e.animations, p));
      }
    }
    if (n) {
      const h = f(e.geometries), p = f(e.materials), v = f(e.textures), g = f(e.images), w = f(e.shapes), E = f(e.skeletons), T = f(e.animations), R = f(e.nodes);
      h.length > 0 && (o.geometries = h), p.length > 0 && (o.materials = p), v.length > 0 && (o.textures = v), g.length > 0 && (o.images = g), w.length > 0 && (o.shapes = w), E.length > 0 && (o.skeletons = E), T.length > 0 && (o.animations = T), R.length > 0 && (o.nodes = R);
    }
    return o.object = l, o;
    function f(h) {
      const p = [];
      for (const v in h) {
        const g = h[v];
        delete g.metadata, p.push(g);
      }
      return p;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, n = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), n === !0)
      for (let o = 0; o < e.children.length; o++) {
        const l = e.children[o];
        this.add(l.clone());
      }
    return this;
  }
}
Mt.DEFAULT_UP = /* @__PURE__ */ new I(0, 1, 0);
Mt.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Mt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const It = /* @__PURE__ */ new I(), Xt = /* @__PURE__ */ new I(), Ir = /* @__PURE__ */ new I(), Yt = /* @__PURE__ */ new I(), Hn = /* @__PURE__ */ new I(), Vn = /* @__PURE__ */ new I(), fa = /* @__PURE__ */ new I(), Nr = /* @__PURE__ */ new I(), Fr = /* @__PURE__ */ new I(), Or = /* @__PURE__ */ new I();
class Ot {
  constructor(e = new I(), n = new I(), o = new I()) {
    this.a = e, this.b = n, this.c = o;
  }
  static getNormal(e, n, o, l) {
    l.subVectors(o, n), It.subVectors(e, n), l.cross(It);
    const u = l.lengthSq();
    return u > 0 ? l.multiplyScalar(1 / Math.sqrt(u)) : l.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(e, n, o, l, u) {
    It.subVectors(l, n), Xt.subVectors(o, n), Ir.subVectors(e, n);
    const f = It.dot(It), h = It.dot(Xt), p = It.dot(Ir), v = Xt.dot(Xt), g = Xt.dot(Ir), w = f * v - h * h;
    if (w === 0)
      return u.set(0, 0, 0), null;
    const E = 1 / w, T = (v * p - h * g) * E, R = (f * g - h * p) * E;
    return u.set(1 - T - R, R, T);
  }
  static containsPoint(e, n, o, l) {
    return this.getBarycoord(e, n, o, l, Yt) === null ? !1 : Yt.x >= 0 && Yt.y >= 0 && Yt.x + Yt.y <= 1;
  }
  static getInterpolation(e, n, o, l, u, f, h, p) {
    return this.getBarycoord(e, n, o, l, Yt) === null ? (p.x = 0, p.y = 0, "z" in p && (p.z = 0), "w" in p && (p.w = 0), null) : (p.setScalar(0), p.addScaledVector(u, Yt.x), p.addScaledVector(f, Yt.y), p.addScaledVector(h, Yt.z), p);
  }
  static isFrontFacing(e, n, o, l) {
    return It.subVectors(o, n), Xt.subVectors(e, n), It.cross(Xt).dot(l) < 0;
  }
  set(e, n, o) {
    return this.a.copy(e), this.b.copy(n), this.c.copy(o), this;
  }
  setFromPointsAndIndices(e, n, o, l) {
    return this.a.copy(e[n]), this.b.copy(e[o]), this.c.copy(e[l]), this;
  }
  setFromAttributeAndIndices(e, n, o, l) {
    return this.a.fromBufferAttribute(e, n), this.b.fromBufferAttribute(e, o), this.c.fromBufferAttribute(e, l), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return It.subVectors(this.c, this.b), Xt.subVectors(this.a, this.b), It.cross(Xt).length() * 0.5;
  }
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return Ot.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, n) {
    return Ot.getBarycoord(e, this.a, this.b, this.c, n);
  }
  getInterpolation(e, n, o, l, u) {
    return Ot.getInterpolation(e, this.a, this.b, this.c, n, o, l, u);
  }
  containsPoint(e) {
    return Ot.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return Ot.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, n) {
    const o = this.a, l = this.b, u = this.c;
    let f, h;
    Hn.subVectors(l, o), Vn.subVectors(u, o), Nr.subVectors(e, o);
    const p = Hn.dot(Nr), v = Vn.dot(Nr);
    if (p <= 0 && v <= 0)
      return n.copy(o);
    Fr.subVectors(e, l);
    const g = Hn.dot(Fr), w = Vn.dot(Fr);
    if (g >= 0 && w <= g)
      return n.copy(l);
    const E = p * w - g * v;
    if (E <= 0 && p >= 0 && g <= 0)
      return f = p / (p - g), n.copy(o).addScaledVector(Hn, f);
    Or.subVectors(e, u);
    const T = Hn.dot(Or), R = Vn.dot(Or);
    if (R >= 0 && T <= R)
      return n.copy(u);
    const _ = T * v - p * R;
    if (_ <= 0 && v >= 0 && R <= 0)
      return h = v / (v - R), n.copy(o).addScaledVector(Vn, h);
    const b = g * R - T * w;
    if (b <= 0 && w - g >= 0 && T - R >= 0)
      return fa.subVectors(u, l), h = (w - g) / (w - g + (T - R)), n.copy(l).addScaledVector(fa, h);
    const M = 1 / (b + _ + E);
    return f = _ * M, h = E * M, n.copy(o).addScaledVector(Hn, f).addScaledVector(Vn, h);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const _o = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, nn = { h: 0, s: 0, l: 0 }, Di = { h: 0, s: 0, l: 0 };
function Br(t, e, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + (e - t) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? t + (e - t) * 6 * (2 / 3 - n) : t;
}
class qe {
  constructor(e, n, o) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, n, o);
  }
  set(e, n, o) {
    if (n === void 0 && o === void 0) {
      const l = e;
      l && l.isColor ? this.copy(l) : typeof l == "number" ? this.setHex(l) : typeof l == "string" && this.setStyle(l);
    } else
      this.setRGB(e, n, o);
    return this;
  }
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  setHex(e, n = Bt) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, je.toWorkingColorSpace(this, n), this;
  }
  setRGB(e, n, o, l = je.workingColorSpace) {
    return this.r = e, this.g = n, this.b = o, je.toWorkingColorSpace(this, l), this;
  }
  setHSL(e, n, o, l = je.workingColorSpace) {
    if (e = us(e, 1), n = _t(n, 0, 1), o = _t(o, 0, 1), n === 0)
      this.r = this.g = this.b = o;
    else {
      const u = o <= 0.5 ? o * (1 + n) : o + n - o * n, f = 2 * o - u;
      this.r = Br(f, u, e + 1 / 3), this.g = Br(f, u, e), this.b = Br(f, u, e - 1 / 3);
    }
    return je.toWorkingColorSpace(this, l), this;
  }
  setStyle(e, n = Bt) {
    function o(u) {
      u !== void 0 && parseFloat(u) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    let l;
    if (l = /^(\w+)\(([^\)]*)\)/.exec(e)) {
      let u;
      const f = l[1], h = l[2];
      switch (f) {
        case "rgb":
        case "rgba":
          if (u = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(h))
            return o(u[4]), this.setRGB(
              Math.min(255, parseInt(u[1], 10)) / 255,
              Math.min(255, parseInt(u[2], 10)) / 255,
              Math.min(255, parseInt(u[3], 10)) / 255,
              n
            );
          if (u = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(h))
            return o(u[4]), this.setRGB(
              Math.min(100, parseInt(u[1], 10)) / 100,
              Math.min(100, parseInt(u[2], 10)) / 100,
              Math.min(100, parseInt(u[3], 10)) / 100,
              n
            );
          break;
        case "hsl":
        case "hsla":
          if (u = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(h))
            return o(u[4]), this.setHSL(
              parseFloat(u[1]) / 360,
              parseFloat(u[2]) / 100,
              parseFloat(u[3]) / 100,
              n
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if (l = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const u = l[1], f = u.length;
      if (f === 3)
        return this.setRGB(
          parseInt(u.charAt(0), 16) / 15,
          parseInt(u.charAt(1), 16) / 15,
          parseInt(u.charAt(2), 16) / 15,
          n
        );
      if (f === 6)
        return this.setHex(parseInt(u, 16), n);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0)
      return this.setColorName(e, n);
    return this;
  }
  setColorName(e, n = Bt) {
    const o = _o[e.toLowerCase()];
    return o !== void 0 ? this.setHex(o, n) : console.warn("THREE.Color: Unknown color " + e), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  copySRGBToLinear(e) {
    return this.r = ti(e.r), this.g = ti(e.g), this.b = ti(e.b), this;
  }
  copyLinearToSRGB(e) {
    return this.r = Tr(e.r), this.g = Tr(e.g), this.b = Tr(e.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = Bt) {
    return je.fromWorkingColorSpace(mt.copy(this), e), Math.round(_t(mt.r * 255, 0, 255)) * 65536 + Math.round(_t(mt.g * 255, 0, 255)) * 256 + Math.round(_t(mt.b * 255, 0, 255));
  }
  getHexString(e = Bt) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, n = je.workingColorSpace) {
    je.fromWorkingColorSpace(mt.copy(this), n);
    const o = mt.r, l = mt.g, u = mt.b, f = Math.max(o, l, u), h = Math.min(o, l, u);
    let p, v;
    const g = (h + f) / 2;
    if (h === f)
      p = 0, v = 0;
    else {
      const w = f - h;
      switch (v = g <= 0.5 ? w / (f + h) : w / (2 - f - h), f) {
        case o:
          p = (l - u) / w + (l < u ? 6 : 0);
          break;
        case l:
          p = (u - o) / w + 2;
          break;
        case u:
          p = (o - l) / w + 4;
          break;
      }
      p /= 6;
    }
    return e.h = p, e.s = v, e.l = g, e;
  }
  getRGB(e, n = je.workingColorSpace) {
    return je.fromWorkingColorSpace(mt.copy(this), n), e.r = mt.r, e.g = mt.g, e.b = mt.b, e;
  }
  getStyle(e = Bt) {
    je.fromWorkingColorSpace(mt.copy(this), e);
    const n = mt.r, o = mt.g, l = mt.b;
    return e !== Bt ? `color(${e} ${n.toFixed(3)} ${o.toFixed(3)} ${l.toFixed(3)})` : `rgb(${Math.round(n * 255)},${Math.round(o * 255)},${Math.round(l * 255)})`;
  }
  offsetHSL(e, n, o) {
    return this.getHSL(nn), this.setHSL(nn.h + e, nn.s + n, nn.l + o);
  }
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  addColors(e, n) {
    return this.r = e.r + n.r, this.g = e.g + n.g, this.b = e.b + n.b, this;
  }
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  lerp(e, n) {
    return this.r += (e.r - this.r) * n, this.g += (e.g - this.g) * n, this.b += (e.b - this.b) * n, this;
  }
  lerpColors(e, n, o) {
    return this.r = e.r + (n.r - e.r) * o, this.g = e.g + (n.g - e.g) * o, this.b = e.b + (n.b - e.b) * o, this;
  }
  lerpHSL(e, n) {
    this.getHSL(nn), e.getHSL(Di);
    const o = mi(nn.h, Di.h, n), l = mi(nn.s, Di.s, n), u = mi(nn.l, Di.l, n);
    return this.setHSL(o, l, u), this;
  }
  setFromVector3(e) {
    return this.r = e.x, this.g = e.y, this.b = e.z, this;
  }
  applyMatrix3(e) {
    const n = this.r, o = this.g, l = this.b, u = e.elements;
    return this.r = u[0] * n + u[3] * o + u[6] * l, this.g = u[1] * n + u[4] * o + u[7] * l, this.b = u[2] * n + u[5] * o + u[8] * l, this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, n = 0) {
    return this.r = e[n], this.g = e[n + 1], this.b = e[n + 2], this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this.r, e[n + 1] = this.g, e[n + 2] = this.b, e;
  }
  fromBufferAttribute(e, n) {
    return this.r = e.getX(n), this.g = e.getY(n), this.b = e.getZ(n), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const mt = /* @__PURE__ */ new qe();
qe.NAMES = _o;
let hc = 0;
class xi extends Ln {
  constructor() {
    super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: hc++ }), this.uuid = oi(), this.name = "", this.type = "Material", this.blending = Qn, this.side = hn, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = Jr, this.blendDst = Qr, this.blendEquation = Tn, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new qe(0, 0, 0), this.blendAlpha = 0, this.depthFunc = Qi, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = Js, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = In, this.stencilZFail = In, this.stencilZPass = In, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
  }
  onBuild() {
  }
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const n in e) {
        const o = e[n];
        if (o === void 0) {
          console.warn(`THREE.Material: parameter '${n}' has value of undefined.`);
          continue;
        }
        const l = this[n];
        if (l === void 0) {
          console.warn(`THREE.Material: '${n}' is not a property of THREE.${this.type}.`);
          continue;
        }
        l && l.isColor ? l.set(o) : l && l.isVector3 && o && o.isVector3 ? l.copy(o) : this[n] = o;
      }
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string";
    n && (e = {
      textures: {},
      images: {}
    });
    const o = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    o.uuid = this.uuid, o.type = this.type, this.name !== "" && (o.name = this.name), this.color && this.color.isColor && (o.color = this.color.getHex()), this.roughness !== void 0 && (o.roughness = this.roughness), this.metalness !== void 0 && (o.metalness = this.metalness), this.sheen !== void 0 && (o.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (o.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (o.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (o.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (o.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (o.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (o.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (o.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (o.shininess = this.shininess), this.clearcoat !== void 0 && (o.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (o.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (o.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (o.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (o.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, o.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.iridescence !== void 0 && (o.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (o.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (o.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (o.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (o.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (o.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (o.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (o.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (o.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (o.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (o.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (o.lightMap = this.lightMap.toJSON(e).uuid, o.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (o.aoMap = this.aoMap.toJSON(e).uuid, o.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (o.bumpMap = this.bumpMap.toJSON(e).uuid, o.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (o.normalMap = this.normalMap.toJSON(e).uuid, o.normalMapType = this.normalMapType, o.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (o.displacementMap = this.displacementMap.toJSON(e).uuid, o.displacementScale = this.displacementScale, o.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (o.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (o.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (o.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (o.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (o.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (o.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (o.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (o.combine = this.combine)), this.envMapRotation !== void 0 && (o.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (o.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (o.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (o.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (o.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (o.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (o.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (o.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (o.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (o.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (o.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (o.size = this.size), this.shadowSide !== null && (o.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (o.sizeAttenuation = this.sizeAttenuation), this.blending !== Qn && (o.blending = this.blending), this.side !== hn && (o.side = this.side), this.vertexColors === !0 && (o.vertexColors = !0), this.opacity < 1 && (o.opacity = this.opacity), this.transparent === !0 && (o.transparent = !0), this.blendSrc !== Jr && (o.blendSrc = this.blendSrc), this.blendDst !== Qr && (o.blendDst = this.blendDst), this.blendEquation !== Tn && (o.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (o.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (o.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (o.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (o.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (o.blendAlpha = this.blendAlpha), this.depthFunc !== Qi && (o.depthFunc = this.depthFunc), this.depthTest === !1 && (o.depthTest = this.depthTest), this.depthWrite === !1 && (o.depthWrite = this.depthWrite), this.colorWrite === !1 && (o.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (o.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== Js && (o.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (o.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (o.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== In && (o.stencilFail = this.stencilFail), this.stencilZFail !== In && (o.stencilZFail = this.stencilZFail), this.stencilZPass !== In && (o.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (o.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (o.rotation = this.rotation), this.polygonOffset === !0 && (o.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (o.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (o.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (o.linewidth = this.linewidth), this.dashSize !== void 0 && (o.dashSize = this.dashSize), this.gapSize !== void 0 && (o.gapSize = this.gapSize), this.scale !== void 0 && (o.scale = this.scale), this.dithering === !0 && (o.dithering = !0), this.alphaTest > 0 && (o.alphaTest = this.alphaTest), this.alphaHash === !0 && (o.alphaHash = !0), this.alphaToCoverage === !0 && (o.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (o.premultipliedAlpha = !0), this.forceSinglePass === !0 && (o.forceSinglePass = !0), this.wireframe === !0 && (o.wireframe = !0), this.wireframeLinewidth > 1 && (o.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (o.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (o.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (o.flatShading = !0), this.visible === !1 && (o.visible = !1), this.toneMapped === !1 && (o.toneMapped = !1), this.fog === !1 && (o.fog = !1), Object.keys(this.userData).length > 0 && (o.userData = this.userData);
    function l(u) {
      const f = [];
      for (const h in u) {
        const p = u[h];
        delete p.metadata, f.push(p);
      }
      return f;
    }
    if (n) {
      const u = l(e.textures), f = l(e.images);
      u.length > 0 && (o.textures = u), f.length > 0 && (o.images = f);
    }
    return o;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
    const n = e.clippingPlanes;
    let o = null;
    if (n !== null) {
      const l = n.length;
      o = new Array(l);
      for (let u = 0; u !== l; ++u)
        o[u] = n[u].clone();
    }
    return this.clippingPlanes = o, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
class ni extends xi {
  constructor(e) {
    super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new qe(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new $t(), this.combine = eo, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
const rt = /* @__PURE__ */ new I(), Ui = /* @__PURE__ */ new Ie();
class Gt {
  constructor(e, n, o = !1) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = n, this.count = e !== void 0 ? e.length / n : 0, this.normalized = o, this.usage = Qs, this._updateRange = { offset: 0, count: -1 }, this.updateRanges = [], this.gpuType = Kt, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  get updateRange() {
    return $l("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  addUpdateRange(e, n) {
    this.updateRanges.push({ start: e, count: n });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
  }
  copyAt(e, n, o) {
    e *= this.itemSize, o *= n.itemSize;
    for (let l = 0, u = this.itemSize; l < u; l++)
      this.array[e + l] = n.array[o + l];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let n = 0, o = this.count; n < o; n++)
        Ui.fromBufferAttribute(this, n), Ui.applyMatrix3(e), this.setXY(n, Ui.x, Ui.y);
    else if (this.itemSize === 3)
      for (let n = 0, o = this.count; n < o; n++)
        rt.fromBufferAttribute(this, n), rt.applyMatrix3(e), this.setXYZ(n, rt.x, rt.y, rt.z);
    return this;
  }
  applyMatrix4(e) {
    for (let n = 0, o = this.count; n < o; n++)
      rt.fromBufferAttribute(this, n), rt.applyMatrix4(e), this.setXYZ(n, rt.x, rt.y, rt.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let n = 0, o = this.count; n < o; n++)
      rt.fromBufferAttribute(this, n), rt.applyNormalMatrix(e), this.setXYZ(n, rt.x, rt.y, rt.z);
    return this;
  }
  transformDirection(e) {
    for (let n = 0, o = this.count; n < o; n++)
      rt.fromBufferAttribute(this, n), rt.transformDirection(e), this.setXYZ(n, rt.x, rt.y, rt.z);
    return this;
  }
  set(e, n = 0) {
    return this.array.set(e, n), this;
  }
  getComponent(e, n) {
    let o = this.array[e * this.itemSize + n];
    return this.normalized && (o = Zn(o, this.array)), o;
  }
  setComponent(e, n, o) {
    return this.normalized && (o = gt(o, this.array)), this.array[e * this.itemSize + n] = o, this;
  }
  getX(e) {
    let n = this.array[e * this.itemSize];
    return this.normalized && (n = Zn(n, this.array)), n;
  }
  setX(e, n) {
    return this.normalized && (n = gt(n, this.array)), this.array[e * this.itemSize] = n, this;
  }
  getY(e) {
    let n = this.array[e * this.itemSize + 1];
    return this.normalized && (n = Zn(n, this.array)), n;
  }
  setY(e, n) {
    return this.normalized && (n = gt(n, this.array)), this.array[e * this.itemSize + 1] = n, this;
  }
  getZ(e) {
    let n = this.array[e * this.itemSize + 2];
    return this.normalized && (n = Zn(n, this.array)), n;
  }
  setZ(e, n) {
    return this.normalized && (n = gt(n, this.array)), this.array[e * this.itemSize + 2] = n, this;
  }
  getW(e) {
    let n = this.array[e * this.itemSize + 3];
    return this.normalized && (n = Zn(n, this.array)), n;
  }
  setW(e, n) {
    return this.normalized && (n = gt(n, this.array)), this.array[e * this.itemSize + 3] = n, this;
  }
  setXY(e, n, o) {
    return e *= this.itemSize, this.normalized && (n = gt(n, this.array), o = gt(o, this.array)), this.array[e + 0] = n, this.array[e + 1] = o, this;
  }
  setXYZ(e, n, o, l) {
    return e *= this.itemSize, this.normalized && (n = gt(n, this.array), o = gt(o, this.array), l = gt(l, this.array)), this.array[e + 0] = n, this.array[e + 1] = o, this.array[e + 2] = l, this;
  }
  setXYZW(e, n, o, l, u) {
    return e *= this.itemSize, this.normalized && (n = gt(n, this.array), o = gt(o, this.array), l = gt(l, this.array), u = gt(u, this.array)), this.array[e + 0] = n, this.array[e + 1] = o, this.array[e + 2] = l, this.array[e + 3] = u, this;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (e.name = this.name), this.usage !== Qs && (e.usage = this.usage), e;
  }
}
class go extends Gt {
  constructor(e, n, o) {
    super(new Uint16Array(e), n, o);
  }
}
class vo extends Gt {
  constructor(e, n, o) {
    super(new Uint32Array(e), n, o);
  }
}
class ut extends Gt {
  constructor(e, n, o) {
    super(new Float32Array(e), n, o);
  }
}
let fc = 0;
const Pt = /* @__PURE__ */ new st(), zr = /* @__PURE__ */ new Mt(), kn = /* @__PURE__ */ new I(), wt = /* @__PURE__ */ new vi(), pi$2 = /* @__PURE__ */ new vi(), ct = /* @__PURE__ */ new I();
class Tt extends Ln {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: fc++ }), this.uuid = oi(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (uo(e) ? vo : go)(e, 1) : this.index = e, this;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, n) {
    return this.attributes[e] = n, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, n, o = 0) {
    this.groups.push({
      start: e,
      count: n,
      materialIndex: o
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, n) {
    this.drawRange.start = e, this.drawRange.count = n;
  }
  applyMatrix4(e) {
    const n = this.attributes.position;
    n !== void 0 && (n.applyMatrix4(e), n.needsUpdate = !0);
    const o = this.attributes.normal;
    if (o !== void 0) {
      const u = new Ge().getNormalMatrix(e);
      o.applyNormalMatrix(u), o.needsUpdate = !0;
    }
    const l = this.attributes.tangent;
    return l !== void 0 && (l.transformDirection(e), l.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return Pt.makeRotationFromQuaternion(e), this.applyMatrix4(Pt), this;
  }
  rotateX(e) {
    return Pt.makeRotationX(e), this.applyMatrix4(Pt), this;
  }
  rotateY(e) {
    return Pt.makeRotationY(e), this.applyMatrix4(Pt), this;
  }
  rotateZ(e) {
    return Pt.makeRotationZ(e), this.applyMatrix4(Pt), this;
  }
  translate(e, n, o) {
    return Pt.makeTranslation(e, n, o), this.applyMatrix4(Pt), this;
  }
  scale(e, n, o) {
    return Pt.makeScale(e, n, o), this.applyMatrix4(Pt), this;
  }
  lookAt(e) {
    return zr.lookAt(e), zr.updateMatrix(), this.applyMatrix4(zr.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(kn).negate(), this.translate(kn.x, kn.y, kn.z), this;
  }
  setFromPoints(e) {
    const n = [];
    for (let o = 0, l = e.length; o < l; o++) {
      const u = e[o];
      n.push(u.x, u.y, u.z || 0);
    }
    return this.setAttribute("position", new ut(n, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new vi());
    const e = this.attributes.position, n = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(
        new I(-1 / 0, -1 / 0, -1 / 0),
        new I(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), n)
        for (let o = 0, l = n.length; o < l; o++) {
          const u = n[o];
          wt.setFromBufferAttribute(u), this.morphTargetsRelative ? (ct.addVectors(this.boundingBox.min, wt.min), this.boundingBox.expandByPoint(ct), ct.addVectors(this.boundingBox.max, wt.max), this.boundingBox.expandByPoint(ct)) : (this.boundingBox.expandByPoint(wt.min), this.boundingBox.expandByPoint(wt.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new ur());
    const e = this.attributes.position, n = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new I(), 1 / 0);
      return;
    }
    if (e) {
      const o = this.boundingSphere.center;
      if (wt.setFromBufferAttribute(e), n)
        for (let u = 0, f = n.length; u < f; u++) {
          const h = n[u];
          pi$2.setFromBufferAttribute(h), this.morphTargetsRelative ? (ct.addVectors(wt.min, pi$2.min), wt.expandByPoint(ct), ct.addVectors(wt.max, pi$2.max), wt.expandByPoint(ct)) : (wt.expandByPoint(pi$2.min), wt.expandByPoint(pi$2.max));
        }
      wt.getCenter(o);
      let l = 0;
      for (let u = 0, f = e.count; u < f; u++)
        ct.fromBufferAttribute(e, u), l = Math.max(l, o.distanceToSquared(ct));
      if (n)
        for (let u = 0, f = n.length; u < f; u++) {
          const h = n[u], p = this.morphTargetsRelative;
          for (let v = 0, g = h.count; v < g; v++)
            ct.fromBufferAttribute(h, v), p && (kn.fromBufferAttribute(e, v), ct.add(kn)), l = Math.max(l, o.distanceToSquared(ct));
        }
      this.boundingSphere.radius = Math.sqrt(l), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const e = this.index, n = this.attributes;
    if (e === null || n.position === void 0 || n.normal === void 0 || n.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const o = n.position, l = n.normal, u = n.uv;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Gt(new Float32Array(4 * o.count), 4));
    const f = this.getAttribute("tangent"), h = [], p = [];
    for (let N = 0; N < o.count; N++)
      h[N] = new I(), p[N] = new I();
    const v = new I(), g = new I(), w = new I(), E = new Ie(), T = new Ie(), R = new Ie(), _ = new I(), b = new I();
    function M(N, j, L) {
      v.fromBufferAttribute(o, N), g.fromBufferAttribute(o, j), w.fromBufferAttribute(o, L), E.fromBufferAttribute(u, N), T.fromBufferAttribute(u, j), R.fromBufferAttribute(u, L), g.sub(v), w.sub(v), T.sub(E), R.sub(E);
      const z = 1 / (T.x * R.y - R.x * T.y);
      isFinite(z) && (_.copy(g).multiplyScalar(R.y).addScaledVector(w, -T.y).multiplyScalar(z), b.copy(w).multiplyScalar(T.x).addScaledVector(g, -R.x).multiplyScalar(z), h[N].add(_), h[j].add(_), h[L].add(_), p[N].add(b), p[j].add(b), p[L].add(b));
    }
    let A = this.groups;
    A.length === 0 && (A = [{
      start: 0,
      count: e.count
    }]);
    for (let N = 0, j = A.length; N < j; ++N) {
      const L = A[N], z = L.start, G = L.count;
      for (let B = z, F = z + G; B < F; B += 3)
        M(
          e.getX(B + 0),
          e.getX(B + 1),
          e.getX(B + 2)
        );
    }
    const $ = new I(), S = new I(), C = new I(), D = new I();
    function O(N) {
      C.fromBufferAttribute(l, N), D.copy(C);
      const j = h[N];
      $.copy(j), $.sub(C.multiplyScalar(C.dot(j))).normalize(), S.crossVectors(D, j);
      const L = S.dot(p[N]) < 0 ? -1 : 1;
      f.setXYZW(N, $.x, $.y, $.z, L);
    }
    for (let N = 0, j = A.length; N < j; ++N) {
      const L = A[N], z = L.start, G = L.count;
      for (let B = z, F = z + G; B < F; B += 3)
        O(e.getX(B + 0)), O(e.getX(B + 1)), O(e.getX(B + 2));
    }
  }
  computeVertexNormals() {
    const e = this.index, n = this.getAttribute("position");
    if (n !== void 0) {
      let o = this.getAttribute("normal");
      if (o === void 0)
        o = new Gt(new Float32Array(n.count * 3), 3), this.setAttribute("normal", o);
      else
        for (let E = 0, T = o.count; E < T; E++)
          o.setXYZ(E, 0, 0, 0);
      const l = new I(), u = new I(), f = new I(), h = new I(), p = new I(), v = new I(), g = new I(), w = new I();
      if (e)
        for (let E = 0, T = e.count; E < T; E += 3) {
          const R = e.getX(E + 0), _ = e.getX(E + 1), b = e.getX(E + 2);
          l.fromBufferAttribute(n, R), u.fromBufferAttribute(n, _), f.fromBufferAttribute(n, b), g.subVectors(f, u), w.subVectors(l, u), g.cross(w), h.fromBufferAttribute(o, R), p.fromBufferAttribute(o, _), v.fromBufferAttribute(o, b), h.add(g), p.add(g), v.add(g), o.setXYZ(R, h.x, h.y, h.z), o.setXYZ(_, p.x, p.y, p.z), o.setXYZ(b, v.x, v.y, v.z);
        }
      else
        for (let E = 0, T = n.count; E < T; E += 3)
          l.fromBufferAttribute(n, E + 0), u.fromBufferAttribute(n, E + 1), f.fromBufferAttribute(n, E + 2), g.subVectors(f, u), w.subVectors(l, u), g.cross(w), o.setXYZ(E + 0, g.x, g.y, g.z), o.setXYZ(E + 1, g.x, g.y, g.z), o.setXYZ(E + 2, g.x, g.y, g.z);
      this.normalizeNormals(), o.needsUpdate = !0;
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let n = 0, o = e.count; n < o; n++)
      ct.fromBufferAttribute(e, n), ct.normalize(), e.setXYZ(n, ct.x, ct.y, ct.z);
  }
  toNonIndexed() {
    function e(h, p) {
      const v = h.array, g = h.itemSize, w = h.normalized, E = new v.constructor(p.length * g);
      let T = 0, R = 0;
      for (let _ = 0, b = p.length; _ < b; _++) {
        h.isInterleavedBufferAttribute ? T = p[_] * h.data.stride + h.offset : T = p[_] * g;
        for (let M = 0; M < g; M++)
          E[R++] = v[T++];
      }
      return new Gt(E, g, w);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const n = new Tt(), o = this.index.array, l = this.attributes;
    for (const h in l) {
      const p = l[h], v = e(p, o);
      n.setAttribute(h, v);
    }
    const u = this.morphAttributes;
    for (const h in u) {
      const p = [], v = u[h];
      for (let g = 0, w = v.length; g < w; g++) {
        const E = v[g], T = e(E, o);
        p.push(T);
      }
      n.morphAttributes[h] = p;
    }
    n.morphTargetsRelative = this.morphTargetsRelative;
    const f = this.groups;
    for (let h = 0, p = f.length; h < p; h++) {
      const v = f[h];
      n.addGroup(v.start, v.count, v.materialIndex);
    }
    return n;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const p = this.parameters;
      for (const v in p)
        p[v] !== void 0 && (e[v] = p[v]);
      return e;
    }
    e.data = { attributes: {} };
    const n = this.index;
    n !== null && (e.data.index = {
      type: n.array.constructor.name,
      array: Array.prototype.slice.call(n.array)
    });
    const o = this.attributes;
    for (const p in o) {
      const v = o[p];
      e.data.attributes[p] = v.toJSON(e.data);
    }
    const l = {};
    let u = !1;
    for (const p in this.morphAttributes) {
      const v = this.morphAttributes[p], g = [];
      for (let w = 0, E = v.length; w < E; w++) {
        const T = v[w];
        g.push(T.toJSON(e.data));
      }
      g.length > 0 && (l[p] = g, u = !0);
    }
    u && (e.data.morphAttributes = l, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const f = this.groups;
    f.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(f)));
    const h = this.boundingSphere;
    return h !== null && (e.data.boundingSphere = {
      center: h.center.toArray(),
      radius: h.radius
    }), e;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const n = {};
    this.name = e.name;
    const o = e.index;
    o !== null && this.setIndex(o.clone(n));
    const l = e.attributes;
    for (const v in l) {
      const g = l[v];
      this.setAttribute(v, g.clone(n));
    }
    const u = e.morphAttributes;
    for (const v in u) {
      const g = [], w = u[v];
      for (let E = 0, T = w.length; E < T; E++)
        g.push(w[E].clone(n));
      this.morphAttributes[v] = g;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const f = e.groups;
    for (let v = 0, g = f.length; v < g; v++) {
      const w = f[v];
      this.addGroup(w.start, w.count, w.materialIndex);
    }
    const h = e.boundingBox;
    h !== null && (this.boundingBox = h.clone());
    const p = e.boundingSphere;
    return p !== null && (this.boundingSphere = p.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const da = /* @__PURE__ */ new st(), xn = /* @__PURE__ */ new hs(), Ii = /* @__PURE__ */ new ur(), pa = /* @__PURE__ */ new I(), Wn = /* @__PURE__ */ new I(), Xn = /* @__PURE__ */ new I(), Yn = /* @__PURE__ */ new I(), Gr = /* @__PURE__ */ new I(), Ni = /* @__PURE__ */ new I(), Fi = /* @__PURE__ */ new Ie(), Oi = /* @__PURE__ */ new Ie(), Bi = /* @__PURE__ */ new Ie(), ma = /* @__PURE__ */ new I(), _a = /* @__PURE__ */ new I(), ga = /* @__PURE__ */ new I(), zi = /* @__PURE__ */ new I(), Gi = /* @__PURE__ */ new I();
class Rt extends Mt {
  constructor(e = new Tt(), n = new ni()) {
    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = n, this.updateMorphTargets();
  }
  copy(e, n) {
    return super.copy(e, n), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  updateMorphTargets() {
    const e = this.geometry.morphAttributes, n = Object.keys(e);
    if (n.length > 0) {
      const o = e[n[0]];
      if (o !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let l = 0, u = o.length; l < u; l++) {
          const f = o[l].name || String(l);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[f] = l;
        }
      }
    }
  }
  getVertexPosition(e, n) {
    const o = this.geometry, l = o.attributes.position, u = o.morphAttributes.position, f = o.morphTargetsRelative;
    n.fromBufferAttribute(l, e);
    const h = this.morphTargetInfluences;
    if (u && h) {
      Ni.set(0, 0, 0);
      for (let p = 0, v = u.length; p < v; p++) {
        const g = h[p], w = u[p];
        g !== 0 && (Gr.fromBufferAttribute(w, e), f ? Ni.addScaledVector(Gr, g) : Ni.addScaledVector(Gr.sub(n), g));
      }
      n.add(Ni);
    }
    return n;
  }
  raycast(e, n) {
    const o = this.geometry, l = this.material, u = this.matrixWorld;
    l !== void 0 && (o.boundingSphere === null && o.computeBoundingSphere(), Ii.copy(o.boundingSphere), Ii.applyMatrix4(u), xn.copy(e.ray).recast(e.near), !(Ii.containsPoint(xn.origin) === !1 && (xn.intersectSphere(Ii, pa) === null || xn.origin.distanceToSquared(pa) > (e.far - e.near) ** 2)) && (da.copy(u).invert(), xn.copy(e.ray).applyMatrix4(da), !(o.boundingBox !== null && xn.intersectsBox(o.boundingBox) === !1) && this._computeIntersections(e, n, xn)));
  }
  _computeIntersections(e, n, o) {
    let l;
    const u = this.geometry, f = this.material, h = u.index, p = u.attributes.position, v = u.attributes.uv, g = u.attributes.uv1, w = u.attributes.normal, E = u.groups, T = u.drawRange;
    if (h !== null)
      if (Array.isArray(f))
        for (let R = 0, _ = E.length; R < _; R++) {
          const b = E[R], M = f[b.materialIndex], A = Math.max(b.start, T.start), $ = Math.min(h.count, Math.min(b.start + b.count, T.start + T.count));
          for (let S = A, C = $; S < C; S += 3) {
            const D = h.getX(S), O = h.getX(S + 1), N = h.getX(S + 2);
            l = Hi(this, M, e, o, v, g, w, D, O, N), l && (l.faceIndex = Math.floor(S / 3), l.face.materialIndex = b.materialIndex, n.push(l));
          }
        }
      else {
        const R = Math.max(0, T.start), _ = Math.min(h.count, T.start + T.count);
        for (let b = R, M = _; b < M; b += 3) {
          const A = h.getX(b), $ = h.getX(b + 1), S = h.getX(b + 2);
          l = Hi(this, f, e, o, v, g, w, A, $, S), l && (l.faceIndex = Math.floor(b / 3), n.push(l));
        }
      }
    else if (p !== void 0)
      if (Array.isArray(f))
        for (let R = 0, _ = E.length; R < _; R++) {
          const b = E[R], M = f[b.materialIndex], A = Math.max(b.start, T.start), $ = Math.min(p.count, Math.min(b.start + b.count, T.start + T.count));
          for (let S = A, C = $; S < C; S += 3) {
            const D = S, O = S + 1, N = S + 2;
            l = Hi(this, M, e, o, v, g, w, D, O, N), l && (l.faceIndex = Math.floor(S / 3), l.face.materialIndex = b.materialIndex, n.push(l));
          }
        }
      else {
        const R = Math.max(0, T.start), _ = Math.min(p.count, T.start + T.count);
        for (let b = R, M = _; b < M; b += 3) {
          const A = b, $ = b + 1, S = b + 2;
          l = Hi(this, f, e, o, v, g, w, A, $, S), l && (l.faceIndex = Math.floor(b / 3), n.push(l));
        }
      }
  }
}
function dc(t, e, n, o, l, u, f, h) {
  let p;
  if (e.side === Et ? p = o.intersectTriangle(f, u, l, !0, h) : p = o.intersectTriangle(l, u, f, e.side === hn, h), p === null)
    return null;
  Gi.copy(h), Gi.applyMatrix4(t.matrixWorld);
  const v = n.ray.origin.distanceTo(Gi);
  return v < n.near || v > n.far ? null : {
    distance: v,
    point: Gi.clone(),
    object: t
  };
}
function Hi(t, e, n, o, l, u, f, h, p, v) {
  t.getVertexPosition(h, Wn), t.getVertexPosition(p, Xn), t.getVertexPosition(v, Yn);
  const g = dc(t, e, n, o, Wn, Xn, Yn, zi);
  if (g) {
    l && (Fi.fromBufferAttribute(l, h), Oi.fromBufferAttribute(l, p), Bi.fromBufferAttribute(l, v), g.uv = Ot.getInterpolation(zi, Wn, Xn, Yn, Fi, Oi, Bi, new Ie())), u && (Fi.fromBufferAttribute(u, h), Oi.fromBufferAttribute(u, p), Bi.fromBufferAttribute(u, v), g.uv1 = Ot.getInterpolation(zi, Wn, Xn, Yn, Fi, Oi, Bi, new Ie())), f && (ma.fromBufferAttribute(f, h), _a.fromBufferAttribute(f, p), ga.fromBufferAttribute(f, v), g.normal = Ot.getInterpolation(zi, Wn, Xn, Yn, ma, _a, ga, new I()), g.normal.dot(o.direction) > 0 && g.normal.multiplyScalar(-1));
    const w = {
      a: h,
      b: p,
      c: v,
      normal: new I(),
      materialIndex: 0
    };
    Ot.getNormal(Wn, Xn, Yn, w.normal), g.face = w;
  }
  return g;
}
class Mi extends Tt {
  constructor(e = 1, n = 1, o = 1, l = 1, u = 1, f = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: n,
      depth: o,
      widthSegments: l,
      heightSegments: u,
      depthSegments: f
    };
    const h = this;
    l = Math.floor(l), u = Math.floor(u), f = Math.floor(f);
    const p = [], v = [], g = [], w = [];
    let E = 0, T = 0;
    R("z", "y", "x", -1, -1, o, n, e, f, u, 0), R("z", "y", "x", 1, -1, o, n, -e, f, u, 1), R("x", "z", "y", 1, 1, e, o, n, l, f, 2), R("x", "z", "y", 1, -1, e, o, -n, l, f, 3), R("x", "y", "z", 1, -1, e, n, o, l, u, 4), R("x", "y", "z", -1, -1, e, n, -o, l, u, 5), this.setIndex(p), this.setAttribute("position", new ut(v, 3)), this.setAttribute("normal", new ut(g, 3)), this.setAttribute("uv", new ut(w, 2));
    function R(_, b, M, A, $, S, C, D, O, N, j) {
      const L = S / O, z = C / N, G = S / 2, B = C / 2, F = D / 2, H = O + 1, W = N + 1;
      let V = 0, X = 0;
      const Z = new I();
      for (let Q = 0; Q < W; Q++) {
        const q = Q * z - B;
        for (let J = 0; J < H; J++) {
          const ie = J * L - G;
          Z[_] = ie * A, Z[b] = q * $, Z[M] = F, v.push(Z.x, Z.y, Z.z), Z[_] = 0, Z[b] = 0, Z[M] = D > 0 ? 1 : -1, g.push(Z.x, Z.y, Z.z), w.push(J / O), w.push(1 - Q / N), V += 1;
        }
      }
      for (let Q = 0; Q < N; Q++)
        for (let q = 0; q < O; q++) {
          const J = E + q + H * Q, ie = E + q + H * (Q + 1), ne = E + (q + 1) + H * (Q + 1), ge = E + (q + 1) + H * Q;
          p.push(J, ie, ge), p.push(ie, ne, ge), X += 6;
        }
      h.addGroup(T, X, j), T += X, E += V;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Mi(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
function ai(t) {
  const e = {};
  for (const n in t) {
    e[n] = {};
    for (const o in t[n]) {
      const l = t[n][o];
      l && (l.isColor || l.isMatrix3 || l.isMatrix4 || l.isVector2 || l.isVector3 || l.isVector4 || l.isTexture || l.isQuaternion) ? l.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[n][o] = null) : e[n][o] = l.clone() : Array.isArray(l) ? e[n][o] = l.slice() : e[n][o] = l;
    }
  }
  return e;
}
function vt(t) {
  const e = {};
  for (let n = 0; n < t.length; n++) {
    const o = ai(t[n]);
    for (const l in o)
      e[l] = o[l];
  }
  return e;
}
function pc(t) {
  const e = [];
  for (let n = 0; n < t.length; n++)
    e.push(t[n].clone());
  return e;
}
function xo(t) {
  return t.getRenderTarget() === null ? t.outputColorSpace : je.workingColorSpace;
}
const mc = { clone: ai, merge: vt };
var _c = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, gc = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class fn extends xi {
  constructor(e) {
    super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = _c, this.fragmentShader = gc, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
      derivatives: !1,
      // set to use derivatives
      fragDepth: !1,
      // set to use fragment depth values
      drawBuffers: !1,
      // set to use draw buffers
      shaderTextureLOD: !1,
      // set to use shader texture LOD
      clipCullDistance: !1,
      // set to use vertex shader clipping
      multiDraw: !1
      // set to use vertex shader multi_draw / enable gl_DrawID
    }, this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv1: [0, 0]
    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = ai(e.uniforms), this.uniformsGroups = pc(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
  }
  toJSON(e) {
    const n = super.toJSON(e);
    n.glslVersion = this.glslVersion, n.uniforms = {};
    for (const l in this.uniforms) {
      const u = this.uniforms[l].value;
      u && u.isTexture ? n.uniforms[l] = {
        type: "t",
        value: u.toJSON(e).uuid
      } : u && u.isColor ? n.uniforms[l] = {
        type: "c",
        value: u.getHex()
      } : u && u.isVector2 ? n.uniforms[l] = {
        type: "v2",
        value: u.toArray()
      } : u && u.isVector3 ? n.uniforms[l] = {
        type: "v3",
        value: u.toArray()
      } : u && u.isVector4 ? n.uniforms[l] = {
        type: "v4",
        value: u.toArray()
      } : u && u.isMatrix3 ? n.uniforms[l] = {
        type: "m3",
        value: u.toArray()
      } : u && u.isMatrix4 ? n.uniforms[l] = {
        type: "m4",
        value: u.toArray()
      } : n.uniforms[l] = {
        value: u
      };
    }
    Object.keys(this.defines).length > 0 && (n.defines = this.defines), n.vertexShader = this.vertexShader, n.fragmentShader = this.fragmentShader, n.lights = this.lights, n.clipping = this.clipping;
    const o = {};
    for (const l in this.extensions)
      this.extensions[l] === !0 && (o[l] = !0);
    return Object.keys(o).length > 0 && (n.extensions = o), n;
  }
}
class Mo extends Mt {
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new st(), this.projectionMatrix = new st(), this.projectionMatrixInverse = new st(), this.coordinateSystem = Zt;
  }
  copy(e, n) {
    return super.copy(e, n), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this;
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, n) {
    super.updateWorldMatrix(e, n), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const rn = /* @__PURE__ */ new I(), va = /* @__PURE__ */ new Ie(), xa = /* @__PURE__ */ new Ie();
class Lt extends Mo {
  constructor(e = 50, n = 1, o = 0.1, l = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = o, this.far = l, this.focus = 10, this.aspect = n, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(e, n) {
    return super.copy(e, n), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(e) {
    const n = 0.5 * this.getFilmHeight() / e;
    this.fov = gi * 2 * Math.atan(n), this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength() {
    const e = Math.tan(ei * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  }
  getEffectiveFOV() {
    return gi * 2 * Math.atan(
      Math.tan(ei * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
   * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.
   */
  getViewBounds(e, n, o) {
    rn.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), n.set(rn.x, rn.y).multiplyScalar(-e / rn.z), rn.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), o.set(rn.x, rn.y).multiplyScalar(-e / rn.z);
  }
  /**
   * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
   * Copies the result into the target Vector2, where x is width and y is height.
   */
  getViewSize(e, n) {
    return this.getViewBounds(e, va, xa), n.subVectors(xa, va);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset(e, n, o, l, u, f) {
    this.aspect = e / n, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = n, this.view.offsetX = o, this.view.offsetY = l, this.view.width = u, this.view.height = f, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let n = e * Math.tan(ei * 0.5 * this.fov) / this.zoom, o = 2 * n, l = this.aspect * o, u = -0.5 * l;
    const f = this.view;
    if (this.view !== null && this.view.enabled) {
      const p = f.fullWidth, v = f.fullHeight;
      u += f.offsetX * l / p, n -= f.offsetY * o / v, l *= f.width / p, o *= f.height / v;
    }
    const h = this.filmOffset;
    h !== 0 && (u += e * h / this.getFilmWidth()), this.projectionMatrix.makePerspective(u, u + l, n, n - o, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return n.object.fov = this.fov, n.object.zoom = this.zoom, n.object.near = this.near, n.object.far = this.far, n.object.focus = this.focus, n.object.aspect = this.aspect, this.view !== null && (n.object.view = Object.assign({}, this.view)), n.object.filmGauge = this.filmGauge, n.object.filmOffset = this.filmOffset, n;
  }
}
const qn = -90, jn = 1;
class vc extends Mt {
  constructor(e, n, o) {
    super(), this.type = "CubeCamera", this.renderTarget = o, this.coordinateSystem = null, this.activeMipmapLevel = 0;
    const l = new Lt(qn, jn, e, n);
    l.layers = this.layers, this.add(l);
    const u = new Lt(qn, jn, e, n);
    u.layers = this.layers, this.add(u);
    const f = new Lt(qn, jn, e, n);
    f.layers = this.layers, this.add(f);
    const h = new Lt(qn, jn, e, n);
    h.layers = this.layers, this.add(h);
    const p = new Lt(qn, jn, e, n);
    p.layers = this.layers, this.add(p);
    const v = new Lt(qn, jn, e, n);
    v.layers = this.layers, this.add(v);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem, n = this.children.concat(), [o, l, u, f, h, p] = n;
    for (const v of n)
      this.remove(v);
    if (e === Zt)
      o.up.set(0, 1, 0), o.lookAt(1, 0, 0), l.up.set(0, 1, 0), l.lookAt(-1, 0, 0), u.up.set(0, 0, -1), u.lookAt(0, 1, 0), f.up.set(0, 0, 1), f.lookAt(0, -1, 0), h.up.set(0, 1, 0), h.lookAt(0, 0, 1), p.up.set(0, 1, 0), p.lookAt(0, 0, -1);
    else if (e === ir)
      o.up.set(0, -1, 0), o.lookAt(-1, 0, 0), l.up.set(0, -1, 0), l.lookAt(1, 0, 0), u.up.set(0, 0, 1), u.lookAt(0, 1, 0), f.up.set(0, 0, -1), f.lookAt(0, -1, 0), h.up.set(0, -1, 0), h.lookAt(0, 0, 1), p.up.set(0, -1, 0), p.lookAt(0, 0, -1);
    else
      throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
    for (const v of n)
      this.add(v), v.updateMatrixWorld();
  }
  update(e, n) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: o, activeMipmapLevel: l } = this;
    this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
    const [u, f, h, p, v, g] = this.children, w = e.getRenderTarget(), E = e.getActiveCubeFace(), T = e.getActiveMipmapLevel(), R = e.xr.enabled;
    e.xr.enabled = !1;
    const _ = o.texture.generateMipmaps;
    o.texture.generateMipmaps = !1, e.setRenderTarget(o, 0, l), e.render(n, u), e.setRenderTarget(o, 1, l), e.render(n, f), e.setRenderTarget(o, 2, l), e.render(n, h), e.setRenderTarget(o, 3, l), e.render(n, p), e.setRenderTarget(o, 4, l), e.render(n, v), o.texture.generateMipmaps = _, e.setRenderTarget(o, 5, l), e.render(n, g), e.setRenderTarget(w, E, T), e.xr.enabled = R, o.texture.needsPMREMUpdate = !0;
  }
}
class So extends yt {
  constructor(e, n, o, l, u, f, h, p, v, g) {
    e = e !== void 0 ? e : [], n = n !== void 0 ? n : ii, super(e, n, o, l, u, f, h, p, v, g), this.isCubeTexture = !0, this.flipY = !1;
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class xc extends Cn {
  constructor(e = 1, n = {}) {
    super(e, e, n), this.isWebGLCubeRenderTarget = !0;
    const o = { width: e, height: e, depth: 1 }, l = [o, o, o, o, o, o];
    this.texture = new So(l, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = n.generateMipmaps !== void 0 ? n.generateMipmaps : !1, this.texture.minFilter = n.minFilter !== void 0 ? n.minFilter : St;
  }
  fromEquirectangularTexture(e, n) {
    this.texture.type = n.type, this.texture.colorSpace = n.colorSpace, this.texture.generateMipmaps = n.generateMipmaps, this.texture.minFilter = n.minFilter, this.texture.magFilter = n.magFilter;
    const o = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    }, l = new Mi(5, 5, 5), u = new fn({
      name: "CubemapFromEquirect",
      uniforms: ai(o.uniforms),
      vertexShader: o.vertexShader,
      fragmentShader: o.fragmentShader,
      side: Et,
      blending: ln$1
    });
    u.uniforms.tEquirect.value = n;
    const f = new Rt(l, u), h = n.minFilter;
    return n.minFilter === An && (n.minFilter = St), new vc(1, 10, this).update(e, f), n.minFilter = h, f.geometry.dispose(), f.material.dispose(), this;
  }
  clear(e, n, o, l) {
    const u = e.getRenderTarget();
    for (let f = 0; f < 6; f++)
      e.setRenderTarget(this, f), e.clear(n, o, l);
    e.setRenderTarget(u);
  }
}
const Hr = /* @__PURE__ */ new I(), Mc = /* @__PURE__ */ new I(), Sc = /* @__PURE__ */ new Ge();
class sn {
  constructor(e = new I(1, 0, 0), n = 0) {
    this.isPlane = !0, this.normal = e, this.constant = n;
  }
  set(e, n) {
    return this.normal.copy(e), this.constant = n, this;
  }
  setComponents(e, n, o, l) {
    return this.normal.set(e, n, o), this.constant = l, this;
  }
  setFromNormalAndCoplanarPoint(e, n) {
    return this.normal.copy(e), this.constant = -n.dot(this.normal), this;
  }
  setFromCoplanarPoints(e, n, o) {
    const l = Hr.subVectors(o, n).cross(Mc.subVectors(e, n)).normalize();
    return this.setFromNormalAndCoplanarPoint(l, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, n) {
    return n.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, n) {
    const o = e.delta(Hr), l = this.normal.dot(o);
    if (l === 0)
      return this.distanceToPoint(e.start) === 0 ? n.copy(e.start) : null;
    const u = -(e.start.dot(this.normal) + this.constant) / l;
    return u < 0 || u > 1 ? null : n.copy(e.start).addScaledVector(o, u);
  }
  intersectsLine(e) {
    const n = this.distanceToPoint(e.start), o = this.distanceToPoint(e.end);
    return n < 0 && o > 0 || o < 0 && n > 0;
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, n) {
    const o = n || Sc.getNormalMatrix(e), l = this.coplanarPoint(Hr).applyMatrix4(e), u = this.normal.applyMatrix3(o).normalize();
    return this.constant = -l.dot(u), this;
  }
  translate(e) {
    return this.constant -= e.dot(this.normal), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Mn = /* @__PURE__ */ new ur(), Vi = /* @__PURE__ */ new I();
class Eo {
  constructor(e = new sn(), n = new sn(), o = new sn(), l = new sn(), u = new sn(), f = new sn()) {
    this.planes = [e, n, o, l, u, f];
  }
  set(e, n, o, l, u, f) {
    const h = this.planes;
    return h[0].copy(e), h[1].copy(n), h[2].copy(o), h[3].copy(l), h[4].copy(u), h[5].copy(f), this;
  }
  copy(e) {
    const n = this.planes;
    for (let o = 0; o < 6; o++)
      n[o].copy(e.planes[o]);
    return this;
  }
  setFromProjectionMatrix(e, n = Zt) {
    const o = this.planes, l = e.elements, u = l[0], f = l[1], h = l[2], p = l[3], v = l[4], g = l[5], w = l[6], E = l[7], T = l[8], R = l[9], _ = l[10], b = l[11], M = l[12], A = l[13], $ = l[14], S = l[15];
    if (o[0].setComponents(p - u, E - v, b - T, S - M).normalize(), o[1].setComponents(p + u, E + v, b + T, S + M).normalize(), o[2].setComponents(p + f, E + g, b + R, S + A).normalize(), o[3].setComponents(p - f, E - g, b - R, S - A).normalize(), o[4].setComponents(p - h, E - w, b - _, S - $).normalize(), n === Zt)
      o[5].setComponents(p + h, E + w, b + _, S + $).normalize();
    else if (n === ir)
      o[5].setComponents(h, w, _, $).normalize();
    else
      throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + n);
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(), Mn.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const n = e.geometry;
      n.boundingSphere === null && n.computeBoundingSphere(), Mn.copy(n.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(Mn);
  }
  intersectsSprite(e) {
    return Mn.center.set(0, 0, 0), Mn.radius = 0.7071067811865476, Mn.applyMatrix4(e.matrixWorld), this.intersectsSphere(Mn);
  }
  intersectsSphere(e) {
    const n = this.planes, o = e.center, l = -e.radius;
    for (let u = 0; u < 6; u++)
      if (n[u].distanceToPoint(o) < l)
        return !1;
    return !0;
  }
  intersectsBox(e) {
    const n = this.planes;
    for (let o = 0; o < 6; o++) {
      const l = n[o];
      if (Vi.x = l.normal.x > 0 ? e.max.x : e.min.x, Vi.y = l.normal.y > 0 ? e.max.y : e.min.y, Vi.z = l.normal.z > 0 ? e.max.z : e.min.z, l.distanceToPoint(Vi) < 0)
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const n = this.planes;
    for (let o = 0; o < 6; o++)
      if (n[o].distanceToPoint(e) < 0)
        return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function yo() {
  let t = null, e = !1, n = null, o = null;
  function l(u, f) {
    n(u, f), o = t.requestAnimationFrame(l);
  }
  return {
    start: function() {
      e !== !0 && n !== null && (o = t.requestAnimationFrame(l), e = !0);
    },
    stop: function() {
      t.cancelAnimationFrame(o), e = !1;
    },
    setAnimationLoop: function(u) {
      n = u;
    },
    setContext: function(u) {
      t = u;
    }
  };
}
function Ec(t, e) {
  const n = e.isWebGL2, o = /* @__PURE__ */ new WeakMap();
  function l(v, g) {
    const w = v.array, E = v.usage, T = w.byteLength, R = t.createBuffer();
    t.bindBuffer(g, R), t.bufferData(g, w, E), v.onUploadCallback();
    let _;
    if (w instanceof Float32Array)
      _ = t.FLOAT;
    else if (w instanceof Uint16Array)
      if (v.isFloat16BufferAttribute)
        if (n)
          _ = t.HALF_FLOAT;
        else
          throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
      else
        _ = t.UNSIGNED_SHORT;
    else if (w instanceof Int16Array)
      _ = t.SHORT;
    else if (w instanceof Uint32Array)
      _ = t.UNSIGNED_INT;
    else if (w instanceof Int32Array)
      _ = t.INT;
    else if (w instanceof Int8Array)
      _ = t.BYTE;
    else if (w instanceof Uint8Array)
      _ = t.UNSIGNED_BYTE;
    else if (w instanceof Uint8ClampedArray)
      _ = t.UNSIGNED_BYTE;
    else
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + w);
    return {
      buffer: R,
      type: _,
      bytesPerElement: w.BYTES_PER_ELEMENT,
      version: v.version,
      size: T
    };
  }
  function u(v, g, w) {
    const E = g.array, T = g._updateRange, R = g.updateRanges;
    if (t.bindBuffer(w, v), T.count === -1 && R.length === 0 && t.bufferSubData(w, 0, E), R.length !== 0) {
      for (let _ = 0, b = R.length; _ < b; _++) {
        const M = R[_];
        n ? t.bufferSubData(
          w,
          M.start * E.BYTES_PER_ELEMENT,
          E,
          M.start,
          M.count
        ) : t.bufferSubData(
          w,
          M.start * E.BYTES_PER_ELEMENT,
          E.subarray(M.start, M.start + M.count)
        );
      }
      g.clearUpdateRanges();
    }
    T.count !== -1 && (n ? t.bufferSubData(
      w,
      T.offset * E.BYTES_PER_ELEMENT,
      E,
      T.offset,
      T.count
    ) : t.bufferSubData(
      w,
      T.offset * E.BYTES_PER_ELEMENT,
      E.subarray(T.offset, T.offset + T.count)
    ), T.count = -1), g.onUploadCallback();
  }
  function f(v) {
    return v.isInterleavedBufferAttribute && (v = v.data), o.get(v);
  }
  function h(v) {
    v.isInterleavedBufferAttribute && (v = v.data);
    const g = o.get(v);
    g && (t.deleteBuffer(g.buffer), o.delete(v));
  }
  function p(v, g) {
    if (v.isGLBufferAttribute) {
      const E = o.get(v);
      (!E || E.version < v.version) && o.set(v, {
        buffer: v.buffer,
        type: v.type,
        bytesPerElement: v.elementSize,
        version: v.version
      });
      return;
    }
    v.isInterleavedBufferAttribute && (v = v.data);
    const w = o.get(v);
    if (w === void 0)
      o.set(v, l(v, g));
    else if (w.version < v.version) {
      if (w.size !== v.array.byteLength)
        throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
      u(w.buffer, v, g), w.version = v.version;
    }
  }
  return {
    get: f,
    remove: h,
    update: p
  };
}
class hr extends Tt {
  constructor(e = 1, n = 1, o = 1, l = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = {
      width: e,
      height: n,
      widthSegments: o,
      heightSegments: l
    };
    const u = e / 2, f = n / 2, h = Math.floor(o), p = Math.floor(l), v = h + 1, g = p + 1, w = e / h, E = n / p, T = [], R = [], _ = [], b = [];
    for (let M = 0; M < g; M++) {
      const A = M * E - f;
      for (let $ = 0; $ < v; $++) {
        const S = $ * w - u;
        R.push(S, -A, 0), _.push(0, 0, 1), b.push($ / h), b.push(1 - M / p);
      }
    }
    for (let M = 0; M < p; M++)
      for (let A = 0; A < h; A++) {
        const $ = A + v * M, S = A + v * (M + 1), C = A + 1 + v * (M + 1), D = A + 1 + v * M;
        T.push($, S, D), T.push(S, C, D);
      }
    this.setIndex(T), this.setAttribute("position", new ut(R, 3)), this.setAttribute("normal", new ut(_, 3)), this.setAttribute("uv", new ut(b, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new hr(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var yc = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, Tc = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, bc = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, Ac = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, wc = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`, Rc = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, Cc = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, Pc = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, Lc = `#ifdef USE_BATCHING
	attribute float batchId;
	uniform highp sampler2D batchingTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, Dc = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( batchId );
#endif`, Uc = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, Ic = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, Nc = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, Fc = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, Oc = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, Bc = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`, zc = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, Gc = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, Hc = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, Vc = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, kc = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, Wc = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`, Xc = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`, Yc = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, qc = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, jc = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, Kc = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, Zc = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, $c = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, Jc = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, Qc = "gl_FragColor = linearToOutputTexel( gl_FragColor );", eu = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`, tu = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, nu = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, iu = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, ru = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, su = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, au = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, ou = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, lu = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, cu = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, uu = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, hu = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`, fu = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, du = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, pu = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, mu = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, _u = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, gu = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, vu = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, xu = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, Mu = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, Su = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, Eu = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, yu = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, Tu = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, bu = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, Au = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, wu = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, Ru = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`, Cu = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`, Pu = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, Lu = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, Du = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, Uu = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, Iu = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, Nu = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, Fu = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[MORPHTARGETS_COUNT];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`, Ou = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, Bu = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`, zu = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
	#endif
	#ifdef MORPHTARGETS_TEXTURE
		#ifndef USE_INSTANCING_MORPH
			uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		#endif
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`, Gu = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`, Hu = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, Vu = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, ku = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, Wu = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, Xu = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, Yu = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, qu = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, ju = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, Ku = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, Zu = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, $u = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, Ju = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, Qu = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, eh = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, th = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, nh = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, ih = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, rh = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, sh = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`, ah = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, oh = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, lh = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, ch = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, uh = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, hh = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, fh = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, dh = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, ph = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, mh = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, _h = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	float startCompression = 0.8 - 0.04;
	float desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min(color.r, min(color.g, color.b));
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max(color.r, max(color.g, color.b));
	if (peak < startCompression) return color;
	float d = 1. - startCompression;
	float newPeak = 1. - d * d / (peak + d - startCompression);
	color *= newPeak / peak;
	float g = 1. - 1. / (desaturation * (peak - newPeak) + 1.);
	return mix(color, vec3(1, 1, 1), g);
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, gh = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, vh = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, xh = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, Mh = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, Sh = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, Eh = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const yh = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, Th = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, bh = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, Ah = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, wh = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, Rh = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, Ch = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, Ph = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, Lh = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, Dh = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, Uh = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, Ih = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, Nh = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, Fh = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, Oh = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, Bh = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, zh = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Gh = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Hh = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, Vh = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, kh = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, Wh = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, Xh = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Yh = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, qh = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, jh = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Kh = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Zh = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, $h = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, Jh = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, Qh = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, ef = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, tf = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, nf = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, ze = {
  alphahash_fragment: yc,
  alphahash_pars_fragment: Tc,
  alphamap_fragment: bc,
  alphamap_pars_fragment: Ac,
  alphatest_fragment: wc,
  alphatest_pars_fragment: Rc,
  aomap_fragment: Cc,
  aomap_pars_fragment: Pc,
  batching_pars_vertex: Lc,
  batching_vertex: Dc,
  begin_vertex: Uc,
  beginnormal_vertex: Ic,
  bsdfs: Nc,
  iridescence_fragment: Fc,
  bumpmap_pars_fragment: Oc,
  clipping_planes_fragment: Bc,
  clipping_planes_pars_fragment: zc,
  clipping_planes_pars_vertex: Gc,
  clipping_planes_vertex: Hc,
  color_fragment: Vc,
  color_pars_fragment: kc,
  color_pars_vertex: Wc,
  color_vertex: Xc,
  common: Yc,
  cube_uv_reflection_fragment: qc,
  defaultnormal_vertex: jc,
  displacementmap_pars_vertex: Kc,
  displacementmap_vertex: Zc,
  emissivemap_fragment: $c,
  emissivemap_pars_fragment: Jc,
  colorspace_fragment: Qc,
  colorspace_pars_fragment: eu,
  envmap_fragment: tu,
  envmap_common_pars_fragment: nu,
  envmap_pars_fragment: iu,
  envmap_pars_vertex: ru,
  envmap_physical_pars_fragment: _u,
  envmap_vertex: su,
  fog_vertex: au,
  fog_pars_vertex: ou,
  fog_fragment: lu,
  fog_pars_fragment: cu,
  gradientmap_pars_fragment: uu,
  lightmap_fragment: hu,
  lightmap_pars_fragment: fu,
  lights_lambert_fragment: du,
  lights_lambert_pars_fragment: pu,
  lights_pars_begin: mu,
  lights_toon_fragment: gu,
  lights_toon_pars_fragment: vu,
  lights_phong_fragment: xu,
  lights_phong_pars_fragment: Mu,
  lights_physical_fragment: Su,
  lights_physical_pars_fragment: Eu,
  lights_fragment_begin: yu,
  lights_fragment_maps: Tu,
  lights_fragment_end: bu,
  logdepthbuf_fragment: Au,
  logdepthbuf_pars_fragment: wu,
  logdepthbuf_pars_vertex: Ru,
  logdepthbuf_vertex: Cu,
  map_fragment: Pu,
  map_pars_fragment: Lu,
  map_particle_fragment: Du,
  map_particle_pars_fragment: Uu,
  metalnessmap_fragment: Iu,
  metalnessmap_pars_fragment: Nu,
  morphinstance_vertex: Fu,
  morphcolor_vertex: Ou,
  morphnormal_vertex: Bu,
  morphtarget_pars_vertex: zu,
  morphtarget_vertex: Gu,
  normal_fragment_begin: Hu,
  normal_fragment_maps: Vu,
  normal_pars_fragment: ku,
  normal_pars_vertex: Wu,
  normal_vertex: Xu,
  normalmap_pars_fragment: Yu,
  clearcoat_normal_fragment_begin: qu,
  clearcoat_normal_fragment_maps: ju,
  clearcoat_pars_fragment: Ku,
  iridescence_pars_fragment: Zu,
  opaque_fragment: $u,
  packing: Ju,
  premultiplied_alpha_fragment: Qu,
  project_vertex: eh,
  dithering_fragment: th,
  dithering_pars_fragment: nh,
  roughnessmap_fragment: ih,
  roughnessmap_pars_fragment: rh,
  shadowmap_pars_fragment: sh,
  shadowmap_pars_vertex: ah,
  shadowmap_vertex: oh,
  shadowmask_pars_fragment: lh,
  skinbase_vertex: ch,
  skinning_pars_vertex: uh,
  skinning_vertex: hh,
  skinnormal_vertex: fh,
  specularmap_fragment: dh,
  specularmap_pars_fragment: ph,
  tonemapping_fragment: mh,
  tonemapping_pars_fragment: _h,
  transmission_fragment: gh,
  transmission_pars_fragment: vh,
  uv_pars_fragment: xh,
  uv_pars_vertex: Mh,
  uv_vertex: Sh,
  worldpos_vertex: Eh,
  background_vert: yh,
  background_frag: Th,
  backgroundCube_vert: bh,
  backgroundCube_frag: Ah,
  cube_vert: wh,
  cube_frag: Rh,
  depth_vert: Ch,
  depth_frag: Ph,
  distanceRGBA_vert: Lh,
  distanceRGBA_frag: Dh,
  equirect_vert: Uh,
  equirect_frag: Ih,
  linedashed_vert: Nh,
  linedashed_frag: Fh,
  meshbasic_vert: Oh,
  meshbasic_frag: Bh,
  meshlambert_vert: zh,
  meshlambert_frag: Gh,
  meshmatcap_vert: Hh,
  meshmatcap_frag: Vh,
  meshnormal_vert: kh,
  meshnormal_frag: Wh,
  meshphong_vert: Xh,
  meshphong_frag: Yh,
  meshphysical_vert: qh,
  meshphysical_frag: jh,
  meshtoon_vert: Kh,
  meshtoon_frag: Zh,
  points_vert: $h,
  points_frag: Jh,
  shadow_vert: Qh,
  shadow_frag: ef,
  sprite_vert: tf,
  sprite_frag: nf
}, oe = {
  common: {
    diffuse: { value: /* @__PURE__ */ new qe(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new Ge() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Ge() },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null },
    specularMapTransform: { value: /* @__PURE__ */ new Ge() }
  },
  envmap: {
    envMap: { value: null },
    envMapRotation: { value: /* @__PURE__ */ new Ge() },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    // basic, lambert, phong
    ior: { value: 1.5 },
    // physical
    refractionRatio: { value: 0.98 }
    // basic, lambert, phong
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 },
    aoMapTransform: { value: /* @__PURE__ */ new Ge() }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 },
    lightMapTransform: { value: /* @__PURE__ */ new Ge() }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpMapTransform: { value: /* @__PURE__ */ new Ge() },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalMapTransform: { value: /* @__PURE__ */ new Ge() },
    normalScale: { value: /* @__PURE__ */ new Ie(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementMapTransform: { value: /* @__PURE__ */ new Ge() },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  emissivemap: {
    emissiveMap: { value: null },
    emissiveMapTransform: { value: /* @__PURE__ */ new Ge() }
  },
  metalnessmap: {
    metalnessMap: { value: null },
    metalnessMapTransform: { value: /* @__PURE__ */ new Ge() }
  },
  roughnessmap: {
    roughnessMap: { value: null },
    roughnessMapTransform: { value: /* @__PURE__ */ new Ge() }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: /* @__PURE__ */ new qe(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotLightMap: { value: [] },
    spotShadowMap: { value: [] },
    spotLightMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: /* @__PURE__ */ new qe(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Ge() },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new Ge() }
  },
  sprite: {
    diffuse: { value: /* @__PURE__ */ new qe(16777215) },
    opacity: { value: 1 },
    center: { value: /* @__PURE__ */ new Ie(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new Ge() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Ge() },
    alphaTest: { value: 0 }
  }
}, zt = {
  basic: {
    uniforms: /* @__PURE__ */ vt([
      oe.common,
      oe.specularmap,
      oe.envmap,
      oe.aomap,
      oe.lightmap,
      oe.fog
    ]),
    vertexShader: ze.meshbasic_vert,
    fragmentShader: ze.meshbasic_frag
  },
  lambert: {
    uniforms: /* @__PURE__ */ vt([
      oe.common,
      oe.specularmap,
      oe.envmap,
      oe.aomap,
      oe.lightmap,
      oe.emissivemap,
      oe.bumpmap,
      oe.normalmap,
      oe.displacementmap,
      oe.fog,
      oe.lights,
      {
        emissive: { value: /* @__PURE__ */ new qe(0) }
      }
    ]),
    vertexShader: ze.meshlambert_vert,
    fragmentShader: ze.meshlambert_frag
  },
  phong: {
    uniforms: /* @__PURE__ */ vt([
      oe.common,
      oe.specularmap,
      oe.envmap,
      oe.aomap,
      oe.lightmap,
      oe.emissivemap,
      oe.bumpmap,
      oe.normalmap,
      oe.displacementmap,
      oe.fog,
      oe.lights,
      {
        emissive: { value: /* @__PURE__ */ new qe(0) },
        specular: { value: /* @__PURE__ */ new qe(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: ze.meshphong_vert,
    fragmentShader: ze.meshphong_frag
  },
  standard: {
    uniforms: /* @__PURE__ */ vt([
      oe.common,
      oe.envmap,
      oe.aomap,
      oe.lightmap,
      oe.emissivemap,
      oe.bumpmap,
      oe.normalmap,
      oe.displacementmap,
      oe.roughnessmap,
      oe.metalnessmap,
      oe.fog,
      oe.lights,
      {
        emissive: { value: /* @__PURE__ */ new qe(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
        // temporary
      }
    ]),
    vertexShader: ze.meshphysical_vert,
    fragmentShader: ze.meshphysical_frag
  },
  toon: {
    uniforms: /* @__PURE__ */ vt([
      oe.common,
      oe.aomap,
      oe.lightmap,
      oe.emissivemap,
      oe.bumpmap,
      oe.normalmap,
      oe.displacementmap,
      oe.gradientmap,
      oe.fog,
      oe.lights,
      {
        emissive: { value: /* @__PURE__ */ new qe(0) }
      }
    ]),
    vertexShader: ze.meshtoon_vert,
    fragmentShader: ze.meshtoon_frag
  },
  matcap: {
    uniforms: /* @__PURE__ */ vt([
      oe.common,
      oe.bumpmap,
      oe.normalmap,
      oe.displacementmap,
      oe.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: ze.meshmatcap_vert,
    fragmentShader: ze.meshmatcap_frag
  },
  points: {
    uniforms: /* @__PURE__ */ vt([
      oe.points,
      oe.fog
    ]),
    vertexShader: ze.points_vert,
    fragmentShader: ze.points_frag
  },
  dashed: {
    uniforms: /* @__PURE__ */ vt([
      oe.common,
      oe.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: ze.linedashed_vert,
    fragmentShader: ze.linedashed_frag
  },
  depth: {
    uniforms: /* @__PURE__ */ vt([
      oe.common,
      oe.displacementmap
    ]),
    vertexShader: ze.depth_vert,
    fragmentShader: ze.depth_frag
  },
  normal: {
    uniforms: /* @__PURE__ */ vt([
      oe.common,
      oe.bumpmap,
      oe.normalmap,
      oe.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ze.meshnormal_vert,
    fragmentShader: ze.meshnormal_frag
  },
  sprite: {
    uniforms: /* @__PURE__ */ vt([
      oe.sprite,
      oe.fog
    ]),
    vertexShader: ze.sprite_vert,
    fragmentShader: ze.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: /* @__PURE__ */ new Ge() },
      t2D: { value: null },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: ze.background_vert,
    fragmentShader: ze.background_frag
  },
  backgroundCube: {
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      backgroundBlurriness: { value: 0 },
      backgroundIntensity: { value: 1 },
      backgroundRotation: { value: /* @__PURE__ */ new Ge() }
    },
    vertexShader: ze.backgroundCube_vert,
    fragmentShader: ze.backgroundCube_frag
  },
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 }
    },
    vertexShader: ze.cube_vert,
    fragmentShader: ze.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: ze.equirect_vert,
    fragmentShader: ze.equirect_frag
  },
  distanceRGBA: {
    uniforms: /* @__PURE__ */ vt([
      oe.common,
      oe.displacementmap,
      {
        referencePosition: { value: /* @__PURE__ */ new I() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: ze.distanceRGBA_vert,
    fragmentShader: ze.distanceRGBA_frag
  },
  shadow: {
    uniforms: /* @__PURE__ */ vt([
      oe.lights,
      oe.fog,
      {
        color: { value: /* @__PURE__ */ new qe(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ze.shadow_vert,
    fragmentShader: ze.shadow_frag
  }
};
zt.physical = {
  uniforms: /* @__PURE__ */ vt([
    zt.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: /* @__PURE__ */ new Ge() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: /* @__PURE__ */ new Ge() },
      clearcoatNormalScale: { value: /* @__PURE__ */ new Ie(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: /* @__PURE__ */ new Ge() },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: /* @__PURE__ */ new Ge() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: /* @__PURE__ */ new Ge() },
      sheen: { value: 0 },
      sheenColor: { value: /* @__PURE__ */ new qe(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: /* @__PURE__ */ new Ge() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: /* @__PURE__ */ new Ge() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: /* @__PURE__ */ new Ge() },
      transmissionSamplerSize: { value: /* @__PURE__ */ new Ie() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: /* @__PURE__ */ new Ge() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: /* @__PURE__ */ new qe(0) },
      specularColor: { value: /* @__PURE__ */ new qe(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: /* @__PURE__ */ new Ge() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: /* @__PURE__ */ new Ge() },
      anisotropyVector: { value: /* @__PURE__ */ new Ie() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: /* @__PURE__ */ new Ge() }
    }
  ]),
  vertexShader: ze.meshphysical_vert,
  fragmentShader: ze.meshphysical_frag
};
const ki = { r: 0, b: 0, g: 0 }, Sn = /* @__PURE__ */ new $t(), rf = /* @__PURE__ */ new st();
function sf(t, e, n, o, l, u, f) {
  const h = new qe(0);
  let p = u === !0 ? 0 : 1, v, g, w = null, E = 0, T = null;
  function R(b, M) {
    let A = !1, $ = M.isScene === !0 ? M.background : null;
    $ && $.isTexture && ($ = (M.backgroundBlurriness > 0 ? n : e).get($)), $ === null ? _(h, p) : $ && $.isColor && (_($, 1), A = !0);
    const S = t.xr.getEnvironmentBlendMode();
    S === "additive" ? o.buffers.color.setClear(0, 0, 0, 1, f) : S === "alpha-blend" && o.buffers.color.setClear(0, 0, 0, 0, f), (t.autoClear || A) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), $ && ($.isCubeTexture || $.mapping === lr) ? (g === void 0 && (g = new Rt(
      new Mi(1, 1, 1),
      new fn({
        name: "BackgroundCubeMaterial",
        uniforms: ai(zt.backgroundCube.uniforms),
        vertexShader: zt.backgroundCube.vertexShader,
        fragmentShader: zt.backgroundCube.fragmentShader,
        side: Et,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), g.geometry.deleteAttribute("normal"), g.geometry.deleteAttribute("uv"), g.onBeforeRender = function(C, D, O) {
      this.matrixWorld.copyPosition(O.matrixWorld);
    }, Object.defineProperty(g.material, "envMap", {
      get: function() {
        return this.uniforms.envMap.value;
      }
    }), l.update(g)), Sn.copy(M.backgroundRotation), Sn.x *= -1, Sn.y *= -1, Sn.z *= -1, $.isCubeTexture && $.isRenderTargetTexture === !1 && (Sn.y *= -1, Sn.z *= -1), g.material.uniforms.envMap.value = $, g.material.uniforms.flipEnvMap.value = $.isCubeTexture && $.isRenderTargetTexture === !1 ? -1 : 1, g.material.uniforms.backgroundBlurriness.value = M.backgroundBlurriness, g.material.uniforms.backgroundIntensity.value = M.backgroundIntensity, g.material.uniforms.backgroundRotation.value.setFromMatrix4(rf.makeRotationFromEuler(Sn)), g.material.toneMapped = je.getTransfer($.colorSpace) !== $e, (w !== $ || E !== $.version || T !== t.toneMapping) && (g.material.needsUpdate = !0, w = $, E = $.version, T = t.toneMapping), g.layers.enableAll(), b.unshift(g, g.geometry, g.material, 0, 0, null)) : $ && $.isTexture && (v === void 0 && (v = new Rt(
      new hr(2, 2),
      new fn({
        name: "BackgroundMaterial",
        uniforms: ai(zt.background.uniforms),
        vertexShader: zt.background.vertexShader,
        fragmentShader: zt.background.fragmentShader,
        side: hn,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), v.geometry.deleteAttribute("normal"), Object.defineProperty(v.material, "map", {
      get: function() {
        return this.uniforms.t2D.value;
      }
    }), l.update(v)), v.material.uniforms.t2D.value = $, v.material.uniforms.backgroundIntensity.value = M.backgroundIntensity, v.material.toneMapped = je.getTransfer($.colorSpace) !== $e, $.matrixAutoUpdate === !0 && $.updateMatrix(), v.material.uniforms.uvTransform.value.copy($.matrix), (w !== $ || E !== $.version || T !== t.toneMapping) && (v.material.needsUpdate = !0, w = $, E = $.version, T = t.toneMapping), v.layers.enableAll(), b.unshift(v, v.geometry, v.material, 0, 0, null));
  }
  function _(b, M) {
    b.getRGB(ki, xo(t)), o.buffers.color.setClear(ki.r, ki.g, ki.b, M, f);
  }
  return {
    getClearColor: function() {
      return h;
    },
    setClearColor: function(b, M = 1) {
      h.set(b), p = M, _(h, p);
    },
    getClearAlpha: function() {
      return p;
    },
    setClearAlpha: function(b) {
      p = b, _(h, p);
    },
    render: R
  };
}
function af(t, e, n, o) {
  const l = t.getParameter(t.MAX_VERTEX_ATTRIBS), u = o.isWebGL2 ? null : e.get("OES_vertex_array_object"), f = o.isWebGL2 || u !== null, h = {}, p = b(null);
  let v = p, g = !1;
  function w(F, H, W, V, X) {
    let Z = !1;
    if (f) {
      const Q = _(V, W, H);
      v !== Q && (v = Q, T(v.object)), Z = M(F, V, W, X), Z && A(F, V, W, X);
    } else {
      const Q = H.wireframe === !0;
      (v.geometry !== V.id || v.program !== W.id || v.wireframe !== Q) && (v.geometry = V.id, v.program = W.id, v.wireframe = Q, Z = !0);
    }
    X !== null && n.update(X, t.ELEMENT_ARRAY_BUFFER), (Z || g) && (g = !1, N(F, H, W, V), X !== null && t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, n.get(X).buffer));
  }
  function E() {
    return o.isWebGL2 ? t.createVertexArray() : u.createVertexArrayOES();
  }
  function T(F) {
    return o.isWebGL2 ? t.bindVertexArray(F) : u.bindVertexArrayOES(F);
  }
  function R(F) {
    return o.isWebGL2 ? t.deleteVertexArray(F) : u.deleteVertexArrayOES(F);
  }
  function _(F, H, W) {
    const V = W.wireframe === !0;
    let X = h[F.id];
    X === void 0 && (X = {}, h[F.id] = X);
    let Z = X[H.id];
    Z === void 0 && (Z = {}, X[H.id] = Z);
    let Q = Z[V];
    return Q === void 0 && (Q = b(E()), Z[V] = Q), Q;
  }
  function b(F) {
    const H = [], W = [], V = [];
    for (let X = 0; X < l; X++)
      H[X] = 0, W[X] = 0, V[X] = 0;
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: H,
      enabledAttributes: W,
      attributeDivisors: V,
      object: F,
      attributes: {},
      index: null
    };
  }
  function M(F, H, W, V) {
    const X = v.attributes, Z = H.attributes;
    let Q = 0;
    const q = W.getAttributes();
    for (const J in q)
      if (q[J].location >= 0) {
        const ie = X[J];
        let ne = Z[J];
        if (ne === void 0 && (J === "instanceMatrix" && F.instanceMatrix && (ne = F.instanceMatrix), J === "instanceColor" && F.instanceColor && (ne = F.instanceColor)), ie === void 0 || ie.attribute !== ne || ne && ie.data !== ne.data)
          return !0;
        Q++;
      }
    return v.attributesNum !== Q || v.index !== V;
  }
  function A(F, H, W, V) {
    const X = {}, Z = H.attributes;
    let Q = 0;
    const q = W.getAttributes();
    for (const J in q)
      if (q[J].location >= 0) {
        let ie = Z[J];
        ie === void 0 && (J === "instanceMatrix" && F.instanceMatrix && (ie = F.instanceMatrix), J === "instanceColor" && F.instanceColor && (ie = F.instanceColor));
        const ne = {};
        ne.attribute = ie, ie && ie.data && (ne.data = ie.data), X[J] = ne, Q++;
      }
    v.attributes = X, v.attributesNum = Q, v.index = V;
  }
  function $() {
    const F = v.newAttributes;
    for (let H = 0, W = F.length; H < W; H++)
      F[H] = 0;
  }
  function S(F) {
    C(F, 0);
  }
  function C(F, H) {
    const W = v.newAttributes, V = v.enabledAttributes, X = v.attributeDivisors;
    W[F] = 1, V[F] === 0 && (t.enableVertexAttribArray(F), V[F] = 1), X[F] !== H && ((o.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[o.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](F, H), X[F] = H);
  }
  function D() {
    const F = v.newAttributes, H = v.enabledAttributes;
    for (let W = 0, V = H.length; W < V; W++)
      H[W] !== F[W] && (t.disableVertexAttribArray(W), H[W] = 0);
  }
  function O(F, H, W, V, X, Z, Q) {
    Q === !0 ? t.vertexAttribIPointer(F, H, W, X, Z) : t.vertexAttribPointer(F, H, W, V, X, Z);
  }
  function N(F, H, W, V) {
    if (o.isWebGL2 === !1 && (F.isInstancedMesh || V.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null)
      return;
    $();
    const X = V.attributes, Z = W.getAttributes(), Q = H.defaultAttributeValues;
    for (const q in Z) {
      const J = Z[q];
      if (J.location >= 0) {
        let ie = X[q];
        if (ie === void 0 && (q === "instanceMatrix" && F.instanceMatrix && (ie = F.instanceMatrix), q === "instanceColor" && F.instanceColor && (ie = F.instanceColor)), ie !== void 0) {
          const ne = ie.normalized, ge = ie.itemSize, ye = n.get(ie);
          if (ye === void 0)
            continue;
          const xe = ye.buffer, we = ye.type, de = ye.bytesPerElement, Te = o.isWebGL2 === !0 && (we === t.INT || we === t.UNSIGNED_INT || ie.gpuType === no);
          if (ie.isInterleavedBufferAttribute) {
            const Ce = ie.data, ee = Ce.stride, Ae = ie.offset;
            if (Ce.isInstancedInterleavedBuffer) {
              for (let be = 0; be < J.locationSize; be++)
                C(J.location + be, Ce.meshPerAttribute);
              F.isInstancedMesh !== !0 && V._maxInstanceCount === void 0 && (V._maxInstanceCount = Ce.meshPerAttribute * Ce.count);
            } else
              for (let be = 0; be < J.locationSize; be++)
                S(J.location + be);
            t.bindBuffer(t.ARRAY_BUFFER, xe);
            for (let be = 0; be < J.locationSize; be++)
              O(
                J.location + be,
                ge / J.locationSize,
                we,
                ne,
                ee * de,
                (Ae + ge / J.locationSize * be) * de,
                Te
              );
          } else {
            if (ie.isInstancedBufferAttribute) {
              for (let Ce = 0; Ce < J.locationSize; Ce++)
                C(J.location + Ce, ie.meshPerAttribute);
              F.isInstancedMesh !== !0 && V._maxInstanceCount === void 0 && (V._maxInstanceCount = ie.meshPerAttribute * ie.count);
            } else
              for (let Ce = 0; Ce < J.locationSize; Ce++)
                S(J.location + Ce);
            t.bindBuffer(t.ARRAY_BUFFER, xe);
            for (let Ce = 0; Ce < J.locationSize; Ce++)
              O(
                J.location + Ce,
                ge / J.locationSize,
                we,
                ne,
                ge * de,
                ge / J.locationSize * Ce * de,
                Te
              );
          }
        } else if (Q !== void 0) {
          const ne = Q[q];
          if (ne !== void 0)
            switch (ne.length) {
              case 2:
                t.vertexAttrib2fv(J.location, ne);
                break;
              case 3:
                t.vertexAttrib3fv(J.location, ne);
                break;
              case 4:
                t.vertexAttrib4fv(J.location, ne);
                break;
              default:
                t.vertexAttrib1fv(J.location, ne);
            }
        }
      }
    }
    D();
  }
  function j() {
    G();
    for (const F in h) {
      const H = h[F];
      for (const W in H) {
        const V = H[W];
        for (const X in V)
          R(V[X].object), delete V[X];
        delete H[W];
      }
      delete h[F];
    }
  }
  function L(F) {
    if (h[F.id] === void 0)
      return;
    const H = h[F.id];
    for (const W in H) {
      const V = H[W];
      for (const X in V)
        R(V[X].object), delete V[X];
      delete H[W];
    }
    delete h[F.id];
  }
  function z(F) {
    for (const H in h) {
      const W = h[H];
      if (W[F.id] === void 0)
        continue;
      const V = W[F.id];
      for (const X in V)
        R(V[X].object), delete V[X];
      delete W[F.id];
    }
  }
  function G() {
    B(), g = !0, v !== p && (v = p, T(v.object));
  }
  function B() {
    p.geometry = null, p.program = null, p.wireframe = !1;
  }
  return {
    setup: w,
    reset: G,
    resetDefaultState: B,
    dispose: j,
    releaseStatesOfGeometry: L,
    releaseStatesOfProgram: z,
    initAttributes: $,
    enableAttribute: S,
    disableUnusedAttributes: D
  };
}
function of(t, e, n, o) {
  const l = o.isWebGL2;
  let u;
  function f(g) {
    u = g;
  }
  function h(g, w) {
    t.drawArrays(u, g, w), n.update(w, u, 1);
  }
  function p(g, w, E) {
    if (E === 0)
      return;
    let T, R;
    if (l)
      T = t, R = "drawArraysInstanced";
    else if (T = e.get("ANGLE_instanced_arrays"), R = "drawArraysInstancedANGLE", T === null) {
      console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    T[R](u, g, w, E), n.update(w, u, E);
  }
  function v(g, w, E) {
    if (E === 0)
      return;
    const T = e.get("WEBGL_multi_draw");
    if (T === null)
      for (let R = 0; R < E; R++)
        this.render(g[R], w[R]);
    else {
      T.multiDrawArraysWEBGL(u, g, 0, w, 0, E);
      let R = 0;
      for (let _ = 0; _ < E; _++)
        R += w[_];
      n.update(R, u, 1);
    }
  }
  this.setMode = f, this.render = h, this.renderInstances = p, this.renderMultiDraw = v;
}
function lf(t, e, n) {
  let o;
  function l() {
    if (o !== void 0)
      return o;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const O = e.get("EXT_texture_filter_anisotropic");
      o = t.getParameter(O.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      o = 0;
    return o;
  }
  function u(O) {
    if (O === "highp") {
      if (t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision > 0)
        return "highp";
      O = "mediump";
    }
    return O === "mediump" && t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
  }
  const f = typeof WebGL2RenderingContext < "u" && t.constructor.name === "WebGL2RenderingContext";
  let h = n.precision !== void 0 ? n.precision : "highp";
  const p = u(h);
  p !== h && (console.warn("THREE.WebGLRenderer:", h, "not supported, using", p, "instead."), h = p);
  const v = f || e.has("WEBGL_draw_buffers"), g = n.logarithmicDepthBuffer === !0, w = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), E = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS), T = t.getParameter(t.MAX_TEXTURE_SIZE), R = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE), _ = t.getParameter(t.MAX_VERTEX_ATTRIBS), b = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS), M = t.getParameter(t.MAX_VARYING_VECTORS), A = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS), $ = E > 0, S = f || e.has("OES_texture_float"), C = $ && S, D = f ? t.getParameter(t.MAX_SAMPLES) : 0;
  return {
    isWebGL2: f,
    drawBuffers: v,
    getMaxAnisotropy: l,
    getMaxPrecision: u,
    precision: h,
    logarithmicDepthBuffer: g,
    maxTextures: w,
    maxVertexTextures: E,
    maxTextureSize: T,
    maxCubemapSize: R,
    maxAttributes: _,
    maxVertexUniforms: b,
    maxVaryings: M,
    maxFragmentUniforms: A,
    vertexTextures: $,
    floatFragmentTextures: S,
    floatVertexTextures: C,
    maxSamples: D
  };
}
function cf(t) {
  const e = this;
  let n = null, o = 0, l = !1, u = !1;
  const f = new sn(), h = new Ge(), p = { value: null, needsUpdate: !1 };
  this.uniform = p, this.numPlanes = 0, this.numIntersection = 0, this.init = function(w, E) {
    const T = w.length !== 0 || E || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    o !== 0 || l;
    return l = E, o = w.length, T;
  }, this.beginShadows = function() {
    u = !0, g(null);
  }, this.endShadows = function() {
    u = !1;
  }, this.setGlobalState = function(w, E) {
    n = g(w, E, 0);
  }, this.setState = function(w, E, T) {
    const R = w.clippingPlanes, _ = w.clipIntersection, b = w.clipShadows, M = t.get(w);
    if (!l || R === null || R.length === 0 || u && !b)
      u ? g(null) : v();
    else {
      const A = u ? 0 : o, $ = A * 4;
      let S = M.clippingState || null;
      p.value = S, S = g(R, E, $, T);
      for (let C = 0; C !== $; ++C)
        S[C] = n[C];
      M.clippingState = S, this.numIntersection = _ ? this.numPlanes : 0, this.numPlanes += A;
    }
  };
  function v() {
    p.value !== n && (p.value = n, p.needsUpdate = o > 0), e.numPlanes = o, e.numIntersection = 0;
  }
  function g(w, E, T, R) {
    const _ = w !== null ? w.length : 0;
    let b = null;
    if (_ !== 0) {
      if (b = p.value, R !== !0 || b === null) {
        const M = T + _ * 4, A = E.matrixWorldInverse;
        h.getNormalMatrix(A), (b === null || b.length < M) && (b = new Float32Array(M));
        for (let $ = 0, S = T; $ !== _; ++$, S += 4)
          f.copy(w[$]).applyMatrix4(A, h), f.normal.toArray(b, S), b[S + 3] = f.constant;
      }
      p.value = b, p.needsUpdate = !0;
    }
    return e.numPlanes = _, e.numIntersection = 0, b;
  }
}
function uf(t) {
  let e = /* @__PURE__ */ new WeakMap();
  function n(f, h) {
    return h === es ? f.mapping = ii : h === ts && (f.mapping = ri), f;
  }
  function o(f) {
    if (f && f.isTexture) {
      const h = f.mapping;
      if (h === es || h === ts)
        if (e.has(f)) {
          const p = e.get(f).texture;
          return n(p, f.mapping);
        } else {
          const p = f.image;
          if (p && p.height > 0) {
            const v = new xc(p.height);
            return v.fromEquirectangularTexture(t, f), e.set(f, v), f.addEventListener("dispose", l), n(v.texture, f.mapping);
          } else
            return null;
        }
    }
    return f;
  }
  function l(f) {
    const h = f.target;
    h.removeEventListener("dispose", l);
    const p = e.get(h);
    p !== void 0 && (e.delete(h), p.dispose());
  }
  function u() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: o,
    dispose: u
  };
}
class hf extends Mo {
  constructor(e = -1, n = 1, o = 1, l = -1, u = 0.1, f = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = n, this.top = o, this.bottom = l, this.near = u, this.far = f, this.updateProjectionMatrix();
  }
  copy(e, n) {
    return super.copy(e, n), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
  }
  setViewOffset(e, n, o, l, u, f) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = n, this.view.offsetX = o, this.view.offsetY = l, this.view.width = u, this.view.height = f, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom), n = (this.top - this.bottom) / (2 * this.zoom), o = (this.right + this.left) / 2, l = (this.top + this.bottom) / 2;
    let u = o - e, f = o + e, h = l + n, p = l - n;
    if (this.view !== null && this.view.enabled) {
      const v = (this.right - this.left) / this.view.fullWidth / this.zoom, g = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      u += v * this.view.offsetX, f = u + v * this.view.width, h -= g * this.view.offsetY, p = h - g * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(u, f, h, p, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return n.object.zoom = this.zoom, n.object.left = this.left, n.object.right = this.right, n.object.top = this.top, n.object.bottom = this.bottom, n.object.near = this.near, n.object.far = this.far, this.view !== null && (n.object.view = Object.assign({}, this.view)), n;
  }
}
const $n = 4, Ma = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], bn = 20, Vr = /* @__PURE__ */ new hf(), Sa = /* @__PURE__ */ new qe();
let kr$1 = null, Wr = 0, Xr = 0;
const yn = (1 + Math.sqrt(5)) / 2, Kn = 1 / yn, Ea = [
  /* @__PURE__ */ new I(1, 1, 1),
  /* @__PURE__ */ new I(-1, 1, 1),
  /* @__PURE__ */ new I(1, 1, -1),
  /* @__PURE__ */ new I(-1, 1, -1),
  /* @__PURE__ */ new I(0, yn, Kn),
  /* @__PURE__ */ new I(0, yn, -Kn),
  /* @__PURE__ */ new I(Kn, 0, yn),
  /* @__PURE__ */ new I(-Kn, 0, yn),
  /* @__PURE__ */ new I(yn, Kn, 0),
  /* @__PURE__ */ new I(-yn, Kn, 0)
];
class ya {
  constructor(e) {
    this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene(e, n = 0, o = 0.1, l = 100) {
    kr$1 = this._renderer.getRenderTarget(), Wr = this._renderer.getActiveCubeFace(), Xr = this._renderer.getActiveMipmapLevel(), this._setSize(256);
    const u = this._allocateTargets();
    return u.depthBuffer = !0, this._sceneToCubeUV(e, o, l, u), n > 0 && this._blur(u, 0, 0, n), this._applyPMREM(u), this._cleanup(u), u;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   * The smallest supported equirectangular image size is 64 x 32.
   */
  fromEquirectangular(e, n = null) {
    return this._fromTexture(e, n);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   * The smallest supported cube size is 16 x 16.
   */
  fromCubemap(e, n = null) {
    return this._fromTexture(e, n);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = Aa(), this._compileMaterial(this._cubemapMaterial));
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = ba(), this._compileMaterial(this._equirectMaterial));
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  // private interface
  _setSize(e) {
    this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(kr$1, Wr, Xr), e.scissorTest = !1, Wi(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, n) {
    e.mapping === ii || e.mapping === ri ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), kr$1 = this._renderer.getRenderTarget(), Wr = this._renderer.getActiveCubeFace(), Xr = this._renderer.getActiveMipmapLevel();
    const o = n || this._allocateTargets();
    return this._textureToCubeUV(e, o), this._applyPMREM(o), this._cleanup(o), o;
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112), n = 4 * this._cubeSize, o = {
      magFilter: St,
      minFilter: St,
      generateMipmaps: !1,
      type: _i,
      format: Ft,
      colorSpace: dn,
      depthBuffer: !1
    }, l = Ta(e, n, o);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== n) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = Ta(e, n, o);
      const { _lodMax: u } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = ff(u)), this._blurMaterial = df(u, e, n);
    }
    return l;
  }
  _compileMaterial(e) {
    const n = new Rt(this._lodPlanes[0], e);
    this._renderer.compile(n, Vr);
  }
  _sceneToCubeUV(e, n, o, l) {
    const u = new Lt(90, 1, n, o), f = [1, -1, 1, 1, 1, 1], h = [1, 1, 1, -1, -1, -1], p = this._renderer, v = p.autoClear, g = p.toneMapping;
    p.getClearColor(Sa), p.toneMapping = cn, p.autoClear = !1;
    const w = new ni({
      name: "PMREM.Background",
      side: Et,
      depthWrite: !1,
      depthTest: !1
    }), E = new Rt(new Mi(), w);
    let T = !1;
    const R = e.background;
    R ? R.isColor && (w.color.copy(R), e.background = null, T = !0) : (w.color.copy(Sa), T = !0);
    for (let _ = 0; _ < 6; _++) {
      const b = _ % 3;
      b === 0 ? (u.up.set(0, f[_], 0), u.lookAt(h[_], 0, 0)) : b === 1 ? (u.up.set(0, 0, f[_]), u.lookAt(0, h[_], 0)) : (u.up.set(0, f[_], 0), u.lookAt(0, 0, h[_]));
      const M = this._cubeSize;
      Wi(l, b * M, _ > 2 ? M : 0, M, M), p.setRenderTarget(l), T && p.render(E, u), p.render(e, u);
    }
    E.geometry.dispose(), E.material.dispose(), p.toneMapping = g, p.autoClear = v, e.background = R;
  }
  _textureToCubeUV(e, n) {
    const o = this._renderer, l = e.mapping === ii || e.mapping === ri;
    l ? (this._cubemapMaterial === null && (this._cubemapMaterial = Aa()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = ba());
    const u = l ? this._cubemapMaterial : this._equirectMaterial, f = new Rt(this._lodPlanes[0], u), h = u.uniforms;
    h.envMap.value = e;
    const p = this._cubeSize;
    Wi(n, 0, 0, 3 * p, 2 * p), o.setRenderTarget(n), o.render(f, Vr);
  }
  _applyPMREM(e) {
    const n = this._renderer, o = n.autoClear;
    n.autoClear = !1;
    for (let l = 1; l < this._lodPlanes.length; l++) {
      const u = Math.sqrt(this._sigmas[l] * this._sigmas[l] - this._sigmas[l - 1] * this._sigmas[l - 1]), f = Ea[(l - 1) % Ea.length];
      this._blur(e, l - 1, l, u, f);
    }
    n.autoClear = o;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur(e, n, o, l, u) {
    const f = this._pingPongRenderTarget;
    this._halfBlur(
      e,
      f,
      n,
      o,
      l,
      "latitudinal",
      u
    ), this._halfBlur(
      f,
      e,
      o,
      o,
      l,
      "longitudinal",
      u
    );
  }
  _halfBlur(e, n, o, l, u, f, h) {
    const p = this._renderer, v = this._blurMaterial;
    f !== "latitudinal" && f !== "longitudinal" && console.error(
      "blur direction must be either latitudinal or longitudinal!"
    );
    const g = 3, w = new Rt(this._lodPlanes[l], v), E = v.uniforms, T = this._sizeLods[o] - 1, R = isFinite(u) ? Math.PI / (2 * T) : 2 * Math.PI / (2 * bn - 1), _ = u / R, b = isFinite(u) ? 1 + Math.floor(g * _) : bn;
    b > bn && console.warn(`sigmaRadians, ${u}, is too large and will clip, as it requested ${b} samples when the maximum is set to ${bn}`);
    const M = [];
    let A = 0;
    for (let O = 0; O < bn; ++O) {
      const N = O / _, j = Math.exp(-N * N / 2);
      M.push(j), O === 0 ? A += j : O < b && (A += 2 * j);
    }
    for (let O = 0; O < M.length; O++)
      M[O] = M[O] / A;
    E.envMap.value = e.texture, E.samples.value = b, E.weights.value = M, E.latitudinal.value = f === "latitudinal", h && (E.poleAxis.value = h);
    const { _lodMax: $ } = this;
    E.dTheta.value = R, E.mipInt.value = $ - o;
    const S = this._sizeLods[l], C = 3 * S * (l > $ - $n ? l - $ + $n : 0), D = 4 * (this._cubeSize - S);
    Wi(n, C, D, 3 * S, 2 * S), p.setRenderTarget(n), p.render(w, Vr);
  }
}
function ff(t) {
  const e = [], n = [], o = [];
  let l = t;
  const u = t - $n + 1 + Ma.length;
  for (let f = 0; f < u; f++) {
    const h = Math.pow(2, l);
    n.push(h);
    let p = 1 / h;
    f > t - $n ? p = Ma[f - t + $n - 1] : f === 0 && (p = 0), o.push(p);
    const v = 1 / (h - 2), g = -v, w = 1 + v, E = [g, g, w, g, w, w, g, g, w, w, g, w], T = 6, R = 6, _ = 3, b = 2, M = 1, A = new Float32Array(_ * R * T), $ = new Float32Array(b * R * T), S = new Float32Array(M * R * T);
    for (let D = 0; D < T; D++) {
      const O = D % 3 * 2 / 3 - 1, N = D > 2 ? 0 : -1, j = [
        O,
        N,
        0,
        O + 2 / 3,
        N,
        0,
        O + 2 / 3,
        N + 1,
        0,
        O,
        N,
        0,
        O + 2 / 3,
        N + 1,
        0,
        O,
        N + 1,
        0
      ];
      A.set(j, _ * R * D), $.set(E, b * R * D);
      const L = [D, D, D, D, D, D];
      S.set(L, M * R * D);
    }
    const C = new Tt();
    C.setAttribute("position", new Gt(A, _)), C.setAttribute("uv", new Gt($, b)), C.setAttribute("faceIndex", new Gt(S, M)), e.push(C), l > $n && l--;
  }
  return { lodPlanes: e, sizeLods: n, sigmas: o };
}
function Ta(t, e, n) {
  const o = new Cn(t, e, n);
  return o.texture.mapping = lr, o.texture.name = "PMREM.cubeUv", o.scissorTest = !0, o;
}
function Wi(t, e, n, o, l) {
  t.viewport.set(e, n, o, l), t.scissor.set(e, n, o, l);
}
function df(t, e, n) {
  const o = new Float32Array(bn), l = new I(0, 1, 0);
  return new fn({
    name: "SphericalGaussianBlur",
    defines: {
      n: bn,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / n,
      CUBEUV_MAX_MIP: `${t}.0`
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: o },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: l }
    },
    vertexShader: fs(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`
    ),
    blending: ln$1,
    depthTest: !1,
    depthWrite: !1
  });
}
function ba() {
  return new fn({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: { value: null }
    },
    vertexShader: fs(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`
    ),
    blending: ln$1,
    depthTest: !1,
    depthWrite: !1
  });
}
function Aa() {
  return new fn({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 }
    },
    vertexShader: fs(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`
    ),
    blending: ln$1,
    depthTest: !1,
    depthWrite: !1
  });
}
function fs() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function pf(t) {
  let e = /* @__PURE__ */ new WeakMap(), n = null;
  function o(h) {
    if (h && h.isTexture) {
      const p = h.mapping, v = p === es || p === ts, g = p === ii || p === ri;
      if (v || g)
        if (h.isRenderTargetTexture && h.needsPMREMUpdate === !0) {
          h.needsPMREMUpdate = !1;
          let w = e.get(h);
          return n === null && (n = new ya(t)), w = v ? n.fromEquirectangular(h, w) : n.fromCubemap(h, w), e.set(h, w), w.texture;
        } else {
          if (e.has(h))
            return e.get(h).texture;
          {
            const w = h.image;
            if (v && w && w.height > 0 || g && w && l(w)) {
              n === null && (n = new ya(t));
              const E = v ? n.fromEquirectangular(h) : n.fromCubemap(h);
              return e.set(h, E), h.addEventListener("dispose", u), E.texture;
            } else
              return null;
          }
        }
    }
    return h;
  }
  function l(h) {
    let p = 0;
    const v = 6;
    for (let g = 0; g < v; g++)
      h[g] !== void 0 && p++;
    return p === v;
  }
  function u(h) {
    const p = h.target;
    p.removeEventListener("dispose", u);
    const v = e.get(p);
    v !== void 0 && (e.delete(p), v.dispose());
  }
  function f() {
    e = /* @__PURE__ */ new WeakMap(), n !== null && (n.dispose(), n = null);
  }
  return {
    get: o,
    dispose: f
  };
}
function mf(t) {
  const e = {};
  function n(o) {
    if (e[o] !== void 0)
      return e[o];
    let l;
    switch (o) {
      case "WEBGL_depth_texture":
        l = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        l = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        l = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        l = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        l = t.getExtension(o);
    }
    return e[o] = l, l;
  }
  return {
    has: function(o) {
      return n(o) !== null;
    },
    init: function(o) {
      o.isWebGL2 ? (n("EXT_color_buffer_float"), n("WEBGL_clip_cull_distance")) : (n("WEBGL_depth_texture"), n("OES_texture_float"), n("OES_texture_half_float"), n("OES_texture_half_float_linear"), n("OES_standard_derivatives"), n("OES_element_index_uint"), n("OES_vertex_array_object"), n("ANGLE_instanced_arrays")), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float"), n("WEBGL_multisampled_render_to_texture");
    },
    get: function(o) {
      const l = n(o);
      return l === null && console.warn("THREE.WebGLRenderer: " + o + " extension not supported."), l;
    }
  };
}
function _f(t, e, n, o) {
  const l = {}, u = /* @__PURE__ */ new WeakMap();
  function f(w) {
    const E = w.target;
    E.index !== null && e.remove(E.index);
    for (const R in E.attributes)
      e.remove(E.attributes[R]);
    for (const R in E.morphAttributes) {
      const _ = E.morphAttributes[R];
      for (let b = 0, M = _.length; b < M; b++)
        e.remove(_[b]);
    }
    E.removeEventListener("dispose", f), delete l[E.id];
    const T = u.get(E);
    T && (e.remove(T), u.delete(E)), o.releaseStatesOfGeometry(E), E.isInstancedBufferGeometry === !0 && delete E._maxInstanceCount, n.memory.geometries--;
  }
  function h(w, E) {
    return l[E.id] === !0 || (E.addEventListener("dispose", f), l[E.id] = !0, n.memory.geometries++), E;
  }
  function p(w) {
    const E = w.attributes;
    for (const R in E)
      e.update(E[R], t.ARRAY_BUFFER);
    const T = w.morphAttributes;
    for (const R in T) {
      const _ = T[R];
      for (let b = 0, M = _.length; b < M; b++)
        e.update(_[b], t.ARRAY_BUFFER);
    }
  }
  function v(w) {
    const E = [], T = w.index, R = w.attributes.position;
    let _ = 0;
    if (T !== null) {
      const A = T.array;
      _ = T.version;
      for (let $ = 0, S = A.length; $ < S; $ += 3) {
        const C = A[$ + 0], D = A[$ + 1], O = A[$ + 2];
        E.push(C, D, D, O, O, C);
      }
    } else if (R !== void 0) {
      const A = R.array;
      _ = R.version;
      for (let $ = 0, S = A.length / 3 - 1; $ < S; $ += 3) {
        const C = $ + 0, D = $ + 1, O = $ + 2;
        E.push(C, D, D, O, O, C);
      }
    } else
      return;
    const b = new (uo(E) ? vo : go)(E, 1);
    b.version = _;
    const M = u.get(w);
    M && e.remove(M), u.set(w, b);
  }
  function g(w) {
    const E = u.get(w);
    if (E) {
      const T = w.index;
      T !== null && E.version < T.version && v(w);
    } else
      v(w);
    return u.get(w);
  }
  return {
    get: h,
    update: p,
    getWireframeAttribute: g
  };
}
function gf(t, e, n, o) {
  const l = o.isWebGL2;
  let u;
  function f(T) {
    u = T;
  }
  let h, p;
  function v(T) {
    h = T.type, p = T.bytesPerElement;
  }
  function g(T, R) {
    t.drawElements(u, R, h, T * p), n.update(R, u, 1);
  }
  function w(T, R, _) {
    if (_ === 0)
      return;
    let b, M;
    if (l)
      b = t, M = "drawElementsInstanced";
    else if (b = e.get("ANGLE_instanced_arrays"), M = "drawElementsInstancedANGLE", b === null) {
      console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    b[M](u, R, h, T * p, _), n.update(R, u, _);
  }
  function E(T, R, _) {
    if (_ === 0)
      return;
    const b = e.get("WEBGL_multi_draw");
    if (b === null)
      for (let M = 0; M < _; M++)
        this.render(T[M] / p, R[M]);
    else {
      b.multiDrawElementsWEBGL(u, R, 0, h, T, 0, _);
      let M = 0;
      for (let A = 0; A < _; A++)
        M += R[A];
      n.update(M, u, 1);
    }
  }
  this.setMode = f, this.setIndex = v, this.render = g, this.renderInstances = w, this.renderMultiDraw = E;
}
function vf(t) {
  const e = {
    geometries: 0,
    textures: 0
  }, n = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function o(u, f, h) {
    switch (n.calls++, f) {
      case t.TRIANGLES:
        n.triangles += h * (u / 3);
        break;
      case t.LINES:
        n.lines += h * (u / 2);
        break;
      case t.LINE_STRIP:
        n.lines += h * (u - 1);
        break;
      case t.LINE_LOOP:
        n.lines += h * u;
        break;
      case t.POINTS:
        n.points += h * u;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", f);
        break;
    }
  }
  function l() {
    n.calls = 0, n.triangles = 0, n.points = 0, n.lines = 0;
  }
  return {
    memory: e,
    render: n,
    programs: null,
    autoReset: !0,
    reset: l,
    update: o
  };
}
function xf(t, e) {
  return t[0] - e[0];
}
function Mf(t, e) {
  return Math.abs(e[1]) - Math.abs(t[1]);
}
function Sf(t, e, n) {
  const o = {}, l = new Float32Array(8), u = /* @__PURE__ */ new WeakMap(), f = new ht(), h = [];
  for (let v = 0; v < 8; v++)
    h[v] = [v, 0];
  function p(v, g, w) {
    const E = v.morphTargetInfluences;
    if (e.isWebGL2 === !0) {
      const T = g.morphAttributes.position || g.morphAttributes.normal || g.morphAttributes.color, R = T !== void 0 ? T.length : 0;
      let _ = u.get(g);
      if (_ === void 0 || _.count !== R) {
        let b = function() {
          z.dispose(), u.delete(g), g.removeEventListener("dispose", b);
        };
        _ !== void 0 && _.texture.dispose();
        const M = g.morphAttributes.position !== void 0, A = g.morphAttributes.normal !== void 0, $ = g.morphAttributes.color !== void 0, S = g.morphAttributes.position || [], C = g.morphAttributes.normal || [], D = g.morphAttributes.color || [];
        let O = 0;
        M === !0 && (O = 1), A === !0 && (O = 2), $ === !0 && (O = 3);
        let N = g.attributes.position.count * O, j = 1;
        N > e.maxTextureSize && (j = Math.ceil(N / e.maxTextureSize), N = e.maxTextureSize);
        const L = new Float32Array(N * j * 4 * R), z = new po(L, N, j, R);
        z.type = Kt, z.needsUpdate = !0;
        const G = O * 4;
        for (let B = 0; B < R; B++) {
          const F = S[B], H = C[B], W = D[B], V = N * j * 4 * B;
          for (let X = 0; X < F.count; X++) {
            const Z = X * G;
            M === !0 && (f.fromBufferAttribute(F, X), L[V + Z + 0] = f.x, L[V + Z + 1] = f.y, L[V + Z + 2] = f.z, L[V + Z + 3] = 0), A === !0 && (f.fromBufferAttribute(H, X), L[V + Z + 4] = f.x, L[V + Z + 5] = f.y, L[V + Z + 6] = f.z, L[V + Z + 7] = 0), $ === !0 && (f.fromBufferAttribute(W, X), L[V + Z + 8] = f.x, L[V + Z + 9] = f.y, L[V + Z + 10] = f.z, L[V + Z + 11] = W.itemSize === 4 ? f.w : 1);
          }
        }
        _ = {
          count: R,
          texture: z,
          size: new Ie(N, j)
        }, u.set(g, _), g.addEventListener("dispose", b);
      }
      if (v.isInstancedMesh === !0 && v.morphTexture !== null)
        w.getUniforms().setValue(t, "morphTexture", v.morphTexture, n);
      else {
        let b = 0;
        for (let A = 0; A < E.length; A++)
          b += E[A];
        const M = g.morphTargetsRelative ? 1 : 1 - b;
        w.getUniforms().setValue(t, "morphTargetBaseInfluence", M), w.getUniforms().setValue(t, "morphTargetInfluences", E);
      }
      w.getUniforms().setValue(t, "morphTargetsTexture", _.texture, n), w.getUniforms().setValue(t, "morphTargetsTextureSize", _.size);
    } else {
      const T = E === void 0 ? 0 : E.length;
      let R = o[g.id];
      if (R === void 0 || R.length !== T) {
        R = [];
        for (let $ = 0; $ < T; $++)
          R[$] = [$, 0];
        o[g.id] = R;
      }
      for (let $ = 0; $ < T; $++) {
        const S = R[$];
        S[0] = $, S[1] = E[$];
      }
      R.sort(Mf);
      for (let $ = 0; $ < 8; $++)
        $ < T && R[$][1] ? (h[$][0] = R[$][0], h[$][1] = R[$][1]) : (h[$][0] = Number.MAX_SAFE_INTEGER, h[$][1] = 0);
      h.sort(xf);
      const _ = g.morphAttributes.position, b = g.morphAttributes.normal;
      let M = 0;
      for (let $ = 0; $ < 8; $++) {
        const S = h[$], C = S[0], D = S[1];
        C !== Number.MAX_SAFE_INTEGER && D ? (_ && g.getAttribute("morphTarget" + $) !== _[C] && g.setAttribute("morphTarget" + $, _[C]), b && g.getAttribute("morphNormal" + $) !== b[C] && g.setAttribute("morphNormal" + $, b[C]), l[$] = D, M += D) : (_ && g.hasAttribute("morphTarget" + $) === !0 && g.deleteAttribute("morphTarget" + $), b && g.hasAttribute("morphNormal" + $) === !0 && g.deleteAttribute("morphNormal" + $), l[$] = 0);
      }
      const A = g.morphTargetsRelative ? 1 : 1 - M;
      w.getUniforms().setValue(t, "morphTargetBaseInfluence", A), w.getUniforms().setValue(t, "morphTargetInfluences", l);
    }
  }
  return {
    update: p
  };
}
function Ef(t, e, n, o) {
  let l = /* @__PURE__ */ new WeakMap();
  function u(p) {
    const v = o.render.frame, g = p.geometry, w = e.get(p, g);
    if (l.get(w) !== v && (e.update(w), l.set(w, v)), p.isInstancedMesh && (p.hasEventListener("dispose", h) === !1 && p.addEventListener("dispose", h), l.get(p) !== v && (n.update(p.instanceMatrix, t.ARRAY_BUFFER), p.instanceColor !== null && n.update(p.instanceColor, t.ARRAY_BUFFER), l.set(p, v))), p.isSkinnedMesh) {
      const E = p.skeleton;
      l.get(E) !== v && (E.update(), l.set(E, v));
    }
    return w;
  }
  function f() {
    l = /* @__PURE__ */ new WeakMap();
  }
  function h(p) {
    const v = p.target;
    v.removeEventListener("dispose", h), n.remove(v.instanceMatrix), v.instanceColor !== null && n.remove(v.instanceColor);
  }
  return {
    update: u,
    dispose: f
  };
}
class To extends yt {
  constructor(e, n, o, l, u, f, h, p, v, g) {
    if (g = g !== void 0 ? g : Rn, g !== Rn && g !== si)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    o === void 0 && g === Rn && (o = on), o === void 0 && g === si && (o = wn), super(null, l, u, f, h, p, g, o, v), this.isDepthTexture = !0, this.image = { width: e, height: n }, this.magFilter = h !== void 0 ? h : xt, this.minFilter = p !== void 0 ? p : xt, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
  }
  copy(e) {
    return super.copy(e), this.compareFunction = e.compareFunction, this;
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return this.compareFunction !== null && (n.compareFunction = this.compareFunction), n;
  }
}
const bo = /* @__PURE__ */ new yt(), Ao = /* @__PURE__ */ new To(1, 1);
Ao.compareFunction = co;
const wo = /* @__PURE__ */ new po(), Ro = /* @__PURE__ */ new nc(), Co = /* @__PURE__ */ new So(), wa = [], Ra = [], Ca = new Float32Array(16), Pa = new Float32Array(9), La = new Float32Array(4);
function li(t, e, n) {
  const o = t[0];
  if (o <= 0 || o > 0)
    return t;
  const l = e * n;
  let u = wa[l];
  if (u === void 0 && (u = new Float32Array(l), wa[l] = u), e !== 0) {
    o.toArray(u, 0);
    for (let f = 1, h = 0; f !== e; ++f)
      h += n, t[f].toArray(u, h);
  }
  return u;
}
function at(t, e) {
  if (t.length !== e.length)
    return !1;
  for (let n = 0, o = t.length; n < o; n++)
    if (t[n] !== e[n])
      return !1;
  return !0;
}
function ot(t, e) {
  for (let n = 0, o = e.length; n < o; n++)
    t[n] = e[n];
}
function fr(t, e) {
  let n = Ra[e];
  n === void 0 && (n = new Int32Array(e), Ra[e] = n);
  for (let o = 0; o !== e; ++o)
    n[o] = t.allocateTextureUnit();
  return n;
}
function yf(t, e) {
  const n = this.cache;
  n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e);
}
function Tf(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y) && (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
  else {
    if (at(n, e))
      return;
    t.uniform2fv(this.addr, e), ot(n, e);
  }
}
function bf(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) && (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
  else if (e.r !== void 0)
    (n[0] !== e.r || n[1] !== e.g || n[2] !== e.b) && (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);
  else {
    if (at(n, e))
      return;
    t.uniform3fv(this.addr, e), ot(n, e);
  }
}
function Af(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) && (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
  else {
    if (at(n, e))
      return;
    t.uniform4fv(this.addr, e), ot(n, e);
  }
}
function wf(t, e) {
  const n = this.cache, o = e.elements;
  if (o === void 0) {
    if (at(n, e))
      return;
    t.uniformMatrix2fv(this.addr, !1, e), ot(n, e);
  } else {
    if (at(n, o))
      return;
    La.set(o), t.uniformMatrix2fv(this.addr, !1, La), ot(n, o);
  }
}
function Rf(t, e) {
  const n = this.cache, o = e.elements;
  if (o === void 0) {
    if (at(n, e))
      return;
    t.uniformMatrix3fv(this.addr, !1, e), ot(n, e);
  } else {
    if (at(n, o))
      return;
    Pa.set(o), t.uniformMatrix3fv(this.addr, !1, Pa), ot(n, o);
  }
}
function Cf(t, e) {
  const n = this.cache, o = e.elements;
  if (o === void 0) {
    if (at(n, e))
      return;
    t.uniformMatrix4fv(this.addr, !1, e), ot(n, e);
  } else {
    if (at(n, o))
      return;
    Ca.set(o), t.uniformMatrix4fv(this.addr, !1, Ca), ot(n, o);
  }
}
function Pf(t, e) {
  const n = this.cache;
  n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e);
}
function Lf(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y) && (t.uniform2i(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
  else {
    if (at(n, e))
      return;
    t.uniform2iv(this.addr, e), ot(n, e);
  }
}
function Df(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) && (t.uniform3i(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
  else {
    if (at(n, e))
      return;
    t.uniform3iv(this.addr, e), ot(n, e);
  }
}
function Uf(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) && (t.uniform4i(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
  else {
    if (at(n, e))
      return;
    t.uniform4iv(this.addr, e), ot(n, e);
  }
}
function If(t, e) {
  const n = this.cache;
  n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e);
}
function Nf(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y) && (t.uniform2ui(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
  else {
    if (at(n, e))
      return;
    t.uniform2uiv(this.addr, e), ot(n, e);
  }
}
function Ff(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) && (t.uniform3ui(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
  else {
    if (at(n, e))
      return;
    t.uniform3uiv(this.addr, e), ot(n, e);
  }
}
function Of(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) && (t.uniform4ui(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
  else {
    if (at(n, e))
      return;
    t.uniform4uiv(this.addr, e), ot(n, e);
  }
}
function Bf(t, e, n) {
  const o = this.cache, l = n.allocateTextureUnit();
  o[0] !== l && (t.uniform1i(this.addr, l), o[0] = l);
  const u = this.type === t.SAMPLER_2D_SHADOW ? Ao : bo;
  n.setTexture2D(e || u, l);
}
function zf(t, e, n) {
  const o = this.cache, l = n.allocateTextureUnit();
  o[0] !== l && (t.uniform1i(this.addr, l), o[0] = l), n.setTexture3D(e || Ro, l);
}
function Gf(t, e, n) {
  const o = this.cache, l = n.allocateTextureUnit();
  o[0] !== l && (t.uniform1i(this.addr, l), o[0] = l), n.setTextureCube(e || Co, l);
}
function Hf(t, e, n) {
  const o = this.cache, l = n.allocateTextureUnit();
  o[0] !== l && (t.uniform1i(this.addr, l), o[0] = l), n.setTexture2DArray(e || wo, l);
}
function Vf(t) {
  switch (t) {
    case 5126:
      return yf;
    case 35664:
      return Tf;
    case 35665:
      return bf;
    case 35666:
      return Af;
    case 35674:
      return wf;
    case 35675:
      return Rf;
    case 35676:
      return Cf;
    case 5124:
    case 35670:
      return Pf;
    case 35667:
    case 35671:
      return Lf;
    case 35668:
    case 35672:
      return Df;
    case 35669:
    case 35673:
      return Uf;
    case 5125:
      return If;
    case 36294:
      return Nf;
    case 36295:
      return Ff;
    case 36296:
      return Of;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return Bf;
    case 35679:
    case 36299:
    case 36307:
      return zf;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return Gf;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return Hf;
  }
}
function kf(t, e) {
  t.uniform1fv(this.addr, e);
}
function Wf(t, e) {
  const n = li(e, this.size, 2);
  t.uniform2fv(this.addr, n);
}
function Xf(t, e) {
  const n = li(e, this.size, 3);
  t.uniform3fv(this.addr, n);
}
function Yf(t, e) {
  const n = li(e, this.size, 4);
  t.uniform4fv(this.addr, n);
}
function qf(t, e) {
  const n = li(e, this.size, 4);
  t.uniformMatrix2fv(this.addr, !1, n);
}
function jf(t, e) {
  const n = li(e, this.size, 9);
  t.uniformMatrix3fv(this.addr, !1, n);
}
function Kf(t, e) {
  const n = li(e, this.size, 16);
  t.uniformMatrix4fv(this.addr, !1, n);
}
function Zf(t, e) {
  t.uniform1iv(this.addr, e);
}
function $f(t, e) {
  t.uniform2iv(this.addr, e);
}
function Jf(t, e) {
  t.uniform3iv(this.addr, e);
}
function Qf(t, e) {
  t.uniform4iv(this.addr, e);
}
function ed(t, e) {
  t.uniform1uiv(this.addr, e);
}
function td(t, e) {
  t.uniform2uiv(this.addr, e);
}
function nd(t, e) {
  t.uniform3uiv(this.addr, e);
}
function id(t, e) {
  t.uniform4uiv(this.addr, e);
}
function rd(t, e, n) {
  const o = this.cache, l = e.length, u = fr(n, l);
  at(o, u) || (t.uniform1iv(this.addr, u), ot(o, u));
  for (let f = 0; f !== l; ++f)
    n.setTexture2D(e[f] || bo, u[f]);
}
function sd(t, e, n) {
  const o = this.cache, l = e.length, u = fr(n, l);
  at(o, u) || (t.uniform1iv(this.addr, u), ot(o, u));
  for (let f = 0; f !== l; ++f)
    n.setTexture3D(e[f] || Ro, u[f]);
}
function ad(t, e, n) {
  const o = this.cache, l = e.length, u = fr(n, l);
  at(o, u) || (t.uniform1iv(this.addr, u), ot(o, u));
  for (let f = 0; f !== l; ++f)
    n.setTextureCube(e[f] || Co, u[f]);
}
function od(t, e, n) {
  const o = this.cache, l = e.length, u = fr(n, l);
  at(o, u) || (t.uniform1iv(this.addr, u), ot(o, u));
  for (let f = 0; f !== l; ++f)
    n.setTexture2DArray(e[f] || wo, u[f]);
}
function ld(t) {
  switch (t) {
    case 5126:
      return kf;
    case 35664:
      return Wf;
    case 35665:
      return Xf;
    case 35666:
      return Yf;
    case 35674:
      return qf;
    case 35675:
      return jf;
    case 35676:
      return Kf;
    case 5124:
    case 35670:
      return Zf;
    case 35667:
    case 35671:
      return $f;
    case 35668:
    case 35672:
      return Jf;
    case 35669:
    case 35673:
      return Qf;
    case 5125:
      return ed;
    case 36294:
      return td;
    case 36295:
      return nd;
    case 36296:
      return id;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return rd;
    case 35679:
    case 36299:
    case 36307:
      return sd;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return ad;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return od;
  }
}
class cd {
  constructor(e, n, o) {
    this.id = e, this.addr = o, this.cache = [], this.type = n.type, this.setValue = Vf(n.type);
  }
}
class ud {
  constructor(e, n, o) {
    this.id = e, this.addr = o, this.cache = [], this.type = n.type, this.size = n.size, this.setValue = ld(n.type);
  }
}
class hd {
  constructor(e) {
    this.id = e, this.seq = [], this.map = {};
  }
  setValue(e, n, o) {
    const l = this.seq;
    for (let u = 0, f = l.length; u !== f; ++u) {
      const h = l[u];
      h.setValue(e, n[h.id], o);
    }
  }
}
const Yr = /(\w+)(\])?(\[|\.)?/g;
function Da(t, e) {
  t.seq.push(e), t.map[e.id] = e;
}
function fd(t, e, n) {
  const o = t.name, l = o.length;
  for (Yr.lastIndex = 0; ; ) {
    const u = Yr.exec(o), f = Yr.lastIndex;
    let h = u[1];
    const p = u[2] === "]", v = u[3];
    if (p && (h = h | 0), v === void 0 || v === "[" && f + 2 === l) {
      Da(n, v === void 0 ? new cd(h, t, e) : new ud(h, t, e));
      break;
    } else {
      let g = n.map[h];
      g === void 0 && (g = new hd(h), Da(n, g)), n = g;
    }
  }
}
class Ji {
  constructor(e, n) {
    this.seq = [], this.map = {};
    const o = e.getProgramParameter(n, e.ACTIVE_UNIFORMS);
    for (let l = 0; l < o; ++l) {
      const u = e.getActiveUniform(n, l), f = e.getUniformLocation(n, u.name);
      fd(u, f, this);
    }
  }
  setValue(e, n, o, l) {
    const u = this.map[n];
    u !== void 0 && u.setValue(e, o, l);
  }
  setOptional(e, n, o) {
    const l = n[o];
    l !== void 0 && this.setValue(e, o, l);
  }
  static upload(e, n, o, l) {
    for (let u = 0, f = n.length; u !== f; ++u) {
      const h = n[u], p = o[h.id];
      p.needsUpdate !== !1 && h.setValue(e, p.value, l);
    }
  }
  static seqWithValue(e, n) {
    const o = [];
    for (let l = 0, u = e.length; l !== u; ++l) {
      const f = e[l];
      f.id in n && o.push(f);
    }
    return o;
  }
}
function Ua(t, e, n) {
  const o = t.createShader(e);
  return t.shaderSource(o, n), t.compileShader(o), o;
}
const dd = 37297;
let pd = 0;
function md(t, e) {
  const n = t.split(`
`), o = [], l = Math.max(e - 6, 0), u = Math.min(e + 6, n.length);
  for (let f = l; f < u; f++) {
    const h = f + 1;
    o.push(`${h === e ? ">" : " "} ${h}: ${n[f]}`);
  }
  return o.join(`
`);
}
function _d(t) {
  const e = je.getPrimaries(je.workingColorSpace), n = je.getPrimaries(t);
  let o;
  switch (e === n ? o = "" : e === nr && n === tr ? o = "LinearDisplayP3ToLinearSRGB" : e === tr && n === nr && (o = "LinearSRGBToLinearDisplayP3"), t) {
    case dn:
    case cr:
      return [o, "LinearTransferOETF"];
    case Bt:
    case cs:
      return [o, "sRGBTransferOETF"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported color space:", t), [o, "LinearTransferOETF"];
  }
}
function Ia(t, e, n) {
  const o = t.getShaderParameter(e, t.COMPILE_STATUS), l = t.getShaderInfoLog(e).trim();
  if (o && l === "")
    return "";
  const u = /ERROR: 0:(\d+)/.exec(l);
  if (u) {
    const f = parseInt(u[1]);
    return n.toUpperCase() + `

` + l + `

` + md(t.getShaderSource(e), f);
  } else
    return l;
}
function gd(t, e) {
  const n = _d(e);
  return `vec4 ${t}( vec4 value ) { return ${n[0]}( ${n[1]}( value ) ); }`;
}
function vd(t, e) {
  let n;
  switch (e) {
    case cl:
      n = "Linear";
      break;
    case ul:
      n = "Reinhard";
      break;
    case hl:
      n = "OptimizedCineon";
      break;
    case fl:
      n = "ACESFilmic";
      break;
    case pl:
      n = "AgX";
      break;
    case ml:
      n = "Neutral";
      break;
    case dl:
      n = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear";
  }
  return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }";
}
function xd(t) {
  return [
    t.extensionDerivatives || t.envMapCubeUVHeight || t.bumpMap || t.normalMapTangentSpace || t.clearcoatNormalMap || t.flatShading || t.alphaToCoverage || t.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
    (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
    t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
    (t.extensionShaderTextureLOD || t.envMap || t.transmission) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ].filter(Jn).join(`
`);
}
function Md(t) {
  return [
    t.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "",
    t.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""
  ].filter(Jn).join(`
`);
}
function Sd(t) {
  const e = [];
  for (const n in t) {
    const o = t[n];
    o !== !1 && e.push("#define " + n + " " + o);
  }
  return e.join(`
`);
}
function Ed(t, e) {
  const n = {}, o = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES);
  for (let l = 0; l < o; l++) {
    const u = t.getActiveAttrib(e, l), f = u.name;
    let h = 1;
    u.type === t.FLOAT_MAT2 && (h = 2), u.type === t.FLOAT_MAT3 && (h = 3), u.type === t.FLOAT_MAT4 && (h = 4), n[f] = {
      type: u.type,
      location: t.getAttribLocation(e, f),
      locationSize: h
    };
  }
  return n;
}
function Jn(t) {
  return t !== "";
}
function Na(t, e) {
  const n = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function Fa(t, e) {
  return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
const yd = /^[ \t]*#include +<([\w\d./]+)>/gm;
function as(t) {
  return t.replace(yd, bd);
}
const Td = /* @__PURE__ */ new Map([
  ["encodings_fragment", "colorspace_fragment"],
  // @deprecated, r154
  ["encodings_pars_fragment", "colorspace_pars_fragment"],
  // @deprecated, r154
  ["output_fragment", "opaque_fragment"]
  // @deprecated, r154
]);
function bd(t, e) {
  let n = ze[e];
  if (n === void 0) {
    const o = Td.get(e);
    if (o !== void 0)
      n = ze[o], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, o);
    else
      throw new Error("Can not resolve #include <" + e + ">");
  }
  return as(n);
}
const Ad = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function Oa(t) {
  return t.replace(Ad, wd);
}
function wd(t, e, n, o) {
  let l = "";
  for (let u = parseInt(e); u < parseInt(n); u++)
    l += o.replace(/\[\s*i\s*\]/g, "[ " + u + " ]").replace(/UNROLLED_LOOP_INDEX/g, u);
  return l;
}
function Ba(t) {
  let e = `precision ${t.precision} float;
	precision ${t.precision} int;
	precision ${t.precision} sampler2D;
	precision ${t.precision} samplerCube;
	`;
  return t.isWebGL2 && (e += `precision ${t.precision} sampler3D;
		precision ${t.precision} sampler2DArray;
		precision ${t.precision} sampler2DShadow;
		precision ${t.precision} samplerCubeShadow;
		precision ${t.precision} sampler2DArrayShadow;
		precision ${t.precision} isampler2D;
		precision ${t.precision} isampler3D;
		precision ${t.precision} isamplerCube;
		precision ${t.precision} isampler2DArray;
		precision ${t.precision} usampler2D;
		precision ${t.precision} usampler3D;
		precision ${t.precision} usamplerCube;
		precision ${t.precision} usampler2DArray;
		`), t.precision === "highp" ? e += `
#define HIGH_PRECISION` : t.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : t.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
}
function Rd(t) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return t.shadowMapType === Qa ? e = "SHADOWMAP_TYPE_PCF" : t.shadowMapType === Oo ? e = "SHADOWMAP_TYPE_PCF_SOFT" : t.shadowMapType === qt && (e = "SHADOWMAP_TYPE_VSM"), e;
}
function Cd(t) {
  let e = "ENVMAP_TYPE_CUBE";
  if (t.envMap)
    switch (t.envMapMode) {
      case ii:
      case ri:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case lr:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function Pd(t) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (t.envMap)
    switch (t.envMapMode) {
      case ri:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function Ld(t) {
  let e = "ENVMAP_BLENDING_NONE";
  if (t.envMap)
    switch (t.combine) {
      case eo:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case ol:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case ll:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function Dd(t) {
  const e = t.envMapCubeUVHeight;
  if (e === null)
    return null;
  const n = Math.log2(e) - 2, o = 1 / e;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 7 * 16)), texelHeight: o, maxMip: n };
}
function Ud(t, e, n, o) {
  const l = t.getContext(), u = n.defines;
  let f = n.vertexShader, h = n.fragmentShader;
  const p = Rd(n), v = Cd(n), g = Pd(n), w = Ld(n), E = Dd(n), T = n.isWebGL2 ? "" : xd(n), R = Md(n), _ = Sd(u), b = l.createProgram();
  let M, A, $ = n.glslVersion ? "#version " + n.glslVersion + `
` : "";
  n.isRawShaderMaterial ? (M = [
    "#define SHADER_TYPE " + n.shaderType,
    "#define SHADER_NAME " + n.shaderName,
    _
  ].filter(Jn).join(`
`), M.length > 0 && (M += `
`), A = [
    T,
    "#define SHADER_TYPE " + n.shaderType,
    "#define SHADER_NAME " + n.shaderName,
    _
  ].filter(Jn).join(`
`), A.length > 0 && (A += `
`)) : (M = [
    Ba(n),
    "#define SHADER_TYPE " + n.shaderType,
    "#define SHADER_NAME " + n.shaderName,
    _,
    n.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
    n.batching ? "#define USE_BATCHING" : "",
    n.instancing ? "#define USE_INSTANCING" : "",
    n.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
    n.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
    n.useFog && n.fog ? "#define USE_FOG" : "",
    n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
    n.map ? "#define USE_MAP" : "",
    n.envMap ? "#define USE_ENVMAP" : "",
    n.envMap ? "#define " + g : "",
    n.lightMap ? "#define USE_LIGHTMAP" : "",
    n.aoMap ? "#define USE_AOMAP" : "",
    n.bumpMap ? "#define USE_BUMPMAP" : "",
    n.normalMap ? "#define USE_NORMALMAP" : "",
    n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
    n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    n.anisotropy ? "#define USE_ANISOTROPY" : "",
    n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    n.specularMap ? "#define USE_SPECULARMAP" : "",
    n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    n.metalnessMap ? "#define USE_METALNESSMAP" : "",
    n.alphaMap ? "#define USE_ALPHAMAP" : "",
    n.alphaHash ? "#define USE_ALPHAHASH" : "",
    n.transmission ? "#define USE_TRANSMISSION" : "",
    n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    //
    n.mapUv ? "#define MAP_UV " + n.mapUv : "",
    n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "",
    n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "",
    n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "",
    n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "",
    n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "",
    n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "",
    n.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv : "",
    n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "",
    n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "",
    n.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv : "",
    n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "",
    n.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv : "",
    n.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv : "",
    n.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv : "",
    n.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv : "",
    n.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv : "",
    n.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv : "",
    n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "",
    n.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv : "",
    n.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv : "",
    n.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv : "",
    n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "",
    //
    n.vertexTangents && n.flatShading === !1 ? "#define USE_TANGENT" : "",
    n.vertexColors ? "#define USE_COLOR" : "",
    n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    n.vertexUv1s ? "#define USE_UV1" : "",
    n.vertexUv2s ? "#define USE_UV2" : "",
    n.vertexUv3s ? "#define USE_UV3" : "",
    n.pointsUvs ? "#define USE_POINTS_UV" : "",
    n.flatShading ? "#define FLAT_SHADED" : "",
    n.skinning ? "#define USE_SKINNING" : "",
    n.morphTargets ? "#define USE_MORPHTARGETS" : "",
    n.morphNormals && n.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
    n.morphColors && n.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
    n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
    n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "",
    n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "",
    n.doubleSided ? "#define DOUBLE_SIDED" : "",
    n.flipSided ? "#define FLIP_SIDED" : "",
    n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    n.shadowMapEnabled ? "#define " + p : "",
    n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
    n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    n.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
    n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    "uniform mat4 modelMatrix;",
    "uniform mat4 modelViewMatrix;",
    "uniform mat4 projectionMatrix;",
    "uniform mat4 viewMatrix;",
    "uniform mat3 normalMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    "#ifdef USE_INSTANCING",
    "	attribute mat4 instanceMatrix;",
    "#endif",
    "#ifdef USE_INSTANCING_COLOR",
    "	attribute vec3 instanceColor;",
    "#endif",
    "#ifdef USE_INSTANCING_MORPH",
    "	uniform sampler2D morphTexture;",
    "#endif",
    "attribute vec3 position;",
    "attribute vec3 normal;",
    "attribute vec2 uv;",
    "#ifdef USE_UV1",
    "	attribute vec2 uv1;",
    "#endif",
    "#ifdef USE_UV2",
    "	attribute vec2 uv2;",
    "#endif",
    "#ifdef USE_UV3",
    "	attribute vec2 uv3;",
    "#endif",
    "#ifdef USE_TANGENT",
    "	attribute vec4 tangent;",
    "#endif",
    "#if defined( USE_COLOR_ALPHA )",
    "	attribute vec4 color;",
    "#elif defined( USE_COLOR )",
    "	attribute vec3 color;",
    "#endif",
    "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
    "	attribute vec3 morphTarget0;",
    "	attribute vec3 morphTarget1;",
    "	attribute vec3 morphTarget2;",
    "	attribute vec3 morphTarget3;",
    "	#ifdef USE_MORPHNORMALS",
    "		attribute vec3 morphNormal0;",
    "		attribute vec3 morphNormal1;",
    "		attribute vec3 morphNormal2;",
    "		attribute vec3 morphNormal3;",
    "	#else",
    "		attribute vec3 morphTarget4;",
    "		attribute vec3 morphTarget5;",
    "		attribute vec3 morphTarget6;",
    "		attribute vec3 morphTarget7;",
    "	#endif",
    "#endif",
    "#ifdef USE_SKINNING",
    "	attribute vec4 skinIndex;",
    "	attribute vec4 skinWeight;",
    "#endif",
    `
`
  ].filter(Jn).join(`
`), A = [
    T,
    Ba(n),
    "#define SHADER_TYPE " + n.shaderType,
    "#define SHADER_NAME " + n.shaderName,
    _,
    n.useFog && n.fog ? "#define USE_FOG" : "",
    n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
    n.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
    n.map ? "#define USE_MAP" : "",
    n.matcap ? "#define USE_MATCAP" : "",
    n.envMap ? "#define USE_ENVMAP" : "",
    n.envMap ? "#define " + v : "",
    n.envMap ? "#define " + g : "",
    n.envMap ? "#define " + w : "",
    E ? "#define CUBEUV_TEXEL_WIDTH " + E.texelWidth : "",
    E ? "#define CUBEUV_TEXEL_HEIGHT " + E.texelHeight : "",
    E ? "#define CUBEUV_MAX_MIP " + E.maxMip + ".0" : "",
    n.lightMap ? "#define USE_LIGHTMAP" : "",
    n.aoMap ? "#define USE_AOMAP" : "",
    n.bumpMap ? "#define USE_BUMPMAP" : "",
    n.normalMap ? "#define USE_NORMALMAP" : "",
    n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    n.anisotropy ? "#define USE_ANISOTROPY" : "",
    n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    n.clearcoat ? "#define USE_CLEARCOAT" : "",
    n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    n.iridescence ? "#define USE_IRIDESCENCE" : "",
    n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    n.specularMap ? "#define USE_SPECULARMAP" : "",
    n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    n.metalnessMap ? "#define USE_METALNESSMAP" : "",
    n.alphaMap ? "#define USE_ALPHAMAP" : "",
    n.alphaTest ? "#define USE_ALPHATEST" : "",
    n.alphaHash ? "#define USE_ALPHAHASH" : "",
    n.sheen ? "#define USE_SHEEN" : "",
    n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    n.transmission ? "#define USE_TRANSMISSION" : "",
    n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    n.vertexTangents && n.flatShading === !1 ? "#define USE_TANGENT" : "",
    n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "",
    n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    n.vertexUv1s ? "#define USE_UV1" : "",
    n.vertexUv2s ? "#define USE_UV2" : "",
    n.vertexUv3s ? "#define USE_UV3" : "",
    n.pointsUvs ? "#define USE_POINTS_UV" : "",
    n.gradientMap ? "#define USE_GRADIENTMAP" : "",
    n.flatShading ? "#define FLAT_SHADED" : "",
    n.doubleSided ? "#define DOUBLE_SIDED" : "",
    n.flipSided ? "#define FLIP_SIDED" : "",
    n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    n.shadowMapEnabled ? "#define " + p : "",
    n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
    n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    n.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
    n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
    n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    "uniform mat4 viewMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    n.toneMapping !== cn ? "#define TONE_MAPPING" : "",
    n.toneMapping !== cn ? ze.tonemapping_pars_fragment : "",
    // this code is required here because it is used by the toneMapping() function defined below
    n.toneMapping !== cn ? vd("toneMapping", n.toneMapping) : "",
    n.dithering ? "#define DITHERING" : "",
    n.opaque ? "#define OPAQUE" : "",
    ze.colorspace_pars_fragment,
    // this code is required here because it is used by the various encoding/decoding function defined below
    gd("linearToOutputTexel", n.outputColorSpace),
    n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "",
    `
`
  ].filter(Jn).join(`
`)), f = as(f), f = Na(f, n), f = Fa(f, n), h = as(h), h = Na(h, n), h = Fa(h, n), f = Oa(f), h = Oa(h), n.isWebGL2 && n.isRawShaderMaterial !== !0 && ($ = `#version 300 es
`, M = [
    R,
    "precision mediump sampler2DArray;",
    "#define attribute in",
    "#define varying out",
    "#define texture2D texture"
  ].join(`
`) + `
` + M, A = [
    "precision mediump sampler2DArray;",
    "#define varying in",
    n.glslVersion === ea ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
    n.glslVersion === ea ? "" : "#define gl_FragColor pc_fragColor",
    "#define gl_FragDepthEXT gl_FragDepth",
    "#define texture2D texture",
    "#define textureCube texture",
    "#define texture2DProj textureProj",
    "#define texture2DLodEXT textureLod",
    "#define texture2DProjLodEXT textureProjLod",
    "#define textureCubeLodEXT textureLod",
    "#define texture2DGradEXT textureGrad",
    "#define texture2DProjGradEXT textureProjGrad",
    "#define textureCubeGradEXT textureGrad"
  ].join(`
`) + `
` + A);
  const S = $ + M + f, C = $ + A + h, D = Ua(l, l.VERTEX_SHADER, S), O = Ua(l, l.FRAGMENT_SHADER, C);
  l.attachShader(b, D), l.attachShader(b, O), n.index0AttributeName !== void 0 ? l.bindAttribLocation(b, 0, n.index0AttributeName) : n.morphTargets === !0 && l.bindAttribLocation(b, 0, "position"), l.linkProgram(b);
  function N(G) {
    if (t.debug.checkShaderErrors) {
      const B = l.getProgramInfoLog(b).trim(), F = l.getShaderInfoLog(D).trim(), H = l.getShaderInfoLog(O).trim();
      let W = !0, V = !0;
      if (l.getProgramParameter(b, l.LINK_STATUS) === !1)
        if (W = !1, typeof t.debug.onShaderError == "function")
          t.debug.onShaderError(l, b, D, O);
        else {
          const X = Ia(l, D, "vertex"), Z = Ia(l, O, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " + l.getError() + " - VALIDATE_STATUS " + l.getProgramParameter(b, l.VALIDATE_STATUS) + `

Material Name: ` + G.name + `
Material Type: ` + G.type + `

Program Info Log: ` + B + `
` + X + `
` + Z
          );
        }
      else
        B !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", B) : (F === "" || H === "") && (V = !1);
      V && (G.diagnostics = {
        runnable: W,
        programLog: B,
        vertexShader: {
          log: F,
          prefix: M
        },
        fragmentShader: {
          log: H,
          prefix: A
        }
      });
    }
    l.deleteShader(D), l.deleteShader(O), j = new Ji(l, b), L = Ed(l, b);
  }
  let j;
  this.getUniforms = function() {
    return j === void 0 && N(this), j;
  };
  let L;
  this.getAttributes = function() {
    return L === void 0 && N(this), L;
  };
  let z = n.rendererExtensionParallelShaderCompile === !1;
  return this.isReady = function() {
    return z === !1 && (z = l.getProgramParameter(b, dd)), z;
  }, this.destroy = function() {
    o.releaseStatesOfProgram(this), l.deleteProgram(b), this.program = void 0;
  }, this.type = n.shaderType, this.name = n.shaderName, this.id = pd++, this.cacheKey = e, this.usedTimes = 1, this.program = b, this.vertexShader = D, this.fragmentShader = O, this;
}
let Id = 0;
class Nd {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(e) {
    const n = e.vertexShader, o = e.fragmentShader, l = this._getShaderStage(n), u = this._getShaderStage(o), f = this._getShaderCacheForMaterial(e);
    return f.has(l) === !1 && (f.add(l), l.usedTimes++), f.has(u) === !1 && (f.add(u), u.usedTimes++), this;
  }
  remove(e) {
    const n = this.materialCache.get(e);
    for (const o of n)
      o.usedTimes--, o.usedTimes === 0 && this.shaderCache.delete(o.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const n = this.materialCache;
    let o = n.get(e);
    return o === void 0 && (o = /* @__PURE__ */ new Set(), n.set(e, o)), o;
  }
  _getShaderStage(e) {
    const n = this.shaderCache;
    let o = n.get(e);
    return o === void 0 && (o = new Fd(e), n.set(e, o)), o;
  }
}
class Fd {
  constructor(e) {
    this.id = Id++, this.code = e, this.usedTimes = 0;
  }
}
function Od(t, e, n, o, l, u, f) {
  const h = new mo(), p = new Nd(), v = /* @__PURE__ */ new Set(), g = [], w = l.isWebGL2, E = l.logarithmicDepthBuffer, T = l.vertexTextures;
  let R = l.precision;
  const _ = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function b(L) {
    return v.add(L), L === 0 ? "uv" : `uv${L}`;
  }
  function M(L, z, G, B, F) {
    const H = B.fog, W = F.geometry, V = L.isMeshStandardMaterial ? B.environment : null, X = (L.isMeshStandardMaterial ? n : e).get(L.envMap || V), Z = X && X.mapping === lr ? X.image.height : null, Q = _[L.type];
    L.precision !== null && (R = l.getMaxPrecision(L.precision), R !== L.precision && console.warn("THREE.WebGLProgram.getParameters:", L.precision, "not supported, using", R, "instead."));
    const q = W.morphAttributes.position || W.morphAttributes.normal || W.morphAttributes.color, J = q !== void 0 ? q.length : 0;
    let ie = 0;
    W.morphAttributes.position !== void 0 && (ie = 1), W.morphAttributes.normal !== void 0 && (ie = 2), W.morphAttributes.color !== void 0 && (ie = 3);
    let ne, ge, ye, xe;
    if (Q) {
      const Le = zt[Q];
      ne = Le.vertexShader, ge = Le.fragmentShader;
    } else
      ne = L.vertexShader, ge = L.fragmentShader, p.update(L), ye = p.getVertexShaderID(L), xe = p.getFragmentShaderID(L);
    const we = t.getRenderTarget(), de = F.isInstancedMesh === !0, Te = F.isBatchedMesh === !0, Ce = !!L.map, ee = !!L.matcap, Ae = !!X, be = !!L.aoMap, Fe = !!L.lightMap, et = !!L.bumpMap, Ye = !!L.normalMap, De = !!L.displacementMap, Ue = !!L.emissiveMap, Qe = !!L.metalnessMap, ue = !!L.roughnessMap, te = L.anisotropy > 0, Be = L.clearcoat > 0, Je = L.iridescence > 0, ft = L.sheen > 0, lt = L.transmission > 0, he = te && !!L.anisotropyMap, ae = Be && !!L.clearcoatMap, se = Be && !!L.clearcoatNormalMap, Re = Be && !!L.clearcoatRoughnessMap, Oe = Je && !!L.iridescenceMap, We = Je && !!L.iridescenceThicknessMap, Ct = ft && !!L.sheenColorMap, le = ft && !!L.sheenRoughnessMap, ke = !!L.specularMap, Ke = !!L.specularColorMap, me = !!L.specularIntensityMap, Ee = lt && !!L.transmissionMap, tt = lt && !!L.thicknessMap, ce = !!L.gradientMap, _e = !!L.alphaMap, Ht = L.alphaTest > 0, K = !!L.alphaHash, Ve = !!L.extensions;
    let Ne = cn;
    L.toneMapped && (we === null || we.isXRRenderTarget === !0) && (Ne = t.toneMapping);
    const pe = {
      isWebGL2: w,
      shaderID: Q,
      shaderType: L.type,
      shaderName: L.name,
      vertexShader: ne,
      fragmentShader: ge,
      defines: L.defines,
      customVertexShaderID: ye,
      customFragmentShaderID: xe,
      isRawShaderMaterial: L.isRawShaderMaterial === !0,
      glslVersion: L.glslVersion,
      precision: R,
      batching: Te,
      instancing: de,
      instancingColor: de && F.instanceColor !== null,
      instancingMorph: de && F.morphTexture !== null,
      supportsVertexTextures: T,
      outputColorSpace: we === null ? t.outputColorSpace : we.isXRRenderTarget === !0 ? we.texture.colorSpace : dn,
      alphaToCoverage: !!L.alphaToCoverage,
      map: Ce,
      matcap: ee,
      envMap: Ae,
      envMapMode: Ae && X.mapping,
      envMapCubeUVHeight: Z,
      aoMap: be,
      lightMap: Fe,
      bumpMap: et,
      normalMap: Ye,
      displacementMap: T && De,
      emissiveMap: Ue,
      normalMapObjectSpace: Ye && L.normalMapType === wl,
      normalMapTangentSpace: Ye && L.normalMapType === Al,
      metalnessMap: Qe,
      roughnessMap: ue,
      anisotropy: te,
      anisotropyMap: he,
      clearcoat: Be,
      clearcoatMap: ae,
      clearcoatNormalMap: se,
      clearcoatRoughnessMap: Re,
      iridescence: Je,
      iridescenceMap: Oe,
      iridescenceThicknessMap: We,
      sheen: ft,
      sheenColorMap: Ct,
      sheenRoughnessMap: le,
      specularMap: ke,
      specularColorMap: Ke,
      specularIntensityMap: me,
      transmission: lt,
      transmissionMap: Ee,
      thicknessMap: tt,
      gradientMap: ce,
      opaque: L.transparent === !1 && L.blending === Qn && L.alphaToCoverage === !1,
      alphaMap: _e,
      alphaTest: Ht,
      alphaHash: K,
      combine: L.combine,
      //
      mapUv: Ce && b(L.map.channel),
      aoMapUv: be && b(L.aoMap.channel),
      lightMapUv: Fe && b(L.lightMap.channel),
      bumpMapUv: et && b(L.bumpMap.channel),
      normalMapUv: Ye && b(L.normalMap.channel),
      displacementMapUv: De && b(L.displacementMap.channel),
      emissiveMapUv: Ue && b(L.emissiveMap.channel),
      metalnessMapUv: Qe && b(L.metalnessMap.channel),
      roughnessMapUv: ue && b(L.roughnessMap.channel),
      anisotropyMapUv: he && b(L.anisotropyMap.channel),
      clearcoatMapUv: ae && b(L.clearcoatMap.channel),
      clearcoatNormalMapUv: se && b(L.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: Re && b(L.clearcoatRoughnessMap.channel),
      iridescenceMapUv: Oe && b(L.iridescenceMap.channel),
      iridescenceThicknessMapUv: We && b(L.iridescenceThicknessMap.channel),
      sheenColorMapUv: Ct && b(L.sheenColorMap.channel),
      sheenRoughnessMapUv: le && b(L.sheenRoughnessMap.channel),
      specularMapUv: ke && b(L.specularMap.channel),
      specularColorMapUv: Ke && b(L.specularColorMap.channel),
      specularIntensityMapUv: me && b(L.specularIntensityMap.channel),
      transmissionMapUv: Ee && b(L.transmissionMap.channel),
      thicknessMapUv: tt && b(L.thicknessMap.channel),
      alphaMapUv: _e && b(L.alphaMap.channel),
      //
      vertexTangents: !!W.attributes.tangent && (Ye || te),
      vertexColors: L.vertexColors,
      vertexAlphas: L.vertexColors === !0 && !!W.attributes.color && W.attributes.color.itemSize === 4,
      pointsUvs: F.isPoints === !0 && !!W.attributes.uv && (Ce || _e),
      fog: !!H,
      useFog: L.fog === !0,
      fogExp2: !!H && H.isFogExp2,
      flatShading: L.flatShading === !0,
      sizeAttenuation: L.sizeAttenuation === !0,
      logarithmicDepthBuffer: E,
      skinning: F.isSkinnedMesh === !0,
      morphTargets: W.morphAttributes.position !== void 0,
      morphNormals: W.morphAttributes.normal !== void 0,
      morphColors: W.morphAttributes.color !== void 0,
      morphTargetsCount: J,
      morphTextureStride: ie,
      numDirLights: z.directional.length,
      numPointLights: z.point.length,
      numSpotLights: z.spot.length,
      numSpotLightMaps: z.spotLightMap.length,
      numRectAreaLights: z.rectArea.length,
      numHemiLights: z.hemi.length,
      numDirLightShadows: z.directionalShadowMap.length,
      numPointLightShadows: z.pointShadowMap.length,
      numSpotLightShadows: z.spotShadowMap.length,
      numSpotLightShadowsWithMaps: z.numSpotLightShadowsWithMaps,
      numLightProbes: z.numLightProbes,
      numClippingPlanes: f.numPlanes,
      numClipIntersection: f.numIntersection,
      dithering: L.dithering,
      shadowMapEnabled: t.shadowMap.enabled && G.length > 0,
      shadowMapType: t.shadowMap.type,
      toneMapping: Ne,
      useLegacyLights: t._useLegacyLights,
      decodeVideoTexture: Ce && L.map.isVideoTexture === !0 && je.getTransfer(L.map.colorSpace) === $e,
      premultipliedAlpha: L.premultipliedAlpha,
      doubleSided: L.side === jt,
      flipSided: L.side === Et,
      useDepthPacking: L.depthPacking >= 0,
      depthPacking: L.depthPacking || 0,
      index0AttributeName: L.index0AttributeName,
      extensionDerivatives: Ve && L.extensions.derivatives === !0,
      extensionFragDepth: Ve && L.extensions.fragDepth === !0,
      extensionDrawBuffers: Ve && L.extensions.drawBuffers === !0,
      extensionShaderTextureLOD: Ve && L.extensions.shaderTextureLOD === !0,
      extensionClipCullDistance: Ve && L.extensions.clipCullDistance === !0 && o.has("WEBGL_clip_cull_distance"),
      extensionMultiDraw: Ve && L.extensions.multiDraw === !0 && o.has("WEBGL_multi_draw"),
      rendererExtensionFragDepth: w || o.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: w || o.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: w || o.has("EXT_shader_texture_lod"),
      rendererExtensionParallelShaderCompile: o.has("KHR_parallel_shader_compile"),
      customProgramCacheKey: L.customProgramCacheKey()
    };
    return pe.vertexUv1s = v.has(1), pe.vertexUv2s = v.has(2), pe.vertexUv3s = v.has(3), v.clear(), pe;
  }
  function A(L) {
    const z = [];
    if (L.shaderID ? z.push(L.shaderID) : (z.push(L.customVertexShaderID), z.push(L.customFragmentShaderID)), L.defines !== void 0)
      for (const G in L.defines)
        z.push(G), z.push(L.defines[G]);
    return L.isRawShaderMaterial === !1 && ($(z, L), S(z, L), z.push(t.outputColorSpace)), z.push(L.customProgramCacheKey), z.join();
  }
  function $(L, z) {
    L.push(z.precision), L.push(z.outputColorSpace), L.push(z.envMapMode), L.push(z.envMapCubeUVHeight), L.push(z.mapUv), L.push(z.alphaMapUv), L.push(z.lightMapUv), L.push(z.aoMapUv), L.push(z.bumpMapUv), L.push(z.normalMapUv), L.push(z.displacementMapUv), L.push(z.emissiveMapUv), L.push(z.metalnessMapUv), L.push(z.roughnessMapUv), L.push(z.anisotropyMapUv), L.push(z.clearcoatMapUv), L.push(z.clearcoatNormalMapUv), L.push(z.clearcoatRoughnessMapUv), L.push(z.iridescenceMapUv), L.push(z.iridescenceThicknessMapUv), L.push(z.sheenColorMapUv), L.push(z.sheenRoughnessMapUv), L.push(z.specularMapUv), L.push(z.specularColorMapUv), L.push(z.specularIntensityMapUv), L.push(z.transmissionMapUv), L.push(z.thicknessMapUv), L.push(z.combine), L.push(z.fogExp2), L.push(z.sizeAttenuation), L.push(z.morphTargetsCount), L.push(z.morphAttributeCount), L.push(z.numDirLights), L.push(z.numPointLights), L.push(z.numSpotLights), L.push(z.numSpotLightMaps), L.push(z.numHemiLights), L.push(z.numRectAreaLights), L.push(z.numDirLightShadows), L.push(z.numPointLightShadows), L.push(z.numSpotLightShadows), L.push(z.numSpotLightShadowsWithMaps), L.push(z.numLightProbes), L.push(z.shadowMapType), L.push(z.toneMapping), L.push(z.numClippingPlanes), L.push(z.numClipIntersection), L.push(z.depthPacking);
  }
  function S(L, z) {
    h.disableAll(), z.isWebGL2 && h.enable(0), z.supportsVertexTextures && h.enable(1), z.instancing && h.enable(2), z.instancingColor && h.enable(3), z.instancingMorph && h.enable(4), z.matcap && h.enable(5), z.envMap && h.enable(6), z.normalMapObjectSpace && h.enable(7), z.normalMapTangentSpace && h.enable(8), z.clearcoat && h.enable(9), z.iridescence && h.enable(10), z.alphaTest && h.enable(11), z.vertexColors && h.enable(12), z.vertexAlphas && h.enable(13), z.vertexUv1s && h.enable(14), z.vertexUv2s && h.enable(15), z.vertexUv3s && h.enable(16), z.vertexTangents && h.enable(17), z.anisotropy && h.enable(18), z.alphaHash && h.enable(19), z.batching && h.enable(20), L.push(h.mask), h.disableAll(), z.fog && h.enable(0), z.useFog && h.enable(1), z.flatShading && h.enable(2), z.logarithmicDepthBuffer && h.enable(3), z.skinning && h.enable(4), z.morphTargets && h.enable(5), z.morphNormals && h.enable(6), z.morphColors && h.enable(7), z.premultipliedAlpha && h.enable(8), z.shadowMapEnabled && h.enable(9), z.useLegacyLights && h.enable(10), z.doubleSided && h.enable(11), z.flipSided && h.enable(12), z.useDepthPacking && h.enable(13), z.dithering && h.enable(14), z.transmission && h.enable(15), z.sheen && h.enable(16), z.opaque && h.enable(17), z.pointsUvs && h.enable(18), z.decodeVideoTexture && h.enable(19), z.alphaToCoverage && h.enable(20), L.push(h.mask);
  }
  function C(L) {
    const z = _[L.type];
    let G;
    if (z) {
      const B = zt[z];
      G = mc.clone(B.uniforms);
    } else
      G = L.uniforms;
    return G;
  }
  function D(L, z) {
    let G;
    for (let B = 0, F = g.length; B < F; B++) {
      const H = g[B];
      if (H.cacheKey === z) {
        G = H, ++G.usedTimes;
        break;
      }
    }
    return G === void 0 && (G = new Ud(t, z, L, u), g.push(G)), G;
  }
  function O(L) {
    if (--L.usedTimes === 0) {
      const z = g.indexOf(L);
      g[z] = g[g.length - 1], g.pop(), L.destroy();
    }
  }
  function N(L) {
    p.remove(L);
  }
  function j() {
    p.dispose();
  }
  return {
    getParameters: M,
    getProgramCacheKey: A,
    getUniforms: C,
    acquireProgram: D,
    releaseProgram: O,
    releaseShaderCache: N,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs: g,
    dispose: j
  };
}
function Bd() {
  let t = /* @__PURE__ */ new WeakMap();
  function e(u) {
    let f = t.get(u);
    return f === void 0 && (f = {}, t.set(u, f)), f;
  }
  function n(u) {
    t.delete(u);
  }
  function o(u, f, h) {
    t.get(u)[f] = h;
  }
  function l() {
    t = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    remove: n,
    update: o,
    dispose: l
  };
}
function zd(t, e) {
  return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id;
}
function za(t, e) {
  return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id;
}
function Ga() {
  const t = [];
  let e = 0;
  const n = [], o = [], l = [];
  function u() {
    e = 0, n.length = 0, o.length = 0, l.length = 0;
  }
  function f(w, E, T, R, _, b) {
    let M = t[e];
    return M === void 0 ? (M = {
      id: w.id,
      object: w,
      geometry: E,
      material: T,
      groupOrder: R,
      renderOrder: w.renderOrder,
      z: _,
      group: b
    }, t[e] = M) : (M.id = w.id, M.object = w, M.geometry = E, M.material = T, M.groupOrder = R, M.renderOrder = w.renderOrder, M.z = _, M.group = b), e++, M;
  }
  function h(w, E, T, R, _, b) {
    const M = f(w, E, T, R, _, b);
    T.transmission > 0 ? o.push(M) : T.transparent === !0 ? l.push(M) : n.push(M);
  }
  function p(w, E, T, R, _, b) {
    const M = f(w, E, T, R, _, b);
    T.transmission > 0 ? o.unshift(M) : T.transparent === !0 ? l.unshift(M) : n.unshift(M);
  }
  function v(w, E) {
    n.length > 1 && n.sort(w || zd), o.length > 1 && o.sort(E || za), l.length > 1 && l.sort(E || za);
  }
  function g() {
    for (let w = e, E = t.length; w < E; w++) {
      const T = t[w];
      if (T.id === null)
        break;
      T.id = null, T.object = null, T.geometry = null, T.material = null, T.group = null;
    }
  }
  return {
    opaque: n,
    transmissive: o,
    transparent: l,
    init: u,
    push: h,
    unshift: p,
    finish: g,
    sort: v
  };
}
function Gd() {
  let t = /* @__PURE__ */ new WeakMap();
  function e(o, l) {
    const u = t.get(o);
    let f;
    return u === void 0 ? (f = new Ga(), t.set(o, [f])) : l >= u.length ? (f = new Ga(), u.push(f)) : f = u[l], f;
  }
  function n() {
    t = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    dispose: n
  };
}
function Hd() {
  const t = {};
  return {
    get: function(e) {
      if (t[e.id] !== void 0)
        return t[e.id];
      let n;
      switch (e.type) {
        case "DirectionalLight":
          n = {
            direction: new I(),
            color: new qe()
          };
          break;
        case "SpotLight":
          n = {
            position: new I(),
            direction: new I(),
            color: new qe(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          n = {
            position: new I(),
            color: new qe(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          n = {
            direction: new I(),
            skyColor: new qe(),
            groundColor: new qe()
          };
          break;
        case "RectAreaLight":
          n = {
            color: new qe(),
            position: new I(),
            halfWidth: new I(),
            halfHeight: new I()
          };
          break;
      }
      return t[e.id] = n, n;
    }
  };
}
function Vd() {
  const t = {};
  return {
    get: function(e) {
      if (t[e.id] !== void 0)
        return t[e.id];
      let n;
      switch (e.type) {
        case "DirectionalLight":
          n = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ie()
          };
          break;
        case "SpotLight":
          n = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ie()
          };
          break;
        case "PointLight":
          n = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ie(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      return t[e.id] = n, n;
    }
  };
}
let kd = 0;
function Wd(t, e) {
  return (e.castShadow ? 2 : 0) - (t.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (t.map ? 1 : 0);
}
function Xd(t, e) {
  const n = new Hd(), o = Vd(), l = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
      numSpotMaps: -1,
      numLightProbes: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotLightMap: [],
    spotShadow: [],
    spotShadowMap: [],
    spotLightMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numSpotLightShadowsWithMaps: 0,
    numLightProbes: 0
  };
  for (let g = 0; g < 9; g++)
    l.probe.push(new I());
  const u = new I(), f = new st(), h = new st();
  function p(g, w) {
    let E = 0, T = 0, R = 0;
    for (let G = 0; G < 9; G++)
      l.probe[G].set(0, 0, 0);
    let _ = 0, b = 0, M = 0, A = 0, $ = 0, S = 0, C = 0, D = 0, O = 0, N = 0, j = 0;
    g.sort(Wd);
    const L = w === !0 ? Math.PI : 1;
    for (let G = 0, B = g.length; G < B; G++) {
      const F = g[G], H = F.color, W = F.intensity, V = F.distance, X = F.shadow && F.shadow.map ? F.shadow.map.texture : null;
      if (F.isAmbientLight)
        E += H.r * W * L, T += H.g * W * L, R += H.b * W * L;
      else if (F.isLightProbe) {
        for (let Z = 0; Z < 9; Z++)
          l.probe[Z].addScaledVector(F.sh.coefficients[Z], W);
        j++;
      } else if (F.isDirectionalLight) {
        const Z = n.get(F);
        if (Z.color.copy(F.color).multiplyScalar(F.intensity * L), F.castShadow) {
          const Q = F.shadow, q = o.get(F);
          q.shadowBias = Q.bias, q.shadowNormalBias = Q.normalBias, q.shadowRadius = Q.radius, q.shadowMapSize = Q.mapSize, l.directionalShadow[_] = q, l.directionalShadowMap[_] = X, l.directionalShadowMatrix[_] = F.shadow.matrix, S++;
        }
        l.directional[_] = Z, _++;
      } else if (F.isSpotLight) {
        const Z = n.get(F);
        Z.position.setFromMatrixPosition(F.matrixWorld), Z.color.copy(H).multiplyScalar(W * L), Z.distance = V, Z.coneCos = Math.cos(F.angle), Z.penumbraCos = Math.cos(F.angle * (1 - F.penumbra)), Z.decay = F.decay, l.spot[M] = Z;
        const Q = F.shadow;
        if (F.map && (l.spotLightMap[O] = F.map, O++, Q.updateMatrices(F), F.castShadow && N++), l.spotLightMatrix[M] = Q.matrix, F.castShadow) {
          const q = o.get(F);
          q.shadowBias = Q.bias, q.shadowNormalBias = Q.normalBias, q.shadowRadius = Q.radius, q.shadowMapSize = Q.mapSize, l.spotShadow[M] = q, l.spotShadowMap[M] = X, D++;
        }
        M++;
      } else if (F.isRectAreaLight) {
        const Z = n.get(F);
        Z.color.copy(H).multiplyScalar(W), Z.halfWidth.set(F.width * 0.5, 0, 0), Z.halfHeight.set(0, F.height * 0.5, 0), l.rectArea[A] = Z, A++;
      } else if (F.isPointLight) {
        const Z = n.get(F);
        if (Z.color.copy(F.color).multiplyScalar(F.intensity * L), Z.distance = F.distance, Z.decay = F.decay, F.castShadow) {
          const Q = F.shadow, q = o.get(F);
          q.shadowBias = Q.bias, q.shadowNormalBias = Q.normalBias, q.shadowRadius = Q.radius, q.shadowMapSize = Q.mapSize, q.shadowCameraNear = Q.camera.near, q.shadowCameraFar = Q.camera.far, l.pointShadow[b] = q, l.pointShadowMap[b] = X, l.pointShadowMatrix[b] = F.shadow.matrix, C++;
        }
        l.point[b] = Z, b++;
      } else if (F.isHemisphereLight) {
        const Z = n.get(F);
        Z.skyColor.copy(F.color).multiplyScalar(W * L), Z.groundColor.copy(F.groundColor).multiplyScalar(W * L), l.hemi[$] = Z, $++;
      }
    }
    A > 0 && (e.isWebGL2 ? t.has("OES_texture_float_linear") === !0 ? (l.rectAreaLTC1 = oe.LTC_FLOAT_1, l.rectAreaLTC2 = oe.LTC_FLOAT_2) : (l.rectAreaLTC1 = oe.LTC_HALF_1, l.rectAreaLTC2 = oe.LTC_HALF_2) : t.has("OES_texture_float_linear") === !0 ? (l.rectAreaLTC1 = oe.LTC_FLOAT_1, l.rectAreaLTC2 = oe.LTC_FLOAT_2) : t.has("OES_texture_half_float_linear") === !0 ? (l.rectAreaLTC1 = oe.LTC_HALF_1, l.rectAreaLTC2 = oe.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), l.ambient[0] = E, l.ambient[1] = T, l.ambient[2] = R;
    const z = l.hash;
    (z.directionalLength !== _ || z.pointLength !== b || z.spotLength !== M || z.rectAreaLength !== A || z.hemiLength !== $ || z.numDirectionalShadows !== S || z.numPointShadows !== C || z.numSpotShadows !== D || z.numSpotMaps !== O || z.numLightProbes !== j) && (l.directional.length = _, l.spot.length = M, l.rectArea.length = A, l.point.length = b, l.hemi.length = $, l.directionalShadow.length = S, l.directionalShadowMap.length = S, l.pointShadow.length = C, l.pointShadowMap.length = C, l.spotShadow.length = D, l.spotShadowMap.length = D, l.directionalShadowMatrix.length = S, l.pointShadowMatrix.length = C, l.spotLightMatrix.length = D + O - N, l.spotLightMap.length = O, l.numSpotLightShadowsWithMaps = N, l.numLightProbes = j, z.directionalLength = _, z.pointLength = b, z.spotLength = M, z.rectAreaLength = A, z.hemiLength = $, z.numDirectionalShadows = S, z.numPointShadows = C, z.numSpotShadows = D, z.numSpotMaps = O, z.numLightProbes = j, l.version = kd++);
  }
  function v(g, w) {
    let E = 0, T = 0, R = 0, _ = 0, b = 0;
    const M = w.matrixWorldInverse;
    for (let A = 0, $ = g.length; A < $; A++) {
      const S = g[A];
      if (S.isDirectionalLight) {
        const C = l.directional[E];
        C.direction.setFromMatrixPosition(S.matrixWorld), u.setFromMatrixPosition(S.target.matrixWorld), C.direction.sub(u), C.direction.transformDirection(M), E++;
      } else if (S.isSpotLight) {
        const C = l.spot[R];
        C.position.setFromMatrixPosition(S.matrixWorld), C.position.applyMatrix4(M), C.direction.setFromMatrixPosition(S.matrixWorld), u.setFromMatrixPosition(S.target.matrixWorld), C.direction.sub(u), C.direction.transformDirection(M), R++;
      } else if (S.isRectAreaLight) {
        const C = l.rectArea[_];
        C.position.setFromMatrixPosition(S.matrixWorld), C.position.applyMatrix4(M), h.identity(), f.copy(S.matrixWorld), f.premultiply(M), h.extractRotation(f), C.halfWidth.set(S.width * 0.5, 0, 0), C.halfHeight.set(0, S.height * 0.5, 0), C.halfWidth.applyMatrix4(h), C.halfHeight.applyMatrix4(h), _++;
      } else if (S.isPointLight) {
        const C = l.point[T];
        C.position.setFromMatrixPosition(S.matrixWorld), C.position.applyMatrix4(M), T++;
      } else if (S.isHemisphereLight) {
        const C = l.hemi[b];
        C.direction.setFromMatrixPosition(S.matrixWorld), C.direction.transformDirection(M), b++;
      }
    }
  }
  return {
    setup: p,
    setupView: v,
    state: l
  };
}
function Ha(t, e) {
  const n = new Xd(t, e), o = [], l = [];
  function u() {
    o.length = 0, l.length = 0;
  }
  function f(g) {
    o.push(g);
  }
  function h(g) {
    l.push(g);
  }
  function p(g) {
    n.setup(o, g);
  }
  function v(g) {
    n.setupView(o, g);
  }
  return {
    init: u,
    state: {
      lightsArray: o,
      shadowsArray: l,
      lights: n
    },
    setupLights: p,
    setupLightsView: v,
    pushLight: f,
    pushShadow: h
  };
}
function Yd(t, e) {
  let n = /* @__PURE__ */ new WeakMap();
  function o(u, f = 0) {
    const h = n.get(u);
    let p;
    return h === void 0 ? (p = new Ha(t, e), n.set(u, [p])) : f >= h.length ? (p = new Ha(t, e), h.push(p)) : p = h[f], p;
  }
  function l() {
    n = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: o,
    dispose: l
  };
}
class qd extends xi {
  constructor(e) {
    super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = Tl, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
  }
}
class jd extends xi {
  constructor(e) {
    super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
  }
}
const Kd = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, Zd = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function $d(t, e, n) {
  let o = new Eo();
  const l = new Ie(), u = new Ie(), f = new ht(), h = new qd({ depthPacking: bl }), p = new jd(), v = {}, g = n.maxTextureSize, w = { [hn]: Et, [Et]: hn, [jt]: jt }, E = new fn({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new Ie() },
      radius: { value: 4 }
    },
    vertexShader: Kd,
    fragmentShader: Zd
  }), T = E.clone();
  T.defines.HORIZONTAL_PASS = 1;
  const R = new Tt();
  R.setAttribute(
    "position",
    new Gt(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const _ = new Rt(R, E), b = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = Qa;
  let M = this.type;
  this.render = function(D, O, N) {
    if (b.enabled === !1 || b.autoUpdate === !1 && b.needsUpdate === !1 || D.length === 0)
      return;
    const j = t.getRenderTarget(), L = t.getActiveCubeFace(), z = t.getActiveMipmapLevel(), G = t.state;
    G.setBlending(ln$1), G.buffers.color.setClear(1, 1, 1, 1), G.buffers.depth.setTest(!0), G.setScissorTest(!1);
    const B = M !== qt && this.type === qt, F = M === qt && this.type !== qt;
    for (let H = 0, W = D.length; H < W; H++) {
      const V = D[H], X = V.shadow;
      if (X === void 0) {
        console.warn("THREE.WebGLShadowMap:", V, "has no shadow.");
        continue;
      }
      if (X.autoUpdate === !1 && X.needsUpdate === !1)
        continue;
      l.copy(X.mapSize);
      const Z = X.getFrameExtents();
      if (l.multiply(Z), u.copy(X.mapSize), (l.x > g || l.y > g) && (l.x > g && (u.x = Math.floor(g / Z.x), l.x = u.x * Z.x, X.mapSize.x = u.x), l.y > g && (u.y = Math.floor(g / Z.y), l.y = u.y * Z.y, X.mapSize.y = u.y)), X.map === null || B === !0 || F === !0) {
        const q = this.type !== qt ? { minFilter: xt, magFilter: xt } : {};
        X.map !== null && X.map.dispose(), X.map = new Cn(l.x, l.y, q), X.map.texture.name = V.name + ".shadowMap", X.camera.updateProjectionMatrix();
      }
      t.setRenderTarget(X.map), t.clear();
      const Q = X.getViewportCount();
      for (let q = 0; q < Q; q++) {
        const J = X.getViewport(q);
        f.set(
          u.x * J.x,
          u.y * J.y,
          u.x * J.z,
          u.y * J.w
        ), G.viewport(f), X.updateMatrices(V, q), o = X.getFrustum(), S(O, N, X.camera, V, this.type);
      }
      X.isPointLightShadow !== !0 && this.type === qt && A(X, N), X.needsUpdate = !1;
    }
    M = this.type, b.needsUpdate = !1, t.setRenderTarget(j, L, z);
  };
  function A(D, O) {
    const N = e.update(_);
    E.defines.VSM_SAMPLES !== D.blurSamples && (E.defines.VSM_SAMPLES = D.blurSamples, T.defines.VSM_SAMPLES = D.blurSamples, E.needsUpdate = !0, T.needsUpdate = !0), D.mapPass === null && (D.mapPass = new Cn(l.x, l.y)), E.uniforms.shadow_pass.value = D.map.texture, E.uniforms.resolution.value = D.mapSize, E.uniforms.radius.value = D.radius, t.setRenderTarget(D.mapPass), t.clear(), t.renderBufferDirect(O, null, N, E, _, null), T.uniforms.shadow_pass.value = D.mapPass.texture, T.uniforms.resolution.value = D.mapSize, T.uniforms.radius.value = D.radius, t.setRenderTarget(D.map), t.clear(), t.renderBufferDirect(O, null, N, T, _, null);
  }
  function $(D, O, N, j) {
    let L = null;
    const z = N.isPointLight === !0 ? D.customDistanceMaterial : D.customDepthMaterial;
    if (z !== void 0)
      L = z;
    else if (L = N.isPointLight === !0 ? p : h, t.localClippingEnabled && O.clipShadows === !0 && Array.isArray(O.clippingPlanes) && O.clippingPlanes.length !== 0 || O.displacementMap && O.displacementScale !== 0 || O.alphaMap && O.alphaTest > 0 || O.map && O.alphaTest > 0) {
      const G = L.uuid, B = O.uuid;
      let F = v[G];
      F === void 0 && (F = {}, v[G] = F);
      let H = F[B];
      H === void 0 && (H = L.clone(), F[B] = H, O.addEventListener("dispose", C)), L = H;
    }
    if (L.visible = O.visible, L.wireframe = O.wireframe, j === qt ? L.side = O.shadowSide !== null ? O.shadowSide : O.side : L.side = O.shadowSide !== null ? O.shadowSide : w[O.side], L.alphaMap = O.alphaMap, L.alphaTest = O.alphaTest, L.map = O.map, L.clipShadows = O.clipShadows, L.clippingPlanes = O.clippingPlanes, L.clipIntersection = O.clipIntersection, L.displacementMap = O.displacementMap, L.displacementScale = O.displacementScale, L.displacementBias = O.displacementBias, L.wireframeLinewidth = O.wireframeLinewidth, L.linewidth = O.linewidth, N.isPointLight === !0 && L.isMeshDistanceMaterial === !0) {
      const G = t.properties.get(L);
      G.light = N;
    }
    return L;
  }
  function S(D, O, N, j, L) {
    if (D.visible === !1)
      return;
    if (D.layers.test(O.layers) && (D.isMesh || D.isLine || D.isPoints) && (D.castShadow || D.receiveShadow && L === qt) && (!D.frustumCulled || o.intersectsObject(D))) {
      D.modelViewMatrix.multiplyMatrices(N.matrixWorldInverse, D.matrixWorld);
      const G = e.update(D), B = D.material;
      if (Array.isArray(B)) {
        const F = G.groups;
        for (let H = 0, W = F.length; H < W; H++) {
          const V = F[H], X = B[V.materialIndex];
          if (X && X.visible) {
            const Z = $(D, X, j, L);
            D.onBeforeShadow(t, D, O, N, G, Z, V), t.renderBufferDirect(N, null, G, Z, D, V), D.onAfterShadow(t, D, O, N, G, Z, V);
          }
        }
      } else if (B.visible) {
        const F = $(D, B, j, L);
        D.onBeforeShadow(t, D, O, N, G, F, null), t.renderBufferDirect(N, null, G, F, D, null), D.onAfterShadow(t, D, O, N, G, F, null);
      }
    }
    const z = D.children;
    for (let G = 0, B = z.length; G < B; G++)
      S(z[G], O, N, j, L);
  }
  function C(D) {
    D.target.removeEventListener("dispose", C);
    for (const O in v) {
      const N = v[O], j = D.target.uuid;
      j in N && (N[j].dispose(), delete N[j]);
    }
  }
}
function Jd(t, e, n) {
  const o = n.isWebGL2;
  function l() {
    let _e = !1;
    const Ht = new ht();
    let K = null;
    const Ve = new ht(0, 0, 0, 0);
    return {
      setMask: function(Ne) {
        K !== Ne && !_e && (t.colorMask(Ne, Ne, Ne, Ne), K = Ne);
      },
      setLocked: function(Ne) {
        _e = Ne;
      },
      setClear: function(Ne, pe, Le, bt, yi) {
        yi === !0 && (Ne *= bt, pe *= bt, Le *= bt), Ht.set(Ne, pe, Le, bt), Ve.equals(Ht) === !1 && (t.clearColor(Ne, pe, Le, bt), Ve.copy(Ht));
      },
      reset: function() {
        _e = !1, K = null, Ve.set(-1, 0, 0, 0);
      }
    };
  }
  function u() {
    let _e = !1, Ht = null, K = null, Ve = null;
    return {
      setTest: function(Ne) {
        Ne ? de(t.DEPTH_TEST) : Te(t.DEPTH_TEST);
      },
      setMask: function(Ne) {
        Ht !== Ne && !_e && (t.depthMask(Ne), Ht = Ne);
      },
      setFunc: function(Ne) {
        if (K !== Ne) {
          switch (Ne) {
            case el:
              t.depthFunc(t.NEVER);
              break;
            case tl:
              t.depthFunc(t.ALWAYS);
              break;
            case nl:
              t.depthFunc(t.LESS);
              break;
            case Qi:
              t.depthFunc(t.LEQUAL);
              break;
            case il:
              t.depthFunc(t.EQUAL);
              break;
            case rl:
              t.depthFunc(t.GEQUAL);
              break;
            case sl:
              t.depthFunc(t.GREATER);
              break;
            case al:
              t.depthFunc(t.NOTEQUAL);
              break;
            default:
              t.depthFunc(t.LEQUAL);
          }
          K = Ne;
        }
      },
      setLocked: function(Ne) {
        _e = Ne;
      },
      setClear: function(Ne) {
        Ve !== Ne && (t.clearDepth(Ne), Ve = Ne);
      },
      reset: function() {
        _e = !1, Ht = null, K = null, Ve = null;
      }
    };
  }
  function f() {
    let _e = !1, Ht = null, K = null, Ve = null, Ne = null, pe = null, Le = null, bt = null, yi = null;
    return {
      setTest: function(_n) {
        _e || (_n ? de(t.STENCIL_TEST) : Te(t.STENCIL_TEST));
      },
      setMask: function(_n) {
        Ht !== _n && !_e && (t.stencilMask(_n), Ht = _n);
      },
      setFunc: function(_n, Do, ms) {
        (K !== _n || Ve !== Do || Ne !== ms) && (t.stencilFunc(_n, Do, ms), K = _n, Ve = Do, Ne = ms);
      },
      setOp: function(_n, Do, ms) {
        (pe !== _n || Le !== Do || bt !== ms) && (t.stencilOp(_n, Do, ms), pe = _n, Le = Do, bt = ms);
      },
      setLocked: function(_n) {
        _e = _n;
      },
      setClear: function(_n) {
        yi !== _n && (t.clearStencil(_n), yi = _n);
      },
      reset: function() {
        _e = !1, Ht = null, K = null, Ve = null, Ne = null, pe = null, Le = null, bt = null, yi = null;
      }
    };
  }
  const h = new l(), p = new u(), v = new f(), g = /* @__PURE__ */ new WeakMap(), w = /* @__PURE__ */ new WeakMap();
  let E = {}, T = {}, R = /* @__PURE__ */ new WeakMap(), _ = [], b = null, M = !1, A = null, $ = null, S = null, C = null, D = null, O = null, N = null, j = new qe(0, 0, 0), L = 0, z = !1, G = null, B = null, F = null, H = null, W = null;
  const V = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let X = !1, Z = 0;
  const Q = t.getParameter(t.VERSION);
  Q.indexOf("WebGL") !== -1 ? (Z = parseFloat(/^WebGL (\d)/.exec(Q)[1]), X = Z >= 1) : Q.indexOf("OpenGL ES") !== -1 && (Z = parseFloat(/^OpenGL ES (\d)/.exec(Q)[1]), X = Z >= 2);
  let q = null, J = {};
  const ie = t.getParameter(t.SCISSOR_BOX), ne = t.getParameter(t.VIEWPORT), ge = new ht().fromArray(ie), ye = new ht().fromArray(ne);
  function xe(_e, Ht, K, Ve) {
    const Ne = new Uint8Array(4), pe = t.createTexture();
    t.bindTexture(_e, pe), t.texParameteri(_e, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(_e, t.TEXTURE_MAG_FILTER, t.NEAREST);
    for (let Le = 0; Le < K; Le++)
      o && (_e === t.TEXTURE_3D || _e === t.TEXTURE_2D_ARRAY) ? t.texImage3D(Ht, 0, t.RGBA, 1, 1, Ve, 0, t.RGBA, t.UNSIGNED_BYTE, Ne) : t.texImage2D(Ht + Le, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, Ne);
    return pe;
  }
  const we = {};
  we[t.TEXTURE_2D] = xe(t.TEXTURE_2D, t.TEXTURE_2D, 1), we[t.TEXTURE_CUBE_MAP] = xe(t.TEXTURE_CUBE_MAP, t.TEXTURE_CUBE_MAP_POSITIVE_X, 6), o && (we[t.TEXTURE_2D_ARRAY] = xe(t.TEXTURE_2D_ARRAY, t.TEXTURE_2D_ARRAY, 1, 1), we[t.TEXTURE_3D] = xe(t.TEXTURE_3D, t.TEXTURE_3D, 1, 1)), h.setClear(0, 0, 0, 1), p.setClear(1), v.setClear(0), de(t.DEPTH_TEST), p.setFunc(Qi), De(!1), Ue(Ms), de(t.CULL_FACE), et(ln$1);
  function de(_e) {
    E[_e] !== !0 && (t.enable(_e), E[_e] = !0);
  }
  function Te(_e) {
    E[_e] !== !1 && (t.disable(_e), E[_e] = !1);
  }
  function Ce(_e, Ht) {
    return T[_e] !== Ht ? (t.bindFramebuffer(_e, Ht), T[_e] = Ht, o && (_e === t.DRAW_FRAMEBUFFER && (T[t.FRAMEBUFFER] = Ht), _e === t.FRAMEBUFFER && (T[t.DRAW_FRAMEBUFFER] = Ht)), !0) : !1;
  }
  function ee(_e, Ht) {
    let K = _, Ve = !1;
    if (_e) {
      K = R.get(Ht), K === void 0 && (K = [], R.set(Ht, K));
      const Ne = _e.textures;
      if (K.length !== Ne.length || K[0] !== t.COLOR_ATTACHMENT0) {
        for (let pe = 0, Le = Ne.length; pe < Le; pe++)
          K[pe] = t.COLOR_ATTACHMENT0 + pe;
        K.length = Ne.length, Ve = !0;
      }
    } else
      K[0] !== t.BACK && (K[0] = t.BACK, Ve = !0);
    if (Ve)
      if (n.isWebGL2)
        t.drawBuffers(K);
      else if (e.has("WEBGL_draw_buffers") === !0)
        e.get("WEBGL_draw_buffers").drawBuffersWEBGL(K);
      else
        throw new Error("THREE.WebGLState: Usage of gl.drawBuffers() require WebGL2 or WEBGL_draw_buffers extension");
  }
  function Ae(_e) {
    return b !== _e ? (t.useProgram(_e), b = _e, !0) : !1;
  }
  const be = {
    [Tn]: t.FUNC_ADD,
    [zo]: t.FUNC_SUBTRACT,
    [Go]: t.FUNC_REVERSE_SUBTRACT
  };
  if (o)
    be[Ts] = t.MIN, be[bs] = t.MAX;
  else {
    const _e = e.get("EXT_blend_minmax");
    _e !== null && (be[Ts] = _e.MIN_EXT, be[bs] = _e.MAX_EXT);
  }
  const Fe = {
    [Ho]: t.ZERO,
    [Vo]: t.ONE,
    [ko]: t.SRC_COLOR,
    [Jr]: t.SRC_ALPHA,
    [Ko]: t.SRC_ALPHA_SATURATE,
    [qo]: t.DST_COLOR,
    [Xo]: t.DST_ALPHA,
    [Wo]: t.ONE_MINUS_SRC_COLOR,
    [Qr]: t.ONE_MINUS_SRC_ALPHA,
    [jo]: t.ONE_MINUS_DST_COLOR,
    [Yo]: t.ONE_MINUS_DST_ALPHA,
    [Zo]: t.CONSTANT_COLOR,
    [$o]: t.ONE_MINUS_CONSTANT_COLOR,
    [Jo]: t.CONSTANT_ALPHA,
    [Qo]: t.ONE_MINUS_CONSTANT_ALPHA
  };
  function et(_e, Ht, K, Ve, Ne, pe, Le, bt, yi, _n) {
    if (_e === ln$1) {
      M === !0 && (Te(t.BLEND), M = !1);
      return;
    }
    if (M === !1 && (de(t.BLEND), M = !0), _e !== Bo) {
      if (_e !== A || _n !== z) {
        if (($ !== Tn || D !== Tn) && (t.blendEquation(t.FUNC_ADD), $ = Tn, D = Tn), _n)
          switch (_e) {
            case Qn:
              t.blendFuncSeparate(t.ONE, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA);
              break;
            case Ss:
              t.blendFunc(t.ONE, t.ONE);
              break;
            case Es:
              t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE);
              break;
            case ys:
              t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", _e);
              break;
          }
        else
          switch (_e) {
            case Qn:
              t.blendFuncSeparate(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA);
              break;
            case Ss:
              t.blendFunc(t.SRC_ALPHA, t.ONE);
              break;
            case Es:
              t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE);
              break;
            case ys:
              t.blendFunc(t.ZERO, t.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", _e);
              break;
          }
        S = null, C = null, O = null, N = null, j.set(0, 0, 0), L = 0, A = _e, z = _n;
      }
      return;
    }
    Ne = Ne || Ht, pe = pe || K, Le = Le || Ve, (Ht !== $ || Ne !== D) && (t.blendEquationSeparate(be[Ht], be[Ne]), $ = Ht, D = Ne), (K !== S || Ve !== C || pe !== O || Le !== N) && (t.blendFuncSeparate(Fe[K], Fe[Ve], Fe[pe], Fe[Le]), S = K, C = Ve, O = pe, N = Le), (bt.equals(j) === !1 || yi !== L) && (t.blendColor(bt.r, bt.g, bt.b, yi), j.copy(bt), L = yi), A = _e, z = !1;
  }
  function Ye(_e, Ht) {
    _e.side === jt ? Te(t.CULL_FACE) : de(t.CULL_FACE);
    let K = _e.side === Et;
    Ht && (K = !K), De(K), _e.blending === Qn && _e.transparent === !1 ? et(ln$1) : et(_e.blending, _e.blendEquation, _e.blendSrc, _e.blendDst, _e.blendEquationAlpha, _e.blendSrcAlpha, _e.blendDstAlpha, _e.blendColor, _e.blendAlpha, _e.premultipliedAlpha), p.setFunc(_e.depthFunc), p.setTest(_e.depthTest), p.setMask(_e.depthWrite), h.setMask(_e.colorWrite);
    const Ve = _e.stencilWrite;
    v.setTest(Ve), Ve && (v.setMask(_e.stencilWriteMask), v.setFunc(_e.stencilFunc, _e.stencilRef, _e.stencilFuncMask), v.setOp(_e.stencilFail, _e.stencilZFail, _e.stencilZPass)), ue(_e.polygonOffset, _e.polygonOffsetFactor, _e.polygonOffsetUnits), _e.alphaToCoverage === !0 ? de(t.SAMPLE_ALPHA_TO_COVERAGE) : Te(t.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function De(_e) {
    G !== _e && (_e ? t.frontFace(t.CW) : t.frontFace(t.CCW), G = _e);
  }
  function Ue(_e) {
    _e !== No ? (de(t.CULL_FACE), _e !== B && (_e === Ms ? t.cullFace(t.BACK) : _e === Fo ? t.cullFace(t.FRONT) : t.cullFace(t.FRONT_AND_BACK))) : Te(t.CULL_FACE), B = _e;
  }
  function Qe(_e) {
    _e !== F && (X && t.lineWidth(_e), F = _e);
  }
  function ue(_e, Ht, K) {
    _e ? (de(t.POLYGON_OFFSET_FILL), (H !== Ht || W !== K) && (t.polygonOffset(Ht, K), H = Ht, W = K)) : Te(t.POLYGON_OFFSET_FILL);
  }
  function te(_e) {
    _e ? de(t.SCISSOR_TEST) : Te(t.SCISSOR_TEST);
  }
  function Be(_e) {
    _e === void 0 && (_e = t.TEXTURE0 + V - 1), q !== _e && (t.activeTexture(_e), q = _e);
  }
  function Je(_e, Ht, K) {
    K === void 0 && (q === null ? K = t.TEXTURE0 + V - 1 : K = q);
    let Ve = J[K];
    Ve === void 0 && (Ve = { type: void 0, texture: void 0 }, J[K] = Ve), (Ve.type !== _e || Ve.texture !== Ht) && (q !== K && (t.activeTexture(K), q = K), t.bindTexture(_e, Ht || we[_e]), Ve.type = _e, Ve.texture = Ht);
  }
  function ft() {
    const _e = J[q];
    _e !== void 0 && _e.type !== void 0 && (t.bindTexture(_e.type, null), _e.type = void 0, _e.texture = void 0);
  }
  function lt() {
    try {
      t.compressedTexImage2D.apply(t, arguments);
    } catch (_e) {
      console.error("THREE.WebGLState:", _e);
    }
  }
  function he() {
    try {
      t.compressedTexImage3D.apply(t, arguments);
    } catch (_e) {
      console.error("THREE.WebGLState:", _e);
    }
  }
  function ae() {
    try {
      t.texSubImage2D.apply(t, arguments);
    } catch (_e) {
      console.error("THREE.WebGLState:", _e);
    }
  }
  function se() {
    try {
      t.texSubImage3D.apply(t, arguments);
    } catch (_e) {
      console.error("THREE.WebGLState:", _e);
    }
  }
  function Re() {
    try {
      t.compressedTexSubImage2D.apply(t, arguments);
    } catch (_e) {
      console.error("THREE.WebGLState:", _e);
    }
  }
  function Oe() {
    try {
      t.compressedTexSubImage3D.apply(t, arguments);
    } catch (_e) {
      console.error("THREE.WebGLState:", _e);
    }
  }
  function We() {
    try {
      t.texStorage2D.apply(t, arguments);
    } catch (_e) {
      console.error("THREE.WebGLState:", _e);
    }
  }
  function Ct() {
    try {
      t.texStorage3D.apply(t, arguments);
    } catch (_e) {
      console.error("THREE.WebGLState:", _e);
    }
  }
  function le() {
    try {
      t.texImage2D.apply(t, arguments);
    } catch (_e) {
      console.error("THREE.WebGLState:", _e);
    }
  }
  function ke() {
    try {
      t.texImage3D.apply(t, arguments);
    } catch (_e) {
      console.error("THREE.WebGLState:", _e);
    }
  }
  function Ke(_e) {
    ge.equals(_e) === !1 && (t.scissor(_e.x, _e.y, _e.z, _e.w), ge.copy(_e));
  }
  function me(_e) {
    ye.equals(_e) === !1 && (t.viewport(_e.x, _e.y, _e.z, _e.w), ye.copy(_e));
  }
  function Ee(_e, Ht) {
    let K = w.get(Ht);
    K === void 0 && (K = /* @__PURE__ */ new WeakMap(), w.set(Ht, K));
    let Ve = K.get(_e);
    Ve === void 0 && (Ve = t.getUniformBlockIndex(Ht, _e.name), K.set(_e, Ve));
  }
  function tt(_e, Ht) {
    const K = w.get(Ht).get(_e);
    g.get(Ht) !== K && (t.uniformBlockBinding(Ht, K, _e.__bindingPointIndex), g.set(Ht, K));
  }
  function ce() {
    t.disable(t.BLEND), t.disable(t.CULL_FACE), t.disable(t.DEPTH_TEST), t.disable(t.POLYGON_OFFSET_FILL), t.disable(t.SCISSOR_TEST), t.disable(t.STENCIL_TEST), t.disable(t.SAMPLE_ALPHA_TO_COVERAGE), t.blendEquation(t.FUNC_ADD), t.blendFunc(t.ONE, t.ZERO), t.blendFuncSeparate(t.ONE, t.ZERO, t.ONE, t.ZERO), t.blendColor(0, 0, 0, 0), t.colorMask(!0, !0, !0, !0), t.clearColor(0, 0, 0, 0), t.depthMask(!0), t.depthFunc(t.LESS), t.clearDepth(1), t.stencilMask(4294967295), t.stencilFunc(t.ALWAYS, 0, 4294967295), t.stencilOp(t.KEEP, t.KEEP, t.KEEP), t.clearStencil(0), t.cullFace(t.BACK), t.frontFace(t.CCW), t.polygonOffset(0, 0), t.activeTexture(t.TEXTURE0), t.bindFramebuffer(t.FRAMEBUFFER, null), o === !0 && (t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null), t.bindFramebuffer(t.READ_FRAMEBUFFER, null)), t.useProgram(null), t.lineWidth(1), t.scissor(0, 0, t.canvas.width, t.canvas.height), t.viewport(0, 0, t.canvas.width, t.canvas.height), E = {}, q = null, J = {}, T = {}, R = /* @__PURE__ */ new WeakMap(), _ = [], b = null, M = !1, A = null, $ = null, S = null, C = null, D = null, O = null, N = null, j = new qe(0, 0, 0), L = 0, z = !1, G = null, B = null, F = null, H = null, W = null, ge.set(0, 0, t.canvas.width, t.canvas.height), ye.set(0, 0, t.canvas.width, t.canvas.height), h.reset(), p.reset(), v.reset();
  }
  return {
    buffers: {
      color: h,
      depth: p,
      stencil: v
    },
    enable: de,
    disable: Te,
    bindFramebuffer: Ce,
    drawBuffers: ee,
    useProgram: Ae,
    setBlending: et,
    setMaterial: Ye,
    setFlipSided: De,
    setCullFace: Ue,
    setLineWidth: Qe,
    setPolygonOffset: ue,
    setScissorTest: te,
    activeTexture: Be,
    bindTexture: Je,
    unbindTexture: ft,
    compressedTexImage2D: lt,
    compressedTexImage3D: he,
    texImage2D: le,
    texImage3D: ke,
    updateUBOMapping: Ee,
    uniformBlockBinding: tt,
    texStorage2D: We,
    texStorage3D: Ct,
    texSubImage2D: ae,
    texSubImage3D: se,
    compressedTexSubImage2D: Re,
    compressedTexSubImage3D: Oe,
    scissor: Ke,
    viewport: me,
    reset: ce
  };
}
function Qd(t, e, n, o, l, u, f) {
  const h = l.isWebGL2, p = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, v = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), g = new Ie(), w = /* @__PURE__ */ new WeakMap();
  let E;
  const T = /* @__PURE__ */ new WeakMap();
  let R = !1;
  try {
    R = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function _(ue, te) {
    return R ? (
      // eslint-disable-next-line compat/compat
      new OffscreenCanvas(ue, te)
    ) : sr("canvas");
  }
  function b(ue, te, Be, Je) {
    let ft = 1;
    const lt = Qe(ue);
    if ((lt.width > Je || lt.height > Je) && (ft = Je / Math.max(lt.width, lt.height)), ft < 1 || te === !0)
      if (typeof HTMLImageElement < "u" && ue instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && ue instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && ue instanceof ImageBitmap || typeof VideoFrame < "u" && ue instanceof VideoFrame) {
        const he = te ? rr : Math.floor, ae = he(ft * lt.width), se = he(ft * lt.height);
        E === void 0 && (E = _(ae, se));
        const Re = Be ? _(ae, se) : E;
        return Re.width = ae, Re.height = se, Re.getContext("2d").drawImage(ue, 0, 0, ae, se), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + lt.width + "x" + lt.height + ") to (" + ae + "x" + se + ")."), Re;
      } else
        return "data" in ue && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + lt.width + "x" + lt.height + ")."), ue;
    return ue;
  }
  function M(ue) {
    const te = Qe(ue);
    return ss(te.width) && ss(te.height);
  }
  function A(ue) {
    return h ? !1 : ue.wrapS !== Nt || ue.wrapT !== Nt || ue.minFilter !== xt && ue.minFilter !== St;
  }
  function $(ue, te) {
    return ue.generateMipmaps && te && ue.minFilter !== xt && ue.minFilter !== St;
  }
  function S(ue) {
    t.generateMipmap(ue);
  }
  function C(ue, te, Be, Je, ft = !1) {
    if (h === !1)
      return te;
    if (ue !== null) {
      if (t[ue] !== void 0)
        return t[ue];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + ue + "'");
    }
    let lt = te;
    if (te === t.RED && (Be === t.FLOAT && (lt = t.R32F), Be === t.HALF_FLOAT && (lt = t.R16F), Be === t.UNSIGNED_BYTE && (lt = t.R8)), te === t.RED_INTEGER && (Be === t.UNSIGNED_BYTE && (lt = t.R8UI), Be === t.UNSIGNED_SHORT && (lt = t.R16UI), Be === t.UNSIGNED_INT && (lt = t.R32UI), Be === t.BYTE && (lt = t.R8I), Be === t.SHORT && (lt = t.R16I), Be === t.INT && (lt = t.R32I)), te === t.RG && (Be === t.FLOAT && (lt = t.RG32F), Be === t.HALF_FLOAT && (lt = t.RG16F), Be === t.UNSIGNED_BYTE && (lt = t.RG8)), te === t.RG_INTEGER && (Be === t.UNSIGNED_BYTE && (lt = t.RG8UI), Be === t.UNSIGNED_SHORT && (lt = t.RG16UI), Be === t.UNSIGNED_INT && (lt = t.RG32UI), Be === t.BYTE && (lt = t.RG8I), Be === t.SHORT && (lt = t.RG16I), Be === t.INT && (lt = t.RG32I)), te === t.RGBA) {
      const he = ft ? er : je.getTransfer(Je);
      Be === t.FLOAT && (lt = t.RGBA32F), Be === t.HALF_FLOAT && (lt = t.RGBA16F), Be === t.UNSIGNED_BYTE && (lt = he === $e ? t.SRGB8_ALPHA8 : t.RGBA8), Be === t.UNSIGNED_SHORT_4_4_4_4 && (lt = t.RGBA4), Be === t.UNSIGNED_SHORT_5_5_5_1 && (lt = t.RGB5_A1);
    }
    return (lt === t.R16F || lt === t.R32F || lt === t.RG16F || lt === t.RG32F || lt === t.RGBA16F || lt === t.RGBA32F) && e.get("EXT_color_buffer_float"), lt;
  }
  function D(ue, te, Be) {
    return $(ue, Be) === !0 || ue.isFramebufferTexture && ue.minFilter !== xt && ue.minFilter !== St ? Math.log2(Math.max(te.width, te.height)) + 1 : ue.mipmaps !== void 0 && ue.mipmaps.length > 0 ? ue.mipmaps.length : ue.isCompressedTexture && Array.isArray(ue.image) ? te.mipmaps.length : 1;
  }
  function O(ue) {
    return ue === xt || ue === As || ue === ui ? t.NEAREST : t.LINEAR;
  }
  function N(ue) {
    const te = ue.target;
    te.removeEventListener("dispose", N), L(te), te.isVideoTexture && w.delete(te);
  }
  function j(ue) {
    const te = ue.target;
    te.removeEventListener("dispose", j), G(te);
  }
  function L(ue) {
    const te = o.get(ue);
    if (te.__webglInit === void 0)
      return;
    const Be = ue.source, Je = T.get(Be);
    if (Je) {
      const ft = Je[te.__cacheKey];
      ft.usedTimes--, ft.usedTimes === 0 && z(ue), Object.keys(Je).length === 0 && T.delete(Be);
    }
    o.remove(ue);
  }
  function z(ue) {
    const te = o.get(ue);
    t.deleteTexture(te.__webglTexture);
    const Be = ue.source, Je = T.get(Be);
    delete Je[te.__cacheKey], f.memory.textures--;
  }
  function G(ue) {
    const te = o.get(ue);
    if (ue.depthTexture && ue.depthTexture.dispose(), ue.isWebGLCubeRenderTarget)
      for (let Je = 0; Je < 6; Je++) {
        if (Array.isArray(te.__webglFramebuffer[Je]))
          for (let ft = 0; ft < te.__webglFramebuffer[Je].length; ft++)
            t.deleteFramebuffer(te.__webglFramebuffer[Je][ft]);
        else
          t.deleteFramebuffer(te.__webglFramebuffer[Je]);
        te.__webglDepthbuffer && t.deleteRenderbuffer(te.__webglDepthbuffer[Je]);
      }
    else {
      if (Array.isArray(te.__webglFramebuffer))
        for (let Je = 0; Je < te.__webglFramebuffer.length; Je++)
          t.deleteFramebuffer(te.__webglFramebuffer[Je]);
      else
        t.deleteFramebuffer(te.__webglFramebuffer);
      if (te.__webglDepthbuffer && t.deleteRenderbuffer(te.__webglDepthbuffer), te.__webglMultisampledFramebuffer && t.deleteFramebuffer(te.__webglMultisampledFramebuffer), te.__webglColorRenderbuffer)
        for (let Je = 0; Je < te.__webglColorRenderbuffer.length; Je++)
          te.__webglColorRenderbuffer[Je] && t.deleteRenderbuffer(te.__webglColorRenderbuffer[Je]);
      te.__webglDepthRenderbuffer && t.deleteRenderbuffer(te.__webglDepthRenderbuffer);
    }
    const Be = ue.textures;
    for (let Je = 0, ft = Be.length; Je < ft; Je++) {
      const lt = o.get(Be[Je]);
      lt.__webglTexture && (t.deleteTexture(lt.__webglTexture), f.memory.textures--), o.remove(Be[Je]);
    }
    o.remove(ue);
  }
  let B = 0;
  function F() {
    B = 0;
  }
  function H() {
    const ue = B;
    return ue >= l.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + ue + " texture units while this GPU supports only " + l.maxTextures), B += 1, ue;
  }
  function W(ue) {
    const te = [];
    return te.push(ue.wrapS), te.push(ue.wrapT), te.push(ue.wrapR || 0), te.push(ue.magFilter), te.push(ue.minFilter), te.push(ue.anisotropy), te.push(ue.internalFormat), te.push(ue.format), te.push(ue.type), te.push(ue.generateMipmaps), te.push(ue.premultiplyAlpha), te.push(ue.flipY), te.push(ue.unpackAlignment), te.push(ue.colorSpace), te.join();
  }
  function V(ue, te) {
    const Be = o.get(ue);
    if (ue.isVideoTexture && De(ue), ue.isRenderTargetTexture === !1 && ue.version > 0 && Be.__version !== ue.version) {
      const Je = ue.image;
      if (Je === null)
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      else if (Je.complete === !1)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        ye(Be, ue, te);
        return;
      }
    }
    n.bindTexture(t.TEXTURE_2D, Be.__webglTexture, t.TEXTURE0 + te);
  }
  function X(ue, te) {
    const Be = o.get(ue);
    if (ue.version > 0 && Be.__version !== ue.version) {
      ye(Be, ue, te);
      return;
    }
    n.bindTexture(t.TEXTURE_2D_ARRAY, Be.__webglTexture, t.TEXTURE0 + te);
  }
  function Z(ue, te) {
    const Be = o.get(ue);
    if (ue.version > 0 && Be.__version !== ue.version) {
      ye(Be, ue, te);
      return;
    }
    n.bindTexture(t.TEXTURE_3D, Be.__webglTexture, t.TEXTURE0 + te);
  }
  function Q(ue, te) {
    const Be = o.get(ue);
    if (ue.version > 0 && Be.__version !== ue.version) {
      xe(Be, ue, te);
      return;
    }
    n.bindTexture(t.TEXTURE_CUBE_MAP, Be.__webglTexture, t.TEXTURE0 + te);
  }
  const q = {
    [ns]: t.REPEAT,
    [Nt]: t.CLAMP_TO_EDGE,
    [is]: t.MIRRORED_REPEAT
  }, J = {
    [xt]: t.NEAREST,
    [As]: t.NEAREST_MIPMAP_NEAREST,
    [ui]: t.NEAREST_MIPMAP_LINEAR,
    [St]: t.LINEAR,
    [gr]: t.LINEAR_MIPMAP_NEAREST,
    [An]: t.LINEAR_MIPMAP_LINEAR
  }, ie = {
    [Rl]: t.NEVER,
    [Il]: t.ALWAYS,
    [Cl]: t.LESS,
    [co]: t.LEQUAL,
    [Pl]: t.EQUAL,
    [Ul]: t.GEQUAL,
    [Ll]: t.GREATER,
    [Dl]: t.NOTEQUAL
  };
  function ne(ue, te, Be) {
    if (te.type === Kt && e.has("OES_texture_float_linear") === !1 && (te.magFilter === St || te.magFilter === gr || te.magFilter === ui || te.magFilter === An || te.minFilter === St || te.minFilter === gr || te.minFilter === ui || te.minFilter === An) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), Be ? (t.texParameteri(ue, t.TEXTURE_WRAP_S, q[te.wrapS]), t.texParameteri(ue, t.TEXTURE_WRAP_T, q[te.wrapT]), (ue === t.TEXTURE_3D || ue === t.TEXTURE_2D_ARRAY) && t.texParameteri(ue, t.TEXTURE_WRAP_R, q[te.wrapR]), t.texParameteri(ue, t.TEXTURE_MAG_FILTER, J[te.magFilter]), t.texParameteri(ue, t.TEXTURE_MIN_FILTER, J[te.minFilter])) : (t.texParameteri(ue, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(ue, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), (ue === t.TEXTURE_3D || ue === t.TEXTURE_2D_ARRAY) && t.texParameteri(ue, t.TEXTURE_WRAP_R, t.CLAMP_TO_EDGE), (te.wrapS !== Nt || te.wrapT !== Nt) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(ue, t.TEXTURE_MAG_FILTER, O(te.magFilter)), t.texParameteri(ue, t.TEXTURE_MIN_FILTER, O(te.minFilter)), te.minFilter !== xt && te.minFilter !== St && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), te.compareFunction && (t.texParameteri(ue, t.TEXTURE_COMPARE_MODE, t.COMPARE_REF_TO_TEXTURE), t.texParameteri(ue, t.TEXTURE_COMPARE_FUNC, ie[te.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) {
      if (te.magFilter === xt || te.minFilter !== ui && te.minFilter !== An || te.type === Kt && e.has("OES_texture_float_linear") === !1 || h === !1 && te.type === _i && e.has("OES_texture_half_float_linear") === !1)
        return;
      if (te.anisotropy > 1 || o.get(te).__currentAnisotropy) {
        const Je = e.get("EXT_texture_filter_anisotropic");
        t.texParameterf(ue, Je.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(te.anisotropy, l.getMaxAnisotropy())), o.get(te).__currentAnisotropy = te.anisotropy;
      }
    }
  }
  function ge(ue, te) {
    let Be = !1;
    ue.__webglInit === void 0 && (ue.__webglInit = !0, te.addEventListener("dispose", N));
    const Je = te.source;
    let ft = T.get(Je);
    ft === void 0 && (ft = {}, T.set(Je, ft));
    const lt = W(te);
    if (lt !== ue.__cacheKey) {
      ft[lt] === void 0 && (ft[lt] = {
        texture: t.createTexture(),
        usedTimes: 0
      }, f.memory.textures++, Be = !0), ft[lt].usedTimes++;
      const he = ft[ue.__cacheKey];
      he !== void 0 && (ft[ue.__cacheKey].usedTimes--, he.usedTimes === 0 && z(te)), ue.__cacheKey = lt, ue.__webglTexture = ft[lt].texture;
    }
    return Be;
  }
  function ye(ue, te, Be) {
    let Je = t.TEXTURE_2D;
    (te.isDataArrayTexture || te.isCompressedArrayTexture) && (Je = t.TEXTURE_2D_ARRAY), te.isData3DTexture && (Je = t.TEXTURE_3D);
    const ft = ge(ue, te), lt = te.source;
    n.bindTexture(Je, ue.__webglTexture, t.TEXTURE0 + Be);
    const he = o.get(lt);
    if (lt.version !== he.__version || ft === !0) {
      n.activeTexture(t.TEXTURE0 + Be);
      const ae = je.getPrimaries(je.workingColorSpace), se = te.colorSpace === an ? null : je.getPrimaries(te.colorSpace), Re = te.colorSpace === an || ae === se ? t.NONE : t.BROWSER_DEFAULT_WEBGL;
      t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, te.flipY), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, te.premultiplyAlpha), t.pixelStorei(t.UNPACK_ALIGNMENT, te.unpackAlignment), t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, Re);
      const Oe = A(te) && M(te.image) === !1;
      let We = b(te.image, Oe, !1, l.maxTextureSize);
      We = Ue(te, We);
      const Ct = M(We) || h, le = u.convert(te.format, te.colorSpace);
      let ke = u.convert(te.type), Ke = C(te.internalFormat, le, ke, te.colorSpace, te.isVideoTexture);
      ne(Je, te, Ct);
      let me;
      const Ee = te.mipmaps, tt = h && te.isVideoTexture !== !0 && Ke !== lo, ce = he.__version === void 0 || ft === !0, _e = lt.dataReady, Ht = D(te, We, Ct);
      if (te.isDepthTexture)
        Ke = t.DEPTH_COMPONENT, h ? te.type === Kt ? Ke = t.DEPTH_COMPONENT32F : te.type === on ? Ke = t.DEPTH_COMPONENT24 : te.type === wn ? Ke = t.DEPTH24_STENCIL8 : Ke = t.DEPTH_COMPONENT16 : te.type === Kt && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), te.format === Rn && Ke === t.DEPTH_COMPONENT && te.type !== ls && te.type !== on && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), te.type = on, ke = u.convert(te.type)), te.format === si && Ke === t.DEPTH_COMPONENT && (Ke = t.DEPTH_STENCIL, te.type !== wn && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), te.type = wn, ke = u.convert(te.type))), ce && (tt ? n.texStorage2D(t.TEXTURE_2D, 1, Ke, We.width, We.height) : n.texImage2D(t.TEXTURE_2D, 0, Ke, We.width, We.height, 0, le, ke, null));
      else if (te.isDataTexture)
        if (Ee.length > 0 && Ct) {
          tt && ce && n.texStorage2D(t.TEXTURE_2D, Ht, Ke, Ee[0].width, Ee[0].height);
          for (let K = 0, Ve = Ee.length; K < Ve; K++)
            me = Ee[K], tt ? _e && n.texSubImage2D(t.TEXTURE_2D, K, 0, 0, me.width, me.height, le, ke, me.data) : n.texImage2D(t.TEXTURE_2D, K, Ke, me.width, me.height, 0, le, ke, me.data);
          te.generateMipmaps = !1;
        } else
          tt ? (ce && n.texStorage2D(t.TEXTURE_2D, Ht, Ke, We.width, We.height), _e && n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, We.width, We.height, le, ke, We.data)) : n.texImage2D(t.TEXTURE_2D, 0, Ke, We.width, We.height, 0, le, ke, We.data);
      else if (te.isCompressedTexture)
        if (te.isCompressedArrayTexture) {
          tt && ce && n.texStorage3D(t.TEXTURE_2D_ARRAY, Ht, Ke, Ee[0].width, Ee[0].height, We.depth);
          for (let K = 0, Ve = Ee.length; K < Ve; K++)
            me = Ee[K], te.format !== Ft ? le !== null ? tt ? _e && n.compressedTexSubImage3D(t.TEXTURE_2D_ARRAY, K, 0, 0, 0, me.width, me.height, We.depth, le, me.data, 0, 0) : n.compressedTexImage3D(t.TEXTURE_2D_ARRAY, K, Ke, me.width, me.height, We.depth, 0, me.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : tt ? _e && n.texSubImage3D(t.TEXTURE_2D_ARRAY, K, 0, 0, 0, me.width, me.height, We.depth, le, ke, me.data) : n.texImage3D(t.TEXTURE_2D_ARRAY, K, Ke, me.width, me.height, We.depth, 0, le, ke, me.data);
        } else {
          tt && ce && n.texStorage2D(t.TEXTURE_2D, Ht, Ke, Ee[0].width, Ee[0].height);
          for (let K = 0, Ve = Ee.length; K < Ve; K++)
            me = Ee[K], te.format !== Ft ? le !== null ? tt ? _e && n.compressedTexSubImage2D(t.TEXTURE_2D, K, 0, 0, me.width, me.height, le, me.data) : n.compressedTexImage2D(t.TEXTURE_2D, K, Ke, me.width, me.height, 0, me.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : tt ? _e && n.texSubImage2D(t.TEXTURE_2D, K, 0, 0, me.width, me.height, le, ke, me.data) : n.texImage2D(t.TEXTURE_2D, K, Ke, me.width, me.height, 0, le, ke, me.data);
        }
      else if (te.isDataArrayTexture)
        tt ? (ce && n.texStorage3D(t.TEXTURE_2D_ARRAY, Ht, Ke, We.width, We.height, We.depth), _e && n.texSubImage3D(t.TEXTURE_2D_ARRAY, 0, 0, 0, 0, We.width, We.height, We.depth, le, ke, We.data)) : n.texImage3D(t.TEXTURE_2D_ARRAY, 0, Ke, We.width, We.height, We.depth, 0, le, ke, We.data);
      else if (te.isData3DTexture)
        tt ? (ce && n.texStorage3D(t.TEXTURE_3D, Ht, Ke, We.width, We.height, We.depth), _e && n.texSubImage3D(t.TEXTURE_3D, 0, 0, 0, 0, We.width, We.height, We.depth, le, ke, We.data)) : n.texImage3D(t.TEXTURE_3D, 0, Ke, We.width, We.height, We.depth, 0, le, ke, We.data);
      else if (te.isFramebufferTexture) {
        if (ce)
          if (tt)
            n.texStorage2D(t.TEXTURE_2D, Ht, Ke, We.width, We.height);
          else {
            let K = We.width, Ve = We.height;
            for (let Ne = 0; Ne < Ht; Ne++)
              n.texImage2D(t.TEXTURE_2D, Ne, Ke, K, Ve, 0, le, ke, null), K >>= 1, Ve >>= 1;
          }
      } else if (Ee.length > 0 && Ct) {
        if (tt && ce) {
          const K = Qe(Ee[0]);
          n.texStorage2D(t.TEXTURE_2D, Ht, Ke, K.width, K.height);
        }
        for (let K = 0, Ve = Ee.length; K < Ve; K++)
          me = Ee[K], tt ? _e && n.texSubImage2D(t.TEXTURE_2D, K, 0, 0, le, ke, me) : n.texImage2D(t.TEXTURE_2D, K, Ke, le, ke, me);
        te.generateMipmaps = !1;
      } else if (tt) {
        if (ce) {
          const K = Qe(We);
          n.texStorage2D(t.TEXTURE_2D, Ht, Ke, K.width, K.height);
        }
        _e && n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, le, ke, We);
      } else
        n.texImage2D(t.TEXTURE_2D, 0, Ke, le, ke, We);
      $(te, Ct) && S(Je), he.__version = lt.version, te.onUpdate && te.onUpdate(te);
    }
    ue.__version = te.version;
  }
  function xe(ue, te, Be) {
    if (te.image.length !== 6)
      return;
    const Je = ge(ue, te), ft = te.source;
    n.bindTexture(t.TEXTURE_CUBE_MAP, ue.__webglTexture, t.TEXTURE0 + Be);
    const lt = o.get(ft);
    if (ft.version !== lt.__version || Je === !0) {
      n.activeTexture(t.TEXTURE0 + Be);
      const he = je.getPrimaries(je.workingColorSpace), ae = te.colorSpace === an ? null : je.getPrimaries(te.colorSpace), se = te.colorSpace === an || he === ae ? t.NONE : t.BROWSER_DEFAULT_WEBGL;
      t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, te.flipY), t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, te.premultiplyAlpha), t.pixelStorei(t.UNPACK_ALIGNMENT, te.unpackAlignment), t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, se);
      const Re = te.isCompressedTexture || te.image[0].isCompressedTexture, Oe = te.image[0] && te.image[0].isDataTexture, We = [];
      for (let K = 0; K < 6; K++)
        !Re && !Oe ? We[K] = b(te.image[K], !1, !0, l.maxCubemapSize) : We[K] = Oe ? te.image[K].image : te.image[K], We[K] = Ue(te, We[K]);
      const Ct = We[0], le = M(Ct) || h, ke = u.convert(te.format, te.colorSpace), Ke = u.convert(te.type), me = C(te.internalFormat, ke, Ke, te.colorSpace), Ee = h && te.isVideoTexture !== !0, tt = lt.__version === void 0 || Je === !0, ce = ft.dataReady;
      let _e = D(te, Ct, le);
      ne(t.TEXTURE_CUBE_MAP, te, le);
      let Ht;
      if (Re) {
        Ee && tt && n.texStorage2D(t.TEXTURE_CUBE_MAP, _e, me, Ct.width, Ct.height);
        for (let K = 0; K < 6; K++) {
          Ht = We[K].mipmaps;
          for (let Ve = 0; Ve < Ht.length; Ve++) {
            const Ne = Ht[Ve];
            te.format !== Ft ? ke !== null ? Ee ? ce && n.compressedTexSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + K, Ve, 0, 0, Ne.width, Ne.height, ke, Ne.data) : n.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + K, Ve, me, Ne.width, Ne.height, 0, Ne.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Ee ? ce && n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + K, Ve, 0, 0, Ne.width, Ne.height, ke, Ke, Ne.data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + K, Ve, me, Ne.width, Ne.height, 0, ke, Ke, Ne.data);
          }
        }
      } else {
        if (Ht = te.mipmaps, Ee && tt) {
          Ht.length > 0 && _e++;
          const K = Qe(We[0]);
          n.texStorage2D(t.TEXTURE_CUBE_MAP, _e, me, K.width, K.height);
        }
        for (let K = 0; K < 6; K++)
          if (Oe) {
            Ee ? ce && n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + K, 0, 0, 0, We[K].width, We[K].height, ke, Ke, We[K].data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + K, 0, me, We[K].width, We[K].height, 0, ke, Ke, We[K].data);
            for (let Ve = 0; Ve < Ht.length; Ve++) {
              const Ne = Ht[Ve].image[K].image;
              Ee ? ce && n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + K, Ve + 1, 0, 0, Ne.width, Ne.height, ke, Ke, Ne.data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + K, Ve + 1, me, Ne.width, Ne.height, 0, ke, Ke, Ne.data);
            }
          } else {
            Ee ? ce && n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + K, 0, 0, 0, ke, Ke, We[K]) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + K, 0, me, ke, Ke, We[K]);
            for (let Ve = 0; Ve < Ht.length; Ve++) {
              const Ne = Ht[Ve];
              Ee ? ce && n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + K, Ve + 1, 0, 0, ke, Ke, Ne.image[K]) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + K, Ve + 1, me, ke, Ke, Ne.image[K]);
            }
          }
      }
      $(te, le) && S(t.TEXTURE_CUBE_MAP), lt.__version = ft.version, te.onUpdate && te.onUpdate(te);
    }
    ue.__version = te.version;
  }
  function we(ue, te, Be, Je, ft, lt) {
    const he = u.convert(Be.format, Be.colorSpace), ae = u.convert(Be.type), se = C(Be.internalFormat, he, ae, Be.colorSpace);
    if (!o.get(te).__hasExternalTextures) {
      const Re = Math.max(1, te.width >> lt), Oe = Math.max(1, te.height >> lt);
      ft === t.TEXTURE_3D || ft === t.TEXTURE_2D_ARRAY ? n.texImage3D(ft, lt, se, Re, Oe, te.depth, 0, he, ae, null) : n.texImage2D(ft, lt, se, Re, Oe, 0, he, ae, null);
    }
    n.bindFramebuffer(t.FRAMEBUFFER, ue), Ye(te) ? p.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, Je, ft, o.get(Be).__webglTexture, 0, et(te)) : (ft === t.TEXTURE_2D || ft >= t.TEXTURE_CUBE_MAP_POSITIVE_X && ft <= t.TEXTURE_CUBE_MAP_NEGATIVE_Z) && t.framebufferTexture2D(t.FRAMEBUFFER, Je, ft, o.get(Be).__webglTexture, lt), n.bindFramebuffer(t.FRAMEBUFFER, null);
  }
  function de(ue, te, Be) {
    if (t.bindRenderbuffer(t.RENDERBUFFER, ue), te.depthBuffer && !te.stencilBuffer) {
      let Je = h === !0 ? t.DEPTH_COMPONENT24 : t.DEPTH_COMPONENT16;
      if (Be || Ye(te)) {
        const ft = te.depthTexture;
        ft && ft.isDepthTexture && (ft.type === Kt ? Je = t.DEPTH_COMPONENT32F : ft.type === on && (Je = t.DEPTH_COMPONENT24));
        const lt = et(te);
        Ye(te) ? p.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, lt, Je, te.width, te.height) : t.renderbufferStorageMultisample(t.RENDERBUFFER, lt, Je, te.width, te.height);
      } else
        t.renderbufferStorage(t.RENDERBUFFER, Je, te.width, te.height);
      t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, ue);
    } else if (te.depthBuffer && te.stencilBuffer) {
      const Je = et(te);
      Be && Ye(te) === !1 ? t.renderbufferStorageMultisample(t.RENDERBUFFER, Je, t.DEPTH24_STENCIL8, te.width, te.height) : Ye(te) ? p.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, Je, t.DEPTH24_STENCIL8, te.width, te.height) : t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_STENCIL, te.width, te.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, ue);
    } else {
      const Je = te.textures;
      for (let ft = 0; ft < Je.length; ft++) {
        const lt = Je[ft], he = u.convert(lt.format, lt.colorSpace), ae = u.convert(lt.type), se = C(lt.internalFormat, he, ae, lt.colorSpace), Re = et(te);
        Be && Ye(te) === !1 ? t.renderbufferStorageMultisample(t.RENDERBUFFER, Re, se, te.width, te.height) : Ye(te) ? p.renderbufferStorageMultisampleEXT(t.RENDERBUFFER, Re, se, te.width, te.height) : t.renderbufferStorage(t.RENDERBUFFER, se, te.width, te.height);
      }
    }
    t.bindRenderbuffer(t.RENDERBUFFER, null);
  }
  function Te(ue, te) {
    if (te && te.isWebGLCubeRenderTarget)
      throw new Error("Depth Texture with cube render targets is not supported");
    if (n.bindFramebuffer(t.FRAMEBUFFER, ue), !(te.depthTexture && te.depthTexture.isDepthTexture))
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    (!o.get(te.depthTexture).__webglTexture || te.depthTexture.image.width !== te.width || te.depthTexture.image.height !== te.height) && (te.depthTexture.image.width = te.width, te.depthTexture.image.height = te.height, te.depthTexture.needsUpdate = !0), V(te.depthTexture, 0);
    const Be = o.get(te.depthTexture).__webglTexture, Je = et(te);
    if (te.depthTexture.format === Rn)
      Ye(te) ? p.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, Be, 0, Je) : t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, Be, 0);
    else if (te.depthTexture.format === si)
      Ye(te) ? p.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, Be, 0, Je) : t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, Be, 0);
    else
      throw new Error("Unknown depthTexture format");
  }
  function Ce(ue) {
    const te = o.get(ue), Be = ue.isWebGLCubeRenderTarget === !0;
    if (ue.depthTexture && !te.__autoAllocateDepthBuffer) {
      if (Be)
        throw new Error("target.depthTexture not supported in Cube render targets");
      Te(te.__webglFramebuffer, ue);
    } else if (Be) {
      te.__webglDepthbuffer = [];
      for (let Je = 0; Je < 6; Je++)
        n.bindFramebuffer(t.FRAMEBUFFER, te.__webglFramebuffer[Je]), te.__webglDepthbuffer[Je] = t.createRenderbuffer(), de(te.__webglDepthbuffer[Je], ue, !1);
    } else
      n.bindFramebuffer(t.FRAMEBUFFER, te.__webglFramebuffer), te.__webglDepthbuffer = t.createRenderbuffer(), de(te.__webglDepthbuffer, ue, !1);
    n.bindFramebuffer(t.FRAMEBUFFER, null);
  }
  function ee(ue, te, Be) {
    const Je = o.get(ue);
    te !== void 0 && we(Je.__webglFramebuffer, ue, ue.texture, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, 0), Be !== void 0 && Ce(ue);
  }
  function Ae(ue) {
    const te = ue.texture, Be = o.get(ue), Je = o.get(te);
    ue.addEventListener("dispose", j);
    const ft = ue.textures, lt = ue.isWebGLCubeRenderTarget === !0, he = ft.length > 1, ae = M(ue) || h;
    if (he || (Je.__webglTexture === void 0 && (Je.__webglTexture = t.createTexture()), Je.__version = te.version, f.memory.textures++), lt) {
      Be.__webglFramebuffer = [];
      for (let se = 0; se < 6; se++)
        if (h && te.mipmaps && te.mipmaps.length > 0) {
          Be.__webglFramebuffer[se] = [];
          for (let Re = 0; Re < te.mipmaps.length; Re++)
            Be.__webglFramebuffer[se][Re] = t.createFramebuffer();
        } else
          Be.__webglFramebuffer[se] = t.createFramebuffer();
    } else {
      if (h && te.mipmaps && te.mipmaps.length > 0) {
        Be.__webglFramebuffer = [];
        for (let se = 0; se < te.mipmaps.length; se++)
          Be.__webglFramebuffer[se] = t.createFramebuffer();
      } else
        Be.__webglFramebuffer = t.createFramebuffer();
      if (he)
        if (l.drawBuffers)
          for (let se = 0, Re = ft.length; se < Re; se++) {
            const Oe = o.get(ft[se]);
            Oe.__webglTexture === void 0 && (Oe.__webglTexture = t.createTexture(), f.memory.textures++);
          }
        else
          console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
      if (h && ue.samples > 0 && Ye(ue) === !1) {
        Be.__webglMultisampledFramebuffer = t.createFramebuffer(), Be.__webglColorRenderbuffer = [], n.bindFramebuffer(t.FRAMEBUFFER, Be.__webglMultisampledFramebuffer);
        for (let se = 0; se < ft.length; se++) {
          const Re = ft[se];
          Be.__webglColorRenderbuffer[se] = t.createRenderbuffer(), t.bindRenderbuffer(t.RENDERBUFFER, Be.__webglColorRenderbuffer[se]);
          const Oe = u.convert(Re.format, Re.colorSpace), We = u.convert(Re.type), Ct = C(Re.internalFormat, Oe, We, Re.colorSpace, ue.isXRRenderTarget === !0), le = et(ue);
          t.renderbufferStorageMultisample(t.RENDERBUFFER, le, Ct, ue.width, ue.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + se, t.RENDERBUFFER, Be.__webglColorRenderbuffer[se]);
        }
        t.bindRenderbuffer(t.RENDERBUFFER, null), ue.depthBuffer && (Be.__webglDepthRenderbuffer = t.createRenderbuffer(), de(Be.__webglDepthRenderbuffer, ue, !0)), n.bindFramebuffer(t.FRAMEBUFFER, null);
      }
    }
    if (lt) {
      n.bindTexture(t.TEXTURE_CUBE_MAP, Je.__webglTexture), ne(t.TEXTURE_CUBE_MAP, te, ae);
      for (let se = 0; se < 6; se++)
        if (h && te.mipmaps && te.mipmaps.length > 0)
          for (let Re = 0; Re < te.mipmaps.length; Re++)
            we(Be.__webglFramebuffer[se][Re], ue, te, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + se, Re);
        else
          we(Be.__webglFramebuffer[se], ue, te, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + se, 0);
      $(te, ae) && S(t.TEXTURE_CUBE_MAP), n.unbindTexture();
    } else if (he) {
      for (let se = 0, Re = ft.length; se < Re; se++) {
        const Oe = ft[se], We = o.get(Oe);
        n.bindTexture(t.TEXTURE_2D, We.__webglTexture), ne(t.TEXTURE_2D, Oe, ae), we(Be.__webglFramebuffer, ue, Oe, t.COLOR_ATTACHMENT0 + se, t.TEXTURE_2D, 0), $(Oe, ae) && S(t.TEXTURE_2D);
      }
      n.unbindTexture();
    } else {
      let se = t.TEXTURE_2D;
      if ((ue.isWebGL3DRenderTarget || ue.isWebGLArrayRenderTarget) && (h ? se = ue.isWebGL3DRenderTarget ? t.TEXTURE_3D : t.TEXTURE_2D_ARRAY : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), n.bindTexture(se, Je.__webglTexture), ne(se, te, ae), h && te.mipmaps && te.mipmaps.length > 0)
        for (let Re = 0; Re < te.mipmaps.length; Re++)
          we(Be.__webglFramebuffer[Re], ue, te, t.COLOR_ATTACHMENT0, se, Re);
      else
        we(Be.__webglFramebuffer, ue, te, t.COLOR_ATTACHMENT0, se, 0);
      $(te, ae) && S(se), n.unbindTexture();
    }
    ue.depthBuffer && Ce(ue);
  }
  function be(ue) {
    const te = M(ue) || h, Be = ue.textures;
    for (let Je = 0, ft = Be.length; Je < ft; Je++) {
      const lt = Be[Je];
      if ($(lt, te)) {
        const he = ue.isWebGLCubeRenderTarget ? t.TEXTURE_CUBE_MAP : t.TEXTURE_2D, ae = o.get(lt).__webglTexture;
        n.bindTexture(he, ae), S(he), n.unbindTexture();
      }
    }
  }
  function Fe(ue) {
    if (h && ue.samples > 0 && Ye(ue) === !1) {
      const te = ue.textures, Be = ue.width, Je = ue.height;
      let ft = t.COLOR_BUFFER_BIT;
      const lt = [], he = ue.stencilBuffer ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT, ae = o.get(ue), se = te.length > 1;
      if (se)
        for (let Re = 0; Re < te.length; Re++)
          n.bindFramebuffer(t.FRAMEBUFFER, ae.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + Re, t.RENDERBUFFER, null), n.bindFramebuffer(t.FRAMEBUFFER, ae.__webglFramebuffer), t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0 + Re, t.TEXTURE_2D, null, 0);
      n.bindFramebuffer(t.READ_FRAMEBUFFER, ae.__webglMultisampledFramebuffer), n.bindFramebuffer(t.DRAW_FRAMEBUFFER, ae.__webglFramebuffer);
      for (let Re = 0; Re < te.length; Re++) {
        lt.push(t.COLOR_ATTACHMENT0 + Re), ue.depthBuffer && lt.push(he);
        const Oe = ae.__ignoreDepthValues !== void 0 ? ae.__ignoreDepthValues : !1;
        if (Oe === !1 && (ue.depthBuffer && (ft |= t.DEPTH_BUFFER_BIT), ue.stencilBuffer && (ft |= t.STENCIL_BUFFER_BIT)), se && t.framebufferRenderbuffer(t.READ_FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.RENDERBUFFER, ae.__webglColorRenderbuffer[Re]), Oe === !0 && (t.invalidateFramebuffer(t.READ_FRAMEBUFFER, [he]), t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER, [he])), se) {
          const We = o.get(te[Re]).__webglTexture;
          t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, We, 0);
        }
        t.blitFramebuffer(0, 0, Be, Je, 0, 0, Be, Je, ft, t.NEAREST), v && t.invalidateFramebuffer(t.READ_FRAMEBUFFER, lt);
      }
      if (n.bindFramebuffer(t.READ_FRAMEBUFFER, null), n.bindFramebuffer(t.DRAW_FRAMEBUFFER, null), se)
        for (let Re = 0; Re < te.length; Re++) {
          n.bindFramebuffer(t.FRAMEBUFFER, ae.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + Re, t.RENDERBUFFER, ae.__webglColorRenderbuffer[Re]);
          const Oe = o.get(te[Re]).__webglTexture;
          n.bindFramebuffer(t.FRAMEBUFFER, ae.__webglFramebuffer), t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0 + Re, t.TEXTURE_2D, Oe, 0);
        }
      n.bindFramebuffer(t.DRAW_FRAMEBUFFER, ae.__webglMultisampledFramebuffer);
    }
  }
  function et(ue) {
    return Math.min(l.maxSamples, ue.samples);
  }
  function Ye(ue) {
    const te = o.get(ue);
    return h && ue.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && te.__useRenderToTexture !== !1;
  }
  function De(ue) {
    const te = f.render.frame;
    w.get(ue) !== te && (w.set(ue, te), ue.update());
  }
  function Ue(ue, te) {
    const Be = ue.colorSpace, Je = ue.format, ft = ue.type;
    return ue.isCompressedTexture === !0 || ue.isVideoTexture === !0 || ue.format === rs || Be !== dn && Be !== an && (je.getTransfer(Be) === $e ? h === !1 ? e.has("EXT_sRGB") === !0 && Je === Ft ? (ue.format = rs, ue.minFilter = St, ue.generateMipmaps = !1) : te = ho.sRGBToLinear(te) : (Je !== Ft || ft !== un) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", Be)), te;
  }
  function Qe(ue) {
    return typeof HTMLImageElement < "u" && ue instanceof HTMLImageElement ? (g.width = ue.naturalWidth || ue.width, g.height = ue.naturalHeight || ue.height) : typeof VideoFrame < "u" && ue instanceof VideoFrame ? (g.width = ue.displayWidth, g.height = ue.displayHeight) : (g.width = ue.width, g.height = ue.height), g;
  }
  this.allocateTextureUnit = H, this.resetTextureUnits = F, this.setTexture2D = V, this.setTexture2DArray = X, this.setTexture3D = Z, this.setTextureCube = Q, this.rebindTextures = ee, this.setupRenderTarget = Ae, this.updateRenderTargetMipmap = be, this.updateMultisampleRenderTarget = Fe, this.setupDepthRenderbuffer = Ce, this.setupFrameBufferTexture = we, this.useMultisampledRTT = Ye;
}
function ep(t, e, n) {
  const o = n.isWebGL2;
  function l(u, f = an) {
    let h;
    const p = je.getTransfer(f);
    if (u === un)
      return t.UNSIGNED_BYTE;
    if (u === io)
      return t.UNSIGNED_SHORT_4_4_4_4;
    if (u === ro)
      return t.UNSIGNED_SHORT_5_5_5_1;
    if (u === _l)
      return t.BYTE;
    if (u === gl)
      return t.SHORT;
    if (u === ls)
      return t.UNSIGNED_SHORT;
    if (u === no)
      return t.INT;
    if (u === on)
      return t.UNSIGNED_INT;
    if (u === Kt)
      return t.FLOAT;
    if (u === _i)
      return o ? t.HALF_FLOAT : (h = e.get("OES_texture_half_float"), h !== null ? h.HALF_FLOAT_OES : null);
    if (u === vl)
      return t.ALPHA;
    if (u === Ft)
      return t.RGBA;
    if (u === xl)
      return t.LUMINANCE;
    if (u === Ml)
      return t.LUMINANCE_ALPHA;
    if (u === Rn)
      return t.DEPTH_COMPONENT;
    if (u === si)
      return t.DEPTH_STENCIL;
    if (u === rs)
      return h = e.get("EXT_sRGB"), h !== null ? h.SRGB_ALPHA_EXT : null;
    if (u === Sl)
      return t.RED;
    if (u === so)
      return t.RED_INTEGER;
    if (u === El)
      return t.RG;
    if (u === ao)
      return t.RG_INTEGER;
    if (u === oo)
      return t.RGBA_INTEGER;
    if (u === vr || u === xr || u === Mr || u === Sr)
      if (p === $e)
        if (h = e.get("WEBGL_compressed_texture_s3tc_srgb"), h !== null) {
          if (u === vr)
            return h.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (u === xr)
            return h.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (u === Mr)
            return h.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (u === Sr)
            return h.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else
          return null;
      else if (h = e.get("WEBGL_compressed_texture_s3tc"), h !== null) {
        if (u === vr)
          return h.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (u === xr)
          return h.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (u === Mr)
          return h.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (u === Sr)
          return h.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (u === ws || u === Rs || u === Cs || u === Ps)
      if (h = e.get("WEBGL_compressed_texture_pvrtc"), h !== null) {
        if (u === ws)
          return h.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (u === Rs)
          return h.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (u === Cs)
          return h.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (u === Ps)
          return h.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (u === lo)
      return h = e.get("WEBGL_compressed_texture_etc1"), h !== null ? h.COMPRESSED_RGB_ETC1_WEBGL : null;
    if (u === Ls || u === Ds)
      if (h = e.get("WEBGL_compressed_texture_etc"), h !== null) {
        if (u === Ls)
          return p === $e ? h.COMPRESSED_SRGB8_ETC2 : h.COMPRESSED_RGB8_ETC2;
        if (u === Ds)
          return p === $e ? h.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : h.COMPRESSED_RGBA8_ETC2_EAC;
      } else
        return null;
    if (u === Us || u === Is || u === Ns || u === Fs || u === Os || u === Bs || u === zs || u === Gs || u === Hs || u === Vs || u === ks || u === Ws || u === Xs || u === Ys)
      if (h = e.get("WEBGL_compressed_texture_astc"), h !== null) {
        if (u === Us)
          return p === $e ? h.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : h.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (u === Is)
          return p === $e ? h.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : h.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (u === Ns)
          return p === $e ? h.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : h.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (u === Fs)
          return p === $e ? h.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : h.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (u === Os)
          return p === $e ? h.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : h.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (u === Bs)
          return p === $e ? h.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : h.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (u === zs)
          return p === $e ? h.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : h.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (u === Gs)
          return p === $e ? h.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : h.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (u === Hs)
          return p === $e ? h.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : h.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (u === Vs)
          return p === $e ? h.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : h.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (u === ks)
          return p === $e ? h.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : h.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (u === Ws)
          return p === $e ? h.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : h.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (u === Xs)
          return p === $e ? h.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : h.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (u === Ys)
          return p === $e ? h.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : h.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else
        return null;
    if (u === Er || u === qs || u === js)
      if (h = e.get("EXT_texture_compression_bptc"), h !== null) {
        if (u === Er)
          return p === $e ? h.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : h.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (u === qs)
          return h.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (u === js)
          return h.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else
        return null;
    if (u === yl || u === Ks || u === Zs || u === $s)
      if (h = e.get("EXT_texture_compression_rgtc"), h !== null) {
        if (u === Er)
          return h.COMPRESSED_RED_RGTC1_EXT;
        if (u === Ks)
          return h.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (u === Zs)
          return h.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (u === $s)
          return h.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else
        return null;
    return u === wn ? o ? t.UNSIGNED_INT_24_8 : (h = e.get("WEBGL_depth_texture"), h !== null ? h.UNSIGNED_INT_24_8_WEBGL : null) : t[u] !== void 0 ? t[u] : null;
  }
  return { convert: l };
}
class tp extends Lt {
  constructor(e = []) {
    super(), this.isArrayCamera = !0, this.cameras = e;
  }
}
class Xi extends Mt {
  constructor() {
    super(), this.isGroup = !0, this.type = "Group";
  }
}
const np = { type: "move" };
class qr {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return this._hand === null && (this._hand = new Xi(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand;
  }
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new Xi(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new I(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new I()), this._targetRay;
  }
  getGripSpace() {
    return this._grip === null && (this._grip = new Xi(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new I(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new I()), this._grip;
  }
  dispatchEvent(e) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
  }
  connect(e) {
    if (e && e.hand) {
      const n = this._hand;
      if (n)
        for (const o of e.hand.values())
          this._getHandJoint(n, o);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
  }
  update(e, n, o) {
    let l = null, u = null, f = null;
    const h = this._targetRay, p = this._grip, v = this._hand;
    if (e && n.session.visibilityState !== "visible-blurred") {
      if (v && e.hand) {
        f = !0;
        for (const _ of e.hand.values()) {
          const b = n.getJointPose(_, o), M = this._getHandJoint(v, _);
          b !== null && (M.matrix.fromArray(b.transform.matrix), M.matrix.decompose(M.position, M.rotation, M.scale), M.matrixWorldNeedsUpdate = !0, M.jointRadius = b.radius), M.visible = b !== null;
        }
        const g = v.joints["index-finger-tip"], w = v.joints["thumb-tip"], E = g.position.distanceTo(w.position), T = 0.02, R = 5e-3;
        v.inputState.pinching && E > T + R ? (v.inputState.pinching = !1, this.dispatchEvent({
          type: "pinchend",
          handedness: e.handedness,
          target: this
        })) : !v.inputState.pinching && E <= T - R && (v.inputState.pinching = !0, this.dispatchEvent({
          type: "pinchstart",
          handedness: e.handedness,
          target: this
        }));
      } else
        p !== null && e.gripSpace && (u = n.getPose(e.gripSpace, o), u !== null && (p.matrix.fromArray(u.transform.matrix), p.matrix.decompose(p.position, p.rotation, p.scale), p.matrixWorldNeedsUpdate = !0, u.linearVelocity ? (p.hasLinearVelocity = !0, p.linearVelocity.copy(u.linearVelocity)) : p.hasLinearVelocity = !1, u.angularVelocity ? (p.hasAngularVelocity = !0, p.angularVelocity.copy(u.angularVelocity)) : p.hasAngularVelocity = !1));
      h !== null && (l = n.getPose(e.targetRaySpace, o), l === null && u !== null && (l = u), l !== null && (h.matrix.fromArray(l.transform.matrix), h.matrix.decompose(h.position, h.rotation, h.scale), h.matrixWorldNeedsUpdate = !0, l.linearVelocity ? (h.hasLinearVelocity = !0, h.linearVelocity.copy(l.linearVelocity)) : h.hasLinearVelocity = !1, l.angularVelocity ? (h.hasAngularVelocity = !0, h.angularVelocity.copy(l.angularVelocity)) : h.hasAngularVelocity = !1, this.dispatchEvent(np)));
    }
    return h !== null && (h.visible = l !== null), p !== null && (p.visible = u !== null), v !== null && (v.visible = f !== null), this;
  }
  // private method
  _getHandJoint(e, n) {
    if (e.joints[n.jointName] === void 0) {
      const o = new Xi();
      o.matrixAutoUpdate = !1, o.visible = !1, e.joints[n.jointName] = o, e.add(o);
    }
    return e.joints[n.jointName];
  }
}
const ip = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`, rp = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepthEXT = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepthEXT = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class sp {
  constructor() {
    this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0;
  }
  init(e, n, o) {
    if (this.texture === null) {
      const l = new yt(), u = e.properties.get(l);
      u.__webglTexture = n.texture, (n.depthNear != o.depthNear || n.depthFar != o.depthFar) && (this.depthNear = n.depthNear, this.depthFar = n.depthFar), this.texture = l;
    }
  }
  render(e, n) {
    if (this.texture !== null) {
      if (this.mesh === null) {
        const o = n.cameras[0].viewport, l = new fn({
          extensions: { fragDepth: !0 },
          vertexShader: ip,
          fragmentShader: rp,
          uniforms: {
            depthColor: { value: this.texture },
            depthWidth: { value: o.z },
            depthHeight: { value: o.w }
          }
        });
        this.mesh = new Rt(new hr(20, 20), l);
      }
      e.render(this.mesh, n);
    }
  }
  reset() {
    this.texture = null, this.mesh = null;
  }
}
class ap extends Ln {
  constructor(e, n) {
    super();
    const o = this;
    let l = null, u = 1, f = null, h = "local-floor", p = 1, v = null, g = null, w = null, E = null, T = null, R = null;
    const _ = new sp(), b = n.getContextAttributes();
    let M = null, A = null;
    const $ = [], S = [], C = new Ie();
    let D = null;
    const O = new Lt();
    O.layers.enable(1), O.viewport = new ht();
    const N = new Lt();
    N.layers.enable(2), N.viewport = new ht();
    const j = [O, N], L = new tp();
    L.layers.enable(1), L.layers.enable(2);
    let z = null, G = null;
    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(ne) {
      let ge = $[ne];
      return ge === void 0 && (ge = new qr(), $[ne] = ge), ge.getTargetRaySpace();
    }, this.getControllerGrip = function(ne) {
      let ge = $[ne];
      return ge === void 0 && (ge = new qr(), $[ne] = ge), ge.getGripSpace();
    }, this.getHand = function(ne) {
      let ge = $[ne];
      return ge === void 0 && (ge = new qr(), $[ne] = ge), ge.getHandSpace();
    };
    function B(ne) {
      const ge = S.indexOf(ne.inputSource);
      if (ge === -1)
        return;
      const ye = $[ge];
      ye !== void 0 && (ye.update(ne.inputSource, ne.frame, v || f), ye.dispatchEvent({ type: ne.type, data: ne.inputSource }));
    }
    function F() {
      l.removeEventListener("select", B), l.removeEventListener("selectstart", B), l.removeEventListener("selectend", B), l.removeEventListener("squeeze", B), l.removeEventListener("squeezestart", B), l.removeEventListener("squeezeend", B), l.removeEventListener("end", F), l.removeEventListener("inputsourceschange", H);
      for (let ne = 0; ne < $.length; ne++) {
        const ge = S[ne];
        ge !== null && (S[ne] = null, $[ne].disconnect(ge));
      }
      z = null, G = null, _.reset(), e.setRenderTarget(M), T = null, E = null, w = null, l = null, A = null, ie.stop(), o.isPresenting = !1, e.setPixelRatio(D), e.setSize(C.width, C.height, !1), o.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(ne) {
      u = ne, o.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(ne) {
      h = ne, o.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return v || f;
    }, this.setReferenceSpace = function(ne) {
      v = ne;
    }, this.getBaseLayer = function() {
      return E !== null ? E : T;
    }, this.getBinding = function() {
      return w;
    }, this.getFrame = function() {
      return R;
    }, this.getSession = function() {
      return l;
    }, this.setSession = async function(ne) {
      if (l = ne, l !== null) {
        if (M = e.getRenderTarget(), l.addEventListener("select", B), l.addEventListener("selectstart", B), l.addEventListener("selectend", B), l.addEventListener("squeeze", B), l.addEventListener("squeezestart", B), l.addEventListener("squeezeend", B), l.addEventListener("end", F), l.addEventListener("inputsourceschange", H), b.xrCompatible !== !0 && await n.makeXRCompatible(), D = e.getPixelRatio(), e.getSize(C), l.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1) {
          const ge = {
            antialias: l.renderState.layers === void 0 ? b.antialias : !0,
            alpha: !0,
            depth: b.depth,
            stencil: b.stencil,
            framebufferScaleFactor: u
          };
          T = new XRWebGLLayer(l, n, ge), l.updateRenderState({ baseLayer: T }), e.setPixelRatio(1), e.setSize(T.framebufferWidth, T.framebufferHeight, !1), A = new Cn(
            T.framebufferWidth,
            T.framebufferHeight,
            {
              format: Ft,
              type: un,
              colorSpace: e.outputColorSpace,
              stencilBuffer: b.stencil
            }
          );
        } else {
          let ge = null, ye = null, xe = null;
          b.depth && (xe = b.stencil ? n.DEPTH24_STENCIL8 : n.DEPTH_COMPONENT24, ge = b.stencil ? si : Rn, ye = b.stencil ? wn : on);
          const we = {
            colorFormat: n.RGBA8,
            depthFormat: xe,
            scaleFactor: u
          };
          w = new XRWebGLBinding(l, n), E = w.createProjectionLayer(we), l.updateRenderState({ layers: [E] }), e.setPixelRatio(1), e.setSize(E.textureWidth, E.textureHeight, !1), A = new Cn(
            E.textureWidth,
            E.textureHeight,
            {
              format: Ft,
              type: un,
              depthTexture: new To(E.textureWidth, E.textureHeight, ye, void 0, void 0, void 0, void 0, void 0, void 0, ge),
              stencilBuffer: b.stencil,
              colorSpace: e.outputColorSpace,
              samples: b.antialias ? 4 : 0
            }
          );
          const de = e.properties.get(A);
          de.__ignoreDepthValues = E.ignoreDepthValues;
        }
        A.isXRRenderTarget = !0, this.setFoveation(p), v = null, f = await l.requestReferenceSpace(h), ie.setContext(l), ie.start(), o.isPresenting = !0, o.dispatchEvent({ type: "sessionstart" });
      }
    }, this.getEnvironmentBlendMode = function() {
      if (l !== null)
        return l.environmentBlendMode;
    };
    function H(ne) {
      for (let ge = 0; ge < ne.removed.length; ge++) {
        const ye = ne.removed[ge], xe = S.indexOf(ye);
        xe >= 0 && (S[xe] = null, $[xe].disconnect(ye));
      }
      for (let ge = 0; ge < ne.added.length; ge++) {
        const ye = ne.added[ge];
        let xe = S.indexOf(ye);
        if (xe === -1) {
          for (let de = 0; de < $.length; de++)
            if (de >= S.length) {
              S.push(ye), xe = de;
              break;
            } else if (S[de] === null) {
              S[de] = ye, xe = de;
              break;
            }
          if (xe === -1)
            break;
        }
        const we = $[xe];
        we && we.connect(ye);
      }
    }
    const W = new I(), V = new I();
    function X(ne, ge, ye) {
      W.setFromMatrixPosition(ge.matrixWorld), V.setFromMatrixPosition(ye.matrixWorld);
      const xe = W.distanceTo(V), we = ge.projectionMatrix.elements, de = ye.projectionMatrix.elements, Te = we[14] / (we[10] - 1), Ce = we[14] / (we[10] + 1), ee = (we[9] + 1) / we[5], Ae = (we[9] - 1) / we[5], be = (we[8] - 1) / we[0], Fe = (de[8] + 1) / de[0], et = Te * be, Ye = Te * Fe, De = xe / (-be + Fe), Ue = De * -be;
      ge.matrixWorld.decompose(ne.position, ne.quaternion, ne.scale), ne.translateX(Ue), ne.translateZ(De), ne.matrixWorld.compose(ne.position, ne.quaternion, ne.scale), ne.matrixWorldInverse.copy(ne.matrixWorld).invert();
      const Qe = Te + De, ue = Ce + De, te = et - Ue, Be = Ye + (xe - Ue), Je = ee * Ce / ue * Qe, ft = Ae * Ce / ue * Qe;
      ne.projectionMatrix.makePerspective(te, Be, Je, ft, Qe, ue), ne.projectionMatrixInverse.copy(ne.projectionMatrix).invert();
    }
    function Z(ne, ge) {
      ge === null ? ne.matrixWorld.copy(ne.matrix) : ne.matrixWorld.multiplyMatrices(ge.matrixWorld, ne.matrix), ne.matrixWorldInverse.copy(ne.matrixWorld).invert();
    }
    this.updateCamera = function(ne) {
      if (l === null)
        return;
      _.texture !== null && (ne.near = _.depthNear, ne.far = _.depthFar), L.near = N.near = O.near = ne.near, L.far = N.far = O.far = ne.far, (z !== L.near || G !== L.far) && (l.updateRenderState({
        depthNear: L.near,
        depthFar: L.far
      }), z = L.near, G = L.far, O.near = z, O.far = G, N.near = z, N.far = G, O.updateProjectionMatrix(), N.updateProjectionMatrix(), ne.updateProjectionMatrix());
      const ge = ne.parent, ye = L.cameras;
      Z(L, ge);
      for (let xe = 0; xe < ye.length; xe++)
        Z(ye[xe], ge);
      ye.length === 2 ? X(L, O, N) : L.projectionMatrix.copy(O.projectionMatrix), Q(ne, L, ge);
    };
    function Q(ne, ge, ye) {
      ye === null ? ne.matrix.copy(ge.matrixWorld) : (ne.matrix.copy(ye.matrixWorld), ne.matrix.invert(), ne.matrix.multiply(ge.matrixWorld)), ne.matrix.decompose(ne.position, ne.quaternion, ne.scale), ne.updateMatrixWorld(!0), ne.projectionMatrix.copy(ge.projectionMatrix), ne.projectionMatrixInverse.copy(ge.projectionMatrixInverse), ne.isPerspectiveCamera && (ne.fov = gi * 2 * Math.atan(1 / ne.projectionMatrix.elements[5]), ne.zoom = 1);
    }
    this.getCamera = function() {
      return L;
    }, this.getFoveation = function() {
      if (!(E === null && T === null))
        return p;
    }, this.setFoveation = function(ne) {
      p = ne, E !== null && (E.fixedFoveation = ne), T !== null && T.fixedFoveation !== void 0 && (T.fixedFoveation = ne);
    }, this.hasDepthSensing = function() {
      return _.texture !== null;
    };
    let q = null;
    function J(ne, ge) {
      if (g = ge.getViewerPose(v || f), R = ge, g !== null) {
        const ye = g.views;
        T !== null && (e.setRenderTargetFramebuffer(A, T.framebuffer), e.setRenderTarget(A));
        let xe = !1;
        ye.length !== L.cameras.length && (L.cameras.length = 0, xe = !0);
        for (let de = 0; de < ye.length; de++) {
          const Te = ye[de];
          let Ce = null;
          if (T !== null)
            Ce = T.getViewport(Te);
          else {
            const Ae = w.getViewSubImage(E, Te);
            Ce = Ae.viewport, de === 0 && (e.setRenderTargetTextures(
              A,
              Ae.colorTexture,
              E.ignoreDepthValues ? void 0 : Ae.depthStencilTexture
            ), e.setRenderTarget(A));
          }
          let ee = j[de];
          ee === void 0 && (ee = new Lt(), ee.layers.enable(de), ee.viewport = new ht(), j[de] = ee), ee.matrix.fromArray(Te.transform.matrix), ee.matrix.decompose(ee.position, ee.quaternion, ee.scale), ee.projectionMatrix.fromArray(Te.projectionMatrix), ee.projectionMatrixInverse.copy(ee.projectionMatrix).invert(), ee.viewport.set(Ce.x, Ce.y, Ce.width, Ce.height), de === 0 && (L.matrix.copy(ee.matrix), L.matrix.decompose(L.position, L.quaternion, L.scale)), xe === !0 && L.cameras.push(ee);
        }
        const we = l.enabledFeatures;
        if (we && we.includes("depth-sensing")) {
          const de = w.getDepthInformation(ye[0]);
          de && de.isValid && de.texture && _.init(e, de, l.renderState);
        }
      }
      for (let ye = 0; ye < $.length; ye++) {
        const xe = S[ye], we = $[ye];
        xe !== null && we !== void 0 && we.update(xe, ge, v || f);
      }
      _.render(e, L), q && q(ne, ge), ge.detectedPlanes && o.dispatchEvent({ type: "planesdetected", data: ge }), R = null;
    }
    const ie = new yo();
    ie.setAnimationLoop(J), this.setAnimationLoop = function(ne) {
      q = ne;
    }, this.dispose = function() {
    };
  }
}
const En = /* @__PURE__ */ new $t(), op = /* @__PURE__ */ new st();
function lp(t, e) {
  function n(b, M) {
    b.matrixAutoUpdate === !0 && b.updateMatrix(), M.value.copy(b.matrix);
  }
  function o(b, M) {
    M.color.getRGB(b.fogColor.value, xo(t)), M.isFog ? (b.fogNear.value = M.near, b.fogFar.value = M.far) : M.isFogExp2 && (b.fogDensity.value = M.density);
  }
  function l(b, M, A, $, S) {
    M.isMeshBasicMaterial || M.isMeshLambertMaterial ? u(b, M) : M.isMeshToonMaterial ? (u(b, M), w(b, M)) : M.isMeshPhongMaterial ? (u(b, M), g(b, M)) : M.isMeshStandardMaterial ? (u(b, M), E(b, M), M.isMeshPhysicalMaterial && T(b, M, S)) : M.isMeshMatcapMaterial ? (u(b, M), R(b, M)) : M.isMeshDepthMaterial ? u(b, M) : M.isMeshDistanceMaterial ? (u(b, M), _(b, M)) : M.isMeshNormalMaterial ? u(b, M) : M.isLineBasicMaterial ? (f(b, M), M.isLineDashedMaterial && h(b, M)) : M.isPointsMaterial ? p(b, M, A, $) : M.isSpriteMaterial ? v(b, M) : M.isShadowMaterial ? (b.color.value.copy(M.color), b.opacity.value = M.opacity) : M.isShaderMaterial && (M.uniformsNeedUpdate = !1);
  }
  function u(b, M) {
    b.opacity.value = M.opacity, M.color && b.diffuse.value.copy(M.color), M.emissive && b.emissive.value.copy(M.emissive).multiplyScalar(M.emissiveIntensity), M.map && (b.map.value = M.map, n(M.map, b.mapTransform)), M.alphaMap && (b.alphaMap.value = M.alphaMap, n(M.alphaMap, b.alphaMapTransform)), M.bumpMap && (b.bumpMap.value = M.bumpMap, n(M.bumpMap, b.bumpMapTransform), b.bumpScale.value = M.bumpScale, M.side === Et && (b.bumpScale.value *= -1)), M.normalMap && (b.normalMap.value = M.normalMap, n(M.normalMap, b.normalMapTransform), b.normalScale.value.copy(M.normalScale), M.side === Et && b.normalScale.value.negate()), M.displacementMap && (b.displacementMap.value = M.displacementMap, n(M.displacementMap, b.displacementMapTransform), b.displacementScale.value = M.displacementScale, b.displacementBias.value = M.displacementBias), M.emissiveMap && (b.emissiveMap.value = M.emissiveMap, n(M.emissiveMap, b.emissiveMapTransform)), M.specularMap && (b.specularMap.value = M.specularMap, n(M.specularMap, b.specularMapTransform)), M.alphaTest > 0 && (b.alphaTest.value = M.alphaTest);
    const A = e.get(M), $ = A.envMap, S = A.envMapRotation;
    if ($ && (b.envMap.value = $, En.copy(S), En.x *= -1, En.y *= -1, En.z *= -1, $.isCubeTexture && $.isRenderTargetTexture === !1 && (En.y *= -1, En.z *= -1), b.envMapRotation.value.setFromMatrix4(op.makeRotationFromEuler(En)), b.flipEnvMap.value = $.isCubeTexture && $.isRenderTargetTexture === !1 ? -1 : 1, b.reflectivity.value = M.reflectivity, b.ior.value = M.ior, b.refractionRatio.value = M.refractionRatio), M.lightMap) {
      b.lightMap.value = M.lightMap;
      const C = t._useLegacyLights === !0 ? Math.PI : 1;
      b.lightMapIntensity.value = M.lightMapIntensity * C, n(M.lightMap, b.lightMapTransform);
    }
    M.aoMap && (b.aoMap.value = M.aoMap, b.aoMapIntensity.value = M.aoMapIntensity, n(M.aoMap, b.aoMapTransform));
  }
  function f(b, M) {
    b.diffuse.value.copy(M.color), b.opacity.value = M.opacity, M.map && (b.map.value = M.map, n(M.map, b.mapTransform));
  }
  function h(b, M) {
    b.dashSize.value = M.dashSize, b.totalSize.value = M.dashSize + M.gapSize, b.scale.value = M.scale;
  }
  function p(b, M, A, $) {
    b.diffuse.value.copy(M.color), b.opacity.value = M.opacity, b.size.value = M.size * A, b.scale.value = $ * 0.5, M.map && (b.map.value = M.map, n(M.map, b.uvTransform)), M.alphaMap && (b.alphaMap.value = M.alphaMap, n(M.alphaMap, b.alphaMapTransform)), M.alphaTest > 0 && (b.alphaTest.value = M.alphaTest);
  }
  function v(b, M) {
    b.diffuse.value.copy(M.color), b.opacity.value = M.opacity, b.rotation.value = M.rotation, M.map && (b.map.value = M.map, n(M.map, b.mapTransform)), M.alphaMap && (b.alphaMap.value = M.alphaMap, n(M.alphaMap, b.alphaMapTransform)), M.alphaTest > 0 && (b.alphaTest.value = M.alphaTest);
  }
  function g(b, M) {
    b.specular.value.copy(M.specular), b.shininess.value = Math.max(M.shininess, 1e-4);
  }
  function w(b, M) {
    M.gradientMap && (b.gradientMap.value = M.gradientMap);
  }
  function E(b, M) {
    b.metalness.value = M.metalness, M.metalnessMap && (b.metalnessMap.value = M.metalnessMap, n(M.metalnessMap, b.metalnessMapTransform)), b.roughness.value = M.roughness, M.roughnessMap && (b.roughnessMap.value = M.roughnessMap, n(M.roughnessMap, b.roughnessMapTransform)), e.get(M).envMap && (b.envMapIntensity.value = M.envMapIntensity);
  }
  function T(b, M, A) {
    b.ior.value = M.ior, M.sheen > 0 && (b.sheenColor.value.copy(M.sheenColor).multiplyScalar(M.sheen), b.sheenRoughness.value = M.sheenRoughness, M.sheenColorMap && (b.sheenColorMap.value = M.sheenColorMap, n(M.sheenColorMap, b.sheenColorMapTransform)), M.sheenRoughnessMap && (b.sheenRoughnessMap.value = M.sheenRoughnessMap, n(M.sheenRoughnessMap, b.sheenRoughnessMapTransform))), M.clearcoat > 0 && (b.clearcoat.value = M.clearcoat, b.clearcoatRoughness.value = M.clearcoatRoughness, M.clearcoatMap && (b.clearcoatMap.value = M.clearcoatMap, n(M.clearcoatMap, b.clearcoatMapTransform)), M.clearcoatRoughnessMap && (b.clearcoatRoughnessMap.value = M.clearcoatRoughnessMap, n(M.clearcoatRoughnessMap, b.clearcoatRoughnessMapTransform)), M.clearcoatNormalMap && (b.clearcoatNormalMap.value = M.clearcoatNormalMap, n(M.clearcoatNormalMap, b.clearcoatNormalMapTransform), b.clearcoatNormalScale.value.copy(M.clearcoatNormalScale), M.side === Et && b.clearcoatNormalScale.value.negate())), M.iridescence > 0 && (b.iridescence.value = M.iridescence, b.iridescenceIOR.value = M.iridescenceIOR, b.iridescenceThicknessMinimum.value = M.iridescenceThicknessRange[0], b.iridescenceThicknessMaximum.value = M.iridescenceThicknessRange[1], M.iridescenceMap && (b.iridescenceMap.value = M.iridescenceMap, n(M.iridescenceMap, b.iridescenceMapTransform)), M.iridescenceThicknessMap && (b.iridescenceThicknessMap.value = M.iridescenceThicknessMap, n(M.iridescenceThicknessMap, b.iridescenceThicknessMapTransform))), M.transmission > 0 && (b.transmission.value = M.transmission, b.transmissionSamplerMap.value = A.texture, b.transmissionSamplerSize.value.set(A.width, A.height), M.transmissionMap && (b.transmissionMap.value = M.transmissionMap, n(M.transmissionMap, b.transmissionMapTransform)), b.thickness.value = M.thickness, M.thicknessMap && (b.thicknessMap.value = M.thicknessMap, n(M.thicknessMap, b.thicknessMapTransform)), b.attenuationDistance.value = M.attenuationDistance, b.attenuationColor.value.copy(M.attenuationColor)), M.anisotropy > 0 && (b.anisotropyVector.value.set(M.anisotropy * Math.cos(M.anisotropyRotation), M.anisotropy * Math.sin(M.anisotropyRotation)), M.anisotropyMap && (b.anisotropyMap.value = M.anisotropyMap, n(M.anisotropyMap, b.anisotropyMapTransform))), b.specularIntensity.value = M.specularIntensity, b.specularColor.value.copy(M.specularColor), M.specularColorMap && (b.specularColorMap.value = M.specularColorMap, n(M.specularColorMap, b.specularColorMapTransform)), M.specularIntensityMap && (b.specularIntensityMap.value = M.specularIntensityMap, n(M.specularIntensityMap, b.specularIntensityMapTransform));
  }
  function R(b, M) {
    M.matcap && (b.matcap.value = M.matcap);
  }
  function _(b, M) {
    const A = e.get(M).light;
    b.referencePosition.value.setFromMatrixPosition(A.matrixWorld), b.nearDistance.value = A.shadow.camera.near, b.farDistance.value = A.shadow.camera.far;
  }
  return {
    refreshFogUniforms: o,
    refreshMaterialUniforms: l
  };
}
function cp(t, e, n, o) {
  let l = {}, u = {}, f = [];
  const h = n.isWebGL2 ? t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
  function p(A, $) {
    const S = $.program;
    o.uniformBlockBinding(A, S);
  }
  function v(A, $) {
    let S = l[A.id];
    S === void 0 && (R(A), S = g(A), l[A.id] = S, A.addEventListener("dispose", b));
    const C = $.program;
    o.updateUBOMapping(A, C);
    const D = e.render.frame;
    u[A.id] !== D && (E(A), u[A.id] = D);
  }
  function g(A) {
    const $ = w();
    A.__bindingPointIndex = $;
    const S = t.createBuffer(), C = A.__size, D = A.usage;
    return t.bindBuffer(t.UNIFORM_BUFFER, S), t.bufferData(t.UNIFORM_BUFFER, C, D), t.bindBuffer(t.UNIFORM_BUFFER, null), t.bindBufferBase(t.UNIFORM_BUFFER, $, S), S;
  }
  function w() {
    for (let A = 0; A < h; A++)
      if (f.indexOf(A) === -1)
        return f.push(A), A;
    return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
  }
  function E(A) {
    const $ = l[A.id], S = A.uniforms, C = A.__cache;
    t.bindBuffer(t.UNIFORM_BUFFER, $);
    for (let D = 0, O = S.length; D < O; D++) {
      const N = Array.isArray(S[D]) ? S[D] : [S[D]];
      for (let j = 0, L = N.length; j < L; j++) {
        const z = N[j];
        if (T(z, D, j, C) === !0) {
          const G = z.__offset, B = Array.isArray(z.value) ? z.value : [z.value];
          let F = 0;
          for (let H = 0; H < B.length; H++) {
            const W = B[H], V = _(W);
            typeof W == "number" || typeof W == "boolean" ? (z.__data[0] = W, t.bufferSubData(t.UNIFORM_BUFFER, G + F, z.__data)) : W.isMatrix3 ? (z.__data[0] = W.elements[0], z.__data[1] = W.elements[1], z.__data[2] = W.elements[2], z.__data[3] = 0, z.__data[4] = W.elements[3], z.__data[5] = W.elements[4], z.__data[6] = W.elements[5], z.__data[7] = 0, z.__data[8] = W.elements[6], z.__data[9] = W.elements[7], z.__data[10] = W.elements[8], z.__data[11] = 0) : (W.toArray(z.__data, F), F += V.storage / Float32Array.BYTES_PER_ELEMENT);
          }
          t.bufferSubData(t.UNIFORM_BUFFER, G, z.__data);
        }
      }
    }
    t.bindBuffer(t.UNIFORM_BUFFER, null);
  }
  function T(A, $, S, C) {
    const D = A.value, O = $ + "_" + S;
    if (C[O] === void 0)
      return typeof D == "number" || typeof D == "boolean" ? C[O] = D : C[O] = D.clone(), !0;
    {
      const N = C[O];
      if (typeof D == "number" || typeof D == "boolean") {
        if (N !== D)
          return C[O] = D, !0;
      } else if (N.equals(D) === !1)
        return N.copy(D), !0;
    }
    return !1;
  }
  function R(A) {
    const $ = A.uniforms;
    let S = 0;
    const C = 16;
    for (let O = 0, N = $.length; O < N; O++) {
      const j = Array.isArray($[O]) ? $[O] : [$[O]];
      for (let L = 0, z = j.length; L < z; L++) {
        const G = j[L], B = Array.isArray(G.value) ? G.value : [G.value];
        for (let F = 0, H = B.length; F < H; F++) {
          const W = B[F], V = _(W), X = S % C;
          X !== 0 && C - X < V.boundary && (S += C - X), G.__data = new Float32Array(V.storage / Float32Array.BYTES_PER_ELEMENT), G.__offset = S, S += V.storage;
        }
      }
    }
    const D = S % C;
    return D > 0 && (S += C - D), A.__size = S, A.__cache = {}, this;
  }
  function _(A) {
    const $ = {
      boundary: 0,
      // bytes
      storage: 0
      // bytes
    };
    return typeof A == "number" || typeof A == "boolean" ? ($.boundary = 4, $.storage = 4) : A.isVector2 ? ($.boundary = 8, $.storage = 8) : A.isVector3 || A.isColor ? ($.boundary = 16, $.storage = 12) : A.isVector4 ? ($.boundary = 16, $.storage = 16) : A.isMatrix3 ? ($.boundary = 48, $.storage = 48) : A.isMatrix4 ? ($.boundary = 64, $.storage = 64) : A.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", A), $;
  }
  function b(A) {
    const $ = A.target;
    $.removeEventListener("dispose", b);
    const S = f.indexOf($.__bindingPointIndex);
    f.splice(S, 1), t.deleteBuffer(l[$.id]), delete l[$.id], delete u[$.id];
  }
  function M() {
    for (const A in l)
      t.deleteBuffer(l[A]);
    f = [], l = {}, u = {};
  }
  return {
    bind: p,
    update: v,
    dispose: M
  };
}
class Po {
  constructor(e = {}) {
    const {
      canvas: n = Zl(),
      context: o = null,
      depth: l = !0,
      stencil: u = !0,
      alpha: f = !1,
      antialias: h = !1,
      premultipliedAlpha: p = !0,
      preserveDrawingBuffer: v = !1,
      powerPreference: g = "default",
      failIfMajorPerformanceCaveat: w = !1
    } = e;
    this.isWebGLRenderer = !0;
    let E;
    o !== null ? E = o.getContextAttributes().alpha : E = f;
    const T = new Uint32Array(4), R = new Int32Array(4);
    let _ = null, b = null;
    const M = [], A = [];
    this.domElement = n, this.debug = {
      /**
       * Enables error checking and reporting when shader programs are being compiled
       * @type {boolean}
       */
      checkShaderErrors: !0,
      /**
       * Callback for custom error reporting.
       * @type {?Function}
       */
      onShaderError: null
    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = Bt, this._useLegacyLights = !1, this.toneMapping = cn, this.toneMappingExposure = 1;
    const $ = this;
    let S = !1, C = 0, D = 0, O = null, N = -1, j = null;
    const L = new ht(), z = new ht();
    let G = null;
    const B = new qe(0);
    let F = 0, H = n.width, W = n.height, V = 1, X = null, Z = null;
    const Q = new ht(0, 0, H, W), q = new ht(0, 0, H, W);
    let J = !1;
    const ie = new Eo();
    let ne = !1, ge = !1, ye = null;
    const xe = new st(), we = new Ie(), de = new I(), Te = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
    function Ce() {
      return O === null ? V : 1;
    }
    let ee = o;
    function Ae(ve, He) {
      for (let nt = 0; nt < ve.length; nt++) {
        const dr = ve[nt], dt = n.getContext(dr, He);
        if (dt !== null)
          return dt;
      }
      return null;
    }
    try {
      const ve = {
        alpha: !0,
        depth: l,
        stencil: u,
        antialias: h,
        premultipliedAlpha: p,
        preserveDrawingBuffer: v,
        powerPreference: g,
        failIfMajorPerformanceCaveat: w
      };
      if ("setAttribute" in n && n.setAttribute("data-engine", `three.js r${os}`), n.addEventListener("webglcontextlost", ce, !1), n.addEventListener("webglcontextrestored", _e, !1), n.addEventListener("webglcontextcreationerror", Ht, !1), ee === null) {
        const He = ["webgl2", "webgl", "experimental-webgl"];
        if ($.isWebGL1Renderer === !0 && He.shift(), ee = Ae(He, ve), ee === null)
          throw Ae(He) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }
      typeof WebGLRenderingContext < "u" && ee instanceof WebGLRenderingContext && console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."), ee.getShaderPrecisionFormat === void 0 && (ee.getShaderPrecisionFormat = function() {
        return { rangeMin: 1, rangeMax: 1, precision: 1 };
      });
    } catch (ve) {
      throw console.error("THREE.WebGLRenderer: " + ve.message), ve;
    }
    let be, Fe, et, Ye, De, Ue, Qe, ue, te, Be, Je, ft, lt, he, ae, se, Re, Oe, We, Ct, le, ke, Ke, me;
    function Ee() {
      be = new mf(ee), Fe = new lf(ee, be, e), be.init(Fe), ke = new ep(ee, be, Fe), et = new Jd(ee, be, Fe), Ye = new vf(ee), De = new Bd(), Ue = new Qd(ee, be, et, De, Fe, ke, Ye), Qe = new uf($), ue = new pf($), te = new Ec(ee, Fe), Ke = new af(ee, be, te, Fe), Be = new _f(ee, te, Ye, Ke), Je = new Ef(ee, Be, te, Ye), We = new Sf(ee, Fe, Ue), se = new cf(De), ft = new Od($, Qe, ue, be, Fe, Ke, se), lt = new lp($, De), he = new Gd(), ae = new Yd(be, Fe), Oe = new sf($, Qe, ue, et, Je, E, p), Re = new $d($, Je, Fe), me = new cp(ee, Ye, Fe, et), Ct = new of(ee, be, Ye, Fe), le = new gf(ee, be, Ye, Fe), Ye.programs = ft.programs, $.capabilities = Fe, $.extensions = be, $.properties = De, $.renderLists = he, $.shadowMap = Re, $.state = et, $.info = Ye;
    }
    Ee();
    const tt = new ap($, ee);
    this.xr = tt, this.getContext = function() {
      return ee;
    }, this.getContextAttributes = function() {
      return ee.getContextAttributes();
    }, this.forceContextLoss = function() {
      const ve = be.get("WEBGL_lose_context");
      ve && ve.loseContext();
    }, this.forceContextRestore = function() {
      const ve = be.get("WEBGL_lose_context");
      ve && ve.restoreContext();
    }, this.getPixelRatio = function() {
      return V;
    }, this.setPixelRatio = function(ve) {
      ve !== void 0 && (V = ve, this.setSize(H, W, !1));
    }, this.getSize = function(ve) {
      return ve.set(H, W);
    }, this.setSize = function(ve, He, nt = !0) {
      if (tt.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      H = ve, W = He, n.width = Math.floor(ve * V), n.height = Math.floor(He * V), nt === !0 && (n.style.width = ve + "px", n.style.height = He + "px"), this.setViewport(0, 0, ve, He);
    }, this.getDrawingBufferSize = function(ve) {
      return ve.set(H * V, W * V).floor();
    }, this.setDrawingBufferSize = function(ve, He, nt) {
      H = ve, W = He, V = nt, n.width = Math.floor(ve * nt), n.height = Math.floor(He * nt), this.setViewport(0, 0, ve, He);
    }, this.getCurrentViewport = function(ve) {
      return ve.copy(L);
    }, this.getViewport = function(ve) {
      return ve.copy(Q);
    }, this.setViewport = function(ve, He, nt, dr) {
      ve.isVector4 ? Q.set(ve.x, ve.y, ve.z, ve.w) : Q.set(ve, He, nt, dr), et.viewport(L.copy(Q).multiplyScalar(V).round());
    }, this.getScissor = function(ve) {
      return ve.copy(q);
    }, this.setScissor = function(ve, He, nt, dr) {
      ve.isVector4 ? q.set(ve.x, ve.y, ve.z, ve.w) : q.set(ve, He, nt, dr), et.scissor(z.copy(q).multiplyScalar(V).round());
    }, this.getScissorTest = function() {
      return J;
    }, this.setScissorTest = function(ve) {
      et.setScissorTest(J = ve);
    }, this.setOpaqueSort = function(ve) {
      X = ve;
    }, this.setTransparentSort = function(ve) {
      Z = ve;
    }, this.getClearColor = function(ve) {
      return ve.copy(Oe.getClearColor());
    }, this.setClearColor = function() {
      Oe.setClearColor.apply(Oe, arguments);
    }, this.getClearAlpha = function() {
      return Oe.getClearAlpha();
    }, this.setClearAlpha = function() {
      Oe.setClearAlpha.apply(Oe, arguments);
    }, this.clear = function(ve = !0, He = !0, nt = !0) {
      let dr = 0;
      if (ve) {
        let dt = !1;
        if (O !== null) {
          const ci = O.texture.format;
          dt = ci === oo || ci === ao || ci === so;
        }
        if (dt) {
          const ci = O.texture.type, Uo = ci === un || ci === on || ci === ls || ci === wn || ci === io || ci === ro, xs = Oe.getClearColor(), vs = Oe.getClearAlpha(), bp = xs.r, Ep = xs.g, Ap = xs.b;
          Uo ? (T[0] = bp, T[1] = Ep, T[2] = Ap, T[3] = vs, ee.clearBufferuiv(ee.COLOR, 0, T)) : (R[0] = bp, R[1] = Ep, R[2] = Ap, R[3] = vs, ee.clearBufferiv(ee.COLOR, 0, R));
        } else
          dr |= ee.COLOR_BUFFER_BIT;
      }
      He && (dr |= ee.DEPTH_BUFFER_BIT), nt && (dr |= ee.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), ee.clear(dr);
    }, this.clearColor = function() {
      this.clear(!0, !1, !1);
    }, this.clearDepth = function() {
      this.clear(!1, !0, !1);
    }, this.clearStencil = function() {
      this.clear(!1, !1, !0);
    }, this.dispose = function() {
      n.removeEventListener("webglcontextlost", ce, !1), n.removeEventListener("webglcontextrestored", _e, !1), n.removeEventListener("webglcontextcreationerror", Ht, !1), he.dispose(), ae.dispose(), De.dispose(), Qe.dispose(), ue.dispose(), Je.dispose(), Ke.dispose(), me.dispose(), ft.dispose(), tt.dispose(), tt.removeEventListener("sessionstart", yi), tt.removeEventListener("sessionend", _n), ye && (ye.dispose(), ye = null), Do.stop();
    };
    function ce(ve) {
      ve.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), S = !0;
    }
    function _e() {
      console.log("THREE.WebGLRenderer: Context Restored."), S = !1;
      const ve = Ye.autoReset, He = Re.enabled, nt = Re.autoUpdate, dr = Re.needsUpdate, dt = Re.type;
      Ee(), Ye.autoReset = ve, Re.enabled = He, Re.autoUpdate = nt, Re.needsUpdate = dr, Re.type = dt;
    }
    function Ht(ve) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", ve.statusMessage);
    }
    function K(ve) {
      const He = ve.target;
      He.removeEventListener("dispose", K), Ve(He);
    }
    function Ve(ve) {
      Ne(ve), De.remove(ve);
    }
    function Ne(ve) {
      const He = De.get(ve).programs;
      He !== void 0 && (He.forEach(function(nt) {
        ft.releaseProgram(nt);
      }), ve.isShaderMaterial && ft.releaseShaderCache(ve));
    }
    this.renderBufferDirect = function(ve, He, nt, dr, dt, ci) {
      He === null && (He = Te);
      const Uo = dt.isMesh && dt.matrixWorld.determinant() < 0, xs = mn(ve, He, nt, dr, dt);
      et.setMaterial(dr, Uo);
      let vs = nt.index, bp = 1;
      if (dr.wireframe === !0) {
        if (vs = Be.getWireframeAttribute(nt), vs === void 0)
          return;
        bp = 2;
      }
      const Ep = nt.drawRange, Ap = nt.attributes.position;
      let wp = Ep.start * bp, jp = (Ep.start + Ep.count) * bp;
      ci !== null && (wp = Math.max(wp, ci.start * bp), jp = Math.min(jp, (ci.start + ci.count) * bp)), vs !== null ? (wp = Math.max(wp, 0), jp = Math.min(jp, vs.count)) : Ap != null && (wp = Math.max(wp, 0), jp = Math.min(jp, Ap.count));
      const Vp = jp - wp;
      if (Vp < 0 || Vp === 1 / 0)
        return;
      Ke.setup(dt, dr, xs, nt, vs);
      let Qp, zp = Ct;
      if (vs !== null && (Qp = te.get(vs), zp = le, zp.setIndex(Qp)), dt.isMesh)
        dr.wireframe === !0 ? (et.setLineWidth(dr.wireframeLinewidth * Ce()), zp.setMode(ee.LINES)) : zp.setMode(ee.TRIANGLES);
      else if (dt.isLine) {
        let Mp = dr.linewidth;
        Mp === void 0 && (Mp = 1), et.setLineWidth(Mp * Ce()), dt.isLineSegments ? zp.setMode(ee.LINES) : dt.isLineLoop ? zp.setMode(ee.LINE_LOOP) : zp.setMode(ee.LINE_STRIP);
      } else
        dt.isPoints ? zp.setMode(ee.POINTS) : dt.isSprite && zp.setMode(ee.TRIANGLES);
      if (dt.isBatchedMesh)
        zp.renderMultiDraw(dt._multiDrawStarts, dt._multiDrawCounts, dt._multiDrawCount);
      else if (dt.isInstancedMesh)
        zp.renderInstances(wp, Vp, dt.count);
      else if (nt.isInstancedBufferGeometry) {
        const Mp = nt._maxInstanceCount !== void 0 ? nt._maxInstanceCount : 1 / 0, fm = Math.min(nt.instanceCount, Mp);
        zp.renderInstances(wp, Vp, fm);
      } else
        zp.render(wp, Vp);
    };
    function pe(ve, He, nt) {
      ve.transparent === !0 && ve.side === jt && ve.forceSinglePass === !1 ? (ve.side = Et, ve.needsUpdate = !0, Xe(ve, He, nt), ve.side = hn, ve.needsUpdate = !0, Xe(ve, He, nt), ve.side = jt) : Xe(ve, He, nt);
    }
    this.compile = function(ve, He, nt = null) {
      nt === null && (nt = ve), b = ae.get(nt), b.init(), A.push(b), nt.traverseVisible(function(dt) {
        dt.isLight && dt.layers.test(He.layers) && (b.pushLight(dt), dt.castShadow && b.pushShadow(dt));
      }), ve !== nt && ve.traverseVisible(function(dt) {
        dt.isLight && dt.layers.test(He.layers) && (b.pushLight(dt), dt.castShadow && b.pushShadow(dt));
      }), b.setupLights($._useLegacyLights);
      const dr = /* @__PURE__ */ new Set();
      return ve.traverse(function(dt) {
        const ci = dt.material;
        if (ci)
          if (Array.isArray(ci))
            for (let Uo = 0; Uo < ci.length; Uo++) {
              const xs = ci[Uo];
              pe(xs, nt, dt), dr.add(xs);
            }
          else
            pe(ci, nt, dt), dr.add(ci);
      }), A.pop(), b = null, dr;
    }, this.compileAsync = function(ve, He, nt = null) {
      const dr = this.compile(ve, He, nt);
      return new Promise((dt) => {
        function ci() {
          if (dr.forEach(function(Uo) {
            De.get(Uo).currentProgram.isReady() && dr.delete(Uo);
          }), dr.size === 0) {
            dt(ve);
            return;
          }
          setTimeout(ci, 10);
        }
        be.get("KHR_parallel_shader_compile") !== null ? ci() : setTimeout(ci, 10);
      });
    };
    let Le = null;
    function bt(ve) {
      Le && Le(ve);
    }
    function yi() {
      Do.stop();
    }
    function _n() {
      Do.start();
    }
    const Do = new yo();
    Do.setAnimationLoop(bt), typeof self < "u" && Do.setContext(self), this.setAnimationLoop = function(ve) {
      Le = ve, tt.setAnimationLoop(ve), ve === null ? Do.stop() : Do.start();
    }, tt.addEventListener("sessionstart", yi), tt.addEventListener("sessionend", _n), this.render = function(ve, He) {
      if (He !== void 0 && He.isCamera !== !0) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (S === !0)
        return;
      ve.matrixWorldAutoUpdate === !0 && ve.updateMatrixWorld(), He.parent === null && He.matrixWorldAutoUpdate === !0 && He.updateMatrixWorld(), tt.enabled === !0 && tt.isPresenting === !0 && (tt.cameraAutoUpdate === !0 && tt.updateCamera(He), He = tt.getCamera()), ve.isScene === !0 && ve.onBeforeRender($, ve, He, O), b = ae.get(ve, A.length), b.init(), A.push(b), xe.multiplyMatrices(He.projectionMatrix, He.matrixWorldInverse), ie.setFromProjectionMatrix(xe), ge = this.localClippingEnabled, ne = se.init(this.clippingPlanes, ge), _ = he.get(ve, M.length), _.init(), M.push(_), ms(ve, He, 0, $.sortObjects), _.finish(), $.sortObjects === !0 && _.sort(X, Z), this.info.render.frame++, ne === !0 && se.beginShadows();
      const nt = b.state.shadowsArray;
      if (Re.render(nt, ve, He), ne === !0 && se.endShadows(), this.info.autoReset === !0 && this.info.reset(), (tt.enabled === !1 || tt.isPresenting === !1 || tt.hasDepthSensing() === !1) && Oe.render(_, ve), b.setupLights($._useLegacyLights), He.isArrayCamera) {
        const dr = He.cameras;
        for (let dt = 0, ci = dr.length; dt < ci; dt++) {
          const Uo = dr[dt];
          Bp(_, ve, Uo, Uo.viewport);
        }
      } else
        Bp(_, ve, He);
      O !== null && (Ue.updateMultisampleRenderTarget(O), Ue.updateRenderTargetMipmap(O)), ve.isScene === !0 && ve.onAfterRender($, ve, He), Ke.resetDefaultState(), N = -1, j = null, A.pop(), A.length > 0 ? b = A[A.length - 1] : b = null, M.pop(), M.length > 0 ? _ = M[M.length - 1] : _ = null;
    };
    function ms(ve, He, nt, dr) {
      if (ve.visible === !1)
        return;
      if (ve.layers.test(He.layers)) {
        if (ve.isGroup)
          nt = ve.renderOrder;
        else if (ve.isLOD)
          ve.autoUpdate === !0 && ve.update(He);
        else if (ve.isLight)
          b.pushLight(ve), ve.castShadow && b.pushShadow(ve);
        else if (ve.isSprite) {
          if (!ve.frustumCulled || ie.intersectsSprite(ve)) {
            dr && de.setFromMatrixPosition(ve.matrixWorld).applyMatrix4(xe);
            const ci = Je.update(ve), Uo = ve.material;
            Uo.visible && _.push(ve, ci, Uo, nt, de.z, null);
          }
        } else if ((ve.isMesh || ve.isLine || ve.isPoints) && (!ve.frustumCulled || ie.intersectsObject(ve))) {
          const ci = Je.update(ve), Uo = ve.material;
          if (dr && (ve.boundingSphere !== void 0 ? (ve.boundingSphere === null && ve.computeBoundingSphere(), de.copy(ve.boundingSphere.center)) : (ci.boundingSphere === null && ci.computeBoundingSphere(), de.copy(ci.boundingSphere.center)), de.applyMatrix4(ve.matrixWorld).applyMatrix4(xe)), Array.isArray(Uo)) {
            const xs = ci.groups;
            for (let vs = 0, bp = xs.length; vs < bp; vs++) {
              const Ep = xs[vs], Ap = Uo[Ep.materialIndex];
              Ap && Ap.visible && _.push(ve, ci, Ap, nt, de.z, Ep);
            }
          } else
            Uo.visible && _.push(ve, ci, Uo, nt, de.z, null);
        }
      }
      const dt = ve.children;
      for (let ci = 0, Uo = dt.length; ci < Uo; ci++)
        ms(dt[ci], He, nt, dr);
    }
    function Bp(ve, He, nt, dr) {
      const dt = ve.opaque, ci = ve.transmissive, Uo = ve.transparent;
      b.setupLightsView(nt), ne === !0 && se.setGlobalState($.clippingPlanes, nt), ci.length > 0 && Sp(dt, ci, He, nt), dr && et.viewport(L.copy(dr)), dt.length > 0 && Tp(dt, He, nt), ci.length > 0 && Tp(ci, He, nt), Uo.length > 0 && Tp(Uo, He, nt), et.buffers.depth.setTest(!0), et.buffers.depth.setMask(!0), et.buffers.color.setMask(!0), et.setPolygonOffset(!1);
    }
    function Sp(ve, He, nt, dr) {
      if ((nt.isScene === !0 ? nt.overrideMaterial : null) !== null)
        return;
      const dt = Fe.isWebGL2;
      ye === null && (ye = new Cn(1, 1, {
        generateMipmaps: !0,
        type: be.has("EXT_color_buffer_half_float") ? _i : un,
        minFilter: An,
        samples: dt ? 4 : 0
      })), $.getDrawingBufferSize(we), dt ? ye.setSize(we.x, we.y) : ye.setSize(rr(we.x), rr(we.y));
      const ci = $.getRenderTarget();
      $.setRenderTarget(ye), $.getClearColor(B), F = $.getClearAlpha(), F < 1 && $.setClearColor(16777215, 0.5), $.clear();
      const Uo = $.toneMapping;
      $.toneMapping = cn, Tp(ve, nt, dr), Ue.updateMultisampleRenderTarget(ye), Ue.updateRenderTargetMipmap(ye);
      let xs = !1;
      for (let vs = 0, bp = He.length; vs < bp; vs++) {
        const Ep = He[vs], Ap = Ep.object, wp = Ep.geometry, jp = Ep.material, Vp = Ep.group;
        if (jp.side === jt && Ap.layers.test(dr.layers)) {
          const Qp = jp.side;
          jp.side = Et, jp.needsUpdate = !0, Pp(Ap, nt, dr, wp, jp, Vp), jp.side = Qp, jp.needsUpdate = !0, xs = !0;
        }
      }
      xs === !0 && (Ue.updateMultisampleRenderTarget(ye), Ue.updateRenderTargetMipmap(ye)), $.setRenderTarget(ci), $.setClearColor(B, F), $.toneMapping = Uo;
    }
    function Tp(ve, He, nt) {
      const dr = He.isScene === !0 ? He.overrideMaterial : null;
      for (let dt = 0, ci = ve.length; dt < ci; dt++) {
        const Uo = ve[dt], xs = Uo.object, vs = Uo.geometry, bp = dr === null ? Uo.material : dr, Ep = Uo.group;
        xs.layers.test(nt.layers) && Pp(xs, He, nt, vs, bp, Ep);
      }
    }
    function Pp(ve, He, nt, dr, dt, ci) {
      ve.onBeforeRender($, He, nt, dr, dt, ci), ve.modelViewMatrix.multiplyMatrices(nt.matrixWorldInverse, ve.matrixWorld), ve.normalMatrix.getNormalMatrix(ve.modelViewMatrix), dt.onBeforeRender($, He, nt, dr, ve, ci), dt.transparent === !0 && dt.side === jt && dt.forceSinglePass === !1 ? (dt.side = Et, dt.needsUpdate = !0, $.renderBufferDirect(nt, He, dr, dt, ve, ci), dt.side = hn, dt.needsUpdate = !0, $.renderBufferDirect(nt, He, dr, dt, ve, ci), dt.side = jt) : $.renderBufferDirect(nt, He, dr, dt, ve, ci), ve.onAfterRender($, He, nt, dr, dt, ci);
    }
    function Xe(ve, He, nt) {
      He.isScene !== !0 && (He = Te);
      const dr = De.get(ve), dt = b.state.lights, ci = b.state.shadowsArray, Uo = dt.state.version, xs = ft.getParameters(ve, dt.state, ci, He, nt), vs = ft.getProgramCacheKey(xs);
      let bp = dr.programs;
      dr.environment = ve.isMeshStandardMaterial ? He.environment : null, dr.fog = He.fog, dr.envMap = (ve.isMeshStandardMaterial ? ue : Qe).get(ve.envMap || dr.environment), dr.envMapRotation = dr.environment !== null && ve.envMap === null ? He.environmentRotation : ve.envMapRotation, bp === void 0 && (ve.addEventListener("dispose", K), bp = /* @__PURE__ */ new Map(), dr.programs = bp);
      let Ep = bp.get(vs);
      if (Ep !== void 0) {
        if (dr.currentProgram === Ep && dr.lightsStateVersion === Uo)
          return pr(ve, xs), Ep;
      } else
        xs.uniforms = ft.getUniforms(ve), ve.onBuild(nt, xs, $), ve.onBeforeCompile(xs, $), Ep = ft.acquireProgram(xs, vs), bp.set(vs, Ep), dr.uniforms = xs.uniforms;
      const Ap = dr.uniforms;
      return (!ve.isShaderMaterial && !ve.isRawShaderMaterial || ve.clipping === !0) && (Ap.clippingPlanes = se.uniform), pr(ve, xs), dr.needsLights = Io(ve), dr.lightsStateVersion = Uo, dr.needsLights && (Ap.ambientLightColor.value = dt.state.ambient, Ap.lightProbe.value = dt.state.probe, Ap.directionalLights.value = dt.state.directional, Ap.directionalLightShadows.value = dt.state.directionalShadow, Ap.spotLights.value = dt.state.spot, Ap.spotLightShadows.value = dt.state.spotShadow, Ap.rectAreaLights.value = dt.state.rectArea, Ap.ltc_1.value = dt.state.rectAreaLTC1, Ap.ltc_2.value = dt.state.rectAreaLTC2, Ap.pointLights.value = dt.state.point, Ap.pointLightShadows.value = dt.state.pointShadow, Ap.hemisphereLights.value = dt.state.hemi, Ap.directionalShadowMap.value = dt.state.directionalShadowMap, Ap.directionalShadowMatrix.value = dt.state.directionalShadowMatrix, Ap.spotShadowMap.value = dt.state.spotShadowMap, Ap.spotLightMatrix.value = dt.state.spotLightMatrix, Ap.spotLightMap.value = dt.state.spotLightMap, Ap.pointShadowMap.value = dt.state.pointShadowMap, Ap.pointShadowMatrix.value = dt.state.pointShadowMatrix), dr.currentProgram = Ep, dr.uniformsList = null, Ep;
    }
    function Se(ve) {
      if (ve.uniformsList === null) {
        const He = ve.currentProgram.getUniforms();
        ve.uniformsList = Ji.seqWithValue(He.seq, ve.uniforms);
      }
      return ve.uniformsList;
    }
    function pr(ve, He) {
      const nt = De.get(ve);
      nt.outputColorSpace = He.outputColorSpace, nt.batching = He.batching, nt.instancing = He.instancing, nt.instancingColor = He.instancingColor, nt.instancingMorph = He.instancingMorph, nt.skinning = He.skinning, nt.morphTargets = He.morphTargets, nt.morphNormals = He.morphNormals, nt.morphColors = He.morphColors, nt.morphTargetsCount = He.morphTargetsCount, nt.numClippingPlanes = He.numClippingPlanes, nt.numIntersection = He.numClipIntersection, nt.vertexAlphas = He.vertexAlphas, nt.vertexTangents = He.vertexTangents, nt.toneMapping = He.toneMapping;
    }
    function mn(ve, He, nt, dr, dt) {
      He.isScene !== !0 && (He = Te), Ue.resetTextureUnits();
      const ci = He.fog, Uo = dr.isMeshStandardMaterial ? He.environment : null, xs = O === null ? $.outputColorSpace : O.isXRRenderTarget === !0 ? O.texture.colorSpace : dn, vs = (dr.isMeshStandardMaterial ? ue : Qe).get(dr.envMap || Uo), bp = dr.vertexColors === !0 && !!nt.attributes.color && nt.attributes.color.itemSize === 4, Ep = !!nt.attributes.tangent && (!!dr.normalMap || dr.anisotropy > 0), Ap = !!nt.morphAttributes.position, wp = !!nt.morphAttributes.normal, jp = !!nt.morphAttributes.color;
      let Vp = cn;
      dr.toneMapped && (O === null || O.isXRRenderTarget === !0) && (Vp = $.toneMapping);
      const Qp = nt.morphAttributes.position || nt.morphAttributes.normal || nt.morphAttributes.color, zp = Qp !== void 0 ? Qp.length : 0, Mp = De.get(dr), fm = b.state.lights;
      if (ne === !0 && (ge === !0 || ve !== j)) {
        const qp = ve === j && dr.id === N;
        se.setState(dr, ve, qp);
      }
      let hm = !1;
      dr.version === Mp.__version ? (Mp.needsLights && Mp.lightsStateVersion !== fm.state.version || Mp.outputColorSpace !== xs || dt.isBatchedMesh && Mp.batching === !1 || !dt.isBatchedMesh && Mp.batching === !0 || dt.isInstancedMesh && Mp.instancing === !1 || !dt.isInstancedMesh && Mp.instancing === !0 || dt.isSkinnedMesh && Mp.skinning === !1 || !dt.isSkinnedMesh && Mp.skinning === !0 || dt.isInstancedMesh && Mp.instancingColor === !0 && dt.instanceColor === null || dt.isInstancedMesh && Mp.instancingColor === !1 && dt.instanceColor !== null || dt.isInstancedMesh && Mp.instancingMorph === !0 && dt.morphTexture === null || dt.isInstancedMesh && Mp.instancingMorph === !1 && dt.morphTexture !== null || Mp.envMap !== vs || dr.fog === !0 && Mp.fog !== ci || Mp.numClippingPlanes !== void 0 && (Mp.numClippingPlanes !== se.numPlanes || Mp.numIntersection !== se.numIntersection) || Mp.vertexAlphas !== bp || Mp.vertexTangents !== Ep || Mp.morphTargets !== Ap || Mp.morphNormals !== wp || Mp.morphColors !== jp || Mp.toneMapping !== Vp || Fe.isWebGL2 === !0 && Mp.morphTargetsCount !== zp) && (hm = !0) : (hm = !0, Mp.__version = dr.version);
      let rm = Mp.currentProgram;
      hm === !0 && (rm = Xe(dr, He, dt));
      let ym = !1, Jp = !1, om = !1;
      const Lp = rm.getUniforms(), Zp = Mp.uniforms;
      if (et.useProgram(rm.program) && (ym = !0, Jp = !0, om = !0), dr.id !== N && (N = dr.id, Jp = !0), ym || j !== ve) {
        Lp.setValue(ee, "projectionMatrix", ve.projectionMatrix), Lp.setValue(ee, "viewMatrix", ve.matrixWorldInverse);
        const qp = Lp.map.cameraPosition;
        qp !== void 0 && qp.setValue(ee, de.setFromMatrixPosition(ve.matrixWorld)), Fe.logarithmicDepthBuffer && Lp.setValue(
          ee,
          "logDepthBufFC",
          2 / (Math.log(ve.far + 1) / Math.LN2)
        ), (dr.isMeshPhongMaterial || dr.isMeshToonMaterial || dr.isMeshLambertMaterial || dr.isMeshBasicMaterial || dr.isMeshStandardMaterial || dr.isShaderMaterial) && Lp.setValue(ee, "isOrthographic", ve.isOrthographicCamera === !0), j !== ve && (j = ve, Jp = !0, om = !0);
      }
      if (dt.isSkinnedMesh) {
        Lp.setOptional(ee, dt, "bindMatrix"), Lp.setOptional(ee, dt, "bindMatrixInverse");
        const qp = dt.skeleton;
        qp && (Fe.floatVertexTextures ? (qp.boneTexture === null && qp.computeBoneTexture(), Lp.setValue(ee, "boneTexture", qp.boneTexture, Ue)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."));
      }
      dt.isBatchedMesh && (Lp.setOptional(ee, dt, "batchingTexture"), Lp.setValue(ee, "batchingTexture", dt._matricesTexture, Ue));
      const nm = nt.morphAttributes;
      if ((nm.position !== void 0 || nm.normal !== void 0 || nm.color !== void 0 && Fe.isWebGL2 === !0) && We.update(dt, nt, rm), (Jp || Mp.receiveShadow !== dt.receiveShadow) && (Mp.receiveShadow = dt.receiveShadow, Lp.setValue(ee, "receiveShadow", dt.receiveShadow)), dr.isMeshGouraudMaterial && dr.envMap !== null && (Zp.envMap.value = vs, Zp.flipEnvMap.value = vs.isCubeTexture && vs.isRenderTargetTexture === !1 ? -1 : 1), Jp && (Lp.setValue(ee, "toneMappingExposure", $.toneMappingExposure), Mp.needsLights && Si(Zp, om), ci && dr.fog === !0 && lt.refreshFogUniforms(Zp, ci), lt.refreshMaterialUniforms(Zp, dr, V, W, ye), Ji.upload(ee, Se(Mp), Zp, Ue)), dr.isShaderMaterial && dr.uniformsNeedUpdate === !0 && (Ji.upload(ee, Se(Mp), Zp, Ue), dr.uniformsNeedUpdate = !1), dr.isSpriteMaterial && Lp.setValue(ee, "center", dt.center), Lp.setValue(ee, "modelViewMatrix", dt.modelViewMatrix), Lp.setValue(ee, "normalMatrix", dt.normalMatrix), Lp.setValue(ee, "modelMatrix", dt.matrixWorld), dr.isShaderMaterial || dr.isRawShaderMaterial) {
        const qp = dr.uniformsGroups;
        for (let xm = 0, sm = qp.length; xm < sm; xm++)
          if (Fe.isWebGL2) {
            const wm = qp[xm];
            me.update(wm, rm), me.bind(wm, rm);
          } else
            console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.");
      }
      return rm;
    }
    function Si(ve, He) {
      ve.ambientLightColor.needsUpdate = He, ve.lightProbe.needsUpdate = He, ve.directionalLights.needsUpdate = He, ve.directionalLightShadows.needsUpdate = He, ve.pointLights.needsUpdate = He, ve.pointLightShadows.needsUpdate = He, ve.spotLights.needsUpdate = He, ve.spotLightShadows.needsUpdate = He, ve.rectAreaLights.needsUpdate = He, ve.hemisphereLights.needsUpdate = He;
    }
    function Io(ve) {
      return ve.isMeshLambertMaterial || ve.isMeshToonMaterial || ve.isMeshPhongMaterial || ve.isMeshStandardMaterial || ve.isShadowMaterial || ve.isShaderMaterial && ve.lights === !0;
    }
    this.getActiveCubeFace = function() {
      return C;
    }, this.getActiveMipmapLevel = function() {
      return D;
    }, this.getRenderTarget = function() {
      return O;
    }, this.setRenderTargetTextures = function(ve, He, nt) {
      De.get(ve.texture).__webglTexture = He, De.get(ve.depthTexture).__webglTexture = nt;
      const dr = De.get(ve);
      dr.__hasExternalTextures = !0, dr.__autoAllocateDepthBuffer = nt === void 0, dr.__autoAllocateDepthBuffer || be.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), dr.__useRenderToTexture = !1);
    }, this.setRenderTargetFramebuffer = function(ve, He) {
      const nt = De.get(ve);
      nt.__webglFramebuffer = He, nt.__useDefaultFramebuffer = He === void 0;
    }, this.setRenderTarget = function(ve, He = 0, nt = 0) {
      O = ve, C = He, D = nt;
      let dr = !0, dt = null, ci = !1, Uo = !1;
      if (ve) {
        const xs = De.get(ve);
        xs.__useDefaultFramebuffer !== void 0 ? (et.bindFramebuffer(ee.FRAMEBUFFER, null), dr = !1) : xs.__webglFramebuffer === void 0 ? Ue.setupRenderTarget(ve) : xs.__hasExternalTextures && Ue.rebindTextures(ve, De.get(ve.texture).__webglTexture, De.get(ve.depthTexture).__webglTexture);
        const vs = ve.texture;
        (vs.isData3DTexture || vs.isDataArrayTexture || vs.isCompressedArrayTexture) && (Uo = !0);
        const bp = De.get(ve).__webglFramebuffer;
        ve.isWebGLCubeRenderTarget ? (Array.isArray(bp[He]) ? dt = bp[He][nt] : dt = bp[He], ci = !0) : Fe.isWebGL2 && ve.samples > 0 && Ue.useMultisampledRTT(ve) === !1 ? dt = De.get(ve).__webglMultisampledFramebuffer : Array.isArray(bp) ? dt = bp[nt] : dt = bp, L.copy(ve.viewport), z.copy(ve.scissor), G = ve.scissorTest;
      } else
        L.copy(Q).multiplyScalar(V).floor(), z.copy(q).multiplyScalar(V).floor(), G = J;
      if (et.bindFramebuffer(ee.FRAMEBUFFER, dt) && Fe.drawBuffers && dr && et.drawBuffers(ve, dt), et.viewport(L), et.scissor(z), et.setScissorTest(G), ci) {
        const xs = De.get(ve.texture);
        ee.framebufferTexture2D(ee.FRAMEBUFFER, ee.COLOR_ATTACHMENT0, ee.TEXTURE_CUBE_MAP_POSITIVE_X + He, xs.__webglTexture, nt);
      } else if (Uo) {
        const xs = De.get(ve.texture), vs = He || 0;
        ee.framebufferTextureLayer(ee.FRAMEBUFFER, ee.COLOR_ATTACHMENT0, xs.__webglTexture, nt || 0, vs);
      }
      N = -1;
    }, this.readRenderTargetPixels = function(ve, He, nt, dr, dt, ci, Uo) {
      if (!(ve && ve.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let xs = De.get(ve).__webglFramebuffer;
      if (ve.isWebGLCubeRenderTarget && Uo !== void 0 && (xs = xs[Uo]), xs) {
        et.bindFramebuffer(ee.FRAMEBUFFER, xs);
        try {
          const vs = ve.texture, bp = vs.format, Ep = vs.type;
          if (bp !== Ft && ke.convert(bp) !== ee.getParameter(ee.IMPLEMENTATION_COLOR_READ_FORMAT)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          const Ap = Ep === _i && (be.has("EXT_color_buffer_half_float") || Fe.isWebGL2 && be.has("EXT_color_buffer_float"));
          if (Ep !== un && ke.convert(Ep) !== ee.getParameter(ee.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
          !(Ep === Kt && (Fe.isWebGL2 || be.has("OES_texture_float") || be.has("WEBGL_color_buffer_float"))) && // Chrome Mac >= 52 and Firefox
          !Ap) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          He >= 0 && He <= ve.width - dr && nt >= 0 && nt <= ve.height - dt && ee.readPixels(He, nt, dr, dt, ke.convert(bp), ke.convert(Ep), ci);
        } finally {
          const vs = O !== null ? De.get(O).__webglFramebuffer : null;
          et.bindFramebuffer(ee.FRAMEBUFFER, vs);
        }
      }
    }, this.copyFramebufferToTexture = function(ve, He, nt = 0) {
      const dr = Math.pow(2, -nt), dt = Math.floor(He.image.width * dr), ci = Math.floor(He.image.height * dr);
      Ue.setTexture2D(He, 0), ee.copyTexSubImage2D(ee.TEXTURE_2D, nt, 0, 0, ve.x, ve.y, dt, ci), et.unbindTexture();
    }, this.copyTextureToTexture = function(ve, He, nt, dr = 0) {
      const dt = He.image.width, ci = He.image.height, Uo = ke.convert(nt.format), xs = ke.convert(nt.type);
      Ue.setTexture2D(nt, 0), ee.pixelStorei(ee.UNPACK_FLIP_Y_WEBGL, nt.flipY), ee.pixelStorei(ee.UNPACK_PREMULTIPLY_ALPHA_WEBGL, nt.premultiplyAlpha), ee.pixelStorei(ee.UNPACK_ALIGNMENT, nt.unpackAlignment), He.isDataTexture ? ee.texSubImage2D(ee.TEXTURE_2D, dr, ve.x, ve.y, dt, ci, Uo, xs, He.image.data) : He.isCompressedTexture ? ee.compressedTexSubImage2D(ee.TEXTURE_2D, dr, ve.x, ve.y, He.mipmaps[0].width, He.mipmaps[0].height, Uo, He.mipmaps[0].data) : ee.texSubImage2D(ee.TEXTURE_2D, dr, ve.x, ve.y, Uo, xs, He.image), dr === 0 && nt.generateMipmaps && ee.generateMipmap(ee.TEXTURE_2D), et.unbindTexture();
    }, this.copyTextureToTexture3D = function(ve, He, nt, dr, dt = 0) {
      if ($.isWebGL1Renderer) {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
        return;
      }
      const ci = Math.round(ve.max.x - ve.min.x), Uo = Math.round(ve.max.y - ve.min.y), xs = ve.max.z - ve.min.z + 1, vs = ke.convert(dr.format), bp = ke.convert(dr.type);
      let Ep;
      if (dr.isData3DTexture)
        Ue.setTexture3D(dr, 0), Ep = ee.TEXTURE_3D;
      else if (dr.isDataArrayTexture || dr.isCompressedArrayTexture)
        Ue.setTexture2DArray(dr, 0), Ep = ee.TEXTURE_2D_ARRAY;
      else {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
        return;
      }
      ee.pixelStorei(ee.UNPACK_FLIP_Y_WEBGL, dr.flipY), ee.pixelStorei(ee.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dr.premultiplyAlpha), ee.pixelStorei(ee.UNPACK_ALIGNMENT, dr.unpackAlignment);
      const Ap = ee.getParameter(ee.UNPACK_ROW_LENGTH), wp = ee.getParameter(ee.UNPACK_IMAGE_HEIGHT), jp = ee.getParameter(ee.UNPACK_SKIP_PIXELS), Vp = ee.getParameter(ee.UNPACK_SKIP_ROWS), Qp = ee.getParameter(ee.UNPACK_SKIP_IMAGES), zp = nt.isCompressedTexture ? nt.mipmaps[dt] : nt.image;
      ee.pixelStorei(ee.UNPACK_ROW_LENGTH, zp.width), ee.pixelStorei(ee.UNPACK_IMAGE_HEIGHT, zp.height), ee.pixelStorei(ee.UNPACK_SKIP_PIXELS, ve.min.x), ee.pixelStorei(ee.UNPACK_SKIP_ROWS, ve.min.y), ee.pixelStorei(ee.UNPACK_SKIP_IMAGES, ve.min.z), nt.isDataTexture || nt.isData3DTexture ? ee.texSubImage3D(Ep, dt, He.x, He.y, He.z, ci, Uo, xs, vs, bp, zp.data) : dr.isCompressedArrayTexture ? ee.compressedTexSubImage3D(Ep, dt, He.x, He.y, He.z, ci, Uo, xs, vs, zp.data) : ee.texSubImage3D(Ep, dt, He.x, He.y, He.z, ci, Uo, xs, vs, bp, zp), ee.pixelStorei(ee.UNPACK_ROW_LENGTH, Ap), ee.pixelStorei(ee.UNPACK_IMAGE_HEIGHT, wp), ee.pixelStorei(ee.UNPACK_SKIP_PIXELS, jp), ee.pixelStorei(ee.UNPACK_SKIP_ROWS, Vp), ee.pixelStorei(ee.UNPACK_SKIP_IMAGES, Qp), dt === 0 && dr.generateMipmaps && ee.generateMipmap(Ep), et.unbindTexture();
    }, this.initTexture = function(ve) {
      ve.isCubeTexture ? Ue.setTextureCube(ve, 0) : ve.isData3DTexture ? Ue.setTexture3D(ve, 0) : ve.isDataArrayTexture || ve.isCompressedArrayTexture ? Ue.setTexture2DArray(ve, 0) : Ue.setTexture2D(ve, 0), et.unbindTexture();
    }, this.resetState = function() {
      C = 0, D = 0, O = null, et.reset(), Ke.reset();
    }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  get coordinateSystem() {
    return Zt;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const n = this.getContext();
    n.drawingBufferColorSpace = e === cs ? "display-p3" : "srgb", n.unpackColorSpace = je.workingColorSpace === cr ? "display-p3" : "srgb";
  }
  get useLegacyLights() {
    return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights;
  }
  set useLegacyLights(e) {
    console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights = e;
  }
}
class up extends Po {
}
up.prototype.isWebGL1Renderer = !0;
class hp extends Mt {
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new $t(), this.environmentRotation = new $t(), this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e, n) {
    return super.copy(e, n), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentRotation.copy(e.environmentRotation), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return this.fog !== null && (n.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (n.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (n.object.backgroundIntensity = this.backgroundIntensity), n.object.backgroundRotation = this.backgroundRotation.toArray(), n.object.environmentRotation = this.environmentRotation.toArray(), n;
  }
}
class ar extends xi {
  constructor(e) {
    super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new qe(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
  }
}
const Va = /* @__PURE__ */ new I(), ka$1 = /* @__PURE__ */ new I(), Wa = /* @__PURE__ */ new st(), jr = /* @__PURE__ */ new hs(), Yi = /* @__PURE__ */ new ur();
class ds extends Mt {
  constructor(e = new Tt(), n = new ar()) {
    super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = n, this.updateMorphTargets();
  }
  copy(e, n) {
    return super.copy(e, n), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const n = e.attributes.position, o = [0];
      for (let l = 1, u = n.count; l < u; l++)
        Va.fromBufferAttribute(n, l - 1), ka$1.fromBufferAttribute(n, l), o[l] = o[l - 1], o[l] += Va.distanceTo(ka$1);
      e.setAttribute("lineDistance", new ut(o, 1));
    } else
      console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
  raycast(e, n) {
    const o = this.geometry, l = this.matrixWorld, u = e.params.Line.threshold, f = o.drawRange;
    if (o.boundingSphere === null && o.computeBoundingSphere(), Yi.copy(o.boundingSphere), Yi.applyMatrix4(l), Yi.radius += u, e.ray.intersectsSphere(Yi) === !1)
      return;
    Wa.copy(l).invert(), jr.copy(e.ray).applyMatrix4(Wa);
    const h = u / ((this.scale.x + this.scale.y + this.scale.z) / 3), p = h * h, v = new I(), g = new I(), w = new I(), E = new I(), T = this.isLineSegments ? 2 : 1, R = o.index, _ = o.attributes.position;
    if (R !== null) {
      const b = Math.max(0, f.start), M = Math.min(R.count, f.start + f.count);
      for (let A = b, $ = M - 1; A < $; A += T) {
        const S = R.getX(A), C = R.getX(A + 1);
        if (v.fromBufferAttribute(_, S), g.fromBufferAttribute(_, C), jr.distanceSqToSegment(v, g, E, w) > p)
          continue;
        E.applyMatrix4(this.matrixWorld);
        const D = e.ray.origin.distanceTo(E);
        D < e.near || D > e.far || n.push({
          distance: D,
          // What do we want? intersection point on the ray or on the segment??
          // point: raycaster.ray.at( distance ),
          point: w.clone().applyMatrix4(this.matrixWorld),
          index: A,
          face: null,
          faceIndex: null,
          object: this
        });
      }
    } else {
      const b = Math.max(0, f.start), M = Math.min(_.count, f.start + f.count);
      for (let A = b, $ = M - 1; A < $; A += T) {
        if (v.fromBufferAttribute(_, A), g.fromBufferAttribute(_, A + 1), jr.distanceSqToSegment(v, g, E, w) > p)
          continue;
        E.applyMatrix4(this.matrixWorld);
        const S = e.ray.origin.distanceTo(E);
        S < e.near || S > e.far || n.push({
          distance: S,
          // What do we want? intersection point on the ray or on the segment??
          // point: raycaster.ray.at( distance ),
          point: w.clone().applyMatrix4(this.matrixWorld),
          index: A,
          face: null,
          faceIndex: null,
          object: this
        });
      }
    }
  }
  updateMorphTargets() {
    const e = this.geometry.morphAttributes, n = Object.keys(e);
    if (n.length > 0) {
      const o = e[n[0]];
      if (o !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let l = 0, u = o.length; l < u; l++) {
          const f = o[l].name || String(l);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[f] = l;
        }
      }
    }
  }
}
const Xa = /* @__PURE__ */ new I(), Ya = /* @__PURE__ */ new I();
class fp extends ds {
  constructor(e, n) {
    super(e, n), this.isLineSegments = !0, this.type = "LineSegments";
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const n = e.attributes.position, o = [];
      for (let l = 0, u = n.count; l < u; l += 2)
        Xa.fromBufferAttribute(n, l), Ya.fromBufferAttribute(n, l + 1), o[l] = l === 0 ? 0 : o[l - 1], o[l + 1] = o[l] + Xa.distanceTo(Ya);
      e.setAttribute("lineDistance", new ut(o, 1));
    } else
      console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
}
class ps extends Tt {
  constructor(e = 1, n = 1, o = 1, l = 32, u = 1, f = !1, h = 0, p = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: e,
      radiusBottom: n,
      height: o,
      radialSegments: l,
      heightSegments: u,
      openEnded: f,
      thetaStart: h,
      thetaLength: p
    };
    const v = this;
    l = Math.floor(l), u = Math.floor(u);
    const g = [], w = [], E = [], T = [];
    let R = 0;
    const _ = [], b = o / 2;
    let M = 0;
    A(), f === !1 && (e > 0 && $(!0), n > 0 && $(!1)), this.setIndex(g), this.setAttribute("position", new ut(w, 3)), this.setAttribute("normal", new ut(E, 3)), this.setAttribute("uv", new ut(T, 2));
    function A() {
      const S = new I(), C = new I();
      let D = 0;
      const O = (n - e) / o;
      for (let N = 0; N <= u; N++) {
        const j = [], L = N / u, z = L * (n - e) + e;
        for (let G = 0; G <= l; G++) {
          const B = G / l, F = B * p + h, H = Math.sin(F), W = Math.cos(F);
          C.x = z * H, C.y = -L * o + b, C.z = z * W, w.push(C.x, C.y, C.z), S.set(H, O, W).normalize(), E.push(S.x, S.y, S.z), T.push(B, 1 - L), j.push(R++);
        }
        _.push(j);
      }
      for (let N = 0; N < l; N++)
        for (let j = 0; j < u; j++) {
          const L = _[j][N], z = _[j + 1][N], G = _[j + 1][N + 1], B = _[j][N + 1];
          g.push(L, z, B), g.push(z, G, B), D += 6;
        }
      v.addGroup(M, D, 0), M += D;
    }
    function $(S) {
      const C = R, D = new Ie(), O = new I();
      let N = 0;
      const j = S === !0 ? e : n, L = S === !0 ? 1 : -1;
      for (let G = 1; G <= l; G++)
        w.push(0, b * L, 0), E.push(0, L, 0), T.push(0.5, 0.5), R++;
      const z = R;
      for (let G = 0; G <= l; G++) {
        const B = G / l * p + h, F = Math.cos(B), H = Math.sin(B);
        O.x = j * H, O.y = b * L, O.z = j * F, w.push(O.x, O.y, O.z), E.push(0, L, 0), D.x = F * 0.5 + 0.5, D.y = H * 0.5 * L + 0.5, T.push(D.x, D.y), R++;
      }
      for (let G = 0; G < l; G++) {
        const B = C + G, F = z + G;
        S === !0 ? g.push(F, F + 1, B) : g.push(F + 1, F, B), N += 3;
      }
      v.addGroup(M, N, S === !0 ? 1 : 2), M += N;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new ps(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
const qi = /* @__PURE__ */ new I(), ji = /* @__PURE__ */ new I(), Kr = /* @__PURE__ */ new I(), Ki = /* @__PURE__ */ new Ot();
class dp extends Tt {
  constructor(e = null, n = 1) {
    if (super(), this.type = "EdgesGeometry", this.parameters = {
      geometry: e,
      thresholdAngle: n
    }, e !== null) {
      const o = Math.pow(10, 4), l = Math.cos(ei * n), u = e.getIndex(), f = e.getAttribute("position"), h = u ? u.count : f.count, p = [0, 0, 0], v = ["a", "b", "c"], g = new Array(3), w = {}, E = [];
      for (let T = 0; T < h; T += 3) {
        u ? (p[0] = u.getX(T), p[1] = u.getX(T + 1), p[2] = u.getX(T + 2)) : (p[0] = T, p[1] = T + 1, p[2] = T + 2);
        const { a: R, b: _, c: b } = Ki;
        if (R.fromBufferAttribute(f, p[0]), _.fromBufferAttribute(f, p[1]), b.fromBufferAttribute(f, p[2]), Ki.getNormal(Kr), g[0] = `${Math.round(R.x * o)},${Math.round(R.y * o)},${Math.round(R.z * o)}`, g[1] = `${Math.round(_.x * o)},${Math.round(_.y * o)},${Math.round(_.z * o)}`, g[2] = `${Math.round(b.x * o)},${Math.round(b.y * o)},${Math.round(b.z * o)}`, !(g[0] === g[1] || g[1] === g[2] || g[2] === g[0]))
          for (let M = 0; M < 3; M++) {
            const A = (M + 1) % 3, $ = g[M], S = g[A], C = Ki[v[M]], D = Ki[v[A]], O = `${$}_${S}`, N = `${S}_${$}`;
            N in w && w[N] ? (Kr.dot(w[N].normal) <= l && (E.push(C.x, C.y, C.z), E.push(D.x, D.y, D.z)), w[N] = null) : O in w || (w[O] = {
              index0: p[M],
              index1: p[A],
              normal: Kr.clone()
            });
          }
      }
      for (const T in w)
        if (w[T]) {
          const { index0: R, index1: _ } = w[T];
          qi.fromBufferAttribute(f, R), ji.fromBufferAttribute(f, _), E.push(qi.x, qi.y, qi.z), E.push(ji.x, ji.y, ji.z);
        }
      this.setAttribute("position", new ut(E, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
class or extends Tt {
  constructor(e = 1, n = 32, o = 16, l = 0, u = Math.PI * 2, f = 0, h = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: e,
      widthSegments: n,
      heightSegments: o,
      phiStart: l,
      phiLength: u,
      thetaStart: f,
      thetaLength: h
    }, n = Math.max(3, Math.floor(n)), o = Math.max(2, Math.floor(o));
    const p = Math.min(f + h, Math.PI);
    let v = 0;
    const g = [], w = new I(), E = new I(), T = [], R = [], _ = [], b = [];
    for (let M = 0; M <= o; M++) {
      const A = [], $ = M / o;
      let S = 0;
      M === 0 && f === 0 ? S = 0.5 / n : M === o && p === Math.PI && (S = -0.5 / n);
      for (let C = 0; C <= n; C++) {
        const D = C / n;
        w.x = -e * Math.cos(l + D * u) * Math.sin(f + $ * h), w.y = e * Math.cos(f + $ * h), w.z = e * Math.sin(l + D * u) * Math.sin(f + $ * h), R.push(w.x, w.y, w.z), E.copy(w).normalize(), _.push(E.x, E.y, E.z), b.push(D + S, 1 - $), A.push(v++);
      }
      g.push(A);
    }
    for (let M = 0; M < o; M++)
      for (let A = 0; A < n; A++) {
        const $ = g[M][A + 1], S = g[M][A], C = g[M + 1][A], D = g[M + 1][A + 1];
        (M !== 0 || f > 0) && T.push($, S, D), (M !== o - 1 || p < Math.PI) && T.push(S, C, D);
      }
    this.setIndex(T), this.setAttribute("position", new ut(R, 3)), this.setAttribute("normal", new ut(_, 3)), this.setAttribute("uv", new ut(b, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new or(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
}
class qa {
  constructor(e = 1, n = 0, o = 0) {
    return this.radius = e, this.phi = n, this.theta = o, this;
  }
  set(e, n, o) {
    return this.radius = e, this.phi = n, this.theta = o, this;
  }
  copy(e) {
    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
  }
  // restrict phi to be between EPS and PI-EPS
  makeSafe() {
    return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, n, o) {
    return this.radius = Math.sqrt(e * e + n * n + o * o), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, o), this.phi = Math.acos(_t(n / this.radius, -1, 1))), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const ja = /* @__PURE__ */ new I();
let Zi, Zr;
class Ka extends Mt {
  // dir is assumed to be normalized
  constructor(e = new I(0, 0, 1), n = new I(0, 0, 0), o = 1, l = 16776960, u = o * 0.2, f = u * 0.2) {
    super(), this.type = "ArrowHelper", Zi === void 0 && (Zi = new Tt(), Zi.setAttribute("position", new ut([0, 0, 0, 0, 1, 0], 3)), Zr = new ps(0, 0.5, 1, 5, 1), Zr.translate(0, -0.5, 0)), this.position.copy(n), this.line = new ds(Zi, new ar({ color: l, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Rt(Zr, new ni({ color: l, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(o, u, f);
  }
  setDirection(e) {
    if (e.y > 0.99999)
      this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999)
      this.quaternion.set(1, 0, 0, 0);
    else {
      ja.set(e.z, 0, -e.x).normalize();
      const n = Math.acos(e.y);
      this.quaternion.setFromAxisAngle(ja, n);
    }
  }
  setLength(e, n = e * 0.2, o = n * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - n), 1), this.line.updateMatrix(), this.cone.scale.set(o, n, o), this.cone.position.y = e, this.cone.updateMatrix();
  }
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e);
  }
  copy(e) {
    return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this;
  }
  dispose() {
    this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose();
  }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: os
} }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = os);
const Za = { type: "change" }, $r = { type: "start" }, $a = { type: "end" }, $i = new hs(), Ja = new sn(), pp = Math.cos(70 * Kl.DEG2RAD);
class mp extends Ln {
  constructor(e, n) {
    super(), this.object = e, this.domElement = n, this.domElement.style.touchAction = "none", this.enabled = !0, this.target = new I(), this.cursor = new I(), this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minTargetRadius = 0, this.maxTargetRadius = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = 0.05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.zoomToCursor = !1, this.autoRotate = !1, this.autoRotateSpeed = 2, this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }, this.mouseButtons = { LEFT: Dn.ROTATE, MIDDLE: Dn.DOLLY, RIGHT: Dn.PAN }, this.touches = { ONE: Un.ROTATE, TWO: Un.DOLLY_PAN }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this.getPolarAngle = function() {
      return h.phi;
    }, this.getAzimuthalAngle = function() {
      return h.theta;
    }, this.getDistance = function() {
      return this.object.position.distanceTo(this.target);
    }, this.listenToKeyEvents = function(me) {
      me.addEventListener("keydown", ae), this._domElementKeyEvents = me;
    }, this.stopListenToKeyEvents = function() {
      this._domElementKeyEvents.removeEventListener("keydown", ae), this._domElementKeyEvents = null;
    }, this.saveState = function() {
      o.target0.copy(o.target), o.position0.copy(o.object.position), o.zoom0 = o.object.zoom;
    }, this.reset = function() {
      o.target.copy(o.target0), o.object.position.copy(o.position0), o.object.zoom = o.zoom0, o.object.updateProjectionMatrix(), o.dispatchEvent(Za), o.update(), u = l.NONE;
    }, this.update = function() {
      const me = new I(), Ee = new Pn().setFromUnitVectors(e.up, new I(0, 1, 0)), tt = Ee.clone().invert(), ce = new I(), _e = new Pn(), Ht = new I(), K = 2 * Math.PI;
      return function(Ve = null) {
        const Ne = o.object.position;
        me.copy(Ne).sub(o.target), me.applyQuaternion(Ee), h.setFromVector3(me), o.autoRotate && u === l.NONE && G(L(Ve)), o.enableDamping ? (h.theta += p.theta * o.dampingFactor, h.phi += p.phi * o.dampingFactor) : (h.theta += p.theta, h.phi += p.phi);
        let pe = o.minAzimuthAngle, Le = o.maxAzimuthAngle;
        isFinite(pe) && isFinite(Le) && (pe < -Math.PI ? pe += K : pe > Math.PI && (pe -= K), Le < -Math.PI ? Le += K : Le > Math.PI && (Le -= K), pe <= Le ? h.theta = Math.max(pe, Math.min(Le, h.theta)) : h.theta = h.theta > (pe + Le) / 2 ? Math.max(pe, h.theta) : Math.min(Le, h.theta)), h.phi = Math.max(o.minPolarAngle, Math.min(o.maxPolarAngle, h.phi)), h.makeSafe(), o.enableDamping === !0 ? o.target.addScaledVector(g, o.dampingFactor) : o.target.add(g), o.target.sub(o.cursor), o.target.clampLength(o.minTargetRadius, o.maxTargetRadius), o.target.add(o.cursor);
        let bt = !1;
        if (o.zoomToCursor && D || o.object.isOrthographicCamera)
          h.radius = Q(h.radius);
        else {
          const yi = h.radius;
          h.radius = Q(h.radius * v), bt = yi != h.radius;
        }
        if (me.setFromSpherical(h), me.applyQuaternion(tt), Ne.copy(o.target).add(me), o.object.lookAt(o.target), o.enableDamping === !0 ? (p.theta *= 1 - o.dampingFactor, p.phi *= 1 - o.dampingFactor, g.multiplyScalar(1 - o.dampingFactor)) : (p.set(0, 0, 0), g.set(0, 0, 0)), o.zoomToCursor && D) {
          let yi = null;
          if (o.object.isPerspectiveCamera) {
            const _n = me.length();
            yi = Q(_n * v);
            const Do = _n - yi;
            o.object.position.addScaledVector(S, Do), o.object.updateMatrixWorld(), bt = !!Do;
          } else if (o.object.isOrthographicCamera) {
            const _n = new I(C.x, C.y, 0);
            _n.unproject(o.object);
            const Do = o.object.zoom;
            o.object.zoom = Math.max(o.minZoom, Math.min(o.maxZoom, o.object.zoom / v)), o.object.updateProjectionMatrix(), bt = Do !== o.object.zoom;
            const ms = new I(C.x, C.y, 0);
            ms.unproject(o.object), o.object.position.sub(ms).add(_n), o.object.updateMatrixWorld(), yi = me.length();
          } else
            console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), o.zoomToCursor = !1;
          yi !== null && (this.screenSpacePanning ? o.target.set(0, 0, -1).transformDirection(o.object.matrix).multiplyScalar(yi).add(o.object.position) : ($i.origin.copy(o.object.position), $i.direction.set(0, 0, -1).transformDirection(o.object.matrix), Math.abs(o.object.up.dot($i.direction)) < pp ? e.lookAt(o.target) : (Ja.setFromNormalAndCoplanarPoint(o.object.up, o.target), $i.intersectPlane(Ja, o.target))));
        } else if (o.object.isOrthographicCamera) {
          const yi = o.object.zoom;
          o.object.zoom = Math.max(o.minZoom, Math.min(o.maxZoom, o.object.zoom / v)), yi !== o.object.zoom && (o.object.updateProjectionMatrix(), bt = !0);
        }
        return v = 1, D = !1, bt || ce.distanceToSquared(o.object.position) > f || 8 * (1 - _e.dot(o.object.quaternion)) > f || Ht.distanceToSquared(o.target) > f ? (o.dispatchEvent(Za), ce.copy(o.object.position), _e.copy(o.object.quaternion), Ht.copy(o.target), !0) : !1;
      };
    }(), this.dispose = function() {
      o.domElement.removeEventListener("contextmenu", Oe), o.domElement.removeEventListener("pointerdown", Ue), o.domElement.removeEventListener("pointercancel", ue), o.domElement.removeEventListener("wheel", Je), o.domElement.removeEventListener("pointermove", Qe), o.domElement.removeEventListener("pointerup", ue), o.domElement.getRootNode().removeEventListener("keydown", lt, { capture: !0 }), o._domElementKeyEvents !== null && (o._domElementKeyEvents.removeEventListener("keydown", ae), o._domElementKeyEvents = null);
    };
    const o = this, l = {
      NONE: -1,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_PAN: 4,
      TOUCH_DOLLY_PAN: 5,
      TOUCH_DOLLY_ROTATE: 6
    };
    let u = l.NONE;
    const f = 1e-6, h = new qa(), p = new qa();
    let v = 1;
    const g = new I(), w = new Ie(), E = new Ie(), T = new Ie(), R = new Ie(), _ = new Ie(), b = new Ie(), M = new Ie(), A = new Ie(), $ = new Ie(), S = new I(), C = new Ie();
    let D = !1;
    const O = [], N = {};
    let j = !1;
    function L(me) {
      return me !== null ? 2 * Math.PI / 60 * o.autoRotateSpeed * me : 2 * Math.PI / 60 / 60 * o.autoRotateSpeed;
    }
    function z(me) {
      const Ee = Math.abs(me * 0.01);
      return Math.pow(0.95, o.zoomSpeed * Ee);
    }
    function G(me) {
      p.theta -= me;
    }
    function B(me) {
      p.phi -= me;
    }
    const F = function() {
      const me = new I();
      return function(Ee, tt) {
        me.setFromMatrixColumn(tt, 0), me.multiplyScalar(-Ee), g.add(me);
      };
    }(), H = function() {
      const me = new I();
      return function(Ee, tt) {
        o.screenSpacePanning === !0 ? me.setFromMatrixColumn(tt, 1) : (me.setFromMatrixColumn(tt, 0), me.crossVectors(o.object.up, me)), me.multiplyScalar(Ee), g.add(me);
      };
    }(), W = function() {
      const me = new I();
      return function(Ee, tt) {
        const ce = o.domElement;
        if (o.object.isPerspectiveCamera) {
          const _e = o.object.position;
          me.copy(_e).sub(o.target);
          let Ht = me.length();
          Ht *= Math.tan(o.object.fov / 2 * Math.PI / 180), F(2 * Ee * Ht / ce.clientHeight, o.object.matrix), H(2 * tt * Ht / ce.clientHeight, o.object.matrix);
        } else
          o.object.isOrthographicCamera ? (F(Ee * (o.object.right - o.object.left) / o.object.zoom / ce.clientWidth, o.object.matrix), H(tt * (o.object.top - o.object.bottom) / o.object.zoom / ce.clientHeight, o.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), o.enablePan = !1);
      };
    }();
    function V(me) {
      o.object.isPerspectiveCamera || o.object.isOrthographicCamera ? v /= me : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), o.enableZoom = !1);
    }
    function X(me) {
      o.object.isPerspectiveCamera || o.object.isOrthographicCamera ? v *= me : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), o.enableZoom = !1);
    }
    function Z(me, Ee) {
      if (!o.zoomToCursor)
        return;
      D = !0;
      const tt = o.domElement.getBoundingClientRect(), ce = me - tt.left, _e = Ee - tt.top, Ht = tt.width, K = tt.height;
      C.x = ce / Ht * 2 - 1, C.y = -(_e / K) * 2 + 1, S.set(C.x, C.y, 1).unproject(o.object).sub(o.object.position).normalize();
    }
    function Q(me) {
      return Math.max(o.minDistance, Math.min(o.maxDistance, me));
    }
    function q(me) {
      w.set(me.clientX, me.clientY);
    }
    function J(me) {
      Z(me.clientX, me.clientX), M.set(me.clientX, me.clientY);
    }
    function ie(me) {
      R.set(me.clientX, me.clientY);
    }
    function ne(me) {
      E.set(me.clientX, me.clientY), T.subVectors(E, w).multiplyScalar(o.rotateSpeed);
      const Ee = o.domElement;
      G(2 * Math.PI * T.x / Ee.clientHeight), B(2 * Math.PI * T.y / Ee.clientHeight), w.copy(E), o.update();
    }
    function ge(me) {
      A.set(me.clientX, me.clientY), $.subVectors(A, M), $.y > 0 ? V(z($.y)) : $.y < 0 && X(z($.y)), M.copy(A), o.update();
    }
    function ye(me) {
      _.set(me.clientX, me.clientY), b.subVectors(_, R).multiplyScalar(o.panSpeed), W(b.x, b.y), R.copy(_), o.update();
    }
    function xe(me) {
      Z(me.clientX, me.clientY), me.deltaY < 0 ? X(z(me.deltaY)) : me.deltaY > 0 && V(z(me.deltaY)), o.update();
    }
    function we(me) {
      let Ee = !1;
      switch (me.code) {
        case o.keys.UP:
          me.ctrlKey || me.metaKey || me.shiftKey ? B(2 * Math.PI * o.rotateSpeed / o.domElement.clientHeight) : W(0, o.keyPanSpeed), Ee = !0;
          break;
        case o.keys.BOTTOM:
          me.ctrlKey || me.metaKey || me.shiftKey ? B(-2 * Math.PI * o.rotateSpeed / o.domElement.clientHeight) : W(0, -o.keyPanSpeed), Ee = !0;
          break;
        case o.keys.LEFT:
          me.ctrlKey || me.metaKey || me.shiftKey ? G(2 * Math.PI * o.rotateSpeed / o.domElement.clientHeight) : W(o.keyPanSpeed, 0), Ee = !0;
          break;
        case o.keys.RIGHT:
          me.ctrlKey || me.metaKey || me.shiftKey ? G(-2 * Math.PI * o.rotateSpeed / o.domElement.clientHeight) : W(-o.keyPanSpeed, 0), Ee = !0;
          break;
      }
      Ee && (me.preventDefault(), o.update());
    }
    function de(me) {
      if (O.length === 1)
        w.set(me.pageX, me.pageY);
      else {
        const Ee = Ke(me), tt = 0.5 * (me.pageX + Ee.x), ce = 0.5 * (me.pageY + Ee.y);
        w.set(tt, ce);
      }
    }
    function Te(me) {
      if (O.length === 1)
        R.set(me.pageX, me.pageY);
      else {
        const Ee = Ke(me), tt = 0.5 * (me.pageX + Ee.x), ce = 0.5 * (me.pageY + Ee.y);
        R.set(tt, ce);
      }
    }
    function Ce(me) {
      const Ee = Ke(me), tt = me.pageX - Ee.x, ce = me.pageY - Ee.y, _e = Math.sqrt(tt * tt + ce * ce);
      M.set(0, _e);
    }
    function ee(me) {
      o.enableZoom && Ce(me), o.enablePan && Te(me);
    }
    function Ae(me) {
      o.enableZoom && Ce(me), o.enableRotate && de(me);
    }
    function be(me) {
      if (O.length == 1)
        E.set(me.pageX, me.pageY);
      else {
        const tt = Ke(me), ce = 0.5 * (me.pageX + tt.x), _e = 0.5 * (me.pageY + tt.y);
        E.set(ce, _e);
      }
      T.subVectors(E, w).multiplyScalar(o.rotateSpeed);
      const Ee = o.domElement;
      G(2 * Math.PI * T.x / Ee.clientHeight), B(2 * Math.PI * T.y / Ee.clientHeight), w.copy(E);
    }
    function Fe(me) {
      if (O.length === 1)
        _.set(me.pageX, me.pageY);
      else {
        const Ee = Ke(me), tt = 0.5 * (me.pageX + Ee.x), ce = 0.5 * (me.pageY + Ee.y);
        _.set(tt, ce);
      }
      b.subVectors(_, R).multiplyScalar(o.panSpeed), W(b.x, b.y), R.copy(_);
    }
    function et(me) {
      const Ee = Ke(me), tt = me.pageX - Ee.x, ce = me.pageY - Ee.y, _e = Math.sqrt(tt * tt + ce * ce);
      A.set(0, _e), $.set(0, Math.pow(A.y / M.y, o.zoomSpeed)), V($.y), M.copy(A);
      const Ht = (me.pageX + Ee.x) * 0.5, K = (me.pageY + Ee.y) * 0.5;
      Z(Ht, K);
    }
    function Ye(me) {
      o.enableZoom && et(me), o.enablePan && Fe(me);
    }
    function De(me) {
      o.enableZoom && et(me), o.enableRotate && be(me);
    }
    function Ue(me) {
      o.enabled !== !1 && (O.length === 0 && (o.domElement.setPointerCapture(me.pointerId), o.domElement.addEventListener("pointermove", Qe), o.domElement.addEventListener("pointerup", ue)), !le(me) && (We(me), me.pointerType === "touch" ? se(me) : te(me)));
    }
    function Qe(me) {
      o.enabled !== !1 && (me.pointerType === "touch" ? Re(me) : Be(me));
    }
    function ue(me) {
      switch (Ct(me), O.length) {
        case 0:
          o.domElement.releasePointerCapture(me.pointerId), o.domElement.removeEventListener("pointermove", Qe), o.domElement.removeEventListener("pointerup", ue), o.dispatchEvent($a), u = l.NONE;
          break;
        case 1:
          const Ee = O[0], tt = N[Ee];
          se({ pointerId: Ee, pageX: tt.x, pageY: tt.y });
          break;
      }
    }
    function te(me) {
      let Ee;
      switch (me.button) {
        case 0:
          Ee = o.mouseButtons.LEFT;
          break;
        case 1:
          Ee = o.mouseButtons.MIDDLE;
          break;
        case 2:
          Ee = o.mouseButtons.RIGHT;
          break;
        default:
          Ee = -1;
      }
      switch (Ee) {
        case Dn.DOLLY:
          if (o.enableZoom === !1)
            return;
          J(me), u = l.DOLLY;
          break;
        case Dn.ROTATE:
          if (me.ctrlKey || me.metaKey || me.shiftKey) {
            if (o.enablePan === !1)
              return;
            ie(me), u = l.PAN;
          } else {
            if (o.enableRotate === !1)
              return;
            q(me), u = l.ROTATE;
          }
          break;
        case Dn.PAN:
          if (me.ctrlKey || me.metaKey || me.shiftKey) {
            if (o.enableRotate === !1)
              return;
            q(me), u = l.ROTATE;
          } else {
            if (o.enablePan === !1)
              return;
            ie(me), u = l.PAN;
          }
          break;
        default:
          u = l.NONE;
      }
      u !== l.NONE && o.dispatchEvent($r);
    }
    function Be(me) {
      switch (u) {
        case l.ROTATE:
          if (o.enableRotate === !1)
            return;
          ne(me);
          break;
        case l.DOLLY:
          if (o.enableZoom === !1)
            return;
          ge(me);
          break;
        case l.PAN:
          if (o.enablePan === !1)
            return;
          ye(me);
          break;
      }
    }
    function Je(me) {
      o.enabled === !1 || o.enableZoom === !1 || u !== l.NONE || (me.preventDefault(), o.dispatchEvent($r), xe(ft(me)), o.dispatchEvent($a));
    }
    function ft(me) {
      const Ee = me.deltaMode, tt = {
        clientX: me.clientX,
        clientY: me.clientY,
        deltaY: me.deltaY
      };
      switch (Ee) {
        case 1:
          tt.deltaY *= 16;
          break;
        case 2:
          tt.deltaY *= 100;
          break;
      }
      return me.ctrlKey && !j && (tt.deltaY *= 10), tt;
    }
    function lt(me) {
      me.key === "Control" && (j = !0, o.domElement.getRootNode().addEventListener("keyup", he, { passive: !0, capture: !0 }));
    }
    function he(me) {
      me.key === "Control" && (j = !1, o.domElement.getRootNode().removeEventListener("keyup", he, { passive: !0, capture: !0 }));
    }
    function ae(me) {
      o.enabled === !1 || o.enablePan === !1 || we(me);
    }
    function se(me) {
      switch (ke(me), O.length) {
        case 1:
          switch (o.touches.ONE) {
            case Un.ROTATE:
              if (o.enableRotate === !1)
                return;
              de(me), u = l.TOUCH_ROTATE;
              break;
            case Un.PAN:
              if (o.enablePan === !1)
                return;
              Te(me), u = l.TOUCH_PAN;
              break;
            default:
              u = l.NONE;
          }
          break;
        case 2:
          switch (o.touches.TWO) {
            case Un.DOLLY_PAN:
              if (o.enableZoom === !1 && o.enablePan === !1)
                return;
              ee(me), u = l.TOUCH_DOLLY_PAN;
              break;
            case Un.DOLLY_ROTATE:
              if (o.enableZoom === !1 && o.enableRotate === !1)
                return;
              Ae(me), u = l.TOUCH_DOLLY_ROTATE;
              break;
            default:
              u = l.NONE;
          }
          break;
        default:
          u = l.NONE;
      }
      u !== l.NONE && o.dispatchEvent($r);
    }
    function Re(me) {
      switch (ke(me), u) {
        case l.TOUCH_ROTATE:
          if (o.enableRotate === !1)
            return;
          be(me), o.update();
          break;
        case l.TOUCH_PAN:
          if (o.enablePan === !1)
            return;
          Fe(me), o.update();
          break;
        case l.TOUCH_DOLLY_PAN:
          if (o.enableZoom === !1 && o.enablePan === !1)
            return;
          Ye(me), o.update();
          break;
        case l.TOUCH_DOLLY_ROTATE:
          if (o.enableZoom === !1 && o.enableRotate === !1)
            return;
          De(me), o.update();
          break;
        default:
          u = l.NONE;
      }
    }
    function Oe(me) {
      o.enabled !== !1 && me.preventDefault();
    }
    function We(me) {
      O.push(me.pointerId);
    }
    function Ct(me) {
      delete N[me.pointerId];
      for (let Ee = 0; Ee < O.length; Ee++)
        if (O[Ee] == me.pointerId) {
          O.splice(Ee, 1);
          return;
        }
    }
    function le(me) {
      for (let Ee = 0; Ee < O.length; Ee++)
        if (O[Ee] == me.pointerId)
          return !0;
      return !1;
    }
    function ke(me) {
      let Ee = N[me.pointerId];
      Ee === void 0 && (Ee = new Ie(), N[me.pointerId] = Ee), Ee.set(me.pageX, me.pageY);
    }
    function Ke(me) {
      const Ee = me.pointerId === O[0] ? O[1] : O[0];
      return N[Ee];
    }
    o.domElement.addEventListener("contextmenu", Oe), o.domElement.addEventListener("pointerdown", Ue), o.domElement.addEventListener("pointercancel", ue), o.domElement.addEventListener("wheel", Je, { passive: !1 }), o.domElement.getRootNode().addEventListener("keydown", lt, { passive: !0, capture: !0 }), this.update();
  }
}
var _p = function(t, e) {
  return e = typeof e < "u" ? e : !1, t = t.replace(/GAMMA/gi, "&Gamma;"), t = t.replace(/DELTA/gi, "&Delta;"), t = t.replace(/SIGMA/gi, "&Sigma;"), t = t.replace(/LAMBDA/gi, "&Lambda;"), t = t.replace(/\-/gi, "&mdash;"), e ? t = t.replace(/_(.)/gi, function(n, o, l, u) {
    return '<tspan baseline-shift="sub">' + o + "</tspan>";
  }) : t = t.replace(/_(.)/gi, function(n, o, l, u) {
    return "<sub>" + o + "</sub>";
  }), t;
}, gp = function(o, l, n) {
  var o = o, l = l;
  n == null && (n = {});
  var u = n.showAxes ?? !0, f = n.showBVectors ?? !0, h = n.showPathpoints ?? !1, p = n.disableInteractOverlay ?? !1, v = !1, g = [], w = new ni({
    color: 13975119,
    opacity: 0.5,
    transparent: !0
    //side: THREE.DoubleSide,
  }), E = new ar({
    color: 3355443,
    opacity: 1,
    transparent: !1,
    linewidth: 1
  }), T = new ar({
    color: 285405,
    opacity: 1,
    transparent: !1
  }), R = new ni({
    color: 3311805,
    opacity: 1,
    transparent: !1
  }), _ = new ni({
    color: 8925746,
    opacity: 1,
    transparent: !1
  }), b = null, M = null, A = null;
  this.resizeRenderer = function() {
    if (o) {
      var O = window.devicePixelRatio || 1, N = o.offsetWidth, j = o.offsetHeight;
      A && (M.aspect = N / j, M.updateProjectionMatrix(), A.setSize(
        N * O,
        j * O
      ), A.domElement.style.width = N + "px", A.domElement.style.height = j + "px", A.domElement.width = N * O, A.domElement.height = j * O, D());
    }
  };
  var $ = function(O, N) {
    N = typeof N < "u" ? N : "#000000";
    var j;
    {
      var j = document.createElement("div");
      j.style.position = "absolute", j.style.fontFamily = "'Helvetica Neue', Helvetica, Arial, sans-serif", j.style.color = N, j.style.width = 100, j.style.height = 100, j.style.fontSize = "12px", j.innerHTML = O, j.style.top = "-100px", j.style.left = "-100px", j.style.userSelect = "none", j.style.userSelect = "none", j.style.webkitUserSelect = "none", j.style.MozUserSelect = "none", j.setAttribute("unselectable", "on"), j.style.pointerEvents = "none";
    }
    return j;
  }, S = function(O) {
    var N = document.createElement("div");
    N.classList.add(O), N.style.position = "absolute", N.style.fontFamily = "'Helvetica Neue', Helvetica, Arial, sans-serif", N.style.zIndex = 1, N.style.width = "100%", N.style.height = "100%", N.style.display = "table", N.style.top = "0px", N.style.left = "0px", N.style.textAlign = "center", N.style.verticalAlign = "middle", N.style.userSelect = "none", N.style.userSelect = "none", N.style.webkitUserSelect = "none", N.style.MozUserSelect = "none", N.setAttribute("unselectable", "on");
    var j = document.createElement("span");
    return j.innerHTML = "Double click to toggle interaction", j.style.color = "rgb(80, 80, 80)", j.style.fontSize = "24px", j.style.fontWeight = "bold", j.style.backgroundColor = "rgba(230,230,230,0.5)", j.style.display = "table-cell", j.style.verticalAlign = "middle", j.style.lineHeight = "normal", j.style.userSelect = "none", j.style.userSelect = "none", j.style.webkitUserSelect = "none", j.style.MozUserSelect = "none", j.setAttribute("unselectable", "on"), j.onmouseover = function() {
      this.style.backgroundColor = "rgba(230,230,230,0.5)", this.innerHTML = "Double click to toggle interaction";
    }, j.onmouseleave = function() {
      this.style.backgroundColor = "rgba(255,255,255,0.01)", this.innerHTML = "";
    }, N.appendChild(j), N;
  };
  this.loadBZ = function(O) {
    if (O == null || Object.keys(O).length === 0 || o == null || o.id == "" || l == null)
      return;
    var N = window.devicePixelRatio || 1;
    l.innerHTML = "";
    for (var j = o; j.firstChild; )
      j.removeChild(j.firstChild);
    g = [], b = new hp();
    let L = j.offsetWidth, z = j.offsetHeight;
    M = new Lt(
      45,
      L / z,
      0.01,
      1e3
    ), M.position.z = 3, A = new Po({
      alpha: !0,
      preserveDrawingBuffer: !0
      // to allow taking screenshots
      //antialias: true // could be much slower!
    }), A.setClearColor(16777215, 0), A.setSize(
      L * N,
      z * N
    ), A.domElement.style.width = L + "px", A.domElement.style.height = z + "px", A.domElement.width = L * N, A.domElement.height = z * N, j.appendChild(A.domElement);
    let G = new mp(M, A.domElement);
    G.addEventListener("change", D), G.enableDamping = !0, G.dampingFactor = 0.25, G.enableZoom = !0;
    let B = O.kpoints, F = O.b1, H = O.b2, W = O.b3, V = Math.sqrt(
      Math.max(
        Math.pow(F[0], 2) + Math.pow(F[1], 2) + Math.pow(F[2], 2),
        Math.pow(H[0], 2) + Math.pow(H[1], 2) + Math.pow(H[2], 2),
        Math.pow(W[0], 2) + Math.pow(W[1], 2) + Math.pow(W[2], 2)
      )
    );
    var X = V * 1.5;
    M.position.z = V * 3;
    let Z = O.faces_data;
    for (var Q in B) {
      let Qe = B[Q], ue = 0.02 * V;
      var q = new or(ue, 16, 16), J = new Rt(q, R);
      J.translateX(Qe[0]), J.translateY(Qe[1]), J.translateZ(Qe[2]), b.add(J), Q = _p(Q, v);
      var ie = $(Q);
      j.appendChild(ie), g.push([new I(Qe[0], Qe[1], Qe[2]), ie]);
    }
    if (u) {
      var ne = [
        [
          new I(1, 0, 0),
          '<span style="font-style: italic">x</span>'
        ],
        [
          new I(0, 1, 0),
          '<span style="font-style: italic">y</span>'
        ],
        [
          new I(0, 0, 1),
          '<span style="font-style: italic">z</span>'
        ]
      ];
      ne.forEach(function(Qe) {
        var ue = Qe[0], te = Qe[1], Be = new I(0, 0, 0), Je = 5592405, ft = new Ka(
          ue,
          Be,
          X,
          Je,
          X / 10,
          X / 20
        );
        b.add(ft);
        var lt = "#555555";
        ie = $(te, lt);
        var he = ue.clone();
        he.sub(Be), he.multiplyScalar(X), j.appendChild(ie), g.push([he, ie]);
      });
    }
    var ge = [
      [F, '<span style="font-weight: bold">b</span><sub>1</sub>'],
      [H, '<span style="font-weight: bold">b</span><sub>2</sub>'],
      [W, '<span style="font-weight: bold">b</span><sub>3</sub>']
    ], ge;
    f || (ge = []), ge.forEach(function(Qe) {
      var ue = Qe[0];
      Q = Qe[1];
      var te = Math.sqrt(
        Math.pow(ue[0], 2) + Math.pow(ue[1], 2) + Math.pow(ue[2], 2)
      ), Be = new I(
        ue[0] / te,
        ue[1] / te,
        ue[2] / te
      ), Je = new I(0, 0, 0), ft = 0, lt = new Ka(
        Be,
        Je,
        length = te,
        ft = ft,
        te / 10,
        te / 20
      );
      b.add(lt);
      var he = $(Q = Q), ae = Be.clone();
      ae.sub(Je), ae.multiplyScalar(te), j.appendChild(he), g.push([ae, he]);
    });
    var ye = new Tt(), xe = [];
    Z.triangles_vertices.forEach(function(Qe) {
      xe.push(Qe[0], Qe[1], Qe[2]);
    }), ye.setAttribute(
      "position",
      new ut(xe, 3)
    );
    var we = [];
    Z.triangles.forEach(function(Qe) {
      we.push(Qe[0], Qe[1], Qe[2]);
    }), ye.setIndex(we);
    var de = new Rt(ye, w), Te = new dp(de.geometry), Ce = new fp(Te, E);
    b.add(de), b.add(Ce);
    var ee = O.path;
    if (ee.forEach(function(Qe) {
      var ue = Qe[0], te = Qe[1], Be = B[ue], Je = B[te], ft = [];
      ft.push(new I(Be[0], Be[1], Be[2])), ft.push(new I(Je[0], Je[1], Je[2]));
      var lt = new Tt().setFromPoints(ft), he = new ds(lt, T);
      he.material.linewidth = 4, b.add(he);
    }), h) {
      var Ae = O.explicit_kpoints_abs;
      for (var be in Ae) {
        var Fe = Ae[be], et = 5e-3 * V, q = new or(et, 16, 16), J = new Rt(q, _);
        J.translateX(Fe[0]), J.translateY(Fe[1]), J.translateZ(Fe[2]), b.add(J);
      }
    }
    D();
    var Ye = function(Qe, ue) {
      if (typeof ue > "u")
        var te = !G.enabled;
      else
        var te = ue;
      G.enabled = te;
      for (var Be = j.getElementsByClassName("BZDoubleClickText"), Je = 0; Je < Be.length; Je++)
        j.removeChild(Be[Je]);
      te || j.appendChild(S("BZDoubleClickText"));
    };
    p || (Ye(), j.addEventListener("dblclick", Ye));
    var De, Ue = !1;
    j.addEventListener("touchend", function(Qe) {
      if (typeof De < "u" && clearTimeout(De), Ue)
        Ue = !1, Qe.preventDefault(), Ye();
      else {
        if (Qe.targetTouches.length != 0) {
          typeof De < "u" && (clearTimeout(De), Ue = !1);
          return;
        }
        Ue = !0, De = setTimeout(function() {
          Ue = !1;
        }, 500);
      }
    }), j.addEventListener("touchcancel", function(Qe) {
      typeof De < "u" && (clearTimeout(De), Ue = !1);
    }), j.addEventListener("touchmove", function(Qe) {
      typeof De < "u" && (clearTimeout(De), Ue = !1);
    });
  };
  function C(O, N) {
    var j = O.clone().project(N), L = window.devicePixelRatio || 1, z, G;
    {
      var z = 0.5 * A.domElement.width / L, G = 0.5 * A.domElement.height / L;
      j.x = j.x * z + z, j.y = -(j.y * G) + G;
    }
    return {
      left: j.x,
      top: j.y
    };
  }
  function D() {
    A.render(b, M), g.forEach(function(O) {
      var N = O[0], j = O[1], L = C(N, M);
      j.style.top = L.top + "px", j.style.left = L.left + "px";
    });
  }
};
function vp(t) {
  let e = "";
  for (; e.length < t; )
    e += Math.random().toString(36).substring(2);
  return e.substring(0, t);
}
function xp(t, e, n) {
  let o = document.createElement("div");
  o.className = "bz-main-container";
  let l = vp(6), u = document.createElement("div");
  u.id = `canvas-${l}`, u.className = "bz-canvas3d";
  let f = document.createElement("div");
  f.id = `info-${l}`, o.appendChild(u), o.appendChild(f), t.appendChild(o);
  let h = new gp(u, f, n);
  return window.addEventListener("resize", h.resizeRenderer), requestAnimationFrame(() => {
    h.loadBZ(e);
  }), h;
}
const Brillouinzone = ({ data: t }) => {
  const e = useRef(null);
  return useEffect(() => {
    e.current && t && xp(e.current, t, {
      showAxes: !1,
      showBVectors: !1,
      showPathpoints: !0,
      disableInteractOverlay: !0
    });
  }, [t]), /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { ref: e, id: "bzvis" });
}, DetailsPage = ({ apiUrl: t }) => {
  const { uuid: e } = useParams(), [n, o] = useState("raw");
  useNavigate();
  const [l, u] = useState(null), [f, h] = useState(null), [p, v] = useState(null), [g, w] = useState(!0), [E, T] = useState(null);
  useState();
  const [R, _] = useState(), [b, M] = useState(), $ = new URLSearchParams(location.search).get("source") === "computersGrid";
  console.log($);
  const S = (O) => O.split(/(\d+)/).map(
    (N, j) => /\d/.test(N) ? /* @__PURE__ */ jsxRuntimeExports$1.jsx("sub", { children: N }, j) : N
  ), C = (O) => {
    const N = { year: "numeric", month: "long", day: "numeric" };
    return new Date(O).toLocaleDateString(void 0, N);
  };
  useEffect(() => {
    const O = async () => {
      try {
        const z = await fetch(`${t}/nodes/${e}/download?download_format=cif&download=false`);
        if (!z.ok)
          throw new Error("Network response was not ok");
        const G = await z.json();
        u(G.data.download.data);
      } catch (z) {
        console.error("Error fetching data:", z), h(z.message);
      } finally {
        w(!1);
      }
    }, N = async () => {
      try {
        const G = await (await fetch(`${t}/nodes/${e}`)).json();
        _(G.data.nodes[0]), w(!1);
      } catch (z) {
        console.error("Error fetching the data:", z), w(!1);
      }
    }, j = async () => {
      try {
        const z = await fetch(`${t}/nodes/${e}/contents/derived_properties`);
        if (!z.ok)
          throw new Error("Network response was not ok");
        const G = await z.json();
        M(G), v(G.data.derived_properties), p ? (v(G.data.derived_properties), console.log(G)) : v(null), console.log(p);
      } catch (z) {
        console.error("Error fetching data:", z), h(z.message);
      } finally {
        w(!1);
      }
    }, L = async () => {
      try {
        const z = await fetch(`${t}/nodes/${e}/contents/attributes`);
        if (!z.ok)
          throw new Error("Network response was not ok");
        const G = await z.json();
        if (!G.data)
          throw new Error("Empty or invalid response");
        T(G.data.attributes);
      } catch (z) {
        console.error("Error fetching data:", z), h(z.message);
      }
    };
    N(), O(), j(), L();
  }, [e]);
  const D = R ? {
    UUID: R.uuid,
    Type: R.full_type,
    "Created on": C(R.ctime),
    "Modified on": C(R.mtime),
    Creator: "Sebastiaan Huber (EPFL)"
  } : {};
  return console.log(D), /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "flex w-full flex-col md:flex-row h-[100vh] mx-4 p-5", children: [
    /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: ` ${$ ? "w-full h-[100vh]" : "w-full md:w-1/2"} p-6 border-2 mb-4 md:mb-0 md:mr-2  rounded-lg relative `, children: [
      /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "p-5 relative border-2 bg-gray-50 border-gray-300 rounded", children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "border-2 border-gray-300 absolute top-[-1rem] left-[2%] px-3 py-1 bg-gray-200 z-10 align-middle items-center", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx("h1", { className: "text-xl font-semibold text-center", children: "Overview" }) }),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "mb-4", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(Search, { uuid: e }) }),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "bg-white rounded shadow p-2", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          JsonViewer,
          {
            value: D,
            theme: "githubLight",
            displayDataTypes: !1,
            displayObjectSize: !1,
            enableClipboard: !1,
            rootName: !1
          }
        ) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "flex pt-3 justify-between mb-4" }),
      /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "px-5 py2 bg-gray-50 h-[65vh] border-2 relative border-gray-300 rounded", children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "border-2 border-gray-300 absolute top-[-1rem] left-[2%] px-3 py-1 bg-gray-200 z-10 align-middle items-center", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx("h1", { className: "text-xl font-semibold text-center", children: "Details" }) }),
        /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "flex justify-center mt-4 mb-4", children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(
            "button",
            {
              className: `px-6 shadow-lg py-2 mx-2 rounded-lg ${n === "raw" ? "bg-blue-400 text-white" : "bg-blue-100"}`,
              onClick: () => o("raw"),
              children: "Raw"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(
            "button",
            {
              className: `px-6 shadow-lg py-2 mx-2 rounded-lg ${n === "rich" ? "bg-blue-400  text-white" : "bg-blue-100"}`,
              onClick: () => o("rich"),
              children: "Rich"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "overflow-auto bg-white p-4 rounded-lg shadow-[0_3px_10px_rgb(0,0,0,0.2)] h-[85%]", children: n === "raw" ? /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(Files, { apiUrl: t, uuid: e }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "h-full", children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx("span", { className: "font-semibold mt-2 font-mono mb-0", children: "Node Attributes :" }),
            /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "h-full", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(Attributes, { apiUrl: t, uuid: e }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "mt-3", children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx("span", { className: "font-semibold font-mono mb-0", children: "Node Extras :" }),
            /* @__PURE__ */ jsxRuntimeExports$1.jsx(ExtraContent, { apiUrl: t, uuid: e })
          ] })
        ] }) : /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(Files, { apiUrl: t, uuid: e }),
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(RepoFiles, { apiUrl: t, uuid: e }),
          p && /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "p-4 bg-gray-50 mb-4 border[-1px] border-gray-300 shadow-md rounded-lg", children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsxs("p", { className: "text-lg font-semibold", children: [
              "Formula: ",
              /* @__PURE__ */ jsxRuntimeExports$1.jsx("span", { className: "font-normal", children: S(p.formula) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports$1.jsxs("p", { className: "text-lg font-semibold", children: [
              "Dimension: ",
              /* @__PURE__ */ jsxRuntimeExports$1.jsx("span", { className: "font-normal", children: p.dimensionality.dim })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports$1.jsxs("p", { className: "text-lg font-semibold", children: [
              p.dimensionality.label,
              ":",
              " ",
              /* @__PURE__ */ jsxRuntimeExports$1.jsx("span", { className: "font-normal", children: p.dimensionality.value })
            ] })
          ] }),
          l && !f && /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "flex items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "m-auto", children: l && /* @__PURE__ */ jsxRuntimeExports$1.jsx(StructureVisualizer, { cifText: l }) }) }),
          E.cell && /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "flex flex-col font-mono text-sm mb-4 mt-4", children: [
            /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "w-full shadow-md overflow-auto h-42 border-2 border-gray-200 rounded-lg mr-2", children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs("table", { className: "table-auto w-full", children: [
              /* @__PURE__ */ jsxRuntimeExports$1.jsx("thead", { children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs("tr", { children: [
                /* @__PURE__ */ jsxRuntimeExports$1.jsx("th", { className: "px-4 py-2", children: "Cell X" }),
                /* @__PURE__ */ jsxRuntimeExports$1.jsx("th", { className: "px-4 py-2", children: "Cell Y" }),
                /* @__PURE__ */ jsxRuntimeExports$1.jsx("th", { className: "px-4 py-2", children: "Cell Z" })
              ] }) }),
              /* @__PURE__ */ jsxRuntimeExports$1.jsx("tbody", { children: E.cell && E.cell.map((O, N) => /* @__PURE__ */ jsxRuntimeExports$1.jsx("tr", { children: O.map((j, L) => /* @__PURE__ */ jsxRuntimeExports$1.jsx("td", { className: "border px-4 py-2", children: j }, L)) }, N)) })
            ] }) }),
            E.sites && /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "w-full shadow-md overflow-auto h-96 mb-4 mt-4 border-2 border-gray-200 rounded-lg", children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs("table", { className: "table-auto w-full", children: [
              /* @__PURE__ */ jsxRuntimeExports$1.jsx("thead", { children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs("tr", { children: [
                /* @__PURE__ */ jsxRuntimeExports$1.jsx("th", { className: "px-4 py-2", children: "Kind Name" }),
                /* @__PURE__ */ jsxRuntimeExports$1.jsx("th", { className: "px-4 py-2", children: "Position X" }),
                /* @__PURE__ */ jsxRuntimeExports$1.jsx("th", { className: "px-4 py-2", children: "Position Y" }),
                /* @__PURE__ */ jsxRuntimeExports$1.jsx("th", { className: "px-4 py-2", children: " Position Z" })
              ] }) }),
              /* @__PURE__ */ jsxRuntimeExports$1.jsx("tbody", { children: E.sites && E.sites.map((O, N) => /* @__PURE__ */ jsxRuntimeExports$1.jsxs("tr", { children: [
                /* @__PURE__ */ jsxRuntimeExports$1.jsx("td", { className: "border px-4 py-2", children: O.kind_name }),
                O.position.map((j, L) => /* @__PURE__ */ jsxRuntimeExports$1.jsx("td", { className: "border px-4 py-2", children: j }, L))
              ] }, N)) })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "h-full w-full ", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(Brillouinzone, { data: b }) })
          ] })
        ] }) })
      ] })
    ] }),
    !$ && /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "w-full md:w-1/2 p-6 relative border-2 md:ml-2 border-gray-200 rounded-lg", children: [
      /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "border-2 border-gray-300 absolute top-[-1rem] left-[11%] translate-x-[-50%] px-3 py-1 bg-gray-200 z-10 align-middle items-center", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx("h1", { className: "text-xl font-semibold text-center", children: "Graph Preview" }) }),
      /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "h-full w-full", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(BrowserSelection, { uuid: e, apiUrl: t }) })
    ] })
  ] }) });
};
function FiChevronDown(t) {
  return GenIcon({ tag: "svg", attr: { viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, child: [{ tag: "polyline", attr: { points: "6 9 12 15 18 9" }, child: [] }] })(t);
}
const buildTree = (t) => {
  let e = t.subspaces || [];
  return {
    label: t.label || "No Label",
    full_type: t.full_type || "",
    children: e.map(buildTree),
    counter: t.counter
  };
}, TreeNode = ({ node: t, onSelectNode: e, selectedNode: n }) => {
  const o = n && t.full_type === n.full_type, [l, u] = useState(o), [f, h] = useState(!1), p = useNavigate(), v = useLocation(), g = () => {
    u(!l), e(t), h(!0);
  };
  return useEffect(() => {
    if (f && v.pathname.includes("/computers")) {
      const w = v.pathname.split("/").slice(0, -1).join("/");
      p(w), h(!1);
    }
  }, [f, v.pathname, p]), /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "ml-0 mt-1", children: [
    /* @__PURE__ */ jsxRuntimeExports$1.jsxs(
      "div",
      {
        className: `cursor-pointer hover:bg-blue-600 text-gray-900 min-w-fit p-2 rounded hover:text-gray-100 flex items-center
          ${o ? "bg-blue-500 text-white" : "bg-gray-100"}`,
        onClick: g,
        children: [
          /* @__PURE__ */ jsxRuntimeExports$1.jsx(
            FiChevronDown,
            {
              className: `w-4 h-4 mr-2 transform transition-transform duration-200 ${l ? "" : "-rotate-90 "}`
            }
          ),
          t.label
        ]
      }
    ),
    l && /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "ml-4 mt-2 ", children: t.children.map((w, E) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      TreeNode,
      {
        node: w,
        onSelectNode: e,
        selectedNode: n
      },
      E
    )) })
  ] });
}, TreeView = ({ fullTypeCounts: t, selectedNode: e, onSelectNode: n }) => {
  if (t == null)
    return /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "loading-animation m-auto flex justify-center text-center", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(ClipLoader, { size: 30, color: "#007bff" }) });
  console.log(t);
  const l = buildTree(t).children;
  return l.length ? /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { children: l.map((u, f) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(
    TreeNode,
    {
      node: u,
      onSelectNode: n,
      selectedNode: e
    },
    f
  )) }) : /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "text-center text-gray-700 bg-blue-100", children: "No data available" });
}, FilterSidebar = ({
  fullTypeCounts: t,
  selectedNode: e,
  onSelectNode: n,
  Computers: o
}) => {
  const l = useNavigate();
  console.log(t);
  const u = (...h) => h.map((p, v) => v === 0 ? p.trim().replace(/\/*$/, "") : p.trim().replace(/(^\/|\/*$)/g, "")).filter((p) => p.length).join("/"), f = () => {
    const h = location.pathname;
    l(u(h, "computers"));
  };
  return /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "p-4 bg-white border-2 border-gray-300 overflow-auto h-full", children: [
    /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      TreeView,
      {
        fullTypeCounts: t,
        selectedNode: e,
        onSelectNode: n
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports$1.jsx("hr", { className: "my-3 text-gray-900" }),
    /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      "button",
      {
        className: "bg-gray-300 p-3 text-center font-medium text-md text-gray-900 w-full",
        onClick: f,
        children: "Computers"
      }
    ) })
  ] });
};
/**
   * table-core
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   */
function createColumnHelper() {
  return {
    accessor: (t, e) => typeof t == "function" ? {
      ...e,
      accessorFn: t
    } : {
      ...e,
      accessorKey: t
    },
    display: (t) => t,
    group: (t) => t
  };
}
function functionalUpdate(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function makeStateUpdater(t, e) {
  return (n) => {
    e.setState((o) => ({
      ...o,
      [t]: functionalUpdate(n, o[t])
    }));
  };
}
function isFunction$4(t) {
  return t instanceof Function;
}
function isNumberArray(t) {
  return Array.isArray(t) && t.every((e) => typeof e == "number");
}
function flattenBy(t, e) {
  const n = [], o = (l) => {
    l.forEach((u) => {
      n.push(u);
      const f = e(u);
      f != null && f.length && o(f);
    });
  };
  return o(t), n;
}
function memo(t, e, n) {
  let o = [], l;
  return (u) => {
    let f;
    n.key && n.debug && (f = Date.now());
    const h = t(u);
    if (!(h.length !== o.length || h.some((g, w) => o[w] !== g)))
      return l;
    o = h;
    let v;
    if (n.key && n.debug && (v = Date.now()), l = e(...h), n == null || n.onChange == null || n.onChange(l), n.key && n.debug && n != null && n.debug()) {
      const g = Math.round((Date.now() - f) * 100) / 100, w = Math.round((Date.now() - v) * 100) / 100, E = w / 16, T = (R, _) => {
        for (R = String(R); R.length < _; )
          R = " " + R;
        return R;
      };
      console.info(`%c⏱ ${T(w, 5)} /${T(g, 5)} ms`, `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(0, Math.min(120 - 120 * E, 120))}deg 100% 31%);`, n == null ? void 0 : n.key);
    }
    return l;
  };
}
function getMemoOptions(t, e, n, o) {
  return {
    debug: () => {
      var l;
      return (l = t == null ? void 0 : t.debugAll) != null ? l : t[e];
    },
    key: process.env.NODE_ENV === "development" && n,
    onChange: o
  };
}
function createCell(t, e, n, o) {
  const l = () => {
    var f;
    return (f = u.getValue()) != null ? f : t.options.renderFallbackValue;
  }, u = {
    id: `${e.id}_${n.id}`,
    row: e,
    column: n,
    getValue: () => e.getValue(o),
    renderValue: l,
    getContext: memo(() => [t, n, e, u], (f, h, p, v) => ({
      table: f,
      column: h,
      row: p,
      cell: v,
      getValue: v.getValue,
      renderValue: v.renderValue
    }), getMemoOptions(t.options, "debugCells", "cell.getContext"))
  };
  return t._features.forEach((f) => {
    f.createCell == null || f.createCell(u, n, e, t);
  }, {}), u;
}
function createColumn(t, e, n, o) {
  var l, u;
  const h = {
    ...t._getDefaultColumnDef(),
    ...e
  }, p = h.accessorKey;
  let v = (l = (u = h.id) != null ? u : p ? typeof String.prototype.replaceAll == "function" ? p.replaceAll(".", "_") : p.replace(/\./g, "_") : void 0) != null ? l : typeof h.header == "string" ? h.header : void 0, g;
  if (h.accessorFn ? g = h.accessorFn : p && (p.includes(".") ? g = (E) => {
    let T = E;
    for (const _ of p.split(".")) {
      var R;
      T = (R = T) == null ? void 0 : R[_], process.env.NODE_ENV !== "production" && T === void 0 && console.warn(`"${_}" in deeply nested key "${p}" returned undefined.`);
    }
    return T;
  } : g = (E) => E[h.accessorKey]), !v)
    throw process.env.NODE_ENV !== "production" ? new Error(h.accessorFn ? "Columns require an id when using an accessorFn" : "Columns require an id when using a non-string header") : new Error();
  let w = {
    id: `${String(v)}`,
    accessorFn: g,
    parent: o,
    depth: n,
    columnDef: h,
    columns: [],
    getFlatColumns: memo(() => [!0], () => {
      var E;
      return [w, ...(E = w.columns) == null ? void 0 : E.flatMap((T) => T.getFlatColumns())];
    }, getMemoOptions(t.options, "debugColumns", "column.getFlatColumns")),
    getLeafColumns: memo(() => [t._getOrderColumnsFn()], (E) => {
      var T;
      if ((T = w.columns) != null && T.length) {
        let R = w.columns.flatMap((_) => _.getLeafColumns());
        return E(R);
      }
      return [w];
    }, getMemoOptions(t.options, "debugColumns", "column.getLeafColumns"))
  };
  for (const E of t._features)
    E.createColumn == null || E.createColumn(w, t);
  return w;
}
const debug = "debugHeaders";
function createHeader(t, e, n) {
  var o;
  let u = {
    id: (o = n.id) != null ? o : e.id,
    column: e,
    index: n.index,
    isPlaceholder: !!n.isPlaceholder,
    placeholderId: n.placeholderId,
    depth: n.depth,
    subHeaders: [],
    colSpan: 0,
    rowSpan: 0,
    headerGroup: null,
    getLeafHeaders: () => {
      const f = [], h = (p) => {
        p.subHeaders && p.subHeaders.length && p.subHeaders.map(h), f.push(p);
      };
      return h(u), f;
    },
    getContext: () => ({
      table: t,
      header: u,
      column: e
    })
  };
  return t._features.forEach((f) => {
    f.createHeader == null || f.createHeader(u, t);
  }), u;
}
const Headers = {
  createTable: (t) => {
    t.getHeaderGroups = memo(() => [t.getAllColumns(), t.getVisibleLeafColumns(), t.getState().columnPinning.left, t.getState().columnPinning.right], (e, n, o, l) => {
      var u, f;
      const h = (u = o == null ? void 0 : o.map((w) => n.find((E) => E.id === w)).filter(Boolean)) != null ? u : [], p = (f = l == null ? void 0 : l.map((w) => n.find((E) => E.id === w)).filter(Boolean)) != null ? f : [], v = n.filter((w) => !(o != null && o.includes(w.id)) && !(l != null && l.includes(w.id)));
      return buildHeaderGroups(e, [...h, ...v, ...p], t);
    }, getMemoOptions(t.options, debug, "getHeaderGroups")), t.getCenterHeaderGroups = memo(() => [t.getAllColumns(), t.getVisibleLeafColumns(), t.getState().columnPinning.left, t.getState().columnPinning.right], (e, n, o, l) => (n = n.filter((u) => !(o != null && o.includes(u.id)) && !(l != null && l.includes(u.id))), buildHeaderGroups(e, n, t, "center")), getMemoOptions(t.options, debug, "getCenterHeaderGroups")), t.getLeftHeaderGroups = memo(() => [t.getAllColumns(), t.getVisibleLeafColumns(), t.getState().columnPinning.left], (e, n, o) => {
      var l;
      const u = (l = o == null ? void 0 : o.map((f) => n.find((h) => h.id === f)).filter(Boolean)) != null ? l : [];
      return buildHeaderGroups(e, u, t, "left");
    }, getMemoOptions(t.options, debug, "getLeftHeaderGroups")), t.getRightHeaderGroups = memo(() => [t.getAllColumns(), t.getVisibleLeafColumns(), t.getState().columnPinning.right], (e, n, o) => {
      var l;
      const u = (l = o == null ? void 0 : o.map((f) => n.find((h) => h.id === f)).filter(Boolean)) != null ? l : [];
      return buildHeaderGroups(e, u, t, "right");
    }, getMemoOptions(t.options, debug, "getRightHeaderGroups")), t.getFooterGroups = memo(() => [t.getHeaderGroups()], (e) => [...e].reverse(), getMemoOptions(t.options, debug, "getFooterGroups")), t.getLeftFooterGroups = memo(() => [t.getLeftHeaderGroups()], (e) => [...e].reverse(), getMemoOptions(t.options, debug, "getLeftFooterGroups")), t.getCenterFooterGroups = memo(() => [t.getCenterHeaderGroups()], (e) => [...e].reverse(), getMemoOptions(t.options, debug, "getCenterFooterGroups")), t.getRightFooterGroups = memo(() => [t.getRightHeaderGroups()], (e) => [...e].reverse(), getMemoOptions(t.options, debug, "getRightFooterGroups")), t.getFlatHeaders = memo(() => [t.getHeaderGroups()], (e) => e.map((n) => n.headers).flat(), getMemoOptions(t.options, debug, "getFlatHeaders")), t.getLeftFlatHeaders = memo(() => [t.getLeftHeaderGroups()], (e) => e.map((n) => n.headers).flat(), getMemoOptions(t.options, debug, "getLeftFlatHeaders")), t.getCenterFlatHeaders = memo(() => [t.getCenterHeaderGroups()], (e) => e.map((n) => n.headers).flat(), getMemoOptions(t.options, debug, "getCenterFlatHeaders")), t.getRightFlatHeaders = memo(() => [t.getRightHeaderGroups()], (e) => e.map((n) => n.headers).flat(), getMemoOptions(t.options, debug, "getRightFlatHeaders")), t.getCenterLeafHeaders = memo(() => [t.getCenterFlatHeaders()], (e) => e.filter((n) => {
      var o;
      return !((o = n.subHeaders) != null && o.length);
    }), getMemoOptions(t.options, debug, "getCenterLeafHeaders")), t.getLeftLeafHeaders = memo(() => [t.getLeftFlatHeaders()], (e) => e.filter((n) => {
      var o;
      return !((o = n.subHeaders) != null && o.length);
    }), getMemoOptions(t.options, debug, "getLeftLeafHeaders")), t.getRightLeafHeaders = memo(() => [t.getRightFlatHeaders()], (e) => e.filter((n) => {
      var o;
      return !((o = n.subHeaders) != null && o.length);
    }), getMemoOptions(t.options, debug, "getRightLeafHeaders")), t.getLeafHeaders = memo(() => [t.getLeftHeaderGroups(), t.getCenterHeaderGroups(), t.getRightHeaderGroups()], (e, n, o) => {
      var l, u, f, h, p, v;
      return [...(l = (u = e[0]) == null ? void 0 : u.headers) != null ? l : [], ...(f = (h = n[0]) == null ? void 0 : h.headers) != null ? f : [], ...(p = (v = o[0]) == null ? void 0 : v.headers) != null ? p : []].map((g) => g.getLeafHeaders()).flat();
    }, getMemoOptions(t.options, debug, "getLeafHeaders"));
  }
};
function buildHeaderGroups(t, e, n, o) {
  var l, u;
  let f = 0;
  const h = function(E, T) {
    T === void 0 && (T = 1), f = Math.max(f, T), E.filter((R) => R.getIsVisible()).forEach((R) => {
      var _;
      (_ = R.columns) != null && _.length && h(R.columns, T + 1);
    }, 0);
  };
  h(t);
  let p = [];
  const v = (E, T) => {
    const R = {
      depth: T,
      id: [o, `${T}`].filter(Boolean).join("_"),
      headers: []
    }, _ = [];
    E.forEach((b) => {
      const M = [..._].reverse()[0], A = b.column.depth === R.depth;
      let $, S = !1;
      if (A && b.column.parent ? $ = b.column.parent : ($ = b.column, S = !0), M && (M == null ? void 0 : M.column) === $)
        M.subHeaders.push(b);
      else {
        const C = createHeader(n, $, {
          id: [o, T, $.id, b == null ? void 0 : b.id].filter(Boolean).join("_"),
          isPlaceholder: S,
          placeholderId: S ? `${_.filter((D) => D.column === $).length}` : void 0,
          depth: T,
          index: _.length
        });
        C.subHeaders.push(b), _.push(C);
      }
      R.headers.push(b), b.headerGroup = R;
    }), p.push(R), T > 0 && v(_, T - 1);
  }, g = e.map((E, T) => createHeader(n, E, {
    depth: f,
    index: T
  }));
  v(g, f - 1), p.reverse();
  const w = (E) => E.filter((R) => R.column.getIsVisible()).map((R) => {
    let _ = 0, b = 0, M = [0];
    R.subHeaders && R.subHeaders.length ? (M = [], w(R.subHeaders).forEach(($) => {
      let {
        colSpan: S,
        rowSpan: C
      } = $;
      _ += S, M.push(C);
    })) : _ = 1;
    const A = Math.min(...M);
    return b = b + A, R.colSpan = _, R.rowSpan = b, {
      colSpan: _,
      rowSpan: b
    };
  });
  return w((l = (u = p[0]) == null ? void 0 : u.headers) != null ? l : []), p;
}
const createRow = (t, e, n, o, l, u, f) => {
  let h = {
    id: e,
    index: o,
    original: n,
    depth: l,
    parentId: f,
    _valuesCache: {},
    _uniqueValuesCache: {},
    getValue: (p) => {
      if (h._valuesCache.hasOwnProperty(p))
        return h._valuesCache[p];
      const v = t.getColumn(p);
      if (v != null && v.accessorFn)
        return h._valuesCache[p] = v.accessorFn(h.original, o), h._valuesCache[p];
    },
    getUniqueValues: (p) => {
      if (h._uniqueValuesCache.hasOwnProperty(p))
        return h._uniqueValuesCache[p];
      const v = t.getColumn(p);
      if (v != null && v.accessorFn)
        return v.columnDef.getUniqueValues ? (h._uniqueValuesCache[p] = v.columnDef.getUniqueValues(h.original, o), h._uniqueValuesCache[p]) : (h._uniqueValuesCache[p] = [h.getValue(p)], h._uniqueValuesCache[p]);
    },
    renderValue: (p) => {
      var v;
      return (v = h.getValue(p)) != null ? v : t.options.renderFallbackValue;
    },
    subRows: [],
    getLeafRows: () => flattenBy(h.subRows, (p) => p.subRows),
    getParentRow: () => h.parentId ? t.getRow(h.parentId, !0) : void 0,
    getParentRows: () => {
      let p = [], v = h;
      for (; ; ) {
        const g = v.getParentRow();
        if (!g) break;
        p.push(g), v = g;
      }
      return p.reverse();
    },
    getAllCells: memo(() => [t.getAllLeafColumns()], (p) => p.map((v) => createCell(t, h, v, v.id)), getMemoOptions(t.options, "debugRows", "getAllCells")),
    _getAllCellsByColumnId: memo(() => [h.getAllCells()], (p) => p.reduce((v, g) => (v[g.column.id] = g, v), {}), getMemoOptions(t.options, "debugRows", "getAllCellsByColumnId"))
  };
  for (let p = 0; p < t._features.length; p++) {
    const v = t._features[p];
    v == null || v.createRow == null || v.createRow(h, t);
  }
  return h;
}, ColumnFaceting = {
  createColumn: (t, e) => {
    t._getFacetedRowModel = e.options.getFacetedRowModel && e.options.getFacetedRowModel(e, t.id), t.getFacetedRowModel = () => t._getFacetedRowModel ? t._getFacetedRowModel() : e.getPreFilteredRowModel(), t._getFacetedUniqueValues = e.options.getFacetedUniqueValues && e.options.getFacetedUniqueValues(e, t.id), t.getFacetedUniqueValues = () => t._getFacetedUniqueValues ? t._getFacetedUniqueValues() : /* @__PURE__ */ new Map(), t._getFacetedMinMaxValues = e.options.getFacetedMinMaxValues && e.options.getFacetedMinMaxValues(e, t.id), t.getFacetedMinMaxValues = () => {
      if (t._getFacetedMinMaxValues)
        return t._getFacetedMinMaxValues();
    };
  }
}, includesString = (t, e, n) => {
  var o;
  const l = n.toLowerCase();
  return !!(!((o = t.getValue(e)) == null || (o = o.toString()) == null || (o = o.toLowerCase()) == null) && o.includes(l));
};
includesString.autoRemove = (t) => testFalsey(t);
const includesStringSensitive = (t, e, n) => {
  var o;
  return !!(!((o = t.getValue(e)) == null || (o = o.toString()) == null) && o.includes(n));
};
includesStringSensitive.autoRemove = (t) => testFalsey(t);
const equalsString = (t, e, n) => {
  var o;
  return ((o = t.getValue(e)) == null || (o = o.toString()) == null ? void 0 : o.toLowerCase()) === (n == null ? void 0 : n.toLowerCase());
};
equalsString.autoRemove = (t) => testFalsey(t);
const arrIncludes = (t, e, n) => {
  var o;
  return (o = t.getValue(e)) == null ? void 0 : o.includes(n);
};
arrIncludes.autoRemove = (t) => testFalsey(t) || !(t != null && t.length);
const arrIncludesAll = (t, e, n) => !n.some((o) => {
  var l;
  return !((l = t.getValue(e)) != null && l.includes(o));
});
arrIncludesAll.autoRemove = (t) => testFalsey(t) || !(t != null && t.length);
const arrIncludesSome = (t, e, n) => n.some((o) => {
  var l;
  return (l = t.getValue(e)) == null ? void 0 : l.includes(o);
});
arrIncludesSome.autoRemove = (t) => testFalsey(t) || !(t != null && t.length);
const equals = (t, e, n) => t.getValue(e) === n;
equals.autoRemove = (t) => testFalsey(t);
const weakEquals = (t, e, n) => t.getValue(e) == n;
weakEquals.autoRemove = (t) => testFalsey(t);
const inNumberRange = (t, e, n) => {
  let [o, l] = n;
  const u = t.getValue(e);
  return u >= o && u <= l;
};
inNumberRange.resolveFilterValue = (t) => {
  let [e, n] = t, o = typeof e != "number" ? parseFloat(e) : e, l = typeof n != "number" ? parseFloat(n) : n, u = e === null || Number.isNaN(o) ? -1 / 0 : o, f = n === null || Number.isNaN(l) ? 1 / 0 : l;
  if (u > f) {
    const h = u;
    u = f, f = h;
  }
  return [u, f];
};
inNumberRange.autoRemove = (t) => testFalsey(t) || testFalsey(t[0]) && testFalsey(t[1]);
const filterFns = {
  includesString,
  includesStringSensitive,
  equalsString,
  arrIncludes,
  arrIncludesAll,
  arrIncludesSome,
  equals,
  weakEquals,
  inNumberRange
};
function testFalsey(t) {
  return t == null || t === "";
}
const ColumnFiltering = {
  getDefaultColumnDef: () => ({
    filterFn: "auto"
  }),
  getInitialState: (t) => ({
    columnFilters: [],
    ...t
  }),
  getDefaultOptions: (t) => ({
    onColumnFiltersChange: makeStateUpdater("columnFilters", t),
    filterFromLeafRows: !1,
    maxLeafRowFilterDepth: 100
  }),
  createColumn: (t, e) => {
    t.getAutoFilterFn = () => {
      const n = e.getCoreRowModel().flatRows[0], o = n == null ? void 0 : n.getValue(t.id);
      return typeof o == "string" ? filterFns.includesString : typeof o == "number" ? filterFns.inNumberRange : typeof o == "boolean" || o !== null && typeof o == "object" ? filterFns.equals : Array.isArray(o) ? filterFns.arrIncludes : filterFns.weakEquals;
    }, t.getFilterFn = () => {
      var n, o;
      return isFunction$4(t.columnDef.filterFn) ? t.columnDef.filterFn : t.columnDef.filterFn === "auto" ? t.getAutoFilterFn() : (
        // @ts-ignore
        (n = (o = e.options.filterFns) == null ? void 0 : o[t.columnDef.filterFn]) != null ? n : filterFns[t.columnDef.filterFn]
      );
    }, t.getCanFilter = () => {
      var n, o, l;
      return ((n = t.columnDef.enableColumnFilter) != null ? n : !0) && ((o = e.options.enableColumnFilters) != null ? o : !0) && ((l = e.options.enableFilters) != null ? l : !0) && !!t.accessorFn;
    }, t.getIsFiltered = () => t.getFilterIndex() > -1, t.getFilterValue = () => {
      var n;
      return (n = e.getState().columnFilters) == null || (n = n.find((o) => o.id === t.id)) == null ? void 0 : n.value;
    }, t.getFilterIndex = () => {
      var n, o;
      return (n = (o = e.getState().columnFilters) == null ? void 0 : o.findIndex((l) => l.id === t.id)) != null ? n : -1;
    }, t.setFilterValue = (n) => {
      e.setColumnFilters((o) => {
        const l = t.getFilterFn(), u = o == null ? void 0 : o.find((g) => g.id === t.id), f = functionalUpdate(n, u ? u.value : void 0);
        if (shouldAutoRemoveFilter(l, f, t)) {
          var h;
          return (h = o == null ? void 0 : o.filter((g) => g.id !== t.id)) != null ? h : [];
        }
        const p = {
          id: t.id,
          value: f
        };
        if (u) {
          var v;
          return (v = o == null ? void 0 : o.map((g) => g.id === t.id ? p : g)) != null ? v : [];
        }
        return o != null && o.length ? [...o, p] : [p];
      });
    };
  },
  createRow: (t, e) => {
    t.columnFilters = {}, t.columnFiltersMeta = {};
  },
  createTable: (t) => {
    t.setColumnFilters = (e) => {
      const n = t.getAllLeafColumns(), o = (l) => {
        var u;
        return (u = functionalUpdate(e, l)) == null ? void 0 : u.filter((f) => {
          const h = n.find((p) => p.id === f.id);
          if (h) {
            const p = h.getFilterFn();
            if (shouldAutoRemoveFilter(p, f.value, h))
              return !1;
          }
          return !0;
        });
      };
      t.options.onColumnFiltersChange == null || t.options.onColumnFiltersChange(o);
    }, t.resetColumnFilters = (e) => {
      var n, o;
      t.setColumnFilters(e ? [] : (n = (o = t.initialState) == null ? void 0 : o.columnFilters) != null ? n : []);
    }, t.getPreFilteredRowModel = () => t.getCoreRowModel(), t.getFilteredRowModel = () => (!t._getFilteredRowModel && t.options.getFilteredRowModel && (t._getFilteredRowModel = t.options.getFilteredRowModel(t)), t.options.manualFiltering || !t._getFilteredRowModel ? t.getPreFilteredRowModel() : t._getFilteredRowModel());
  }
};
function shouldAutoRemoveFilter(t, e, n) {
  return (t && t.autoRemove ? t.autoRemove(e, n) : !1) || typeof e > "u" || typeof e == "string" && !e;
}
const sum = (t, e, n) => n.reduce((o, l) => {
  const u = l.getValue(t);
  return o + (typeof u == "number" ? u : 0);
}, 0), min$5 = (t, e, n) => {
  let o;
  return n.forEach((l) => {
    const u = l.getValue(t);
    u != null && (o > u || o === void 0 && u >= u) && (o = u);
  }), o;
}, max$5 = (t, e, n) => {
  let o;
  return n.forEach((l) => {
    const u = l.getValue(t);
    u != null && (o < u || o === void 0 && u >= u) && (o = u);
  }), o;
}, extent = (t, e, n) => {
  let o, l;
  return n.forEach((u) => {
    const f = u.getValue(t);
    f != null && (o === void 0 ? f >= f && (o = l = f) : (o > f && (o = f), l < f && (l = f)));
  }), [o, l];
}, mean = (t, e) => {
  let n = 0, o = 0;
  if (e.forEach((l) => {
    let u = l.getValue(t);
    u != null && (u = +u) >= u && (++n, o += u);
  }), n) return o / n;
}, median = (t, e) => {
  if (!e.length)
    return;
  const n = e.map((u) => u.getValue(t));
  if (!isNumberArray(n))
    return;
  if (n.length === 1)
    return n[0];
  const o = Math.floor(n.length / 2), l = n.sort((u, f) => u - f);
  return n.length % 2 !== 0 ? l[o] : (l[o - 1] + l[o]) / 2;
}, unique = (t, e) => Array.from(new Set(e.map((n) => n.getValue(t))).values()), uniqueCount = (t, e) => new Set(e.map((n) => n.getValue(t))).size, count$1 = (t, e) => e.length, aggregationFns = {
  sum,
  min: min$5,
  max: max$5,
  extent,
  mean,
  median,
  unique,
  uniqueCount,
  count: count$1
}, ColumnGrouping = {
  getDefaultColumnDef: () => ({
    aggregatedCell: (t) => {
      var e, n;
      return (e = (n = t.getValue()) == null || n.toString == null ? void 0 : n.toString()) != null ? e : null;
    },
    aggregationFn: "auto"
  }),
  getInitialState: (t) => ({
    grouping: [],
    ...t
  }),
  getDefaultOptions: (t) => ({
    onGroupingChange: makeStateUpdater("grouping", t),
    groupedColumnMode: "reorder"
  }),
  createColumn: (t, e) => {
    t.toggleGrouping = () => {
      e.setGrouping((n) => n != null && n.includes(t.id) ? n.filter((o) => o !== t.id) : [...n ?? [], t.id]);
    }, t.getCanGroup = () => {
      var n, o;
      return ((n = t.columnDef.enableGrouping) != null ? n : !0) && ((o = e.options.enableGrouping) != null ? o : !0) && (!!t.accessorFn || !!t.columnDef.getGroupingValue);
    }, t.getIsGrouped = () => {
      var n;
      return (n = e.getState().grouping) == null ? void 0 : n.includes(t.id);
    }, t.getGroupedIndex = () => {
      var n;
      return (n = e.getState().grouping) == null ? void 0 : n.indexOf(t.id);
    }, t.getToggleGroupingHandler = () => {
      const n = t.getCanGroup();
      return () => {
        n && t.toggleGrouping();
      };
    }, t.getAutoAggregationFn = () => {
      const n = e.getCoreRowModel().flatRows[0], o = n == null ? void 0 : n.getValue(t.id);
      if (typeof o == "number")
        return aggregationFns.sum;
      if (Object.prototype.toString.call(o) === "[object Date]")
        return aggregationFns.extent;
    }, t.getAggregationFn = () => {
      var n, o;
      if (!t)
        throw new Error();
      return isFunction$4(t.columnDef.aggregationFn) ? t.columnDef.aggregationFn : t.columnDef.aggregationFn === "auto" ? t.getAutoAggregationFn() : (n = (o = e.options.aggregationFns) == null ? void 0 : o[t.columnDef.aggregationFn]) != null ? n : aggregationFns[t.columnDef.aggregationFn];
    };
  },
  createTable: (t) => {
    t.setGrouping = (e) => t.options.onGroupingChange == null ? void 0 : t.options.onGroupingChange(e), t.resetGrouping = (e) => {
      var n, o;
      t.setGrouping(e ? [] : (n = (o = t.initialState) == null ? void 0 : o.grouping) != null ? n : []);
    }, t.getPreGroupedRowModel = () => t.getFilteredRowModel(), t.getGroupedRowModel = () => (!t._getGroupedRowModel && t.options.getGroupedRowModel && (t._getGroupedRowModel = t.options.getGroupedRowModel(t)), t.options.manualGrouping || !t._getGroupedRowModel ? t.getPreGroupedRowModel() : t._getGroupedRowModel());
  },
  createRow: (t, e) => {
    t.getIsGrouped = () => !!t.groupingColumnId, t.getGroupingValue = (n) => {
      if (t._groupingValuesCache.hasOwnProperty(n))
        return t._groupingValuesCache[n];
      const o = e.getColumn(n);
      return o != null && o.columnDef.getGroupingValue ? (t._groupingValuesCache[n] = o.columnDef.getGroupingValue(t.original), t._groupingValuesCache[n]) : t.getValue(n);
    }, t._groupingValuesCache = {};
  },
  createCell: (t, e, n, o) => {
    t.getIsGrouped = () => e.getIsGrouped() && e.id === n.groupingColumnId, t.getIsPlaceholder = () => !t.getIsGrouped() && e.getIsGrouped(), t.getIsAggregated = () => {
      var l;
      return !t.getIsGrouped() && !t.getIsPlaceholder() && !!((l = n.subRows) != null && l.length);
    };
  }
};
function orderColumns(t, e, n) {
  if (!(e != null && e.length) || !n)
    return t;
  const o = t.filter((u) => !e.includes(u.id));
  return n === "remove" ? o : [...e.map((u) => t.find((f) => f.id === u)).filter(Boolean), ...o];
}
const ColumnOrdering = {
  getInitialState: (t) => ({
    columnOrder: [],
    ...t
  }),
  getDefaultOptions: (t) => ({
    onColumnOrderChange: makeStateUpdater("columnOrder", t)
  }),
  createColumn: (t, e) => {
    t.getIndex = memo((n) => [_getVisibleLeafColumns(e, n)], (n) => n.findIndex((o) => o.id === t.id), getMemoOptions(e.options, "debugColumns", "getIndex")), t.getIsFirstColumn = (n) => {
      var o;
      return ((o = _getVisibleLeafColumns(e, n)[0]) == null ? void 0 : o.id) === t.id;
    }, t.getIsLastColumn = (n) => {
      var o;
      const l = _getVisibleLeafColumns(e, n);
      return ((o = l[l.length - 1]) == null ? void 0 : o.id) === t.id;
    };
  },
  createTable: (t) => {
    t.setColumnOrder = (e) => t.options.onColumnOrderChange == null ? void 0 : t.options.onColumnOrderChange(e), t.resetColumnOrder = (e) => {
      var n;
      t.setColumnOrder(e ? [] : (n = t.initialState.columnOrder) != null ? n : []);
    }, t._getOrderColumnsFn = memo(() => [t.getState().columnOrder, t.getState().grouping, t.options.groupedColumnMode], (e, n, o) => (l) => {
      let u = [];
      if (!(e != null && e.length))
        u = l;
      else {
        const f = [...e], h = [...l];
        for (; h.length && f.length; ) {
          const p = f.shift(), v = h.findIndex((g) => g.id === p);
          v > -1 && u.push(h.splice(v, 1)[0]);
        }
        u = [...u, ...h];
      }
      return orderColumns(u, n, o);
    }, getMemoOptions(t.options, "debugTable", "_getOrderColumnsFn"));
  }
}, getDefaultColumnPinningState = () => ({
  left: [],
  right: []
}), ColumnPinning = {
  getInitialState: (t) => ({
    columnPinning: getDefaultColumnPinningState(),
    ...t
  }),
  getDefaultOptions: (t) => ({
    onColumnPinningChange: makeStateUpdater("columnPinning", t)
  }),
  createColumn: (t, e) => {
    t.pin = (n) => {
      const o = t.getLeafColumns().map((l) => l.id).filter(Boolean);
      e.setColumnPinning((l) => {
        var u, f;
        if (n === "right") {
          var h, p;
          return {
            left: ((h = l == null ? void 0 : l.left) != null ? h : []).filter((w) => !(o != null && o.includes(w))),
            right: [...((p = l == null ? void 0 : l.right) != null ? p : []).filter((w) => !(o != null && o.includes(w))), ...o]
          };
        }
        if (n === "left") {
          var v, g;
          return {
            left: [...((v = l == null ? void 0 : l.left) != null ? v : []).filter((w) => !(o != null && o.includes(w))), ...o],
            right: ((g = l == null ? void 0 : l.right) != null ? g : []).filter((w) => !(o != null && o.includes(w)))
          };
        }
        return {
          left: ((u = l == null ? void 0 : l.left) != null ? u : []).filter((w) => !(o != null && o.includes(w))),
          right: ((f = l == null ? void 0 : l.right) != null ? f : []).filter((w) => !(o != null && o.includes(w)))
        };
      });
    }, t.getCanPin = () => t.getLeafColumns().some((o) => {
      var l, u, f;
      return ((l = o.columnDef.enablePinning) != null ? l : !0) && ((u = (f = e.options.enableColumnPinning) != null ? f : e.options.enablePinning) != null ? u : !0);
    }), t.getIsPinned = () => {
      const n = t.getLeafColumns().map((h) => h.id), {
        left: o,
        right: l
      } = e.getState().columnPinning, u = n.some((h) => o == null ? void 0 : o.includes(h)), f = n.some((h) => l == null ? void 0 : l.includes(h));
      return u ? "left" : f ? "right" : !1;
    }, t.getPinnedIndex = () => {
      var n, o;
      const l = t.getIsPinned();
      return l ? (n = (o = e.getState().columnPinning) == null || (o = o[l]) == null ? void 0 : o.indexOf(t.id)) != null ? n : -1 : 0;
    };
  },
  createRow: (t, e) => {
    t.getCenterVisibleCells = memo(() => [t._getAllVisibleCells(), e.getState().columnPinning.left, e.getState().columnPinning.right], (n, o, l) => {
      const u = [...o ?? [], ...l ?? []];
      return n.filter((f) => !u.includes(f.column.id));
    }, getMemoOptions(e.options, "debugRows", "getCenterVisibleCells")), t.getLeftVisibleCells = memo(() => [t._getAllVisibleCells(), e.getState().columnPinning.left], (n, o) => (o ?? []).map((u) => n.find((f) => f.column.id === u)).filter(Boolean).map((u) => ({
      ...u,
      position: "left"
    })), getMemoOptions(e.options, "debugRows", "getLeftVisibleCells")), t.getRightVisibleCells = memo(() => [t._getAllVisibleCells(), e.getState().columnPinning.right], (n, o) => (o ?? []).map((u) => n.find((f) => f.column.id === u)).filter(Boolean).map((u) => ({
      ...u,
      position: "right"
    })), getMemoOptions(e.options, "debugRows", "getRightVisibleCells"));
  },
  createTable: (t) => {
    t.setColumnPinning = (e) => t.options.onColumnPinningChange == null ? void 0 : t.options.onColumnPinningChange(e), t.resetColumnPinning = (e) => {
      var n, o;
      return t.setColumnPinning(e ? getDefaultColumnPinningState() : (n = (o = t.initialState) == null ? void 0 : o.columnPinning) != null ? n : getDefaultColumnPinningState());
    }, t.getIsSomeColumnsPinned = (e) => {
      var n;
      const o = t.getState().columnPinning;
      if (!e) {
        var l, u;
        return !!((l = o.left) != null && l.length || (u = o.right) != null && u.length);
      }
      return !!((n = o[e]) != null && n.length);
    }, t.getLeftLeafColumns = memo(() => [t.getAllLeafColumns(), t.getState().columnPinning.left], (e, n) => (n ?? []).map((o) => e.find((l) => l.id === o)).filter(Boolean), getMemoOptions(t.options, "debugColumns", "getLeftLeafColumns")), t.getRightLeafColumns = memo(() => [t.getAllLeafColumns(), t.getState().columnPinning.right], (e, n) => (n ?? []).map((o) => e.find((l) => l.id === o)).filter(Boolean), getMemoOptions(t.options, "debugColumns", "getRightLeafColumns")), t.getCenterLeafColumns = memo(() => [t.getAllLeafColumns(), t.getState().columnPinning.left, t.getState().columnPinning.right], (e, n, o) => {
      const l = [...n ?? [], ...o ?? []];
      return e.filter((u) => !l.includes(u.id));
    }, getMemoOptions(t.options, "debugColumns", "getCenterLeafColumns"));
  }
}, defaultColumnSizing = {
  size: 150,
  minSize: 20,
  maxSize: Number.MAX_SAFE_INTEGER
}, getDefaultColumnSizingInfoState = () => ({
  startOffset: null,
  startSize: null,
  deltaOffset: null,
  deltaPercentage: null,
  isResizingColumn: !1,
  columnSizingStart: []
}), ColumnSizing = {
  getDefaultColumnDef: () => defaultColumnSizing,
  getInitialState: (t) => ({
    columnSizing: {},
    columnSizingInfo: getDefaultColumnSizingInfoState(),
    ...t
  }),
  getDefaultOptions: (t) => ({
    columnResizeMode: "onEnd",
    columnResizeDirection: "ltr",
    onColumnSizingChange: makeStateUpdater("columnSizing", t),
    onColumnSizingInfoChange: makeStateUpdater("columnSizingInfo", t)
  }),
  createColumn: (t, e) => {
    t.getSize = () => {
      var n, o, l;
      const u = e.getState().columnSizing[t.id];
      return Math.min(Math.max((n = t.columnDef.minSize) != null ? n : defaultColumnSizing.minSize, (o = u ?? t.columnDef.size) != null ? o : defaultColumnSizing.size), (l = t.columnDef.maxSize) != null ? l : defaultColumnSizing.maxSize);
    }, t.getStart = memo((n) => [n, _getVisibleLeafColumns(e, n), e.getState().columnSizing], (n, o) => o.slice(0, t.getIndex(n)).reduce((l, u) => l + u.getSize(), 0), getMemoOptions(e.options, "debugColumns", "getStart")), t.getAfter = memo((n) => [n, _getVisibleLeafColumns(e, n), e.getState().columnSizing], (n, o) => o.slice(t.getIndex(n) + 1).reduce((l, u) => l + u.getSize(), 0), getMemoOptions(e.options, "debugColumns", "getAfter")), t.resetSize = () => {
      e.setColumnSizing((n) => {
        let {
          [t.id]: o,
          ...l
        } = n;
        return l;
      });
    }, t.getCanResize = () => {
      var n, o;
      return ((n = t.columnDef.enableResizing) != null ? n : !0) && ((o = e.options.enableColumnResizing) != null ? o : !0);
    }, t.getIsResizing = () => e.getState().columnSizingInfo.isResizingColumn === t.id;
  },
  createHeader: (t, e) => {
    t.getSize = () => {
      let n = 0;
      const o = (l) => {
        if (l.subHeaders.length)
          l.subHeaders.forEach(o);
        else {
          var u;
          n += (u = l.column.getSize()) != null ? u : 0;
        }
      };
      return o(t), n;
    }, t.getStart = () => {
      if (t.index > 0) {
        const n = t.headerGroup.headers[t.index - 1];
        return n.getStart() + n.getSize();
      }
      return 0;
    }, t.getResizeHandler = (n) => {
      const o = e.getColumn(t.column.id), l = o == null ? void 0 : o.getCanResize();
      return (u) => {
        if (!o || !l || (u.persist == null || u.persist(), isTouchStartEvent(u) && u.touches && u.touches.length > 1))
          return;
        const f = t.getSize(), h = t ? t.getLeafHeaders().map((M) => [M.column.id, M.column.getSize()]) : [[o.id, o.getSize()]], p = isTouchStartEvent(u) ? Math.round(u.touches[0].clientX) : u.clientX, v = {}, g = (M, A) => {
          typeof A == "number" && (e.setColumnSizingInfo(($) => {
            var S, C;
            const D = e.options.columnResizeDirection === "rtl" ? -1 : 1, O = (A - ((S = $ == null ? void 0 : $.startOffset) != null ? S : 0)) * D, N = Math.max(O / ((C = $ == null ? void 0 : $.startSize) != null ? C : 0), -0.999999);
            return $.columnSizingStart.forEach((j) => {
              let [L, z] = j;
              v[L] = Math.round(Math.max(z + z * N, 0) * 100) / 100;
            }), {
              ...$,
              deltaOffset: O,
              deltaPercentage: N
            };
          }), (e.options.columnResizeMode === "onChange" || M === "end") && e.setColumnSizing(($) => ({
            ...$,
            ...v
          })));
        }, w = (M) => g("move", M), E = (M) => {
          g("end", M), e.setColumnSizingInfo((A) => ({
            ...A,
            isResizingColumn: !1,
            startOffset: null,
            startSize: null,
            deltaOffset: null,
            deltaPercentage: null,
            columnSizingStart: []
          }));
        }, T = n || typeof document < "u" ? document : null, R = {
          moveHandler: (M) => w(M.clientX),
          upHandler: (M) => {
            T == null || T.removeEventListener("mousemove", R.moveHandler), T == null || T.removeEventListener("mouseup", R.upHandler), E(M.clientX);
          }
        }, _ = {
          moveHandler: (M) => (M.cancelable && (M.preventDefault(), M.stopPropagation()), w(M.touches[0].clientX), !1),
          upHandler: (M) => {
            var A;
            T == null || T.removeEventListener("touchmove", _.moveHandler), T == null || T.removeEventListener("touchend", _.upHandler), M.cancelable && (M.preventDefault(), M.stopPropagation()), E((A = M.touches[0]) == null ? void 0 : A.clientX);
          }
        }, b = passiveEventSupported() ? {
          passive: !1
        } : !1;
        isTouchStartEvent(u) ? (T == null || T.addEventListener("touchmove", _.moveHandler, b), T == null || T.addEventListener("touchend", _.upHandler, b)) : (T == null || T.addEventListener("mousemove", R.moveHandler, b), T == null || T.addEventListener("mouseup", R.upHandler, b)), e.setColumnSizingInfo((M) => ({
          ...M,
          startOffset: p,
          startSize: f,
          deltaOffset: 0,
          deltaPercentage: 0,
          columnSizingStart: h,
          isResizingColumn: o.id
        }));
      };
    };
  },
  createTable: (t) => {
    t.setColumnSizing = (e) => t.options.onColumnSizingChange == null ? void 0 : t.options.onColumnSizingChange(e), t.setColumnSizingInfo = (e) => t.options.onColumnSizingInfoChange == null ? void 0 : t.options.onColumnSizingInfoChange(e), t.resetColumnSizing = (e) => {
      var n;
      t.setColumnSizing(e ? {} : (n = t.initialState.columnSizing) != null ? n : {});
    }, t.resetHeaderSizeInfo = (e) => {
      var n;
      t.setColumnSizingInfo(e ? getDefaultColumnSizingInfoState() : (n = t.initialState.columnSizingInfo) != null ? n : getDefaultColumnSizingInfoState());
    }, t.getTotalSize = () => {
      var e, n;
      return (e = (n = t.getHeaderGroups()[0]) == null ? void 0 : n.headers.reduce((o, l) => o + l.getSize(), 0)) != null ? e : 0;
    }, t.getLeftTotalSize = () => {
      var e, n;
      return (e = (n = t.getLeftHeaderGroups()[0]) == null ? void 0 : n.headers.reduce((o, l) => o + l.getSize(), 0)) != null ? e : 0;
    }, t.getCenterTotalSize = () => {
      var e, n;
      return (e = (n = t.getCenterHeaderGroups()[0]) == null ? void 0 : n.headers.reduce((o, l) => o + l.getSize(), 0)) != null ? e : 0;
    }, t.getRightTotalSize = () => {
      var e, n;
      return (e = (n = t.getRightHeaderGroups()[0]) == null ? void 0 : n.headers.reduce((o, l) => o + l.getSize(), 0)) != null ? e : 0;
    };
  }
};
let passiveSupported = null;
function passiveEventSupported() {
  if (typeof passiveSupported == "boolean") return passiveSupported;
  let t = !1;
  try {
    const e = {
      get passive() {
        return t = !0, !1;
      }
    }, n = () => {
    };
    window.addEventListener("test", n, e), window.removeEventListener("test", n);
  } catch {
    t = !1;
  }
  return passiveSupported = t, passiveSupported;
}
function isTouchStartEvent(t) {
  return t.type === "touchstart";
}
const ColumnVisibility = {
  getInitialState: (t) => ({
    columnVisibility: {},
    ...t
  }),
  getDefaultOptions: (t) => ({
    onColumnVisibilityChange: makeStateUpdater("columnVisibility", t)
  }),
  createColumn: (t, e) => {
    t.toggleVisibility = (n) => {
      t.getCanHide() && e.setColumnVisibility((o) => ({
        ...o,
        [t.id]: n ?? !t.getIsVisible()
      }));
    }, t.getIsVisible = () => {
      var n, o;
      const l = t.columns;
      return (n = l.length ? l.some((u) => u.getIsVisible()) : (o = e.getState().columnVisibility) == null ? void 0 : o[t.id]) != null ? n : !0;
    }, t.getCanHide = () => {
      var n, o;
      return ((n = t.columnDef.enableHiding) != null ? n : !0) && ((o = e.options.enableHiding) != null ? o : !0);
    }, t.getToggleVisibilityHandler = () => (n) => {
      t.toggleVisibility == null || t.toggleVisibility(n.target.checked);
    };
  },
  createRow: (t, e) => {
    t._getAllVisibleCells = memo(() => [t.getAllCells(), e.getState().columnVisibility], (n) => n.filter((o) => o.column.getIsVisible()), getMemoOptions(e.options, "debugRows", "_getAllVisibleCells")), t.getVisibleCells = memo(() => [t.getLeftVisibleCells(), t.getCenterVisibleCells(), t.getRightVisibleCells()], (n, o, l) => [...n, ...o, ...l], getMemoOptions(e.options, "debugRows", "getVisibleCells"));
  },
  createTable: (t) => {
    const e = (n, o) => memo(() => [o(), o().filter((l) => l.getIsVisible()).map((l) => l.id).join("_")], (l) => l.filter((u) => u.getIsVisible == null ? void 0 : u.getIsVisible()), getMemoOptions(t.options, "debugColumns", n));
    t.getVisibleFlatColumns = e("getVisibleFlatColumns", () => t.getAllFlatColumns()), t.getVisibleLeafColumns = e("getVisibleLeafColumns", () => t.getAllLeafColumns()), t.getLeftVisibleLeafColumns = e("getLeftVisibleLeafColumns", () => t.getLeftLeafColumns()), t.getRightVisibleLeafColumns = e("getRightVisibleLeafColumns", () => t.getRightLeafColumns()), t.getCenterVisibleLeafColumns = e("getCenterVisibleLeafColumns", () => t.getCenterLeafColumns()), t.setColumnVisibility = (n) => t.options.onColumnVisibilityChange == null ? void 0 : t.options.onColumnVisibilityChange(n), t.resetColumnVisibility = (n) => {
      var o;
      t.setColumnVisibility(n ? {} : (o = t.initialState.columnVisibility) != null ? o : {});
    }, t.toggleAllColumnsVisible = (n) => {
      var o;
      n = (o = n) != null ? o : !t.getIsAllColumnsVisible(), t.setColumnVisibility(t.getAllLeafColumns().reduce((l, u) => ({
        ...l,
        [u.id]: n || !(u.getCanHide != null && u.getCanHide())
      }), {}));
    }, t.getIsAllColumnsVisible = () => !t.getAllLeafColumns().some((n) => !(n.getIsVisible != null && n.getIsVisible())), t.getIsSomeColumnsVisible = () => t.getAllLeafColumns().some((n) => n.getIsVisible == null ? void 0 : n.getIsVisible()), t.getToggleAllColumnsVisibilityHandler = () => (n) => {
      var o;
      t.toggleAllColumnsVisible((o = n.target) == null ? void 0 : o.checked);
    };
  }
};
function _getVisibleLeafColumns(t, e) {
  return e ? e === "center" ? t.getCenterVisibleLeafColumns() : e === "left" ? t.getLeftVisibleLeafColumns() : t.getRightVisibleLeafColumns() : t.getVisibleLeafColumns();
}
const GlobalFaceting = {
  createTable: (t) => {
    t._getGlobalFacetedRowModel = t.options.getFacetedRowModel && t.options.getFacetedRowModel(t, "__global__"), t.getGlobalFacetedRowModel = () => t.options.manualFiltering || !t._getGlobalFacetedRowModel ? t.getPreFilteredRowModel() : t._getGlobalFacetedRowModel(), t._getGlobalFacetedUniqueValues = t.options.getFacetedUniqueValues && t.options.getFacetedUniqueValues(t, "__global__"), t.getGlobalFacetedUniqueValues = () => t._getGlobalFacetedUniqueValues ? t._getGlobalFacetedUniqueValues() : /* @__PURE__ */ new Map(), t._getGlobalFacetedMinMaxValues = t.options.getFacetedMinMaxValues && t.options.getFacetedMinMaxValues(t, "__global__"), t.getGlobalFacetedMinMaxValues = () => {
      if (t._getGlobalFacetedMinMaxValues)
        return t._getGlobalFacetedMinMaxValues();
    };
  }
}, GlobalFiltering = {
  getInitialState: (t) => ({
    globalFilter: void 0,
    ...t
  }),
  getDefaultOptions: (t) => ({
    onGlobalFilterChange: makeStateUpdater("globalFilter", t),
    globalFilterFn: "auto",
    getColumnCanGlobalFilter: (e) => {
      var n;
      const o = (n = t.getCoreRowModel().flatRows[0]) == null || (n = n._getAllCellsByColumnId()[e.id]) == null ? void 0 : n.getValue();
      return typeof o == "string" || typeof o == "number";
    }
  }),
  createColumn: (t, e) => {
    t.getCanGlobalFilter = () => {
      var n, o, l, u;
      return ((n = t.columnDef.enableGlobalFilter) != null ? n : !0) && ((o = e.options.enableGlobalFilter) != null ? o : !0) && ((l = e.options.enableFilters) != null ? l : !0) && ((u = e.options.getColumnCanGlobalFilter == null ? void 0 : e.options.getColumnCanGlobalFilter(t)) != null ? u : !0) && !!t.accessorFn;
    };
  },
  createTable: (t) => {
    t.getGlobalAutoFilterFn = () => filterFns.includesString, t.getGlobalFilterFn = () => {
      var e, n;
      const {
        globalFilterFn: o
      } = t.options;
      return isFunction$4(o) ? o : o === "auto" ? t.getGlobalAutoFilterFn() : (e = (n = t.options.filterFns) == null ? void 0 : n[o]) != null ? e : filterFns[o];
    }, t.setGlobalFilter = (e) => {
      t.options.onGlobalFilterChange == null || t.options.onGlobalFilterChange(e);
    }, t.resetGlobalFilter = (e) => {
      t.setGlobalFilter(e ? void 0 : t.initialState.globalFilter);
    };
  }
}, RowExpanding = {
  getInitialState: (t) => ({
    expanded: {},
    ...t
  }),
  getDefaultOptions: (t) => ({
    onExpandedChange: makeStateUpdater("expanded", t),
    paginateExpandedRows: !0
  }),
  createTable: (t) => {
    let e = !1, n = !1;
    t._autoResetExpanded = () => {
      var o, l;
      if (!e) {
        t._queue(() => {
          e = !0;
        });
        return;
      }
      if ((o = (l = t.options.autoResetAll) != null ? l : t.options.autoResetExpanded) != null ? o : !t.options.manualExpanding) {
        if (n) return;
        n = !0, t._queue(() => {
          t.resetExpanded(), n = !1;
        });
      }
    }, t.setExpanded = (o) => t.options.onExpandedChange == null ? void 0 : t.options.onExpandedChange(o), t.toggleAllRowsExpanded = (o) => {
      o ?? !t.getIsAllRowsExpanded() ? t.setExpanded(!0) : t.setExpanded({});
    }, t.resetExpanded = (o) => {
      var l, u;
      t.setExpanded(o ? {} : (l = (u = t.initialState) == null ? void 0 : u.expanded) != null ? l : {});
    }, t.getCanSomeRowsExpand = () => t.getPrePaginationRowModel().flatRows.some((o) => o.getCanExpand()), t.getToggleAllRowsExpandedHandler = () => (o) => {
      o.persist == null || o.persist(), t.toggleAllRowsExpanded();
    }, t.getIsSomeRowsExpanded = () => {
      const o = t.getState().expanded;
      return o === !0 || Object.values(o).some(Boolean);
    }, t.getIsAllRowsExpanded = () => {
      const o = t.getState().expanded;
      return typeof o == "boolean" ? o === !0 : !(!Object.keys(o).length || t.getRowModel().flatRows.some((l) => !l.getIsExpanded()));
    }, t.getExpandedDepth = () => {
      let o = 0;
      return (t.getState().expanded === !0 ? Object.keys(t.getRowModel().rowsById) : Object.keys(t.getState().expanded)).forEach((u) => {
        const f = u.split(".");
        o = Math.max(o, f.length);
      }), o;
    }, t.getPreExpandedRowModel = () => t.getSortedRowModel(), t.getExpandedRowModel = () => (!t._getExpandedRowModel && t.options.getExpandedRowModel && (t._getExpandedRowModel = t.options.getExpandedRowModel(t)), t.options.manualExpanding || !t._getExpandedRowModel ? t.getPreExpandedRowModel() : t._getExpandedRowModel());
  },
  createRow: (t, e) => {
    t.toggleExpanded = (n) => {
      e.setExpanded((o) => {
        var l;
        const u = o === !0 ? !0 : !!(o != null && o[t.id]);
        let f = {};
        if (o === !0 ? Object.keys(e.getRowModel().rowsById).forEach((h) => {
          f[h] = !0;
        }) : f = o, n = (l = n) != null ? l : !u, !u && n)
          return {
            ...f,
            [t.id]: !0
          };
        if (u && !n) {
          const {
            [t.id]: h,
            ...p
          } = f;
          return p;
        }
        return o;
      });
    }, t.getIsExpanded = () => {
      var n;
      const o = e.getState().expanded;
      return !!((n = e.options.getIsRowExpanded == null ? void 0 : e.options.getIsRowExpanded(t)) != null ? n : o === !0 || o != null && o[t.id]);
    }, t.getCanExpand = () => {
      var n, o, l;
      return (n = e.options.getRowCanExpand == null ? void 0 : e.options.getRowCanExpand(t)) != null ? n : ((o = e.options.enableExpanding) != null ? o : !0) && !!((l = t.subRows) != null && l.length);
    }, t.getIsAllParentsExpanded = () => {
      let n = !0, o = t;
      for (; n && o.parentId; )
        o = e.getRow(o.parentId, !0), n = o.getIsExpanded();
      return n;
    }, t.getToggleExpandedHandler = () => {
      const n = t.getCanExpand();
      return () => {
        n && t.toggleExpanded();
      };
    };
  }
}, defaultPageIndex = 0, defaultPageSize = 10, getDefaultPaginationState = () => ({
  pageIndex: defaultPageIndex,
  pageSize: defaultPageSize
}), RowPagination = {
  getInitialState: (t) => ({
    ...t,
    pagination: {
      ...getDefaultPaginationState(),
      ...t == null ? void 0 : t.pagination
    }
  }),
  getDefaultOptions: (t) => ({
    onPaginationChange: makeStateUpdater("pagination", t)
  }),
  createTable: (t) => {
    let e = !1, n = !1;
    t._autoResetPageIndex = () => {
      var o, l;
      if (!e) {
        t._queue(() => {
          e = !0;
        });
        return;
      }
      if ((o = (l = t.options.autoResetAll) != null ? l : t.options.autoResetPageIndex) != null ? o : !t.options.manualPagination) {
        if (n) return;
        n = !0, t._queue(() => {
          t.resetPageIndex(), n = !1;
        });
      }
    }, t.setPagination = (o) => {
      const l = (u) => functionalUpdate(o, u);
      return t.options.onPaginationChange == null ? void 0 : t.options.onPaginationChange(l);
    }, t.resetPagination = (o) => {
      var l;
      t.setPagination(o ? getDefaultPaginationState() : (l = t.initialState.pagination) != null ? l : getDefaultPaginationState());
    }, t.setPageIndex = (o) => {
      t.setPagination((l) => {
        let u = functionalUpdate(o, l.pageIndex);
        const f = typeof t.options.pageCount > "u" || t.options.pageCount === -1 ? Number.MAX_SAFE_INTEGER : t.options.pageCount - 1;
        return u = Math.max(0, Math.min(u, f)), {
          ...l,
          pageIndex: u
        };
      });
    }, t.resetPageIndex = (o) => {
      var l, u;
      t.setPageIndex(o ? defaultPageIndex : (l = (u = t.initialState) == null || (u = u.pagination) == null ? void 0 : u.pageIndex) != null ? l : defaultPageIndex);
    }, t.resetPageSize = (o) => {
      var l, u;
      t.setPageSize(o ? defaultPageSize : (l = (u = t.initialState) == null || (u = u.pagination) == null ? void 0 : u.pageSize) != null ? l : defaultPageSize);
    }, t.setPageSize = (o) => {
      t.setPagination((l) => {
        const u = Math.max(1, functionalUpdate(o, l.pageSize)), f = l.pageSize * l.pageIndex, h = Math.floor(f / u);
        return {
          ...l,
          pageIndex: h,
          pageSize: u
        };
      });
    }, t.setPageCount = (o) => t.setPagination((l) => {
      var u;
      let f = functionalUpdate(o, (u = t.options.pageCount) != null ? u : -1);
      return typeof f == "number" && (f = Math.max(-1, f)), {
        ...l,
        pageCount: f
      };
    }), t.getPageOptions = memo(() => [t.getPageCount()], (o) => {
      let l = [];
      return o && o > 0 && (l = [...new Array(o)].fill(null).map((u, f) => f)), l;
    }, getMemoOptions(t.options, "debugTable", "getPageOptions")), t.getCanPreviousPage = () => t.getState().pagination.pageIndex > 0, t.getCanNextPage = () => {
      const {
        pageIndex: o
      } = t.getState().pagination, l = t.getPageCount();
      return l === -1 ? !0 : l === 0 ? !1 : o < l - 1;
    }, t.previousPage = () => t.setPageIndex((o) => o - 1), t.nextPage = () => t.setPageIndex((o) => o + 1), t.firstPage = () => t.setPageIndex(0), t.lastPage = () => t.setPageIndex(t.getPageCount() - 1), t.getPrePaginationRowModel = () => t.getExpandedRowModel(), t.getPaginationRowModel = () => (!t._getPaginationRowModel && t.options.getPaginationRowModel && (t._getPaginationRowModel = t.options.getPaginationRowModel(t)), t.options.manualPagination || !t._getPaginationRowModel ? t.getPrePaginationRowModel() : t._getPaginationRowModel()), t.getPageCount = () => {
      var o;
      return (o = t.options.pageCount) != null ? o : Math.ceil(t.getRowCount() / t.getState().pagination.pageSize);
    }, t.getRowCount = () => {
      var o;
      return (o = t.options.rowCount) != null ? o : t.getPrePaginationRowModel().rows.length;
    };
  }
}, getDefaultRowPinningState = () => ({
  top: [],
  bottom: []
}), RowPinning = {
  getInitialState: (t) => ({
    rowPinning: getDefaultRowPinningState(),
    ...t
  }),
  getDefaultOptions: (t) => ({
    onRowPinningChange: makeStateUpdater("rowPinning", t)
  }),
  createRow: (t, e) => {
    t.pin = (n, o, l) => {
      const u = o ? t.getLeafRows().map((p) => {
        let {
          id: v
        } = p;
        return v;
      }) : [], f = l ? t.getParentRows().map((p) => {
        let {
          id: v
        } = p;
        return v;
      }) : [], h = /* @__PURE__ */ new Set([...f, t.id, ...u]);
      e.setRowPinning((p) => {
        var v, g;
        if (n === "bottom") {
          var w, E;
          return {
            top: ((w = p == null ? void 0 : p.top) != null ? w : []).filter((_) => !(h != null && h.has(_))),
            bottom: [...((E = p == null ? void 0 : p.bottom) != null ? E : []).filter((_) => !(h != null && h.has(_))), ...Array.from(h)]
          };
        }
        if (n === "top") {
          var T, R;
          return {
            top: [...((T = p == null ? void 0 : p.top) != null ? T : []).filter((_) => !(h != null && h.has(_))), ...Array.from(h)],
            bottom: ((R = p == null ? void 0 : p.bottom) != null ? R : []).filter((_) => !(h != null && h.has(_)))
          };
        }
        return {
          top: ((v = p == null ? void 0 : p.top) != null ? v : []).filter((_) => !(h != null && h.has(_))),
          bottom: ((g = p == null ? void 0 : p.bottom) != null ? g : []).filter((_) => !(h != null && h.has(_)))
        };
      });
    }, t.getCanPin = () => {
      var n;
      const {
        enableRowPinning: o,
        enablePinning: l
      } = e.options;
      return typeof o == "function" ? o(t) : (n = o ?? l) != null ? n : !0;
    }, t.getIsPinned = () => {
      const n = [t.id], {
        top: o,
        bottom: l
      } = e.getState().rowPinning, u = n.some((h) => o == null ? void 0 : o.includes(h)), f = n.some((h) => l == null ? void 0 : l.includes(h));
      return u ? "top" : f ? "bottom" : !1;
    }, t.getPinnedIndex = () => {
      var n, o;
      const l = t.getIsPinned();
      if (!l) return -1;
      const u = (n = l === "top" ? e.getTopRows() : e.getBottomRows()) == null ? void 0 : n.map((f) => {
        let {
          id: h
        } = f;
        return h;
      });
      return (o = u == null ? void 0 : u.indexOf(t.id)) != null ? o : -1;
    };
  },
  createTable: (t) => {
    t.setRowPinning = (e) => t.options.onRowPinningChange == null ? void 0 : t.options.onRowPinningChange(e), t.resetRowPinning = (e) => {
      var n, o;
      return t.setRowPinning(e ? getDefaultRowPinningState() : (n = (o = t.initialState) == null ? void 0 : o.rowPinning) != null ? n : getDefaultRowPinningState());
    }, t.getIsSomeRowsPinned = (e) => {
      var n;
      const o = t.getState().rowPinning;
      if (!e) {
        var l, u;
        return !!((l = o.top) != null && l.length || (u = o.bottom) != null && u.length);
      }
      return !!((n = o[e]) != null && n.length);
    }, t._getPinnedRows = (e, n, o) => {
      var l;
      return ((l = t.options.keepPinnedRows) == null || l ? (
        //get all rows that are pinned even if they would not be otherwise visible
        //account for expanded parent rows, but not pagination or filtering
        (n ?? []).map((f) => {
          const h = t.getRow(f, !0);
          return h.getIsAllParentsExpanded() ? h : null;
        })
      ) : (
        //else get only visible rows that are pinned
        (n ?? []).map((f) => e.find((h) => h.id === f))
      )).filter(Boolean).map((f) => ({
        ...f,
        position: o
      }));
    }, t.getTopRows = memo(() => [t.getRowModel().rows, t.getState().rowPinning.top], (e, n) => t._getPinnedRows(e, n, "top"), getMemoOptions(t.options, "debugRows", "getTopRows")), t.getBottomRows = memo(() => [t.getRowModel().rows, t.getState().rowPinning.bottom], (e, n) => t._getPinnedRows(e, n, "bottom"), getMemoOptions(t.options, "debugRows", "getBottomRows")), t.getCenterRows = memo(() => [t.getRowModel().rows, t.getState().rowPinning.top, t.getState().rowPinning.bottom], (e, n, o) => {
      const l = /* @__PURE__ */ new Set([...n ?? [], ...o ?? []]);
      return e.filter((u) => !l.has(u.id));
    }, getMemoOptions(t.options, "debugRows", "getCenterRows"));
  }
}, RowSelection = {
  getInitialState: (t) => ({
    rowSelection: {},
    ...t
  }),
  getDefaultOptions: (t) => ({
    onRowSelectionChange: makeStateUpdater("rowSelection", t),
    enableRowSelection: !0,
    enableMultiRowSelection: !0,
    enableSubRowSelection: !0
    // enableGroupingRowSelection: false,
    // isAdditiveSelectEvent: (e: unknown) => !!e.metaKey,
    // isInclusiveSelectEvent: (e: unknown) => !!e.shiftKey,
  }),
  createTable: (t) => {
    t.setRowSelection = (e) => t.options.onRowSelectionChange == null ? void 0 : t.options.onRowSelectionChange(e), t.resetRowSelection = (e) => {
      var n;
      return t.setRowSelection(e ? {} : (n = t.initialState.rowSelection) != null ? n : {});
    }, t.toggleAllRowsSelected = (e) => {
      t.setRowSelection((n) => {
        e = typeof e < "u" ? e : !t.getIsAllRowsSelected();
        const o = {
          ...n
        }, l = t.getPreGroupedRowModel().flatRows;
        return e ? l.forEach((u) => {
          u.getCanSelect() && (o[u.id] = !0);
        }) : l.forEach((u) => {
          delete o[u.id];
        }), o;
      });
    }, t.toggleAllPageRowsSelected = (e) => t.setRowSelection((n) => {
      const o = typeof e < "u" ? e : !t.getIsAllPageRowsSelected(), l = {
        ...n
      };
      return t.getRowModel().rows.forEach((u) => {
        mutateRowIsSelected(l, u.id, o, !0, t);
      }), l;
    }), t.getPreSelectedRowModel = () => t.getCoreRowModel(), t.getSelectedRowModel = memo(() => [t.getState().rowSelection, t.getCoreRowModel()], (e, n) => Object.keys(e).length ? selectRowsFn(t, n) : {
      rows: [],
      flatRows: [],
      rowsById: {}
    }, getMemoOptions(t.options, "debugTable", "getSelectedRowModel")), t.getFilteredSelectedRowModel = memo(() => [t.getState().rowSelection, t.getFilteredRowModel()], (e, n) => Object.keys(e).length ? selectRowsFn(t, n) : {
      rows: [],
      flatRows: [],
      rowsById: {}
    }, getMemoOptions(t.options, "debugTable", "getFilteredSelectedRowModel")), t.getGroupedSelectedRowModel = memo(() => [t.getState().rowSelection, t.getSortedRowModel()], (e, n) => Object.keys(e).length ? selectRowsFn(t, n) : {
      rows: [],
      flatRows: [],
      rowsById: {}
    }, getMemoOptions(t.options, "debugTable", "getGroupedSelectedRowModel")), t.getIsAllRowsSelected = () => {
      const e = t.getFilteredRowModel().flatRows, {
        rowSelection: n
      } = t.getState();
      let o = !!(e.length && Object.keys(n).length);
      return o && e.some((l) => l.getCanSelect() && !n[l.id]) && (o = !1), o;
    }, t.getIsAllPageRowsSelected = () => {
      const e = t.getPaginationRowModel().flatRows.filter((l) => l.getCanSelect()), {
        rowSelection: n
      } = t.getState();
      let o = !!e.length;
      return o && e.some((l) => !n[l.id]) && (o = !1), o;
    }, t.getIsSomeRowsSelected = () => {
      var e;
      const n = Object.keys((e = t.getState().rowSelection) != null ? e : {}).length;
      return n > 0 && n < t.getFilteredRowModel().flatRows.length;
    }, t.getIsSomePageRowsSelected = () => {
      const e = t.getPaginationRowModel().flatRows;
      return t.getIsAllPageRowsSelected() ? !1 : e.filter((n) => n.getCanSelect()).some((n) => n.getIsSelected() || n.getIsSomeSelected());
    }, t.getToggleAllRowsSelectedHandler = () => (e) => {
      t.toggleAllRowsSelected(e.target.checked);
    }, t.getToggleAllPageRowsSelectedHandler = () => (e) => {
      t.toggleAllPageRowsSelected(e.target.checked);
    };
  },
  createRow: (t, e) => {
    t.toggleSelected = (n, o) => {
      const l = t.getIsSelected();
      e.setRowSelection((u) => {
        var f;
        if (n = typeof n < "u" ? n : !l, t.getCanSelect() && l === n)
          return u;
        const h = {
          ...u
        };
        return mutateRowIsSelected(h, t.id, n, (f = o == null ? void 0 : o.selectChildren) != null ? f : !0, e), h;
      });
    }, t.getIsSelected = () => {
      const {
        rowSelection: n
      } = e.getState();
      return isRowSelected(t, n);
    }, t.getIsSomeSelected = () => {
      const {
        rowSelection: n
      } = e.getState();
      return isSubRowSelected(t, n) === "some";
    }, t.getIsAllSubRowsSelected = () => {
      const {
        rowSelection: n
      } = e.getState();
      return isSubRowSelected(t, n) === "all";
    }, t.getCanSelect = () => {
      var n;
      return typeof e.options.enableRowSelection == "function" ? e.options.enableRowSelection(t) : (n = e.options.enableRowSelection) != null ? n : !0;
    }, t.getCanSelectSubRows = () => {
      var n;
      return typeof e.options.enableSubRowSelection == "function" ? e.options.enableSubRowSelection(t) : (n = e.options.enableSubRowSelection) != null ? n : !0;
    }, t.getCanMultiSelect = () => {
      var n;
      return typeof e.options.enableMultiRowSelection == "function" ? e.options.enableMultiRowSelection(t) : (n = e.options.enableMultiRowSelection) != null ? n : !0;
    }, t.getToggleSelectedHandler = () => {
      const n = t.getCanSelect();
      return (o) => {
        var l;
        n && t.toggleSelected((l = o.target) == null ? void 0 : l.checked);
      };
    };
  }
}, mutateRowIsSelected = (t, e, n, o, l) => {
  var u;
  const f = l.getRow(e, !0);
  n ? (f.getCanMultiSelect() || Object.keys(t).forEach((h) => delete t[h]), f.getCanSelect() && (t[e] = !0)) : delete t[e], o && (u = f.subRows) != null && u.length && f.getCanSelectSubRows() && f.subRows.forEach((h) => mutateRowIsSelected(t, h.id, n, o, l));
};
function selectRowsFn(t, e) {
  const n = t.getState().rowSelection, o = [], l = {}, u = function(f, h) {
    return f.map((p) => {
      var v;
      const g = isRowSelected(p, n);
      if (g && (o.push(p), l[p.id] = p), (v = p.subRows) != null && v.length && (p = {
        ...p,
        subRows: u(p.subRows)
      }), g)
        return p;
    }).filter(Boolean);
  };
  return {
    rows: u(e.rows),
    flatRows: o,
    rowsById: l
  };
}
function isRowSelected(t, e) {
  var n;
  return (n = e[t.id]) != null ? n : !1;
}
function isSubRowSelected(t, e, n) {
  var o;
  if (!((o = t.subRows) != null && o.length)) return !1;
  let l = !0, u = !1;
  return t.subRows.forEach((f) => {
    if (!(u && !l) && (f.getCanSelect() && (isRowSelected(f, e) ? u = !0 : l = !1), f.subRows && f.subRows.length)) {
      const h = isSubRowSelected(f, e);
      h === "all" ? u = !0 : (h === "some" && (u = !0), l = !1);
    }
  }), l ? "all" : u ? "some" : !1;
}
const reSplitAlphaNumeric = /([0-9]+)/gm, alphanumeric = (t, e, n) => compareAlphanumeric(toString$4(t.getValue(n)).toLowerCase(), toString$4(e.getValue(n)).toLowerCase()), alphanumericCaseSensitive = (t, e, n) => compareAlphanumeric(toString$4(t.getValue(n)), toString$4(e.getValue(n))), text = (t, e, n) => compareBasic(toString$4(t.getValue(n)).toLowerCase(), toString$4(e.getValue(n)).toLowerCase()), textCaseSensitive = (t, e, n) => compareBasic(toString$4(t.getValue(n)), toString$4(e.getValue(n))), datetime = (t, e, n) => {
  const o = t.getValue(n), l = e.getValue(n);
  return o > l ? 1 : o < l ? -1 : 0;
}, basic = (t, e, n) => compareBasic(t.getValue(n), e.getValue(n));
function compareBasic(t, e) {
  return t === e ? 0 : t > e ? 1 : -1;
}
function toString$4(t) {
  return typeof t == "number" ? isNaN(t) || t === 1 / 0 || t === -1 / 0 ? "" : String(t) : typeof t == "string" ? t : "";
}
function compareAlphanumeric(t, e) {
  const n = t.split(reSplitAlphaNumeric).filter(Boolean), o = e.split(reSplitAlphaNumeric).filter(Boolean);
  for (; n.length && o.length; ) {
    const l = n.shift(), u = o.shift(), f = parseInt(l, 10), h = parseInt(u, 10), p = [f, h].sort();
    if (isNaN(p[0])) {
      if (l > u)
        return 1;
      if (u > l)
        return -1;
      continue;
    }
    if (isNaN(p[1]))
      return isNaN(f) ? -1 : 1;
    if (f > h)
      return 1;
    if (h > f)
      return -1;
  }
  return n.length - o.length;
}
const sortingFns = {
  alphanumeric,
  alphanumericCaseSensitive,
  text,
  textCaseSensitive,
  datetime,
  basic
}, RowSorting = {
  getInitialState: (t) => ({
    sorting: [],
    ...t
  }),
  getDefaultColumnDef: () => ({
    sortingFn: "auto",
    sortUndefined: 1
  }),
  getDefaultOptions: (t) => ({
    onSortingChange: makeStateUpdater("sorting", t),
    isMultiSortEvent: (e) => e.shiftKey
  }),
  createColumn: (t, e) => {
    t.getAutoSortingFn = () => {
      const n = e.getFilteredRowModel().flatRows.slice(10);
      let o = !1;
      for (const l of n) {
        const u = l == null ? void 0 : l.getValue(t.id);
        if (Object.prototype.toString.call(u) === "[object Date]")
          return sortingFns.datetime;
        if (typeof u == "string" && (o = !0, u.split(reSplitAlphaNumeric).length > 1))
          return sortingFns.alphanumeric;
      }
      return o ? sortingFns.text : sortingFns.basic;
    }, t.getAutoSortDir = () => {
      const n = e.getFilteredRowModel().flatRows[0];
      return typeof (n == null ? void 0 : n.getValue(t.id)) == "string" ? "asc" : "desc";
    }, t.getSortingFn = () => {
      var n, o;
      if (!t)
        throw new Error();
      return isFunction$4(t.columnDef.sortingFn) ? t.columnDef.sortingFn : t.columnDef.sortingFn === "auto" ? t.getAutoSortingFn() : (n = (o = e.options.sortingFns) == null ? void 0 : o[t.columnDef.sortingFn]) != null ? n : sortingFns[t.columnDef.sortingFn];
    }, t.toggleSorting = (n, o) => {
      const l = t.getNextSortingOrder(), u = typeof n < "u" && n !== null;
      e.setSorting((f) => {
        const h = f == null ? void 0 : f.find((T) => T.id === t.id), p = f == null ? void 0 : f.findIndex((T) => T.id === t.id);
        let v = [], g, w = u ? n : l === "desc";
        if (f != null && f.length && t.getCanMultiSort() && o ? h ? g = "toggle" : g = "add" : f != null && f.length && p !== f.length - 1 ? g = "replace" : h ? g = "toggle" : g = "replace", g === "toggle" && (u || l || (g = "remove")), g === "add") {
          var E;
          v = [...f, {
            id: t.id,
            desc: w
          }], v.splice(0, v.length - ((E = e.options.maxMultiSortColCount) != null ? E : Number.MAX_SAFE_INTEGER));
        } else g === "toggle" ? v = f.map((T) => T.id === t.id ? {
          ...T,
          desc: w
        } : T) : g === "remove" ? v = f.filter((T) => T.id !== t.id) : v = [{
          id: t.id,
          desc: w
        }];
        return v;
      });
    }, t.getFirstSortDir = () => {
      var n, o;
      return ((n = (o = t.columnDef.sortDescFirst) != null ? o : e.options.sortDescFirst) != null ? n : t.getAutoSortDir() === "desc") ? "desc" : "asc";
    }, t.getNextSortingOrder = (n) => {
      var o, l;
      const u = t.getFirstSortDir(), f = t.getIsSorted();
      return f ? f !== u && ((o = e.options.enableSortingRemoval) == null || o) && // If enableSortRemove, enable in general
      (!(n && (l = e.options.enableMultiRemove) != null) || l) ? !1 : f === "desc" ? "asc" : "desc" : u;
    }, t.getCanSort = () => {
      var n, o;
      return ((n = t.columnDef.enableSorting) != null ? n : !0) && ((o = e.options.enableSorting) != null ? o : !0) && !!t.accessorFn;
    }, t.getCanMultiSort = () => {
      var n, o;
      return (n = (o = t.columnDef.enableMultiSort) != null ? o : e.options.enableMultiSort) != null ? n : !!t.accessorFn;
    }, t.getIsSorted = () => {
      var n;
      const o = (n = e.getState().sorting) == null ? void 0 : n.find((l) => l.id === t.id);
      return o ? o.desc ? "desc" : "asc" : !1;
    }, t.getSortIndex = () => {
      var n, o;
      return (n = (o = e.getState().sorting) == null ? void 0 : o.findIndex((l) => l.id === t.id)) != null ? n : -1;
    }, t.clearSorting = () => {
      e.setSorting((n) => n != null && n.length ? n.filter((o) => o.id !== t.id) : []);
    }, t.getToggleSortingHandler = () => {
      const n = t.getCanSort();
      return (o) => {
        n && (o.persist == null || o.persist(), t.toggleSorting == null || t.toggleSorting(void 0, t.getCanMultiSort() ? e.options.isMultiSortEvent == null ? void 0 : e.options.isMultiSortEvent(o) : !1));
      };
    };
  },
  createTable: (t) => {
    t.setSorting = (e) => t.options.onSortingChange == null ? void 0 : t.options.onSortingChange(e), t.resetSorting = (e) => {
      var n, o;
      t.setSorting(e ? [] : (n = (o = t.initialState) == null ? void 0 : o.sorting) != null ? n : []);
    }, t.getPreSortedRowModel = () => t.getGroupedRowModel(), t.getSortedRowModel = () => (!t._getSortedRowModel && t.options.getSortedRowModel && (t._getSortedRowModel = t.options.getSortedRowModel(t)), t.options.manualSorting || !t._getSortedRowModel ? t.getPreSortedRowModel() : t._getSortedRowModel());
  }
}, builtInFeatures = [
  Headers,
  ColumnVisibility,
  ColumnOrdering,
  ColumnPinning,
  ColumnFaceting,
  ColumnFiltering,
  GlobalFaceting,
  //depends on ColumnFaceting
  GlobalFiltering,
  //depends on ColumnFiltering
  RowSorting,
  ColumnGrouping,
  //depends on RowSorting
  RowExpanding,
  RowPagination,
  RowPinning,
  RowSelection,
  ColumnSizing
];
function createTable(t) {
  var e, n;
  process.env.NODE_ENV !== "production" && (t.debugAll || t.debugTable) && console.info("Creating Table Instance...");
  const o = [...builtInFeatures, ...(e = t._features) != null ? e : []];
  let l = {
    _features: o
  };
  const u = l._features.reduce((E, T) => Object.assign(E, T.getDefaultOptions == null ? void 0 : T.getDefaultOptions(l)), {}), f = (E) => l.options.mergeOptions ? l.options.mergeOptions(u, E) : {
    ...u,
    ...E
  };
  let p = {
    ...{},
    ...(n = t.initialState) != null ? n : {}
  };
  l._features.forEach((E) => {
    var T;
    p = (T = E.getInitialState == null ? void 0 : E.getInitialState(p)) != null ? T : p;
  });
  const v = [];
  let g = !1;
  const w = {
    _features: o,
    options: {
      ...u,
      ...t
    },
    initialState: p,
    _queue: (E) => {
      v.push(E), g || (g = !0, Promise.resolve().then(() => {
        for (; v.length; )
          v.shift()();
        g = !1;
      }).catch((T) => setTimeout(() => {
        throw T;
      })));
    },
    reset: () => {
      l.setState(l.initialState);
    },
    setOptions: (E) => {
      const T = functionalUpdate(E, l.options);
      l.options = f(T);
    },
    getState: () => l.options.state,
    setState: (E) => {
      l.options.onStateChange == null || l.options.onStateChange(E);
    },
    _getRowId: (E, T, R) => {
      var _;
      return (_ = l.options.getRowId == null ? void 0 : l.options.getRowId(E, T, R)) != null ? _ : `${R ? [R.id, T].join(".") : T}`;
    },
    getCoreRowModel: () => (l._getCoreRowModel || (l._getCoreRowModel = l.options.getCoreRowModel(l)), l._getCoreRowModel()),
    // The final calls start at the bottom of the model,
    // expanded rows, which then work their way up
    getRowModel: () => l.getPaginationRowModel(),
    //in next version, we should just pass in the row model as the optional 2nd arg
    getRow: (E, T) => {
      let R = (T ? l.getPrePaginationRowModel() : l.getRowModel()).rowsById[E];
      if (!R && (R = l.getCoreRowModel().rowsById[E], !R))
        throw process.env.NODE_ENV !== "production" ? new Error(`getRow could not find row with ID: ${E}`) : new Error();
      return R;
    },
    _getDefaultColumnDef: memo(() => [l.options.defaultColumn], (E) => {
      var T;
      return E = (T = E) != null ? T : {}, {
        header: (R) => {
          const _ = R.header.column.columnDef;
          return _.accessorKey ? _.accessorKey : _.accessorFn ? _.id : null;
        },
        // footer: props => props.header.column.id,
        cell: (R) => {
          var _, b;
          return (_ = (b = R.renderValue()) == null || b.toString == null ? void 0 : b.toString()) != null ? _ : null;
        },
        ...l._features.reduce((R, _) => Object.assign(R, _.getDefaultColumnDef == null ? void 0 : _.getDefaultColumnDef()), {}),
        ...E
      };
    }, getMemoOptions(t, "debugColumns", "_getDefaultColumnDef")),
    _getColumnDefs: () => l.options.columns,
    getAllColumns: memo(() => [l._getColumnDefs()], (E) => {
      const T = function(R, _, b) {
        return b === void 0 && (b = 0), R.map((M) => {
          const A = createColumn(l, M, b, _), $ = M;
          return A.columns = $.columns ? T($.columns, A, b + 1) : [], A;
        });
      };
      return T(E);
    }, getMemoOptions(t, "debugColumns", "getAllColumns")),
    getAllFlatColumns: memo(() => [l.getAllColumns()], (E) => E.flatMap((T) => T.getFlatColumns()), getMemoOptions(t, "debugColumns", "getAllFlatColumns")),
    _getAllFlatColumnsById: memo(() => [l.getAllFlatColumns()], (E) => E.reduce((T, R) => (T[R.id] = R, T), {}), getMemoOptions(t, "debugColumns", "getAllFlatColumnsById")),
    getAllLeafColumns: memo(() => [l.getAllColumns(), l._getOrderColumnsFn()], (E, T) => {
      let R = E.flatMap((_) => _.getLeafColumns());
      return T(R);
    }, getMemoOptions(t, "debugColumns", "getAllLeafColumns")),
    getColumn: (E) => {
      const T = l._getAllFlatColumnsById()[E];
      return process.env.NODE_ENV !== "production" && !T && console.error(`[Table] Column with id '${E}' does not exist.`), T;
    }
  };
  Object.assign(l, w);
  for (let E = 0; E < l._features.length; E++) {
    const T = l._features[E];
    T == null || T.createTable == null || T.createTable(l);
  }
  return l;
}
function getCoreRowModel() {
  return (t) => memo(() => [t.options.data], (e) => {
    const n = {
      rows: [],
      flatRows: [],
      rowsById: {}
    }, o = function(l, u, f) {
      u === void 0 && (u = 0);
      const h = [];
      for (let v = 0; v < l.length; v++) {
        const g = createRow(t, t._getRowId(l[v], v, f), l[v], v, u, void 0, f == null ? void 0 : f.id);
        if (n.flatRows.push(g), n.rowsById[g.id] = g, h.push(g), t.options.getSubRows) {
          var p;
          g.originalSubRows = t.options.getSubRows(l[v], v), (p = g.originalSubRows) != null && p.length && (g.subRows = o(g.originalSubRows, u + 1, g));
        }
      }
      return h;
    };
    return n.rows = o(e), n;
  }, getMemoOptions(t.options, "debugTable", "getRowModel", () => t._autoResetPageIndex()));
}
function expandRows(t) {
  const e = [], n = (o) => {
    var l;
    e.push(o), (l = o.subRows) != null && l.length && o.getIsExpanded() && o.subRows.forEach(n);
  };
  return t.rows.forEach(n), {
    rows: e,
    flatRows: t.flatRows,
    rowsById: t.rowsById
  };
}
function filterRows(t, e, n) {
  return n.options.filterFromLeafRows ? filterRowModelFromLeafs(t, e, n) : filterRowModelFromRoot(t, e, n);
}
function filterRowModelFromLeafs(t, e, n) {
  var o;
  const l = [], u = {}, f = (o = n.options.maxLeafRowFilterDepth) != null ? o : 100, h = function(p, v) {
    v === void 0 && (v = 0);
    const g = [];
    for (let E = 0; E < p.length; E++) {
      var w;
      let T = p[E];
      const R = createRow(n, T.id, T.original, T.index, T.depth, void 0, T.parentId);
      if (R.columnFilters = T.columnFilters, (w = T.subRows) != null && w.length && v < f) {
        if (R.subRows = h(T.subRows, v + 1), T = R, e(T) && !R.subRows.length) {
          g.push(T), u[T.id] = T, l.push(T);
          continue;
        }
        if (e(T) || R.subRows.length) {
          g.push(T), u[T.id] = T, l.push(T);
          continue;
        }
      } else
        T = R, e(T) && (g.push(T), u[T.id] = T, l.push(T));
    }
    return g;
  };
  return {
    rows: h(t),
    flatRows: l,
    rowsById: u
  };
}
function filterRowModelFromRoot(t, e, n) {
  var o;
  const l = [], u = {}, f = (o = n.options.maxLeafRowFilterDepth) != null ? o : 100, h = function(p, v) {
    v === void 0 && (v = 0);
    const g = [];
    for (let E = 0; E < p.length; E++) {
      let T = p[E];
      if (e(T)) {
        var w;
        if ((w = T.subRows) != null && w.length && v < f) {
          const _ = createRow(n, T.id, T.original, T.index, T.depth, void 0, T.parentId);
          _.subRows = h(T.subRows, v + 1), T = _;
        }
        g.push(T), l.push(T), u[T.id] = T;
      }
    }
    return g;
  };
  return {
    rows: h(t),
    flatRows: l,
    rowsById: u
  };
}
function getFilteredRowModel() {
  return (t) => memo(() => [t.getPreFilteredRowModel(), t.getState().columnFilters, t.getState().globalFilter], (e, n, o) => {
    if (!e.rows.length || !(n != null && n.length) && !o) {
      for (let E = 0; E < e.flatRows.length; E++)
        e.flatRows[E].columnFilters = {}, e.flatRows[E].columnFiltersMeta = {};
      return e;
    }
    const l = [], u = [];
    (n ?? []).forEach((E) => {
      var T;
      const R = t.getColumn(E.id);
      if (!R)
        return;
      const _ = R.getFilterFn();
      if (!_) {
        process.env.NODE_ENV !== "production" && console.warn(`Could not find a valid 'column.filterFn' for column with the ID: ${R.id}.`);
        return;
      }
      l.push({
        id: E.id,
        filterFn: _,
        resolvedValue: (T = _.resolveFilterValue == null ? void 0 : _.resolveFilterValue(E.value)) != null ? T : E.value
      });
    });
    const f = (n ?? []).map((E) => E.id), h = t.getGlobalFilterFn(), p = t.getAllLeafColumns().filter((E) => E.getCanGlobalFilter());
    o && h && p.length && (f.push("__global__"), p.forEach((E) => {
      var T;
      u.push({
        id: E.id,
        filterFn: h,
        resolvedValue: (T = h.resolveFilterValue == null ? void 0 : h.resolveFilterValue(o)) != null ? T : o
      });
    }));
    let v, g;
    for (let E = 0; E < e.flatRows.length; E++) {
      const T = e.flatRows[E];
      if (T.columnFilters = {}, l.length)
        for (let R = 0; R < l.length; R++) {
          v = l[R];
          const _ = v.id;
          T.columnFilters[_] = v.filterFn(T, _, v.resolvedValue, (b) => {
            T.columnFiltersMeta[_] = b;
          });
        }
      if (u.length) {
        for (let R = 0; R < u.length; R++) {
          g = u[R];
          const _ = g.id;
          if (g.filterFn(T, _, g.resolvedValue, (b) => {
            T.columnFiltersMeta[_] = b;
          })) {
            T.columnFilters.__global__ = !0;
            break;
          }
        }
        T.columnFilters.__global__ !== !0 && (T.columnFilters.__global__ = !1);
      }
    }
    const w = (E) => {
      for (let T = 0; T < f.length; T++)
        if (E.columnFilters[f[T]] === !1)
          return !1;
      return !0;
    };
    return filterRows(e.rows, w, t);
  }, getMemoOptions(t.options, "debugTable", "getFilteredRowModel", () => t._autoResetPageIndex()));
}
function getPaginationRowModel(t) {
  return (e) => memo(() => [e.getState().pagination, e.getPrePaginationRowModel(), e.options.paginateExpandedRows ? void 0 : e.getState().expanded], (n, o) => {
    if (!o.rows.length)
      return o;
    const {
      pageSize: l,
      pageIndex: u
    } = n;
    let {
      rows: f,
      flatRows: h,
      rowsById: p
    } = o;
    const v = l * u, g = v + l;
    f = f.slice(v, g);
    let w;
    e.options.paginateExpandedRows ? w = {
      rows: f,
      flatRows: h,
      rowsById: p
    } : w = expandRows({
      rows: f,
      flatRows: h,
      rowsById: p
    }), w.flatRows = [];
    const E = (T) => {
      w.flatRows.push(T), T.subRows.length && T.subRows.forEach(E);
    };
    return w.rows.forEach(E), w;
  }, getMemoOptions(e.options, "debugTable", "getPaginationRowModel"));
}
function getSortedRowModel() {
  return (t) => memo(() => [t.getState().sorting, t.getPreSortedRowModel()], (e, n) => {
    if (!n.rows.length || !(e != null && e.length))
      return n;
    const o = t.getState().sorting, l = [], u = o.filter((p) => {
      var v;
      return (v = t.getColumn(p.id)) == null ? void 0 : v.getCanSort();
    }), f = {};
    u.forEach((p) => {
      const v = t.getColumn(p.id);
      v && (f[p.id] = {
        sortUndefined: v.columnDef.sortUndefined,
        invertSorting: v.columnDef.invertSorting,
        sortingFn: v.getSortingFn()
      });
    });
    const h = (p) => {
      const v = p.map((g) => ({
        ...g
      }));
      return v.sort((g, w) => {
        for (let T = 0; T < u.length; T += 1) {
          var E;
          const R = u[T], _ = f[R.id], b = _.sortUndefined, M = (E = R == null ? void 0 : R.desc) != null ? E : !1;
          let A = 0;
          if (b) {
            const $ = g.getValue(R.id), S = w.getValue(R.id), C = $ === void 0, D = S === void 0;
            if (C || D) {
              if (b === "first") return C ? -1 : 1;
              if (b === "last") return C ? 1 : -1;
              A = C && D ? 0 : C ? b : -b;
            }
          }
          if (A === 0 && (A = _.sortingFn(g, w, R.id)), A !== 0)
            return M && (A *= -1), _.invertSorting && (A *= -1), A;
        }
        return g.index - w.index;
      }), v.forEach((g) => {
        var w;
        l.push(g), (w = g.subRows) != null && w.length && (g.subRows = h(g.subRows));
      }), v;
    };
    return {
      rows: h(n.rows),
      flatRows: l,
      rowsById: n.rowsById
    };
  }, getMemoOptions(t.options, "debugTable", "getSortedRowModel", () => t._autoResetPageIndex()));
}
/**
   * react-table
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   */
function flexRender(t, e) {
  return t ? isReactComponent(t) ? /* @__PURE__ */ React.createElement(t, e) : t : null;
}
function isReactComponent(t) {
  return isClassComponent(t) || typeof t == "function" || isExoticComponent(t);
}
function isClassComponent(t) {
  return typeof t == "function" && (() => {
    const e = Object.getPrototypeOf(t);
    return e.prototype && e.prototype.isReactComponent;
  })();
}
function isExoticComponent(t) {
  return typeof t == "object" && typeof t.$$typeof == "symbol" && ["react.memo", "react.forward_ref"].includes(t.$$typeof.description);
}
function useReactTable(t) {
  const e = {
    state: {},
    // Dummy state
    onStateChange: () => {
    },
    // noop
    renderFallbackValue: null,
    ...t
  }, [n] = React.useState(() => ({
    current: createTable(e)
  })), [o, l] = React.useState(() => n.current.initialState);
  return n.current.setOptions((u) => ({
    ...u,
    ...t,
    state: {
      ...o,
      ...t.state
    },
    // Similarly, we'll maintain both our internal state and any user-provided
    // state.
    onStateChange: (f) => {
      l(f), t.onStateChange == null || t.onStateChange(f);
    }
  })), n.current;
}
function toDate(t) {
  const e = Object.prototype.toString.call(t);
  return t instanceof Date || typeof t == "object" && e === "[object Date]" ? new t.constructor(+t) : typeof t == "number" || e === "[object Number]" || typeof t == "string" || e === "[object String]" ? new Date(t) : /* @__PURE__ */ new Date(NaN);
}
function constructFrom(t, e) {
  return t instanceof Date ? new t.constructor(e) : new Date(e);
}
function addDays(t, e) {
  const n = toDate(t);
  return isNaN(e) ? constructFrom(t, NaN) : (e && n.setDate(n.getDate() + e), n);
}
function addMonths(t, e) {
  const n = toDate(t);
  if (isNaN(e)) return constructFrom(t, NaN);
  if (!e)
    return n;
  const o = n.getDate(), l = constructFrom(t, n.getTime());
  l.setMonth(n.getMonth() + e + 1, 0);
  const u = l.getDate();
  return o >= u ? l : (n.setFullYear(
    l.getFullYear(),
    l.getMonth(),
    o
  ), n);
}
function addMilliseconds(t, e) {
  const n = +toDate(t);
  return constructFrom(t, n + e);
}
const millisecondsInWeek = 6048e5, millisecondsInDay = 864e5, millisecondsInMinute = 6e4, millisecondsInHour = 36e5, millisecondsInSecond = 1e3;
function addHours(t, e) {
  return addMilliseconds(t, e * millisecondsInHour);
}
let defaultOptions = {};
function getDefaultOptions$1() {
  return defaultOptions;
}
function startOfWeek(t, e) {
  var h, p, v, g;
  const n = getDefaultOptions$1(), o = (e == null ? void 0 : e.weekStartsOn) ?? ((p = (h = e == null ? void 0 : e.locale) == null ? void 0 : h.options) == null ? void 0 : p.weekStartsOn) ?? n.weekStartsOn ?? ((g = (v = n.locale) == null ? void 0 : v.options) == null ? void 0 : g.weekStartsOn) ?? 0, l = toDate(t), u = l.getDay(), f = (u < o ? 7 : 0) + u - o;
  return l.setDate(l.getDate() - f), l.setHours(0, 0, 0, 0), l;
}
function startOfISOWeek(t) {
  return startOfWeek(t, { weekStartsOn: 1 });
}
function getISOWeekYear(t) {
  const e = toDate(t), n = e.getFullYear(), o = constructFrom(t, 0);
  o.setFullYear(n + 1, 0, 4), o.setHours(0, 0, 0, 0);
  const l = startOfISOWeek(o), u = constructFrom(t, 0);
  u.setFullYear(n, 0, 4), u.setHours(0, 0, 0, 0);
  const f = startOfISOWeek(u);
  return e.getTime() >= l.getTime() ? n + 1 : e.getTime() >= f.getTime() ? n : n - 1;
}
function startOfDay(t) {
  const e = toDate(t);
  return e.setHours(0, 0, 0, 0), e;
}
function getTimezoneOffsetInMilliseconds(t) {
  const e = toDate(t), n = new Date(
    Date.UTC(
      e.getFullYear(),
      e.getMonth(),
      e.getDate(),
      e.getHours(),
      e.getMinutes(),
      e.getSeconds(),
      e.getMilliseconds()
    )
  );
  return n.setUTCFullYear(e.getFullYear()), +t - +n;
}
function differenceInCalendarDays(t, e) {
  const n = startOfDay(t), o = startOfDay(e), l = +n - getTimezoneOffsetInMilliseconds(n), u = +o - getTimezoneOffsetInMilliseconds(o);
  return Math.round((l - u) / millisecondsInDay);
}
function startOfISOWeekYear(t) {
  const e = getISOWeekYear(t), n = constructFrom(t, 0);
  return n.setFullYear(e, 0, 4), n.setHours(0, 0, 0, 0), startOfISOWeek(n);
}
function addMinutes(t, e) {
  return addMilliseconds(t, e * millisecondsInMinute);
}
function addQuarters(t, e) {
  const n = e * 3;
  return addMonths(t, n);
}
function addSeconds(t, e) {
  return addMilliseconds(t, e * 1e3);
}
function addWeeks(t, e) {
  const n = e * 7;
  return addDays(t, n);
}
function addYears(t, e) {
  return addMonths(t, e * 12);
}
function max$4(t) {
  let e;
  return t.forEach(function(n) {
    const o = toDate(n);
    (e === void 0 || e < o || isNaN(Number(o))) && (e = o);
  }), e || /* @__PURE__ */ new Date(NaN);
}
function min$4(t) {
  let e;
  return t.forEach((n) => {
    const o = toDate(n);
    (!e || e > o || isNaN(+o)) && (e = o);
  }), e || /* @__PURE__ */ new Date(NaN);
}
function isSameDay$1(t, e) {
  const n = startOfDay(t), o = startOfDay(e);
  return +n == +o;
}
function isDate(t) {
  return t instanceof Date || typeof t == "object" && Object.prototype.toString.call(t) === "[object Date]";
}
function isValid$1(t) {
  if (!isDate(t) && typeof t != "number")
    return !1;
  const e = toDate(t);
  return !isNaN(Number(e));
}
function differenceInCalendarMonths(t, e) {
  const n = toDate(t), o = toDate(e), l = n.getFullYear() - o.getFullYear(), u = n.getMonth() - o.getMonth();
  return l * 12 + u;
}
function getQuarter(t) {
  const e = toDate(t);
  return Math.trunc(e.getMonth() / 3) + 1;
}
function differenceInCalendarQuarters(t, e) {
  const n = toDate(t), o = toDate(e), l = n.getFullYear() - o.getFullYear(), u = getQuarter(n) - getQuarter(o);
  return l * 4 + u;
}
function differenceInCalendarYears(t, e) {
  const n = toDate(t), o = toDate(e);
  return n.getFullYear() - o.getFullYear();
}
function endOfDay(t) {
  const e = toDate(t);
  return e.setHours(23, 59, 59, 999), e;
}
function endOfMonth(t) {
  const e = toDate(t), n = e.getMonth();
  return e.setFullYear(e.getFullYear(), n + 1, 0), e.setHours(23, 59, 59, 999), e;
}
function startOfQuarter(t) {
  const e = toDate(t), n = e.getMonth(), o = n - n % 3;
  return e.setMonth(o, 1), e.setHours(0, 0, 0, 0), e;
}
function startOfMonth(t) {
  const e = toDate(t);
  return e.setDate(1), e.setHours(0, 0, 0, 0), e;
}
function endOfYear(t) {
  const e = toDate(t), n = e.getFullYear();
  return e.setFullYear(n + 1, 0, 0), e.setHours(23, 59, 59, 999), e;
}
function startOfYear(t) {
  const e = toDate(t), n = constructFrom(t, 0);
  return n.setFullYear(e.getFullYear(), 0, 1), n.setHours(0, 0, 0, 0), n;
}
function endOfWeek(t, e) {
  var h, p;
  const n = getDefaultOptions$1(), o = n.weekStartsOn ?? ((p = (h = n.locale) == null ? void 0 : h.options) == null ? void 0 : p.weekStartsOn) ?? 0, l = toDate(t), u = l.getDay(), f = (u < o ? -7 : 0) + 6 - (u - o);
  return l.setDate(l.getDate() + f), l.setHours(23, 59, 59, 999), l;
}
const formatDistanceLocale = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
}, formatDistance = (t, e, n) => {
  let o;
  const l = formatDistanceLocale[t];
  return typeof l == "string" ? o = l : e === 1 ? o = l.one : o = l.other.replace("{{count}}", e.toString()), n != null && n.addSuffix ? n.comparison && n.comparison > 0 ? "in " + o : o + " ago" : o;
};
function buildFormatLongFn(t) {
  return (e = {}) => {
    const n = e.width ? String(e.width) : t.defaultWidth;
    return t.formats[n] || t.formats[t.defaultWidth];
  };
}
const dateFormats = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
}, timeFormats = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
}, dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
}, formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
}, formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
}, formatRelative = (t, e, n, o) => formatRelativeLocale[t];
function buildLocalizeFn(t) {
  return (e, n) => {
    const o = n != null && n.context ? String(n.context) : "standalone";
    let l;
    if (o === "formatting" && t.formattingValues) {
      const f = t.defaultFormattingWidth || t.defaultWidth, h = n != null && n.width ? String(n.width) : f;
      l = t.formattingValues[h] || t.formattingValues[f];
    } else {
      const f = t.defaultWidth, h = n != null && n.width ? String(n.width) : t.defaultWidth;
      l = t.values[h] || t.values[f];
    }
    const u = t.argumentCallback ? t.argumentCallback(e) : e;
    return l[u];
  };
}
const eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
}, quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
}, monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  wide: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ]
}, dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ]
}, dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
}, formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
}, ordinalNumber = (t, e) => {
  const n = Number(t), o = n % 100;
  if (o > 20 || o < 10)
    switch (o % 10) {
      case 1:
        return n + "st";
      case 2:
        return n + "nd";
      case 3:
        return n + "rd";
    }
  return n + "th";
}, localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: (t) => t - 1
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};
function buildMatchFn(t) {
  return (e, n = {}) => {
    const o = n.width, l = o && t.matchPatterns[o] || t.matchPatterns[t.defaultMatchWidth], u = e.match(l);
    if (!u)
      return null;
    const f = u[0], h = o && t.parsePatterns[o] || t.parsePatterns[t.defaultParseWidth], p = Array.isArray(h) ? findIndex$2(h, (w) => w.test(f)) : (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
      findKey(h, (w) => w.test(f))
    );
    let v;
    v = t.valueCallback ? t.valueCallback(p) : p, v = n.valueCallback ? (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
      n.valueCallback(v)
    ) : v;
    const g = e.slice(f.length);
    return { value: v, rest: g };
  };
}
function findKey(t, e) {
  for (const n in t)
    if (Object.prototype.hasOwnProperty.call(t, n) && e(t[n]))
      return n;
}
function findIndex$2(t, e) {
  for (let n = 0; n < t.length; n++)
    if (e(t[n]))
      return n;
}
function buildMatchPatternFn(t) {
  return (e, n = {}) => {
    const o = e.match(t.matchPattern);
    if (!o) return null;
    const l = o[0], u = e.match(t.parsePattern);
    if (!u) return null;
    let f = t.valueCallback ? t.valueCallback(u[0]) : u[0];
    f = n.valueCallback ? n.valueCallback(f) : f;
    const h = e.slice(l.length);
    return { value: f, rest: h };
  };
}
const matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i, parseOrdinalNumberPattern = /\d+/i, matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
}, parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
}, matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
}, parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
}, matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
}, parseMonthPatterns = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
}, matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
}, parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
}, matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
}, parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
}, match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: (t) => parseInt(t, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: (t) => t + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
}, enUS = {
  code: "en-US",
  formatDistance,
  formatLong,
  formatRelative,
  localize,
  match,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
function getDayOfYear(t) {
  const e = toDate(t);
  return differenceInCalendarDays(e, startOfYear(e)) + 1;
}
function getISOWeek(t) {
  const e = toDate(t), n = +startOfISOWeek(e) - +startOfISOWeekYear(e);
  return Math.round(n / millisecondsInWeek) + 1;
}
function getWeekYear(t, e) {
  var g, w, E, T;
  const n = toDate(t), o = n.getFullYear(), l = getDefaultOptions$1(), u = (e == null ? void 0 : e.firstWeekContainsDate) ?? ((w = (g = e == null ? void 0 : e.locale) == null ? void 0 : g.options) == null ? void 0 : w.firstWeekContainsDate) ?? l.firstWeekContainsDate ?? ((T = (E = l.locale) == null ? void 0 : E.options) == null ? void 0 : T.firstWeekContainsDate) ?? 1, f = constructFrom(t, 0);
  f.setFullYear(o + 1, 0, u), f.setHours(0, 0, 0, 0);
  const h = startOfWeek(f, e), p = constructFrom(t, 0);
  p.setFullYear(o, 0, u), p.setHours(0, 0, 0, 0);
  const v = startOfWeek(p, e);
  return n.getTime() >= h.getTime() ? o + 1 : n.getTime() >= v.getTime() ? o : o - 1;
}
function startOfWeekYear(t, e) {
  var h, p, v, g;
  const n = getDefaultOptions$1(), o = (e == null ? void 0 : e.firstWeekContainsDate) ?? ((p = (h = e == null ? void 0 : e.locale) == null ? void 0 : h.options) == null ? void 0 : p.firstWeekContainsDate) ?? n.firstWeekContainsDate ?? ((g = (v = n.locale) == null ? void 0 : v.options) == null ? void 0 : g.firstWeekContainsDate) ?? 1, l = getWeekYear(t, e), u = constructFrom(t, 0);
  return u.setFullYear(l, 0, o), u.setHours(0, 0, 0, 0), startOfWeek(u, e);
}
function getWeek$1(t, e) {
  const n = toDate(t), o = +startOfWeek(n, e) - +startOfWeekYear(n, e);
  return Math.round(o / millisecondsInWeek) + 1;
}
function addLeadingZeros(t, e) {
  const n = t < 0 ? "-" : "", o = Math.abs(t).toString().padStart(e, "0");
  return n + o;
}
const lightFormatters = {
  // Year
  y(t, e) {
    const n = t.getFullYear(), o = n > 0 ? n : 1 - n;
    return addLeadingZeros(e === "yy" ? o % 100 : o, e.length);
  },
  // Month
  M(t, e) {
    const n = t.getMonth();
    return e === "M" ? String(n + 1) : addLeadingZeros(n + 1, 2);
  },
  // Day of the month
  d(t, e) {
    return addLeadingZeros(t.getDate(), e.length);
  },
  // AM or PM
  a(t, e) {
    const n = t.getHours() / 12 >= 1 ? "pm" : "am";
    switch (e) {
      case "a":
      case "aa":
        return n.toUpperCase();
      case "aaa":
        return n;
      case "aaaaa":
        return n[0];
      case "aaaa":
      default:
        return n === "am" ? "a.m." : "p.m.";
    }
  },
  // Hour [1-12]
  h(t, e) {
    return addLeadingZeros(t.getHours() % 12 || 12, e.length);
  },
  // Hour [0-23]
  H(t, e) {
    return addLeadingZeros(t.getHours(), e.length);
  },
  // Minute
  m(t, e) {
    return addLeadingZeros(t.getMinutes(), e.length);
  },
  // Second
  s(t, e) {
    return addLeadingZeros(t.getSeconds(), e.length);
  },
  // Fraction of second
  S(t, e) {
    const n = e.length, o = t.getMilliseconds(), l = Math.trunc(
      o * Math.pow(10, n - 3)
    );
    return addLeadingZeros(l, e.length);
  }
}, dayPeriodEnum = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
}, formatters = {
  // Era
  G: function(t, e, n) {
    const o = t.getFullYear() > 0 ? 1 : 0;
    switch (e) {
      case "G":
      case "GG":
      case "GGG":
        return n.era(o, { width: "abbreviated" });
      case "GGGGG":
        return n.era(o, { width: "narrow" });
      case "GGGG":
      default:
        return n.era(o, { width: "wide" });
    }
  },
  // Year
  y: function(t, e, n) {
    if (e === "yo") {
      const o = t.getFullYear(), l = o > 0 ? o : 1 - o;
      return n.ordinalNumber(l, { unit: "year" });
    }
    return lightFormatters.y(t, e);
  },
  // Local week-numbering year
  Y: function(t, e, n, o) {
    const l = getWeekYear(t, o), u = l > 0 ? l : 1 - l;
    if (e === "YY") {
      const f = u % 100;
      return addLeadingZeros(f, 2);
    }
    return e === "Yo" ? n.ordinalNumber(u, { unit: "year" }) : addLeadingZeros(u, e.length);
  },
  // ISO week-numbering year
  R: function(t, e) {
    const n = getISOWeekYear(t);
    return addLeadingZeros(n, e.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function(t, e) {
    const n = t.getFullYear();
    return addLeadingZeros(n, e.length);
  },
  // Quarter
  Q: function(t, e, n) {
    const o = Math.ceil((t.getMonth() + 1) / 3);
    switch (e) {
      case "Q":
        return String(o);
      case "QQ":
        return addLeadingZeros(o, 2);
      case "Qo":
        return n.ordinalNumber(o, { unit: "quarter" });
      case "QQQ":
        return n.quarter(o, {
          width: "abbreviated",
          context: "formatting"
        });
      case "QQQQQ":
        return n.quarter(o, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return n.quarter(o, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone quarter
  q: function(t, e, n) {
    const o = Math.ceil((t.getMonth() + 1) / 3);
    switch (e) {
      case "q":
        return String(o);
      case "qq":
        return addLeadingZeros(o, 2);
      case "qo":
        return n.ordinalNumber(o, { unit: "quarter" });
      case "qqq":
        return n.quarter(o, {
          width: "abbreviated",
          context: "standalone"
        });
      case "qqqqq":
        return n.quarter(o, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return n.quarter(o, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Month
  M: function(t, e, n) {
    const o = t.getMonth();
    switch (e) {
      case "M":
      case "MM":
        return lightFormatters.M(t, e);
      case "Mo":
        return n.ordinalNumber(o + 1, { unit: "month" });
      case "MMM":
        return n.month(o, {
          width: "abbreviated",
          context: "formatting"
        });
      case "MMMMM":
        return n.month(o, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return n.month(o, { width: "wide", context: "formatting" });
    }
  },
  // Stand-alone month
  L: function(t, e, n) {
    const o = t.getMonth();
    switch (e) {
      case "L":
        return String(o + 1);
      case "LL":
        return addLeadingZeros(o + 1, 2);
      case "Lo":
        return n.ordinalNumber(o + 1, { unit: "month" });
      case "LLL":
        return n.month(o, {
          width: "abbreviated",
          context: "standalone"
        });
      case "LLLLL":
        return n.month(o, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return n.month(o, { width: "wide", context: "standalone" });
    }
  },
  // Local week of year
  w: function(t, e, n, o) {
    const l = getWeek$1(t, o);
    return e === "wo" ? n.ordinalNumber(l, { unit: "week" }) : addLeadingZeros(l, e.length);
  },
  // ISO week of year
  I: function(t, e, n) {
    const o = getISOWeek(t);
    return e === "Io" ? n.ordinalNumber(o, { unit: "week" }) : addLeadingZeros(o, e.length);
  },
  // Day of the month
  d: function(t, e, n) {
    return e === "do" ? n.ordinalNumber(t.getDate(), { unit: "date" }) : lightFormatters.d(t, e);
  },
  // Day of year
  D: function(t, e, n) {
    const o = getDayOfYear(t);
    return e === "Do" ? n.ordinalNumber(o, { unit: "dayOfYear" }) : addLeadingZeros(o, e.length);
  },
  // Day of week
  E: function(t, e, n) {
    const o = t.getDay();
    switch (e) {
      case "E":
      case "EE":
      case "EEE":
        return n.day(o, {
          width: "abbreviated",
          context: "formatting"
        });
      case "EEEEE":
        return n.day(o, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return n.day(o, {
          width: "short",
          context: "formatting"
        });
      case "EEEE":
      default:
        return n.day(o, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Local day of week
  e: function(t, e, n, o) {
    const l = t.getDay(), u = (l - o.weekStartsOn + 8) % 7 || 7;
    switch (e) {
      case "e":
        return String(u);
      case "ee":
        return addLeadingZeros(u, 2);
      case "eo":
        return n.ordinalNumber(u, { unit: "day" });
      case "eee":
        return n.day(l, {
          width: "abbreviated",
          context: "formatting"
        });
      case "eeeee":
        return n.day(l, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return n.day(l, {
          width: "short",
          context: "formatting"
        });
      case "eeee":
      default:
        return n.day(l, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone local day of week
  c: function(t, e, n, o) {
    const l = t.getDay(), u = (l - o.weekStartsOn + 8) % 7 || 7;
    switch (e) {
      case "c":
        return String(u);
      case "cc":
        return addLeadingZeros(u, e.length);
      case "co":
        return n.ordinalNumber(u, { unit: "day" });
      case "ccc":
        return n.day(l, {
          width: "abbreviated",
          context: "standalone"
        });
      case "ccccc":
        return n.day(l, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return n.day(l, {
          width: "short",
          context: "standalone"
        });
      case "cccc":
      default:
        return n.day(l, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // ISO day of week
  i: function(t, e, n) {
    const o = t.getDay(), l = o === 0 ? 7 : o;
    switch (e) {
      case "i":
        return String(l);
      case "ii":
        return addLeadingZeros(l, e.length);
      case "io":
        return n.ordinalNumber(l, { unit: "day" });
      case "iii":
        return n.day(o, {
          width: "abbreviated",
          context: "formatting"
        });
      case "iiiii":
        return n.day(o, {
          width: "narrow",
          context: "formatting"
        });
      case "iiiiii":
        return n.day(o, {
          width: "short",
          context: "formatting"
        });
      case "iiii":
      default:
        return n.day(o, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM or PM
  a: function(t, e, n) {
    const l = t.getHours() / 12 >= 1 ? "pm" : "am";
    switch (e) {
      case "a":
      case "aa":
        return n.dayPeriod(l, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return n.dayPeriod(l, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return n.dayPeriod(l, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return n.dayPeriod(l, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM, PM, midnight, noon
  b: function(t, e, n) {
    const o = t.getHours();
    let l;
    switch (o === 12 ? l = dayPeriodEnum.noon : o === 0 ? l = dayPeriodEnum.midnight : l = o / 12 >= 1 ? "pm" : "am", e) {
      case "b":
      case "bb":
        return n.dayPeriod(l, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return n.dayPeriod(l, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return n.dayPeriod(l, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return n.dayPeriod(l, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function(t, e, n) {
    const o = t.getHours();
    let l;
    switch (o >= 17 ? l = dayPeriodEnum.evening : o >= 12 ? l = dayPeriodEnum.afternoon : o >= 4 ? l = dayPeriodEnum.morning : l = dayPeriodEnum.night, e) {
      case "B":
      case "BB":
      case "BBB":
        return n.dayPeriod(l, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return n.dayPeriod(l, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return n.dayPeriod(l, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Hour [1-12]
  h: function(t, e, n) {
    if (e === "ho") {
      let o = t.getHours() % 12;
      return o === 0 && (o = 12), n.ordinalNumber(o, { unit: "hour" });
    }
    return lightFormatters.h(t, e);
  },
  // Hour [0-23]
  H: function(t, e, n) {
    return e === "Ho" ? n.ordinalNumber(t.getHours(), { unit: "hour" }) : lightFormatters.H(t, e);
  },
  // Hour [0-11]
  K: function(t, e, n) {
    const o = t.getHours() % 12;
    return e === "Ko" ? n.ordinalNumber(o, { unit: "hour" }) : addLeadingZeros(o, e.length);
  },
  // Hour [1-24]
  k: function(t, e, n) {
    let o = t.getHours();
    return o === 0 && (o = 24), e === "ko" ? n.ordinalNumber(o, { unit: "hour" }) : addLeadingZeros(o, e.length);
  },
  // Minute
  m: function(t, e, n) {
    return e === "mo" ? n.ordinalNumber(t.getMinutes(), { unit: "minute" }) : lightFormatters.m(t, e);
  },
  // Second
  s: function(t, e, n) {
    return e === "so" ? n.ordinalNumber(t.getSeconds(), { unit: "second" }) : lightFormatters.s(t, e);
  },
  // Fraction of second
  S: function(t, e) {
    return lightFormatters.S(t, e);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function(t, e, n) {
    const o = t.getTimezoneOffset();
    if (o === 0)
      return "Z";
    switch (e) {
      case "X":
        return formatTimezoneWithOptionalMinutes(o);
      case "XXXX":
      case "XX":
        return formatTimezone(o);
      case "XXXXX":
      case "XXX":
      default:
        return formatTimezone(o, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function(t, e, n) {
    const o = t.getTimezoneOffset();
    switch (e) {
      case "x":
        return formatTimezoneWithOptionalMinutes(o);
      case "xxxx":
      case "xx":
        return formatTimezone(o);
      case "xxxxx":
      case "xxx":
      default:
        return formatTimezone(o, ":");
    }
  },
  // Timezone (GMT)
  O: function(t, e, n) {
    const o = t.getTimezoneOffset();
    switch (e) {
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(o, ":");
      case "OOOO":
      default:
        return "GMT" + formatTimezone(o, ":");
    }
  },
  // Timezone (specific non-location)
  z: function(t, e, n) {
    const o = t.getTimezoneOffset();
    switch (e) {
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + formatTimezoneShort(o, ":");
      case "zzzz":
      default:
        return "GMT" + formatTimezone(o, ":");
    }
  },
  // Seconds timestamp
  t: function(t, e, n) {
    const o = Math.trunc(t.getTime() / 1e3);
    return addLeadingZeros(o, e.length);
  },
  // Milliseconds timestamp
  T: function(t, e, n) {
    const o = t.getTime();
    return addLeadingZeros(o, e.length);
  }
};
function formatTimezoneShort(t, e = "") {
  const n = t > 0 ? "-" : "+", o = Math.abs(t), l = Math.trunc(o / 60), u = o % 60;
  return u === 0 ? n + String(l) : n + String(l) + e + addLeadingZeros(u, 2);
}
function formatTimezoneWithOptionalMinutes(t, e) {
  return t % 60 === 0 ? (t > 0 ? "-" : "+") + addLeadingZeros(Math.abs(t) / 60, 2) : formatTimezone(t, e);
}
function formatTimezone(t, e = "") {
  const n = t > 0 ? "-" : "+", o = Math.abs(t), l = addLeadingZeros(Math.trunc(o / 60), 2), u = addLeadingZeros(o % 60, 2);
  return n + l + e + u;
}
const dateLongFormatter = (t, e) => {
  switch (t) {
    case "P":
      return e.date({ width: "short" });
    case "PP":
      return e.date({ width: "medium" });
    case "PPP":
      return e.date({ width: "long" });
    case "PPPP":
    default:
      return e.date({ width: "full" });
  }
}, timeLongFormatter = (t, e) => {
  switch (t) {
    case "p":
      return e.time({ width: "short" });
    case "pp":
      return e.time({ width: "medium" });
    case "ppp":
      return e.time({ width: "long" });
    case "pppp":
    default:
      return e.time({ width: "full" });
  }
}, dateTimeLongFormatter = (t, e) => {
  const n = t.match(/(P+)(p+)?/) || [], o = n[1], l = n[2];
  if (!l)
    return dateLongFormatter(t, e);
  let u;
  switch (o) {
    case "P":
      u = e.dateTime({ width: "short" });
      break;
    case "PP":
      u = e.dateTime({ width: "medium" });
      break;
    case "PPP":
      u = e.dateTime({ width: "long" });
      break;
    case "PPPP":
    default:
      u = e.dateTime({ width: "full" });
      break;
  }
  return u.replace("{{date}}", dateLongFormatter(o, e)).replace("{{time}}", timeLongFormatter(l, e));
}, longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
}, dayOfYearTokenRE = /^D+$/, weekYearTokenRE = /^Y+$/, throwTokens = ["D", "DD", "YY", "YYYY"];
function isProtectedDayOfYearToken(t) {
  return dayOfYearTokenRE.test(t);
}
function isProtectedWeekYearToken(t) {
  return weekYearTokenRE.test(t);
}
function warnOrThrowProtectedError(t, e, n) {
  const o = message(t, e, n);
  if (console.warn(o), throwTokens.includes(t)) throw new RangeError(o);
}
function message(t, e, n) {
  const o = t[0] === "Y" ? "years" : "days of the month";
  return `Use \`${t.toLowerCase()}\` instead of \`${t}\` (in \`${e}\`) for formatting ${o} to the input \`${n}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
}
const formattingTokensRegExp$1 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, longFormattingTokensRegExp$2 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, escapedStringRegExp$1 = /^'([^]*?)'?$/, doubleQuoteRegExp$1 = /''/g, unescapedLatinCharacterRegExp$1 = /[a-zA-Z]/;
function format$1(t, e, n) {
  var g, w, E, T, R, _, b, M;
  const o = getDefaultOptions$1(), l = (n == null ? void 0 : n.locale) ?? o.locale ?? enUS, u = (n == null ? void 0 : n.firstWeekContainsDate) ?? ((w = (g = n == null ? void 0 : n.locale) == null ? void 0 : g.options) == null ? void 0 : w.firstWeekContainsDate) ?? o.firstWeekContainsDate ?? ((T = (E = o.locale) == null ? void 0 : E.options) == null ? void 0 : T.firstWeekContainsDate) ?? 1, f = (n == null ? void 0 : n.weekStartsOn) ?? ((_ = (R = n == null ? void 0 : n.locale) == null ? void 0 : R.options) == null ? void 0 : _.weekStartsOn) ?? o.weekStartsOn ?? ((M = (b = o.locale) == null ? void 0 : b.options) == null ? void 0 : M.weekStartsOn) ?? 0, h = toDate(t);
  if (!isValid$1(h))
    throw new RangeError("Invalid time value");
  let p = e.match(longFormattingTokensRegExp$2).map((A) => {
    const $ = A[0];
    if ($ === "p" || $ === "P") {
      const S = longFormatters[$];
      return S(A, l.formatLong);
    }
    return A;
  }).join("").match(formattingTokensRegExp$1).map((A) => {
    if (A === "''")
      return { isToken: !1, value: "'" };
    const $ = A[0];
    if ($ === "'")
      return { isToken: !1, value: cleanEscapedString$1(A) };
    if (formatters[$])
      return { isToken: !0, value: A };
    if ($.match(unescapedLatinCharacterRegExp$1))
      throw new RangeError(
        "Format string contains an unescaped latin alphabet character `" + $ + "`"
      );
    return { isToken: !1, value: A };
  });
  l.localize.preprocessor && (p = l.localize.preprocessor(h, p));
  const v = {
    firstWeekContainsDate: u,
    weekStartsOn: f,
    locale: l
  };
  return p.map((A) => {
    if (!A.isToken) return A.value;
    const $ = A.value;
    (!(n != null && n.useAdditionalWeekYearTokens) && isProtectedWeekYearToken($) || !(n != null && n.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken($)) && warnOrThrowProtectedError($, e, String(t));
    const S = formatters[$[0]];
    return S(h, $, l.localize, v);
  }).join("");
}
function cleanEscapedString$1(t) {
  const e = t.match(escapedStringRegExp$1);
  return e ? e[1].replace(doubleQuoteRegExp$1, "'") : t;
}
function getDate(t) {
  return toDate(t).getDate();
}
function getDay(t) {
  return toDate(t).getDay();
}
function getDaysInMonth(t) {
  const e = toDate(t), n = e.getFullYear(), o = e.getMonth(), l = constructFrom(t, 0);
  return l.setFullYear(n, o + 1, 0), l.setHours(0, 0, 0, 0), l.getDate();
}
function getDefaultOptions() {
  return Object.assign({}, getDefaultOptions$1());
}
function getHours(t) {
  return toDate(t).getHours();
}
function getISODay(t) {
  let n = toDate(t).getDay();
  return n === 0 && (n = 7), n;
}
function getMinutes(t) {
  return toDate(t).getMinutes();
}
function getMonth(t) {
  return toDate(t).getMonth();
}
function getSeconds(t) {
  return toDate(t).getSeconds();
}
function getTime(t) {
  return toDate(t).getTime();
}
function getYear(t) {
  return toDate(t).getFullYear();
}
function isAfter(t, e) {
  const n = toDate(t), o = toDate(e);
  return n.getTime() > o.getTime();
}
function isBefore(t, e) {
  const n = toDate(t), o = toDate(e);
  return +n < +o;
}
function isEqual$3(t, e) {
  const n = toDate(t), o = toDate(e);
  return +n == +o;
}
function transpose(t, e) {
  const n = e instanceof Date ? constructFrom(e, 0) : new e(0);
  return n.setFullYear(
    t.getFullYear(),
    t.getMonth(),
    t.getDate()
  ), n.setHours(
    t.getHours(),
    t.getMinutes(),
    t.getSeconds(),
    t.getMilliseconds()
  ), n;
}
const TIMEZONE_UNIT_PRIORITY = 10;
class Setter {
  constructor() {
    _s(this, "subPriority", 0);
  }
  validate(e, n) {
    return !0;
  }
}
class ValueSetter extends Setter {
  constructor(e, n, o, l, u) {
    super(), this.value = e, this.validateValue = n, this.setValue = o, this.priority = l, u && (this.subPriority = u);
  }
  validate(e, n) {
    return this.validateValue(e, this.value, n);
  }
  set(e, n, o) {
    return this.setValue(e, n, this.value, o);
  }
}
class DateToSystemTimezoneSetter extends Setter {
  constructor() {
    super(...arguments);
    _s(this, "priority", TIMEZONE_UNIT_PRIORITY);
    _s(this, "subPriority", -1);
  }
  set(n, o) {
    return o.timestampIsSet ? n : constructFrom(n, transpose(n, Date));
  }
}
class Parser {
  run(e, n, o, l) {
    const u = this.parse(e, n, o, l);
    return u ? {
      setter: new ValueSetter(
        u.value,
        this.validate,
        this.set,
        this.priority,
        this.subPriority
      ),
      rest: u.rest
    } : null;
  }
  validate(e, n, o) {
    return !0;
  }
}
class EraParser extends Parser {
  constructor() {
    super(...arguments);
    _s(this, "priority", 140);
    _s(this, "incompatibleTokens", ["R", "u", "t", "T"]);
  }
  parse(n, o, l) {
    switch (o) {
      case "G":
      case "GG":
      case "GGG":
        return l.era(n, { width: "abbreviated" }) || l.era(n, { width: "narrow" });
      case "GGGGG":
        return l.era(n, { width: "narrow" });
      case "GGGG":
      default:
        return l.era(n, { width: "wide" }) || l.era(n, { width: "abbreviated" }) || l.era(n, { width: "narrow" });
    }
  }
  set(n, o, l) {
    return o.era = l, n.setFullYear(l, 0, 1), n.setHours(0, 0, 0, 0), n;
  }
}
const numericPatterns = {
  month: /^(1[0-2]|0?\d)/,
  // 0 to 12
  date: /^(3[0-1]|[0-2]?\d)/,
  // 0 to 31
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  // 0 to 366
  week: /^(5[0-3]|[0-4]?\d)/,
  // 0 to 53
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  // 0 to 23
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  // 0 to 24
  hour11h: /^(1[0-1]|0?\d)/,
  // 0 to 11
  hour12h: /^(1[0-2]|0?\d)/,
  // 0 to 12
  minute: /^[0-5]?\d/,
  // 0 to 59
  second: /^[0-5]?\d/,
  // 0 to 59
  singleDigit: /^\d/,
  // 0 to 9
  twoDigits: /^\d{1,2}/,
  // 0 to 99
  threeDigits: /^\d{1,3}/,
  // 0 to 999
  fourDigits: /^\d{1,4}/,
  // 0 to 9999
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  // 0 to 9, -0 to -9
  twoDigitsSigned: /^-?\d{1,2}/,
  // 0 to 99, -0 to -99
  threeDigitsSigned: /^-?\d{1,3}/,
  // 0 to 999, -0 to -999
  fourDigitsSigned: /^-?\d{1,4}/
  // 0 to 9999, -0 to -9999
}, timezonePatterns = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};
function mapValue(t, e) {
  return t && {
    value: e(t.value),
    rest: t.rest
  };
}
function parseNumericPattern(t, e) {
  const n = e.match(t);
  return n ? {
    value: parseInt(n[0], 10),
    rest: e.slice(n[0].length)
  } : null;
}
function parseTimezonePattern(t, e) {
  const n = e.match(t);
  if (!n)
    return null;
  if (n[0] === "Z")
    return {
      value: 0,
      rest: e.slice(1)
    };
  const o = n[1] === "+" ? 1 : -1, l = n[2] ? parseInt(n[2], 10) : 0, u = n[3] ? parseInt(n[3], 10) : 0, f = n[5] ? parseInt(n[5], 10) : 0;
  return {
    value: o * (l * millisecondsInHour + u * millisecondsInMinute + f * millisecondsInSecond),
    rest: e.slice(n[0].length)
  };
}
function parseAnyDigitsSigned(t) {
  return parseNumericPattern(numericPatterns.anyDigitsSigned, t);
}
function parseNDigits(t, e) {
  switch (t) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigit, e);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigits, e);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigits, e);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigits, e);
    default:
      return parseNumericPattern(new RegExp("^\\d{1," + t + "}"), e);
  }
}
function parseNDigitsSigned(t, e) {
  switch (t) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigitSigned, e);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigitsSigned, e);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigitsSigned, e);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigitsSigned, e);
    default:
      return parseNumericPattern(new RegExp("^-?\\d{1," + t + "}"), e);
  }
}
function dayPeriodEnumToHours(t) {
  switch (t) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0;
  }
}
function normalizeTwoDigitYear(t, e) {
  const n = e > 0, o = n ? e : 1 - e;
  let l;
  if (o <= 50)
    l = t || 100;
  else {
    const u = o + 50, f = Math.trunc(u / 100) * 100, h = t >= u % 100;
    l = t + f - (h ? 100 : 0);
  }
  return n ? l : 1 - l;
}
function isLeapYearIndex$1(t) {
  return t % 400 === 0 || t % 4 === 0 && t % 100 !== 0;
}
class YearParser extends Parser {
  constructor() {
    super(...arguments);
    _s(this, "priority", 130);
    _s(this, "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]);
  }
  parse(n, o, l) {
    const u = (f) => ({
      year: f,
      isTwoDigitYear: o === "yy"
    });
    switch (o) {
      case "y":
        return mapValue(parseNDigits(4, n), u);
      case "yo":
        return mapValue(
          l.ordinalNumber(n, {
            unit: "year"
          }),
          u
        );
      default:
        return mapValue(parseNDigits(o.length, n), u);
    }
  }
  validate(n, o) {
    return o.isTwoDigitYear || o.year > 0;
  }
  set(n, o, l) {
    const u = n.getFullYear();
    if (l.isTwoDigitYear) {
      const h = normalizeTwoDigitYear(
        l.year,
        u
      );
      return n.setFullYear(h, 0, 1), n.setHours(0, 0, 0, 0), n;
    }
    const f = !("era" in o) || o.era === 1 ? l.year : 1 - l.year;
    return n.setFullYear(f, 0, 1), n.setHours(0, 0, 0, 0), n;
  }
}
class LocalWeekYearParser extends Parser {
  constructor() {
    super(...arguments);
    _s(this, "priority", 130);
    _s(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "Q",
      "q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "i",
      "t",
      "T"
    ]);
  }
  parse(n, o, l) {
    const u = (f) => ({
      year: f,
      isTwoDigitYear: o === "YY"
    });
    switch (o) {
      case "Y":
        return mapValue(parseNDigits(4, n), u);
      case "Yo":
        return mapValue(
          l.ordinalNumber(n, {
            unit: "year"
          }),
          u
        );
      default:
        return mapValue(parseNDigits(o.length, n), u);
    }
  }
  validate(n, o) {
    return o.isTwoDigitYear || o.year > 0;
  }
  set(n, o, l, u) {
    const f = getWeekYear(n, u);
    if (l.isTwoDigitYear) {
      const p = normalizeTwoDigitYear(
        l.year,
        f
      );
      return n.setFullYear(
        p,
        0,
        u.firstWeekContainsDate
      ), n.setHours(0, 0, 0, 0), startOfWeek(n, u);
    }
    const h = !("era" in o) || o.era === 1 ? l.year : 1 - l.year;
    return n.setFullYear(h, 0, u.firstWeekContainsDate), n.setHours(0, 0, 0, 0), startOfWeek(n, u);
  }
}
class ISOWeekYearParser extends Parser {
  constructor() {
    super(...arguments);
    _s(this, "priority", 130);
    _s(this, "incompatibleTokens", [
      "G",
      "y",
      "Y",
      "u",
      "Q",
      "q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(n, o) {
    return parseNDigitsSigned(o === "R" ? 4 : o.length, n);
  }
  set(n, o, l) {
    const u = constructFrom(n, 0);
    return u.setFullYear(l, 0, 4), u.setHours(0, 0, 0, 0), startOfISOWeek(u);
  }
}
class ExtendedYearParser extends Parser {
  constructor() {
    super(...arguments);
    _s(this, "priority", 130);
    _s(this, "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]);
  }
  parse(n, o) {
    return parseNDigitsSigned(o === "u" ? 4 : o.length, n);
  }
  set(n, o, l) {
    return n.setFullYear(l, 0, 1), n.setHours(0, 0, 0, 0), n;
  }
}
class QuarterParser extends Parser {
  constructor() {
    super(...arguments);
    _s(this, "priority", 120);
    _s(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(n, o, l) {
    switch (o) {
      case "Q":
      case "QQ":
        return parseNDigits(o.length, n);
      case "Qo":
        return l.ordinalNumber(n, { unit: "quarter" });
      case "QQQ":
        return l.quarter(n, {
          width: "abbreviated",
          context: "formatting"
        }) || l.quarter(n, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQQ":
        return l.quarter(n, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return l.quarter(n, {
          width: "wide",
          context: "formatting"
        }) || l.quarter(n, {
          width: "abbreviated",
          context: "formatting"
        }) || l.quarter(n, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  validate(n, o) {
    return o >= 1 && o <= 4;
  }
  set(n, o, l) {
    return n.setMonth((l - 1) * 3, 1), n.setHours(0, 0, 0, 0), n;
  }
}
class StandAloneQuarterParser extends Parser {
  constructor() {
    super(...arguments);
    _s(this, "priority", 120);
    _s(this, "incompatibleTokens", [
      "Y",
      "R",
      "Q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(n, o, l) {
    switch (o) {
      case "q":
      case "qq":
        return parseNDigits(o.length, n);
      case "qo":
        return l.ordinalNumber(n, { unit: "quarter" });
      case "qqq":
        return l.quarter(n, {
          width: "abbreviated",
          context: "standalone"
        }) || l.quarter(n, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqqq":
        return l.quarter(n, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return l.quarter(n, {
          width: "wide",
          context: "standalone"
        }) || l.quarter(n, {
          width: "abbreviated",
          context: "standalone"
        }) || l.quarter(n, {
          width: "narrow",
          context: "standalone"
        });
    }
  }
  validate(n, o) {
    return o >= 1 && o <= 4;
  }
  set(n, o, l) {
    return n.setMonth((l - 1) * 3, 1), n.setHours(0, 0, 0, 0), n;
  }
}
class MonthParser extends Parser {
  constructor() {
    super(...arguments);
    _s(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "L",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
    _s(this, "priority", 110);
  }
  parse(n, o, l) {
    const u = (f) => f - 1;
    switch (o) {
      case "M":
        return mapValue(
          parseNumericPattern(numericPatterns.month, n),
          u
        );
      case "MM":
        return mapValue(parseNDigits(2, n), u);
      case "Mo":
        return mapValue(
          l.ordinalNumber(n, {
            unit: "month"
          }),
          u
        );
      case "MMM":
        return l.month(n, {
          width: "abbreviated",
          context: "formatting"
        }) || l.month(n, { width: "narrow", context: "formatting" });
      case "MMMMM":
        return l.month(n, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return l.month(n, { width: "wide", context: "formatting" }) || l.month(n, {
          width: "abbreviated",
          context: "formatting"
        }) || l.month(n, { width: "narrow", context: "formatting" });
    }
  }
  validate(n, o) {
    return o >= 0 && o <= 11;
  }
  set(n, o, l) {
    return n.setMonth(l, 1), n.setHours(0, 0, 0, 0), n;
  }
}
class StandAloneMonthParser extends Parser {
  constructor() {
    super(...arguments);
    _s(this, "priority", 110);
    _s(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "M",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(n, o, l) {
    const u = (f) => f - 1;
    switch (o) {
      case "L":
        return mapValue(
          parseNumericPattern(numericPatterns.month, n),
          u
        );
      case "LL":
        return mapValue(parseNDigits(2, n), u);
      case "Lo":
        return mapValue(
          l.ordinalNumber(n, {
            unit: "month"
          }),
          u
        );
      case "LLL":
        return l.month(n, {
          width: "abbreviated",
          context: "standalone"
        }) || l.month(n, { width: "narrow", context: "standalone" });
      case "LLLLL":
        return l.month(n, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return l.month(n, { width: "wide", context: "standalone" }) || l.month(n, {
          width: "abbreviated",
          context: "standalone"
        }) || l.month(n, { width: "narrow", context: "standalone" });
    }
  }
  validate(n, o) {
    return o >= 0 && o <= 11;
  }
  set(n, o, l) {
    return n.setMonth(l, 1), n.setHours(0, 0, 0, 0), n;
  }
}
function setWeek(t, e, n) {
  const o = toDate(t), l = getWeek$1(o, n) - e;
  return o.setDate(o.getDate() - l * 7), o;
}
class LocalWeekParser extends Parser {
  constructor() {
    super(...arguments);
    _s(this, "priority", 100);
    _s(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "i",
      "t",
      "T"
    ]);
  }
  parse(n, o, l) {
    switch (o) {
      case "w":
        return parseNumericPattern(numericPatterns.week, n);
      case "wo":
        return l.ordinalNumber(n, { unit: "week" });
      default:
        return parseNDigits(o.length, n);
    }
  }
  validate(n, o) {
    return o >= 1 && o <= 53;
  }
  set(n, o, l, u) {
    return startOfWeek(setWeek(n, l, u), u);
  }
}
function setISOWeek(t, e) {
  const n = toDate(t), o = getISOWeek(n) - e;
  return n.setDate(n.getDate() - o * 7), n;
}
class ISOWeekParser extends Parser {
  constructor() {
    super(...arguments);
    _s(this, "priority", 100);
    _s(this, "incompatibleTokens", [
      "y",
      "Y",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(n, o, l) {
    switch (o) {
      case "I":
        return parseNumericPattern(numericPatterns.week, n);
      case "Io":
        return l.ordinalNumber(n, { unit: "week" });
      default:
        return parseNDigits(o.length, n);
    }
  }
  validate(n, o) {
    return o >= 1 && o <= 53;
  }
  set(n, o, l) {
    return startOfISOWeek(setISOWeek(n, l));
  }
}
const DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], DAYS_IN_MONTH_LEAP_YEAR = [
  31,
  29,
  31,
  30,
  31,
  30,
  31,
  31,
  30,
  31,
  30,
  31
];
class DateParser extends Parser {
  constructor() {
    super(...arguments);
    _s(this, "priority", 90);
    _s(this, "subPriority", 1);
    _s(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(n, o, l) {
    switch (o) {
      case "d":
        return parseNumericPattern(numericPatterns.date, n);
      case "do":
        return l.ordinalNumber(n, { unit: "date" });
      default:
        return parseNDigits(o.length, n);
    }
  }
  validate(n, o) {
    const l = n.getFullYear(), u = isLeapYearIndex$1(l), f = n.getMonth();
    return u ? o >= 1 && o <= DAYS_IN_MONTH_LEAP_YEAR[f] : o >= 1 && o <= DAYS_IN_MONTH[f];
  }
  set(n, o, l) {
    return n.setDate(l), n.setHours(0, 0, 0, 0), n;
  }
}
class DayOfYearParser extends Parser {
  constructor() {
    super(...arguments);
    _s(this, "priority", 90);
    _s(this, "subpriority", 1);
    _s(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "E",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(n, o, l) {
    switch (o) {
      case "D":
      case "DD":
        return parseNumericPattern(numericPatterns.dayOfYear, n);
      case "Do":
        return l.ordinalNumber(n, { unit: "date" });
      default:
        return parseNDigits(o.length, n);
    }
  }
  validate(n, o) {
    const l = n.getFullYear();
    return isLeapYearIndex$1(l) ? o >= 1 && o <= 366 : o >= 1 && o <= 365;
  }
  set(n, o, l) {
    return n.setMonth(0, l), n.setHours(0, 0, 0, 0), n;
  }
}
function setDay(t, e, n) {
  var w, E, T, R;
  const o = getDefaultOptions$1(), l = (n == null ? void 0 : n.weekStartsOn) ?? ((E = (w = n == null ? void 0 : n.locale) == null ? void 0 : w.options) == null ? void 0 : E.weekStartsOn) ?? o.weekStartsOn ?? ((R = (T = o.locale) == null ? void 0 : T.options) == null ? void 0 : R.weekStartsOn) ?? 0, u = toDate(t), f = u.getDay(), p = (e % 7 + 7) % 7, v = 7 - l, g = e < 0 || e > 6 ? e - (f + v) % 7 : (p + v) % 7 - (f + v) % 7;
  return addDays(u, g);
}
class DayParser extends Parser {
  constructor() {
    super(...arguments);
    _s(this, "priority", 90);
    _s(this, "incompatibleTokens", ["D", "i", "e", "c", "t", "T"]);
  }
  parse(n, o, l) {
    switch (o) {
      case "E":
      case "EE":
      case "EEE":
        return l.day(n, {
          width: "abbreviated",
          context: "formatting"
        }) || l.day(n, { width: "short", context: "formatting" }) || l.day(n, { width: "narrow", context: "formatting" });
      case "EEEEE":
        return l.day(n, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return l.day(n, { width: "short", context: "formatting" }) || l.day(n, { width: "narrow", context: "formatting" });
      case "EEEE":
      default:
        return l.day(n, { width: "wide", context: "formatting" }) || l.day(n, {
          width: "abbreviated",
          context: "formatting"
        }) || l.day(n, { width: "short", context: "formatting" }) || l.day(n, { width: "narrow", context: "formatting" });
    }
  }
  validate(n, o) {
    return o >= 0 && o <= 6;
  }
  set(n, o, l, u) {
    return n = setDay(n, l, u), n.setHours(0, 0, 0, 0), n;
  }
}
class LocalDayParser extends Parser {
  constructor() {
    super(...arguments);
    _s(this, "priority", 90);
    _s(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "E",
      "i",
      "c",
      "t",
      "T"
    ]);
  }
  parse(n, o, l, u) {
    const f = (h) => {
      const p = Math.floor((h - 1) / 7) * 7;
      return (h + u.weekStartsOn + 6) % 7 + p;
    };
    switch (o) {
      case "e":
      case "ee":
        return mapValue(parseNDigits(o.length, n), f);
      case "eo":
        return mapValue(
          l.ordinalNumber(n, {
            unit: "day"
          }),
          f
        );
      case "eee":
        return l.day(n, {
          width: "abbreviated",
          context: "formatting"
        }) || l.day(n, { width: "short", context: "formatting" }) || l.day(n, { width: "narrow", context: "formatting" });
      case "eeeee":
        return l.day(n, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return l.day(n, { width: "short", context: "formatting" }) || l.day(n, { width: "narrow", context: "formatting" });
      case "eeee":
      default:
        return l.day(n, { width: "wide", context: "formatting" }) || l.day(n, {
          width: "abbreviated",
          context: "formatting"
        }) || l.day(n, { width: "short", context: "formatting" }) || l.day(n, { width: "narrow", context: "formatting" });
    }
  }
  validate(n, o) {
    return o >= 0 && o <= 6;
  }
  set(n, o, l, u) {
    return n = setDay(n, l, u), n.setHours(0, 0, 0, 0), n;
  }
}
class StandAloneLocalDayParser extends Parser {
  constructor() {
    super(...arguments);
    _s(this, "priority", 90);
    _s(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "E",
      "i",
      "e",
      "t",
      "T"
    ]);
  }
  parse(n, o, l, u) {
    const f = (h) => {
      const p = Math.floor((h - 1) / 7) * 7;
      return (h + u.weekStartsOn + 6) % 7 + p;
    };
    switch (o) {
      case "c":
      case "cc":
        return mapValue(parseNDigits(o.length, n), f);
      case "co":
        return mapValue(
          l.ordinalNumber(n, {
            unit: "day"
          }),
          f
        );
      case "ccc":
        return l.day(n, {
          width: "abbreviated",
          context: "standalone"
        }) || l.day(n, { width: "short", context: "standalone" }) || l.day(n, { width: "narrow", context: "standalone" });
      case "ccccc":
        return l.day(n, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return l.day(n, { width: "short", context: "standalone" }) || l.day(n, { width: "narrow", context: "standalone" });
      case "cccc":
      default:
        return l.day(n, { width: "wide", context: "standalone" }) || l.day(n, {
          width: "abbreviated",
          context: "standalone"
        }) || l.day(n, { width: "short", context: "standalone" }) || l.day(n, { width: "narrow", context: "standalone" });
    }
  }
  validate(n, o) {
    return o >= 0 && o <= 6;
  }
  set(n, o, l, u) {
    return n = setDay(n, l, u), n.setHours(0, 0, 0, 0), n;
  }
}
function setISODay(t, e) {
  const n = toDate(t), o = getISODay(n), l = e - o;
  return addDays(n, l);
}
class ISODayParser extends Parser {
  constructor() {
    super(...arguments);
    _s(this, "priority", 90);
    _s(this, "incompatibleTokens", [
      "y",
      "Y",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "E",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(n, o, l) {
    const u = (f) => f === 0 ? 7 : f;
    switch (o) {
      case "i":
      case "ii":
        return parseNDigits(o.length, n);
      case "io":
        return l.ordinalNumber(n, { unit: "day" });
      case "iii":
        return mapValue(
          l.day(n, {
            width: "abbreviated",
            context: "formatting"
          }) || l.day(n, {
            width: "short",
            context: "formatting"
          }) || l.day(n, {
            width: "narrow",
            context: "formatting"
          }),
          u
        );
      case "iiiii":
        return mapValue(
          l.day(n, {
            width: "narrow",
            context: "formatting"
          }),
          u
        );
      case "iiiiii":
        return mapValue(
          l.day(n, {
            width: "short",
            context: "formatting"
          }) || l.day(n, {
            width: "narrow",
            context: "formatting"
          }),
          u
        );
      case "iiii":
      default:
        return mapValue(
          l.day(n, {
            width: "wide",
            context: "formatting"
          }) || l.day(n, {
            width: "abbreviated",
            context: "formatting"
          }) || l.day(n, {
            width: "short",
            context: "formatting"
          }) || l.day(n, {
            width: "narrow",
            context: "formatting"
          }),
          u
        );
    }
  }
  validate(n, o) {
    return o >= 1 && o <= 7;
  }
  set(n, o, l) {
    return n = setISODay(n, l), n.setHours(0, 0, 0, 0), n;
  }
}
class AMPMParser extends Parser {
  constructor() {
    super(...arguments);
    _s(this, "priority", 80);
    _s(this, "incompatibleTokens", ["b", "B", "H", "k", "t", "T"]);
  }
  parse(n, o, l) {
    switch (o) {
      case "a":
      case "aa":
      case "aaa":
        return l.dayPeriod(n, {
          width: "abbreviated",
          context: "formatting"
        }) || l.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaaa":
        return l.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return l.dayPeriod(n, {
          width: "wide",
          context: "formatting"
        }) || l.dayPeriod(n, {
          width: "abbreviated",
          context: "formatting"
        }) || l.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(n, o, l) {
    return n.setHours(dayPeriodEnumToHours(l), 0, 0, 0), n;
  }
}
class AMPMMidnightParser extends Parser {
  constructor() {
    super(...arguments);
    _s(this, "priority", 80);
    _s(this, "incompatibleTokens", ["a", "B", "H", "k", "t", "T"]);
  }
  parse(n, o, l) {
    switch (o) {
      case "b":
      case "bb":
      case "bbb":
        return l.dayPeriod(n, {
          width: "abbreviated",
          context: "formatting"
        }) || l.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbbb":
        return l.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return l.dayPeriod(n, {
          width: "wide",
          context: "formatting"
        }) || l.dayPeriod(n, {
          width: "abbreviated",
          context: "formatting"
        }) || l.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(n, o, l) {
    return n.setHours(dayPeriodEnumToHours(l), 0, 0, 0), n;
  }
}
class DayPeriodParser extends Parser {
  constructor() {
    super(...arguments);
    _s(this, "priority", 80);
    _s(this, "incompatibleTokens", ["a", "b", "t", "T"]);
  }
  parse(n, o, l) {
    switch (o) {
      case "B":
      case "BB":
      case "BBB":
        return l.dayPeriod(n, {
          width: "abbreviated",
          context: "formatting"
        }) || l.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBBB":
        return l.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return l.dayPeriod(n, {
          width: "wide",
          context: "formatting"
        }) || l.dayPeriod(n, {
          width: "abbreviated",
          context: "formatting"
        }) || l.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(n, o, l) {
    return n.setHours(dayPeriodEnumToHours(l), 0, 0, 0), n;
  }
}
class Hour1to12Parser extends Parser {
  constructor() {
    super(...arguments);
    _s(this, "priority", 70);
    _s(this, "incompatibleTokens", ["H", "K", "k", "t", "T"]);
  }
  parse(n, o, l) {
    switch (o) {
      case "h":
        return parseNumericPattern(numericPatterns.hour12h, n);
      case "ho":
        return l.ordinalNumber(n, { unit: "hour" });
      default:
        return parseNDigits(o.length, n);
    }
  }
  validate(n, o) {
    return o >= 1 && o <= 12;
  }
  set(n, o, l) {
    const u = n.getHours() >= 12;
    return u && l < 12 ? n.setHours(l + 12, 0, 0, 0) : !u && l === 12 ? n.setHours(0, 0, 0, 0) : n.setHours(l, 0, 0, 0), n;
  }
}
class Hour0to23Parser extends Parser {
  constructor() {
    super(...arguments);
    _s(this, "priority", 70);
    _s(this, "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"]);
  }
  parse(n, o, l) {
    switch (o) {
      case "H":
        return parseNumericPattern(numericPatterns.hour23h, n);
      case "Ho":
        return l.ordinalNumber(n, { unit: "hour" });
      default:
        return parseNDigits(o.length, n);
    }
  }
  validate(n, o) {
    return o >= 0 && o <= 23;
  }
  set(n, o, l) {
    return n.setHours(l, 0, 0, 0), n;
  }
}
class Hour0To11Parser extends Parser {
  constructor() {
    super(...arguments);
    _s(this, "priority", 70);
    _s(this, "incompatibleTokens", ["h", "H", "k", "t", "T"]);
  }
  parse(n, o, l) {
    switch (o) {
      case "K":
        return parseNumericPattern(numericPatterns.hour11h, n);
      case "Ko":
        return l.ordinalNumber(n, { unit: "hour" });
      default:
        return parseNDigits(o.length, n);
    }
  }
  validate(n, o) {
    return o >= 0 && o <= 11;
  }
  set(n, o, l) {
    return n.getHours() >= 12 && l < 12 ? n.setHours(l + 12, 0, 0, 0) : n.setHours(l, 0, 0, 0), n;
  }
}
class Hour1To24Parser extends Parser {
  constructor() {
    super(...arguments);
    _s(this, "priority", 70);
    _s(this, "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"]);
  }
  parse(n, o, l) {
    switch (o) {
      case "k":
        return parseNumericPattern(numericPatterns.hour24h, n);
      case "ko":
        return l.ordinalNumber(n, { unit: "hour" });
      default:
        return parseNDigits(o.length, n);
    }
  }
  validate(n, o) {
    return o >= 1 && o <= 24;
  }
  set(n, o, l) {
    const u = l <= 24 ? l % 24 : l;
    return n.setHours(u, 0, 0, 0), n;
  }
}
class MinuteParser extends Parser {
  constructor() {
    super(...arguments);
    _s(this, "priority", 60);
    _s(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(n, o, l) {
    switch (o) {
      case "m":
        return parseNumericPattern(numericPatterns.minute, n);
      case "mo":
        return l.ordinalNumber(n, { unit: "minute" });
      default:
        return parseNDigits(o.length, n);
    }
  }
  validate(n, o) {
    return o >= 0 && o <= 59;
  }
  set(n, o, l) {
    return n.setMinutes(l, 0, 0), n;
  }
}
class SecondParser extends Parser {
  constructor() {
    super(...arguments);
    _s(this, "priority", 50);
    _s(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(n, o, l) {
    switch (o) {
      case "s":
        return parseNumericPattern(numericPatterns.second, n);
      case "so":
        return l.ordinalNumber(n, { unit: "second" });
      default:
        return parseNDigits(o.length, n);
    }
  }
  validate(n, o) {
    return o >= 0 && o <= 59;
  }
  set(n, o, l) {
    return n.setSeconds(l, 0), n;
  }
}
class FractionOfSecondParser extends Parser {
  constructor() {
    super(...arguments);
    _s(this, "priority", 30);
    _s(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(n, o) {
    const l = (u) => Math.trunc(u * Math.pow(10, -o.length + 3));
    return mapValue(parseNDigits(o.length, n), l);
  }
  set(n, o, l) {
    return n.setMilliseconds(l), n;
  }
}
class ISOTimezoneWithZParser extends Parser {
  constructor() {
    super(...arguments);
    _s(this, "priority", 10);
    _s(this, "incompatibleTokens", ["t", "T", "x"]);
  }
  parse(n, o) {
    switch (o) {
      case "X":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalMinutes,
          n
        );
      case "XX":
        return parseTimezonePattern(timezonePatterns.basic, n);
      case "XXXX":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalSeconds,
          n
        );
      case "XXXXX":
        return parseTimezonePattern(
          timezonePatterns.extendedOptionalSeconds,
          n
        );
      case "XXX":
      default:
        return parseTimezonePattern(timezonePatterns.extended, n);
    }
  }
  set(n, o, l) {
    return o.timestampIsSet ? n : constructFrom(
      n,
      n.getTime() - getTimezoneOffsetInMilliseconds(n) - l
    );
  }
}
class ISOTimezoneParser extends Parser {
  constructor() {
    super(...arguments);
    _s(this, "priority", 10);
    _s(this, "incompatibleTokens", ["t", "T", "X"]);
  }
  parse(n, o) {
    switch (o) {
      case "x":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalMinutes,
          n
        );
      case "xx":
        return parseTimezonePattern(timezonePatterns.basic, n);
      case "xxxx":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalSeconds,
          n
        );
      case "xxxxx":
        return parseTimezonePattern(
          timezonePatterns.extendedOptionalSeconds,
          n
        );
      case "xxx":
      default:
        return parseTimezonePattern(timezonePatterns.extended, n);
    }
  }
  set(n, o, l) {
    return o.timestampIsSet ? n : constructFrom(
      n,
      n.getTime() - getTimezoneOffsetInMilliseconds(n) - l
    );
  }
}
class TimestampSecondsParser extends Parser {
  constructor() {
    super(...arguments);
    _s(this, "priority", 40);
    _s(this, "incompatibleTokens", "*");
  }
  parse(n) {
    return parseAnyDigitsSigned(n);
  }
  set(n, o, l) {
    return [constructFrom(n, l * 1e3), { timestampIsSet: !0 }];
  }
}
class TimestampMillisecondsParser extends Parser {
  constructor() {
    super(...arguments);
    _s(this, "priority", 20);
    _s(this, "incompatibleTokens", "*");
  }
  parse(n) {
    return parseAnyDigitsSigned(n);
  }
  set(n, o, l) {
    return [constructFrom(n, l), { timestampIsSet: !0 }];
  }
}
const parsers = {
  G: new EraParser(),
  y: new YearParser(),
  Y: new LocalWeekYearParser(),
  R: new ISOWeekYearParser(),
  u: new ExtendedYearParser(),
  Q: new QuarterParser(),
  q: new StandAloneQuarterParser(),
  M: new MonthParser(),
  L: new StandAloneMonthParser(),
  w: new LocalWeekParser(),
  I: new ISOWeekParser(),
  d: new DateParser(),
  D: new DayOfYearParser(),
  E: new DayParser(),
  e: new LocalDayParser(),
  c: new StandAloneLocalDayParser(),
  i: new ISODayParser(),
  a: new AMPMParser(),
  b: new AMPMMidnightParser(),
  B: new DayPeriodParser(),
  h: new Hour1to12Parser(),
  H: new Hour0to23Parser(),
  K: new Hour0To11Parser(),
  k: new Hour1To24Parser(),
  m: new MinuteParser(),
  s: new SecondParser(),
  S: new FractionOfSecondParser(),
  X: new ISOTimezoneWithZParser(),
  x: new ISOTimezoneParser(),
  t: new TimestampSecondsParser(),
  T: new TimestampMillisecondsParser()
}, formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, longFormattingTokensRegExp$1 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, escapedStringRegExp = /^'([^]*?)'?$/, doubleQuoteRegExp = /''/g, notWhitespaceRegExp = /\S/, unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function parse(t, e, n, o) {
  var _, b, M, A, $, S, C, D;
  const l = getDefaultOptions(), u = (o == null ? void 0 : o.locale) ?? l.locale ?? enUS, f = (o == null ? void 0 : o.firstWeekContainsDate) ?? ((b = (_ = o == null ? void 0 : o.locale) == null ? void 0 : _.options) == null ? void 0 : b.firstWeekContainsDate) ?? l.firstWeekContainsDate ?? ((A = (M = l.locale) == null ? void 0 : M.options) == null ? void 0 : A.firstWeekContainsDate) ?? 1, h = (o == null ? void 0 : o.weekStartsOn) ?? ((S = ($ = o == null ? void 0 : o.locale) == null ? void 0 : $.options) == null ? void 0 : S.weekStartsOn) ?? l.weekStartsOn ?? ((D = (C = l.locale) == null ? void 0 : C.options) == null ? void 0 : D.weekStartsOn) ?? 0;
  if (e === "")
    return t === "" ? toDate(n) : constructFrom(n, NaN);
  const p = {
    firstWeekContainsDate: f,
    weekStartsOn: h,
    locale: u
  }, v = [new DateToSystemTimezoneSetter()], g = e.match(longFormattingTokensRegExp$1).map((O) => {
    const N = O[0];
    if (N in longFormatters) {
      const j = longFormatters[N];
      return j(O, u.formatLong);
    }
    return O;
  }).join("").match(formattingTokensRegExp), w = [];
  for (let O of g) {
    !(o != null && o.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(O) && warnOrThrowProtectedError(O, e, t), !(o != null && o.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(O) && warnOrThrowProtectedError(O, e, t);
    const N = O[0], j = parsers[N];
    if (j) {
      const { incompatibleTokens: L } = j;
      if (Array.isArray(L)) {
        const G = w.find(
          (B) => L.includes(B.token) || B.token === N
        );
        if (G)
          throw new RangeError(
            `The format string mustn't contain \`${G.fullToken}\` and \`${O}\` at the same time`
          );
      } else if (j.incompatibleTokens === "*" && w.length > 0)
        throw new RangeError(
          `The format string mustn't contain \`${O}\` and any other token at the same time`
        );
      w.push({ token: N, fullToken: O });
      const z = j.run(
        t,
        O,
        u.match,
        p
      );
      if (!z)
        return constructFrom(n, NaN);
      v.push(z.setter), t = z.rest;
    } else {
      if (N.match(unescapedLatinCharacterRegExp))
        throw new RangeError(
          "Format string contains an unescaped latin alphabet character `" + N + "`"
        );
      if (O === "''" ? O = "'" : N === "'" && (O = cleanEscapedString(O)), t.indexOf(O) === 0)
        t = t.slice(O.length);
      else
        return constructFrom(n, NaN);
    }
  }
  if (t.length > 0 && notWhitespaceRegExp.test(t))
    return constructFrom(n, NaN);
  const E = v.map((O) => O.priority).sort((O, N) => N - O).filter((O, N, j) => j.indexOf(O) === N).map(
    (O) => v.filter((N) => N.priority === O).sort((N, j) => j.subPriority - N.subPriority)
  ).map((O) => O[0]);
  let T = toDate(n);
  if (isNaN(T.getTime()))
    return constructFrom(n, NaN);
  const R = {};
  for (const O of E) {
    if (!O.validate(T, p))
      return constructFrom(n, NaN);
    const N = O.set(T, R, p);
    Array.isArray(N) ? (T = N[0], Object.assign(R, N[1])) : T = N;
  }
  return constructFrom(n, T);
}
function cleanEscapedString(t) {
  return t.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
}
function isSameMonth$1(t, e) {
  const n = toDate(t), o = toDate(e);
  return n.getFullYear() === o.getFullYear() && n.getMonth() === o.getMonth();
}
function isSameQuarter$1(t, e) {
  const n = startOfQuarter(t), o = startOfQuarter(e);
  return +n == +o;
}
function isSameYear$1(t, e) {
  const n = toDate(t), o = toDate(e);
  return n.getFullYear() === o.getFullYear();
}
function isWithinInterval(t, e) {
  const n = +toDate(t), [o, l] = [
    +toDate(e.start),
    +toDate(e.end)
  ].sort((u, f) => u - f);
  return n >= o && n <= l;
}
function subDays(t, e) {
  return addDays(t, -e);
}
function parseISO(t, e) {
  const o = splitDateString(t);
  let l;
  if (o.date) {
    const p = parseYear$1(o.date, 2);
    l = parseDate$1(p.restDateString, p.year);
  }
  if (!l || isNaN(l.getTime()))
    return /* @__PURE__ */ new Date(NaN);
  const u = l.getTime();
  let f = 0, h;
  if (o.time && (f = parseTime(o.time), isNaN(f)))
    return /* @__PURE__ */ new Date(NaN);
  if (o.timezone) {
    if (h = parseTimezone(o.timezone), isNaN(h))
      return /* @__PURE__ */ new Date(NaN);
  } else {
    const p = new Date(u + f), v = /* @__PURE__ */ new Date(0);
    return v.setFullYear(
      p.getUTCFullYear(),
      p.getUTCMonth(),
      p.getUTCDate()
    ), v.setHours(
      p.getUTCHours(),
      p.getUTCMinutes(),
      p.getUTCSeconds(),
      p.getUTCMilliseconds()
    ), v;
  }
  return new Date(u + f + h);
}
const patterns = {
  dateTimeDelimiter: /[T ]/,
  timeZoneDelimiter: /[Z ]/i,
  timezone: /([Z+-].*)$/
}, dateRegex = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/, timeRegex = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/, timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
function splitDateString(t) {
  const e = {}, n = t.split(patterns.dateTimeDelimiter);
  let o;
  if (n.length > 2)
    return e;
  if (/:/.test(n[0]) ? o = n[0] : (e.date = n[0], o = n[1], patterns.timeZoneDelimiter.test(e.date) && (e.date = t.split(patterns.timeZoneDelimiter)[0], o = t.substr(
    e.date.length,
    t.length
  ))), o) {
    const l = patterns.timezone.exec(o);
    l ? (e.time = o.replace(l[1], ""), e.timezone = l[1]) : e.time = o;
  }
  return e;
}
function parseYear$1(t, e) {
  const n = new RegExp(
    "^(?:(\\d{4}|[+-]\\d{" + (4 + e) + "})|(\\d{2}|[+-]\\d{" + (2 + e) + "})$)"
  ), o = t.match(n);
  if (!o) return { year: NaN, restDateString: "" };
  const l = o[1] ? parseInt(o[1]) : null, u = o[2] ? parseInt(o[2]) : null;
  return {
    year: u === null ? l : u * 100,
    restDateString: t.slice((o[1] || o[2]).length)
  };
}
function parseDate$1(t, e) {
  if (e === null) return /* @__PURE__ */ new Date(NaN);
  const n = t.match(dateRegex);
  if (!n) return /* @__PURE__ */ new Date(NaN);
  const o = !!n[4], l = parseDateUnit(n[1]), u = parseDateUnit(n[2]) - 1, f = parseDateUnit(n[3]), h = parseDateUnit(n[4]), p = parseDateUnit(n[5]) - 1;
  if (o)
    return validateWeekDate(e, h, p) ? dayOfISOWeekYear(e, h, p) : /* @__PURE__ */ new Date(NaN);
  {
    const v = /* @__PURE__ */ new Date(0);
    return !validateDate(e, u, f) || !validateDayOfYearDate(e, l) ? /* @__PURE__ */ new Date(NaN) : (v.setUTCFullYear(e, u, Math.max(l, f)), v);
  }
}
function parseDateUnit(t) {
  return t ? parseInt(t) : 1;
}
function parseTime(t) {
  const e = t.match(timeRegex);
  if (!e) return NaN;
  const n = parseTimeUnit(e[1]), o = parseTimeUnit(e[2]), l = parseTimeUnit(e[3]);
  return validateTime(n, o, l) ? n * millisecondsInHour + o * millisecondsInMinute + l * 1e3 : NaN;
}
function parseTimeUnit(t) {
  return t && parseFloat(t.replace(",", ".")) || 0;
}
function parseTimezone(t) {
  if (t === "Z") return 0;
  const e = t.match(timezoneRegex);
  if (!e) return 0;
  const n = e[1] === "+" ? -1 : 1, o = parseInt(e[2]), l = e[3] && parseInt(e[3]) || 0;
  return validateTimezone(o, l) ? n * (o * millisecondsInHour + l * millisecondsInMinute) : NaN;
}
function dayOfISOWeekYear(t, e, n) {
  const o = /* @__PURE__ */ new Date(0);
  o.setUTCFullYear(t, 0, 4);
  const l = o.getUTCDay() || 7, u = (e - 1) * 7 + n + 1 - l;
  return o.setUTCDate(o.getUTCDate() + u), o;
}
const daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function isLeapYearIndex(t) {
  return t % 400 === 0 || t % 4 === 0 && t % 100 !== 0;
}
function validateDate(t, e, n) {
  return e >= 0 && e <= 11 && n >= 1 && n <= (daysInMonths[e] || (isLeapYearIndex(t) ? 29 : 28));
}
function validateDayOfYearDate(t, e) {
  return e >= 1 && e <= (isLeapYearIndex(t) ? 366 : 365);
}
function validateWeekDate(t, e, n) {
  return e >= 1 && e <= 53 && n >= 0 && n <= 6;
}
function validateTime(t, e, n) {
  return t === 24 ? e === 0 && n === 0 : n >= 0 && n < 60 && e >= 0 && e < 60 && t >= 0 && t < 25;
}
function validateTimezone(t, e) {
  return e >= 0 && e <= 59;
}
function setMonth(t, e) {
  const n = toDate(t), o = n.getFullYear(), l = n.getDate(), u = constructFrom(t, 0);
  u.setFullYear(o, e, 15), u.setHours(0, 0, 0, 0);
  const f = getDaysInMonth(u);
  return n.setMonth(e, Math.min(l, f)), n;
}
function set(t, e) {
  let n = toDate(t);
  return isNaN(+n) ? constructFrom(t, NaN) : (e.year != null && n.setFullYear(e.year), e.month != null && (n = setMonth(n, e.month)), e.date != null && n.setDate(e.date), e.hours != null && n.setHours(e.hours), e.minutes != null && n.setMinutes(e.minutes), e.seconds != null && n.setSeconds(e.seconds), e.milliseconds != null && n.setMilliseconds(e.milliseconds), n);
}
function setHours(t, e) {
  const n = toDate(t);
  return n.setHours(e), n;
}
function setMinutes(t, e) {
  const n = toDate(t);
  return n.setMinutes(e), n;
}
function setQuarter(t, e) {
  const n = toDate(t), o = Math.trunc(n.getMonth() / 3) + 1, l = e - o;
  return setMonth(n, n.getMonth() + l * 3);
}
function setSeconds(t, e) {
  const n = toDate(t);
  return n.setSeconds(e), n;
}
function setYear(t, e) {
  const n = toDate(t);
  return isNaN(+n) ? constructFrom(t, NaN) : (n.setFullYear(e), n);
}
function subMonths(t, e) {
  return addMonths(t, -e);
}
function subQuarters(t, e) {
  return addQuarters(t, -e);
}
function subWeeks(t, e) {
  return addWeeks(t, -e);
}
function subYears(t, e) {
  return addYears(t, -e);
}
const NodeTable = ({ data: t, loading: e, sorting: n, onSort: o }) => {
  const l = useNavigate(), u = createColumnHelper(), f = (g) => {
    l(`details/${g}`);
  }, h = ({ column: g, children: w }) => {
    const E = ["mtime", "ctime", "uuid"].includes(g), T = n.column === g ? n.order : null;
    return /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "flex items-center", children: [
      w,
      E && /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "ml-2 flex flex-col", children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          "button",
          {
            onClick: () => o(g),
            className: `text-xs ${T === "asc" ? "text-blue-500" : "text-gray-400"}`,
            children: "▲"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          "button",
          {
            onClick: () => o(g),
            className: `text-xs ${T === "desc" ? "text-blue-500" : "text-gray-400"}`,
            children: "▼"
          }
        )
      ] })
    ] });
  }, p = [
    u.accessor("uuid", {
      header: ({ column: g }) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(h, { column: "uuid", children: "UUID" }),
      cell: (g) => g.getValue()
    }),
    u.accessor("node_type", {
      header: "Name",
      cell: (g) => g.getValue()
    }),
    u.accessor("ctime", {
      header: ({ column: g }) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(h, { column: "ctime", children: "Creation Time" }),
      cell: (g) => format$1(new Date(g.getValue()), "yyyy-MM-dd")
    }),
    u.accessor("mtime", {
      header: ({ column: g }) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(h, { column: "mtime", children: "Modification Time" }),
      cell: (g) => format$1(new Date(g.getValue()), "yyyy-MM-dd")
    }),
    u.accessor("user_id", {
      header: "Creator",
      cell: (g) => g.getValue()
    }),
    u.accessor("process_type", {
      header: "Process State",
      cell: (g) => g.getValue()
    }),
    u.display({
      id: "actions",
      cell: (g) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(
        "button",
        {
          className: "bg-blue-300 hover:bg-blue-400 py-1 px-2 rounded-md",
          onClick: () => f(g.row.original.uuid),
          children: "Details"
        }
      )
    })
  ], v = useReactTable({
    data: t,
    columns: p,
    getCoreRowModel: getCoreRowModel()
  });
  return e ? /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "loading-animation m-auto flex justify-center text-center", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(ClipLoader, { size: 30, color: "#007bff" }) }) : /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs("table", { className: "min-w-full bg-white border border-gray-200", children: [
    /* @__PURE__ */ jsxRuntimeExports$1.jsx("thead", { children: v.getHeaderGroups().map((g) => /* @__PURE__ */ jsxRuntimeExports$1.jsx("tr", { children: g.headers.map((w) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      "th",
      {
        className: "p-2 border-b text-left bg-blue-50",
        children: w.isPlaceholder ? null : flexRender(
          w.column.columnDef.header,
          w.getContext()
        )
      },
      w.id
    )) }, g.id)) }),
    /* @__PURE__ */ jsxRuntimeExports$1.jsx("tbody", { children: v.getRowModel().rows.map((g) => /* @__PURE__ */ jsxRuntimeExports$1.jsx("tr", { className: "hover:bg-gray-50", children: g.getVisibleCells().map((w) => /* @__PURE__ */ jsxRuntimeExports$1.jsx("td", { className: "p-2 border-b", children: flexRender(w.column.columnDef.cell, w.getContext()) }, w.id)) }, g.id)) })
  ] }) });
};
async function fetchFullTypeCounts(t) {
  try {
    return (await (await fetch(`${t}/nodes/full_types_count/`)).json()).data;
  } catch (e) {
    console.error("Error fetching full type counts:", e);
  }
}
async function fetchNodesPaginated(t, e, n, o = 20, l = "ctime", u = "desc") {
  let f = `${t}/nodes/page/${n}`;
  return f += `?perpage=${o}&full_type="${e}"&orderby=${u === "desc" ? "-" : ""}${l}`, e.includes("process") && (f += "&attributes=true", f += "&attributes_filter=process_label,process_state,exit_status,exit_message,process_status,exception"), (await (await fetch(f)).json()).data.nodes;
}
const NodeGrid = ({ apiUrl: t }) => {
  const e = t, n = 20, [o, l] = useState([]), [u, f] = useState(!1), [h, p] = useState(1);
  useSearchParams();
  const [v, g] = useState(null), [w, E] = useState(null), [T, R] = useState({ column: "ctime", order: "desc" }), _ = async (S) => {
    if (f(!0), v && S >= 1)
      try {
        const C = await fetchNodesPaginated(
          e,
          v.full_type,
          S,
          n,
          T.column,
          T.order
        );
        l(C);
      } catch (C) {
        console.error("Error fetching data:", C), l([]);
      } finally {
        f(!1);
      }
  }, b = () => {
    if (v && v.counter) {
      const S = v.counter;
      return Math.ceil(S / n);
    }
    return 1;
  };
  useEffect(() => {
    f(!0), fetchFullTypeCounts(e).then((S) => {
      E(S), S.subspaces && g(S.subspaces[0]);
    }).finally(() => f(!1));
  }, []), useEffect(() => {
    _(h);
  }, [v, h, T]);
  const M = (S) => {
    S >= 1 && S <= b() && p(S);
  }, A = (S) => {
    R((C) => ({
      column: S,
      order: C.column === S && C.order === "asc" ? "desc" : "asc"
    }));
  }, $ = () => {
    const S = b(), C = Math.max(1, h - 7), D = Math.min(S, h + 7), O = [];
    for (let N = C; N <= D; N++)
      O.push(
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          "button",
          {
            onClick: () => M(N),
            className: `px-2 py-1 ${N === h ? "bg-blue-200" : "bg-gray-100"} text-sm rounded`,
            children: N
          },
          N
        )
      );
    return /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "flex space-x-2", children: [
      /* @__PURE__ */ jsxRuntimeExports$1.jsx(
        "button",
        {
          onClick: () => M(1),
          disabled: h === 1,
          className: "px-2 py-1 bg-gray-100 text-sm rounded",
          children: "First"
        }
      ),
      O,
      /* @__PURE__ */ jsxRuntimeExports$1.jsx(
        "button",
        {
          onClick: () => M(S),
          disabled: h === S,
          className: "px-2 py-1 bg-gray-100 text-sm rounded",
          children: "Last"
        }
      )
    ] });
  };
  return /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "flex w-full h-4/5 mx-auto py-2 px-0 text-sm", children: [
    /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "w-full sm:w-1/5 mr-2 bg-green-50", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      FilterSidebar,
      {
        fullTypeCounts: w,
        selectedNode: v,
        onSelectNode: (S) => {
          g(S), p(1);
        }
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "w-full sm:w-4/5 ml-2 flex flex-col", children: [
      /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "overflow-x-auto h-[96%] flex-grow", children: u ? /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "flex justify-center items-center h-[96%]", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(ClipLoader, { size: 50, color: "#007bff" }) }) : /* @__PURE__ */ jsxRuntimeExports$1.jsx(
        NodeTable,
        {
          data: o,
          loading: u,
          sorting: T,
          onSort: A
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "flex justify-between items-center mt-4", children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          "button",
          {
            onClick: () => M(h - 1),
            disabled: h === 1,
            className: "px-3 py-1 bg-green-100 text-green-800 rounded disabled:bg-gray-100 disabled:text-gray-400 text-xs",
            children: "Previous"
          }
        ),
        $(),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          "button",
          {
            onClick: () => M(h + 1),
            disabled: h === b(),
            className: "px-3 py-1 bg-green-100 text-green-800 rounded disabled:bg-gray-100 disabled:text-gray-400 text-xs",
            children: "Next"
          }
        )
      ] })
    ] })
  ] });
};
var isArray$f = Array.isArray, isArray_1 = isArray$f, freeGlobal$1 = typeof commonjsGlobal$1 == "object" && commonjsGlobal$1 && commonjsGlobal$1.Object === Object && commonjsGlobal$1, _freeGlobal = freeGlobal$1, freeGlobal = _freeGlobal, freeSelf = typeof self == "object" && self && self.Object === Object && self, root$9 = freeGlobal || freeSelf || Function("return this")(), _root = root$9, root$8 = _root, Symbol$7 = root$8.Symbol, _Symbol = Symbol$7, Symbol$6 = _Symbol, objectProto$c = Object.prototype, hasOwnProperty$a = objectProto$c.hasOwnProperty, nativeObjectToString$1 = objectProto$c.toString, symToStringTag$1 = Symbol$6 ? Symbol$6.toStringTag : void 0;
function getRawTag$1(t) {
  var e = hasOwnProperty$a.call(t, symToStringTag$1), n = t[symToStringTag$1];
  try {
    t[symToStringTag$1] = void 0;
    var o = !0;
  } catch {
  }
  var l = nativeObjectToString$1.call(t);
  return o && (e ? t[symToStringTag$1] = n : delete t[symToStringTag$1]), l;
}
var _getRawTag = getRawTag$1, objectProto$b = Object.prototype, nativeObjectToString = objectProto$b.toString;
function objectToString$1(t) {
  return nativeObjectToString.call(t);
}
var _objectToString = objectToString$1, Symbol$5 = _Symbol, getRawTag = _getRawTag, objectToString = _objectToString, nullTag = "[object Null]", undefinedTag = "[object Undefined]", symToStringTag = Symbol$5 ? Symbol$5.toStringTag : void 0;
function baseGetTag$9(t) {
  return t == null ? t === void 0 ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object(t) ? getRawTag(t) : objectToString(t);
}
var _baseGetTag = baseGetTag$9;
function isObjectLike$9(t) {
  return t != null && typeof t == "object";
}
var isObjectLike_1 = isObjectLike$9, baseGetTag$8 = _baseGetTag, isObjectLike$8 = isObjectLike_1, symbolTag$1 = "[object Symbol]";
function isSymbol$6(t) {
  return typeof t == "symbol" || isObjectLike$8(t) && baseGetTag$8(t) == symbolTag$1;
}
var isSymbol_1 = isSymbol$6, isArray$e = isArray_1, isSymbol$5 = isSymbol_1, reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey$3(t, e) {
  if (isArray$e(t))
    return !1;
  var n = typeof t;
  return n == "number" || n == "symbol" || n == "boolean" || t == null || isSymbol$5(t) ? !0 : reIsPlainProp.test(t) || !reIsDeepProp.test(t) || e != null && t in Object(e);
}
var _isKey = isKey$3;
function isObject$7(t) {
  var e = typeof t;
  return t != null && (e == "object" || e == "function");
}
var isObject_1 = isObject$7;
const isObject$8 = /* @__PURE__ */ getDefaultExportFromCjs(isObject_1);
var baseGetTag$7 = _baseGetTag, isObject$6 = isObject_1, asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$2(t) {
  if (!isObject$6(t))
    return !1;
  var e = baseGetTag$7(t);
  return e == funcTag$1 || e == genTag || e == asyncTag || e == proxyTag;
}
var isFunction_1 = isFunction$2;
const isFunction$3 = /* @__PURE__ */ getDefaultExportFromCjs(isFunction_1);
var root$7 = _root, coreJsData$1 = root$7["__core-js_shared__"], _coreJsData = coreJsData$1, coreJsData = _coreJsData, maskSrcKey = function() {
  var t = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return t ? "Symbol(src)_1." + t : "";
}();
function isMasked$1(t) {
  return !!maskSrcKey && maskSrcKey in t;
}
var _isMasked = isMasked$1, funcProto$2 = Function.prototype, funcToString$2 = funcProto$2.toString;
function toSource$2(t) {
  if (t != null) {
    try {
      return funcToString$2.call(t);
    } catch {
    }
    try {
      return t + "";
    } catch {
    }
  }
  return "";
}
var _toSource = toSource$2, isFunction$1 = isFunction_1, isMasked = _isMasked, isObject$5 = isObject_1, toSource$1 = _toSource, reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reIsHostCtor = /^\[object .+?Constructor\]$/, funcProto$1 = Function.prototype, objectProto$a = Object.prototype, funcToString$1 = funcProto$1.toString, hasOwnProperty$9 = objectProto$a.hasOwnProperty, reIsNative = RegExp(
  "^" + funcToString$1.call(hasOwnProperty$9).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative$1(t) {
  if (!isObject$5(t) || isMasked(t))
    return !1;
  var e = isFunction$1(t) ? reIsNative : reIsHostCtor;
  return e.test(toSource$1(t));
}
var _baseIsNative = baseIsNative$1;
function getValue$1(t, e) {
  return t == null ? void 0 : t[e];
}
var _getValue = getValue$1, baseIsNative = _baseIsNative, getValue = _getValue;
function getNative$7(t, e) {
  var n = getValue(t, e);
  return baseIsNative(n) ? n : void 0;
}
var _getNative = getNative$7, getNative$6 = _getNative, nativeCreate$4 = getNative$6(Object, "create"), _nativeCreate = nativeCreate$4, nativeCreate$3 = _nativeCreate;
function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {}, this.size = 0;
}
var _hashClear = hashClear$1;
function hashDelete$1(t) {
  var e = this.has(t) && delete this.__data__[t];
  return this.size -= e ? 1 : 0, e;
}
var _hashDelete = hashDelete$1, nativeCreate$2 = _nativeCreate, HASH_UNDEFINED$2 = "__lodash_hash_undefined__", objectProto$9 = Object.prototype, hasOwnProperty$8 = objectProto$9.hasOwnProperty;
function hashGet$1(t) {
  var e = this.__data__;
  if (nativeCreate$2) {
    var n = e[t];
    return n === HASH_UNDEFINED$2 ? void 0 : n;
  }
  return hasOwnProperty$8.call(e, t) ? e[t] : void 0;
}
var _hashGet = hashGet$1, nativeCreate$1 = _nativeCreate, objectProto$8 = Object.prototype, hasOwnProperty$7 = objectProto$8.hasOwnProperty;
function hashHas$1(t) {
  var e = this.__data__;
  return nativeCreate$1 ? e[t] !== void 0 : hasOwnProperty$7.call(e, t);
}
var _hashHas = hashHas$1, nativeCreate = _nativeCreate, HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet$1(t, e) {
  var n = this.__data__;
  return this.size += this.has(t) ? 0 : 1, n[t] = nativeCreate && e === void 0 ? HASH_UNDEFINED$1 : e, this;
}
var _hashSet = hashSet$1, hashClear = _hashClear, hashDelete = _hashDelete, hashGet = _hashGet, hashHas = _hashHas, hashSet = _hashSet;
function Hash$1(t) {
  var e = -1, n = t == null ? 0 : t.length;
  for (this.clear(); ++e < n; ) {
    var o = t[e];
    this.set(o[0], o[1]);
  }
}
Hash$1.prototype.clear = hashClear;
Hash$1.prototype.delete = hashDelete;
Hash$1.prototype.get = hashGet;
Hash$1.prototype.has = hashHas;
Hash$1.prototype.set = hashSet;
var _Hash = Hash$1;
function listCacheClear$1() {
  this.__data__ = [], this.size = 0;
}
var _listCacheClear = listCacheClear$1;
function eq$3(t, e) {
  return t === e || t !== t && e !== e;
}
var eq_1 = eq$3, eq$2 = eq_1;
function assocIndexOf$4(t, e) {
  for (var n = t.length; n--; )
    if (eq$2(t[n][0], e))
      return n;
  return -1;
}
var _assocIndexOf = assocIndexOf$4, assocIndexOf$3 = _assocIndexOf, arrayProto = Array.prototype, splice = arrayProto.splice;
function listCacheDelete$1(t) {
  var e = this.__data__, n = assocIndexOf$3(e, t);
  if (n < 0)
    return !1;
  var o = e.length - 1;
  return n == o ? e.pop() : splice.call(e, n, 1), --this.size, !0;
}
var _listCacheDelete = listCacheDelete$1, assocIndexOf$2 = _assocIndexOf;
function listCacheGet$1(t) {
  var e = this.__data__, n = assocIndexOf$2(e, t);
  return n < 0 ? void 0 : e[n][1];
}
var _listCacheGet = listCacheGet$1, assocIndexOf$1 = _assocIndexOf;
function listCacheHas$1(t) {
  return assocIndexOf$1(this.__data__, t) > -1;
}
var _listCacheHas = listCacheHas$1, assocIndexOf = _assocIndexOf;
function listCacheSet$1(t, e) {
  var n = this.__data__, o = assocIndexOf(n, t);
  return o < 0 ? (++this.size, n.push([t, e])) : n[o][1] = e, this;
}
var _listCacheSet = listCacheSet$1, listCacheClear = _listCacheClear, listCacheDelete = _listCacheDelete, listCacheGet = _listCacheGet, listCacheHas = _listCacheHas, listCacheSet = _listCacheSet;
function ListCache$4(t) {
  var e = -1, n = t == null ? 0 : t.length;
  for (this.clear(); ++e < n; ) {
    var o = t[e];
    this.set(o[0], o[1]);
  }
}
ListCache$4.prototype.clear = listCacheClear;
ListCache$4.prototype.delete = listCacheDelete;
ListCache$4.prototype.get = listCacheGet;
ListCache$4.prototype.has = listCacheHas;
ListCache$4.prototype.set = listCacheSet;
var _ListCache = ListCache$4, getNative$5 = _getNative, root$6 = _root, Map$4 = getNative$5(root$6, "Map"), _Map = Map$4, Hash = _Hash, ListCache$3 = _ListCache, Map$3 = _Map;
function mapCacheClear$1() {
  this.size = 0, this.__data__ = {
    hash: new Hash(),
    map: new (Map$3 || ListCache$3)(),
    string: new Hash()
  };
}
var _mapCacheClear = mapCacheClear$1;
function isKeyable$1(t) {
  var e = typeof t;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t !== "__proto__" : t === null;
}
var _isKeyable = isKeyable$1, isKeyable = _isKeyable;
function getMapData$4(t, e) {
  var n = t.__data__;
  return isKeyable(e) ? n[typeof e == "string" ? "string" : "hash"] : n.map;
}
var _getMapData = getMapData$4, getMapData$3 = _getMapData;
function mapCacheDelete$1(t) {
  var e = getMapData$3(this, t).delete(t);
  return this.size -= e ? 1 : 0, e;
}
var _mapCacheDelete = mapCacheDelete$1, getMapData$2 = _getMapData;
function mapCacheGet$1(t) {
  return getMapData$2(this, t).get(t);
}
var _mapCacheGet = mapCacheGet$1, getMapData$1 = _getMapData;
function mapCacheHas$1(t) {
  return getMapData$1(this, t).has(t);
}
var _mapCacheHas = mapCacheHas$1, getMapData = _getMapData;
function mapCacheSet$1(t, e) {
  var n = getMapData(this, t), o = n.size;
  return n.set(t, e), this.size += n.size == o ? 0 : 1, this;
}
var _mapCacheSet = mapCacheSet$1, mapCacheClear = _mapCacheClear, mapCacheDelete = _mapCacheDelete, mapCacheGet = _mapCacheGet, mapCacheHas = _mapCacheHas, mapCacheSet = _mapCacheSet;
function MapCache$3(t) {
  var e = -1, n = t == null ? 0 : t.length;
  for (this.clear(); ++e < n; ) {
    var o = t[e];
    this.set(o[0], o[1]);
  }
}
MapCache$3.prototype.clear = mapCacheClear;
MapCache$3.prototype.delete = mapCacheDelete;
MapCache$3.prototype.get = mapCacheGet;
MapCache$3.prototype.has = mapCacheHas;
MapCache$3.prototype.set = mapCacheSet;
var _MapCache = MapCache$3, MapCache$2 = _MapCache, FUNC_ERROR_TEXT$2 = "Expected a function";
function memoize$2(t, e) {
  if (typeof t != "function" || e != null && typeof e != "function")
    throw new TypeError(FUNC_ERROR_TEXT$2);
  var n = function() {
    var o = arguments, l = e ? e.apply(this, o) : o[0], u = n.cache;
    if (u.has(l))
      return u.get(l);
    var f = t.apply(this, o);
    return n.cache = u.set(l, f) || u, f;
  };
  return n.cache = new (memoize$2.Cache || MapCache$2)(), n;
}
memoize$2.Cache = MapCache$2;
var memoize_1 = memoize$2;
const memoize$3 = /* @__PURE__ */ getDefaultExportFromCjs(memoize_1);
var memoize$1 = memoize_1, MAX_MEMOIZE_SIZE = 500;
function memoizeCapped$1(t) {
  var e = memoize$1(t, function(o) {
    return n.size === MAX_MEMOIZE_SIZE && n.clear(), o;
  }), n = e.cache;
  return e;
}
var _memoizeCapped = memoizeCapped$1, memoizeCapped = _memoizeCapped, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, reEscapeChar = /\\(\\)?/g, stringToPath$1 = memoizeCapped(function(t) {
  var e = [];
  return t.charCodeAt(0) === 46 && e.push(""), t.replace(rePropName, function(n, o, l, u) {
    e.push(l ? u.replace(reEscapeChar, "$1") : o || n);
  }), e;
}), _stringToPath = stringToPath$1;
function arrayMap$3(t, e) {
  for (var n = -1, o = t == null ? 0 : t.length, l = Array(o); ++n < o; )
    l[n] = e(t[n], n, t);
  return l;
}
var _arrayMap = arrayMap$3, Symbol$4 = _Symbol, arrayMap$2 = _arrayMap, isArray$d = isArray_1, isSymbol$4 = isSymbol_1, INFINITY$3 = 1 / 0, symbolProto$1 = Symbol$4 ? Symbol$4.prototype : void 0, symbolToString = symbolProto$1 ? symbolProto$1.toString : void 0;
function baseToString$1(t) {
  if (typeof t == "string")
    return t;
  if (isArray$d(t))
    return arrayMap$2(t, baseToString$1) + "";
  if (isSymbol$4(t))
    return symbolToString ? symbolToString.call(t) : "";
  var e = t + "";
  return e == "0" && 1 / t == -INFINITY$3 ? "-0" : e;
}
var _baseToString = baseToString$1, baseToString = _baseToString;
function toString$3(t) {
  return t == null ? "" : baseToString(t);
}
var toString_1 = toString$3, isArray$c = isArray_1, isKey$2 = _isKey, stringToPath = _stringToPath, toString$2 = toString_1;
function castPath$2(t, e) {
  return isArray$c(t) ? t : isKey$2(t, e) ? [t] : stringToPath(toString$2(t));
}
var _castPath = castPath$2, isSymbol$3 = isSymbol_1, INFINITY$2 = 1 / 0;
function toKey$4(t) {
  if (typeof t == "string" || isSymbol$3(t))
    return t;
  var e = t + "";
  return e == "0" && 1 / t == -INFINITY$2 ? "-0" : e;
}
var _toKey = toKey$4, castPath$1 = _castPath, toKey$3 = _toKey;
function baseGet$3(t, e) {
  e = castPath$1(e, t);
  for (var n = 0, o = e.length; t != null && n < o; )
    t = t[toKey$3(e[n++])];
  return n && n == o ? t : void 0;
}
var _baseGet = baseGet$3, baseGet$2 = _baseGet;
function get$1(t, e, n) {
  var o = t == null ? void 0 : baseGet$2(t, e);
  return o === void 0 ? n : o;
}
var get_1 = get$1;
const get$2 = /* @__PURE__ */ getDefaultExportFromCjs(get_1);
function isNil(t) {
  return t == null;
}
var isNil_1 = isNil;
const isNil$1 = /* @__PURE__ */ getDefaultExportFromCjs(isNil_1);
var baseGetTag$6 = _baseGetTag, isArray$b = isArray_1, isObjectLike$7 = isObjectLike_1, stringTag$2 = "[object String]";
function isString(t) {
  return typeof t == "string" || !isArray$b(t) && isObjectLike$7(t) && baseGetTag$6(t) == stringTag$2;
}
var isString_1 = isString;
const isString$1 = /* @__PURE__ */ getDefaultExportFromCjs(isString_1);
var reactIs = { exports: {} }, reactIs_production_min = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_production_min;
function requireReactIs_production_min() {
  if (hasRequiredReactIs_production_min) return reactIs_production_min;
  hasRequiredReactIs_production_min = 1;
  var t = typeof Symbol == "function" && Symbol.for, e = t ? Symbol.for("react.element") : 60103, n = t ? Symbol.for("react.portal") : 60106, o = t ? Symbol.for("react.fragment") : 60107, l = t ? Symbol.for("react.strict_mode") : 60108, u = t ? Symbol.for("react.profiler") : 60114, f = t ? Symbol.for("react.provider") : 60109, h = t ? Symbol.for("react.context") : 60110, p = t ? Symbol.for("react.async_mode") : 60111, v = t ? Symbol.for("react.concurrent_mode") : 60111, g = t ? Symbol.for("react.forward_ref") : 60112, w = t ? Symbol.for("react.suspense") : 60113, E = t ? Symbol.for("react.suspense_list") : 60120, T = t ? Symbol.for("react.memo") : 60115, R = t ? Symbol.for("react.lazy") : 60116, _ = t ? Symbol.for("react.block") : 60121, b = t ? Symbol.for("react.fundamental") : 60117, M = t ? Symbol.for("react.responder") : 60118, A = t ? Symbol.for("react.scope") : 60119;
  function $(C) {
    if (typeof C == "object" && C !== null) {
      var D = C.$$typeof;
      switch (D) {
        case e:
          switch (C = C.type, C) {
            case p:
            case v:
            case o:
            case u:
            case l:
            case w:
              return C;
            default:
              switch (C = C && C.$$typeof, C) {
                case h:
                case g:
                case R:
                case T:
                case f:
                  return C;
                default:
                  return D;
              }
          }
        case n:
          return D;
      }
    }
  }
  function S(C) {
    return $(C) === v;
  }
  return reactIs_production_min.AsyncMode = p, reactIs_production_min.ConcurrentMode = v, reactIs_production_min.ContextConsumer = h, reactIs_production_min.ContextProvider = f, reactIs_production_min.Element = e, reactIs_production_min.ForwardRef = g, reactIs_production_min.Fragment = o, reactIs_production_min.Lazy = R, reactIs_production_min.Memo = T, reactIs_production_min.Portal = n, reactIs_production_min.Profiler = u, reactIs_production_min.StrictMode = l, reactIs_production_min.Suspense = w, reactIs_production_min.isAsyncMode = function(C) {
    return S(C) || $(C) === p;
  }, reactIs_production_min.isConcurrentMode = S, reactIs_production_min.isContextConsumer = function(C) {
    return $(C) === h;
  }, reactIs_production_min.isContextProvider = function(C) {
    return $(C) === f;
  }, reactIs_production_min.isElement = function(C) {
    return typeof C == "object" && C !== null && C.$$typeof === e;
  }, reactIs_production_min.isForwardRef = function(C) {
    return $(C) === g;
  }, reactIs_production_min.isFragment = function(C) {
    return $(C) === o;
  }, reactIs_production_min.isLazy = function(C) {
    return $(C) === R;
  }, reactIs_production_min.isMemo = function(C) {
    return $(C) === T;
  }, reactIs_production_min.isPortal = function(C) {
    return $(C) === n;
  }, reactIs_production_min.isProfiler = function(C) {
    return $(C) === u;
  }, reactIs_production_min.isStrictMode = function(C) {
    return $(C) === l;
  }, reactIs_production_min.isSuspense = function(C) {
    return $(C) === w;
  }, reactIs_production_min.isValidElementType = function(C) {
    return typeof C == "string" || typeof C == "function" || C === o || C === v || C === u || C === l || C === w || C === E || typeof C == "object" && C !== null && (C.$$typeof === R || C.$$typeof === T || C.$$typeof === f || C.$$typeof === h || C.$$typeof === g || C.$$typeof === b || C.$$typeof === M || C.$$typeof === A || C.$$typeof === _);
  }, reactIs_production_min.typeOf = $, reactIs_production_min;
}
var reactIs_development = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_development;
function requireReactIs_development() {
  return hasRequiredReactIs_development || (hasRequiredReactIs_development = 1, process.env.NODE_ENV !== "production" && function() {
    var t = typeof Symbol == "function" && Symbol.for, e = t ? Symbol.for("react.element") : 60103, n = t ? Symbol.for("react.portal") : 60106, o = t ? Symbol.for("react.fragment") : 60107, l = t ? Symbol.for("react.strict_mode") : 60108, u = t ? Symbol.for("react.profiler") : 60114, f = t ? Symbol.for("react.provider") : 60109, h = t ? Symbol.for("react.context") : 60110, p = t ? Symbol.for("react.async_mode") : 60111, v = t ? Symbol.for("react.concurrent_mode") : 60111, g = t ? Symbol.for("react.forward_ref") : 60112, w = t ? Symbol.for("react.suspense") : 60113, E = t ? Symbol.for("react.suspense_list") : 60120, T = t ? Symbol.for("react.memo") : 60115, R = t ? Symbol.for("react.lazy") : 60116, _ = t ? Symbol.for("react.block") : 60121, b = t ? Symbol.for("react.fundamental") : 60117, M = t ? Symbol.for("react.responder") : 60118, A = t ? Symbol.for("react.scope") : 60119;
    function $(ee) {
      return typeof ee == "string" || typeof ee == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      ee === o || ee === v || ee === u || ee === l || ee === w || ee === E || typeof ee == "object" && ee !== null && (ee.$$typeof === R || ee.$$typeof === T || ee.$$typeof === f || ee.$$typeof === h || ee.$$typeof === g || ee.$$typeof === b || ee.$$typeof === M || ee.$$typeof === A || ee.$$typeof === _);
    }
    function S(ee) {
      if (typeof ee == "object" && ee !== null) {
        var Ae = ee.$$typeof;
        switch (Ae) {
          case e:
            var be = ee.type;
            switch (be) {
              case p:
              case v:
              case o:
              case u:
              case l:
              case w:
                return be;
              default:
                var Fe = be && be.$$typeof;
                switch (Fe) {
                  case h:
                  case g:
                  case R:
                  case T:
                  case f:
                    return Fe;
                  default:
                    return Ae;
                }
            }
          case n:
            return Ae;
        }
      }
    }
    var C = p, D = v, O = h, N = f, j = e, L = g, z = o, G = R, B = T, F = n, H = u, W = l, V = w, X = !1;
    function Z(ee) {
      return X || (X = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), Q(ee) || S(ee) === p;
    }
    function Q(ee) {
      return S(ee) === v;
    }
    function q(ee) {
      return S(ee) === h;
    }
    function J(ee) {
      return S(ee) === f;
    }
    function ie(ee) {
      return typeof ee == "object" && ee !== null && ee.$$typeof === e;
    }
    function ne(ee) {
      return S(ee) === g;
    }
    function ge(ee) {
      return S(ee) === o;
    }
    function ye(ee) {
      return S(ee) === R;
    }
    function xe(ee) {
      return S(ee) === T;
    }
    function we(ee) {
      return S(ee) === n;
    }
    function de(ee) {
      return S(ee) === u;
    }
    function Te(ee) {
      return S(ee) === l;
    }
    function Ce(ee) {
      return S(ee) === w;
    }
    reactIs_development.AsyncMode = C, reactIs_development.ConcurrentMode = D, reactIs_development.ContextConsumer = O, reactIs_development.ContextProvider = N, reactIs_development.Element = j, reactIs_development.ForwardRef = L, reactIs_development.Fragment = z, reactIs_development.Lazy = G, reactIs_development.Memo = B, reactIs_development.Portal = F, reactIs_development.Profiler = H, reactIs_development.StrictMode = W, reactIs_development.Suspense = V, reactIs_development.isAsyncMode = Z, reactIs_development.isConcurrentMode = Q, reactIs_development.isContextConsumer = q, reactIs_development.isContextProvider = J, reactIs_development.isElement = ie, reactIs_development.isForwardRef = ne, reactIs_development.isFragment = ge, reactIs_development.isLazy = ye, reactIs_development.isMemo = xe, reactIs_development.isPortal = we, reactIs_development.isProfiler = de, reactIs_development.isStrictMode = Te, reactIs_development.isSuspense = Ce, reactIs_development.isValidElementType = $, reactIs_development.typeOf = S;
  }()), reactIs_development;
}
process.env.NODE_ENV === "production" ? reactIs.exports = requireReactIs_production_min() : reactIs.exports = requireReactIs_development();
var reactIsExports = reactIs.exports, baseGetTag$5 = _baseGetTag, isObjectLike$6 = isObjectLike_1, numberTag$2 = "[object Number]";
function isNumber$2(t) {
  return typeof t == "number" || isObjectLike$6(t) && baseGetTag$5(t) == numberTag$2;
}
var isNumber_1 = isNumber$2;
const isNumber$3 = /* @__PURE__ */ getDefaultExportFromCjs(isNumber_1);
var isNumber$1 = isNumber_1;
function isNaN$1(t) {
  return isNumber$1(t) && t != +t;
}
var _isNaN = isNaN$1;
const isNan = /* @__PURE__ */ getDefaultExportFromCjs(_isNaN);
var mathSign = function t(e) {
  return e === 0 ? 0 : e > 0 ? 1 : -1;
}, isPercent = function t(e) {
  return isString$1(e) && e.indexOf("%") === e.length - 1;
}, isNumber = function t(e) {
  return isNumber$3(e) && !isNan(e);
}, isNumOrStr = function t(e) {
  return isNumber(e) || isString$1(e);
}, idCounter = 0, uniqueId = function t(e) {
  var n = ++idCounter;
  return "".concat(e || "").concat(n);
}, getPercentValue = function t(e, n) {
  var o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, l = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  if (!isNumber(e) && !isString$1(e))
    return o;
  var u;
  if (isPercent(e)) {
    var f = e.indexOf("%");
    u = n * parseFloat(e.slice(0, f)) / 100;
  } else
    u = +e;
  return isNan(u) && (u = o), l && u > n && (u = n), u;
}, getAnyElementOfObject = function t(e) {
  if (!e)
    return null;
  var n = Object.keys(e);
  return n && n.length ? e[n[0]] : null;
}, hasDuplicate = function t(e) {
  if (!Array.isArray(e))
    return !1;
  for (var n = e.length, o = {}, l = 0; l < n; l++)
    if (!o[e[l]])
      o[e[l]] = !0;
    else
      return !0;
  return !1;
}, interpolateNumber$1 = function t(e, n) {
  return isNumber(e) && isNumber(n) ? function(o) {
    return e + o * (n - e);
  } : function() {
    return n;
  };
};
function findEntryInArray(t, e, n) {
  return !t || !t.length ? null : t.find(function(o) {
    return o && (typeof e == "function" ? e(o) : get$2(o, e)) === n;
  });
}
function shallowEqual(t, e) {
  for (var n in t)
    if ({}.hasOwnProperty.call(t, n) && (!{}.hasOwnProperty.call(e, n) || t[n] !== e[n]))
      return !1;
  for (var o in e)
    if ({}.hasOwnProperty.call(e, o) && !{}.hasOwnProperty.call(t, o))
      return !1;
  return !0;
}
function _typeof$I(t) {
  "@babel/helpers - typeof";
  return _typeof$I = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof$I(t);
}
var SVGContainerPropKeys = ["viewBox", "children"], SVGElementPropKeys = [
  "aria-activedescendant",
  "aria-atomic",
  "aria-autocomplete",
  "aria-busy",
  "aria-checked",
  "aria-colcount",
  "aria-colindex",
  "aria-colspan",
  "aria-controls",
  "aria-current",
  "aria-describedby",
  "aria-details",
  "aria-disabled",
  "aria-errormessage",
  "aria-expanded",
  "aria-flowto",
  "aria-haspopup",
  "aria-hidden",
  "aria-invalid",
  "aria-keyshortcuts",
  "aria-label",
  "aria-labelledby",
  "aria-level",
  "aria-live",
  "aria-modal",
  "aria-multiline",
  "aria-multiselectable",
  "aria-orientation",
  "aria-owns",
  "aria-placeholder",
  "aria-posinset",
  "aria-pressed",
  "aria-readonly",
  "aria-relevant",
  "aria-required",
  "aria-roledescription",
  "aria-rowcount",
  "aria-rowindex",
  "aria-rowspan",
  "aria-selected",
  "aria-setsize",
  "aria-sort",
  "aria-valuemax",
  "aria-valuemin",
  "aria-valuenow",
  "aria-valuetext",
  "className",
  "color",
  "height",
  "id",
  "lang",
  "max",
  "media",
  "method",
  "min",
  "name",
  "style",
  /*
   * removed 'type' SVGElementPropKey because we do not currently use any SVG elements
   * that can use it and it conflicts with the recharts prop 'type'
   * https://github.com/recharts/recharts/pull/3327
   * https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/type
   */
  // 'type',
  "target",
  "width",
  "role",
  "tabIndex",
  "accentHeight",
  "accumulate",
  "additive",
  "alignmentBaseline",
  "allowReorder",
  "alphabetic",
  "amplitude",
  "arabicForm",
  "ascent",
  "attributeName",
  "attributeType",
  "autoReverse",
  "azimuth",
  "baseFrequency",
  "baselineShift",
  "baseProfile",
  "bbox",
  "begin",
  "bias",
  "by",
  "calcMode",
  "capHeight",
  "clip",
  "clipPath",
  "clipPathUnits",
  "clipRule",
  "colorInterpolation",
  "colorInterpolationFilters",
  "colorProfile",
  "colorRendering",
  "contentScriptType",
  "contentStyleType",
  "cursor",
  "cx",
  "cy",
  "d",
  "decelerate",
  "descent",
  "diffuseConstant",
  "direction",
  "display",
  "divisor",
  "dominantBaseline",
  "dur",
  "dx",
  "dy",
  "edgeMode",
  "elevation",
  "enableBackground",
  "end",
  "exponent",
  "externalResourcesRequired",
  "fill",
  "fillOpacity",
  "fillRule",
  "filter",
  "filterRes",
  "filterUnits",
  "floodColor",
  "floodOpacity",
  "focusable",
  "fontFamily",
  "fontSize",
  "fontSizeAdjust",
  "fontStretch",
  "fontStyle",
  "fontVariant",
  "fontWeight",
  "format",
  "from",
  "fx",
  "fy",
  "g1",
  "g2",
  "glyphName",
  "glyphOrientationHorizontal",
  "glyphOrientationVertical",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "hanging",
  "horizAdvX",
  "horizOriginX",
  "href",
  "ideographic",
  "imageRendering",
  "in2",
  "in",
  "intercept",
  "k1",
  "k2",
  "k3",
  "k4",
  "k",
  "kernelMatrix",
  "kernelUnitLength",
  "kerning",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "letterSpacing",
  "lightingColor",
  "limitingConeAngle",
  "local",
  "markerEnd",
  "markerHeight",
  "markerMid",
  "markerStart",
  "markerUnits",
  "markerWidth",
  "mask",
  "maskContentUnits",
  "maskUnits",
  "mathematical",
  "mode",
  "numOctaves",
  "offset",
  "opacity",
  "operator",
  "order",
  "orient",
  "orientation",
  "origin",
  "overflow",
  "overlinePosition",
  "overlineThickness",
  "paintOrder",
  "panose1",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointerEvents",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "r",
  "radius",
  "refX",
  "refY",
  "renderingIntent",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "restart",
  "result",
  "rotate",
  "rx",
  "ry",
  "seed",
  "shapeRendering",
  "slope",
  "spacing",
  "specularConstant",
  "specularExponent",
  "speed",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stemh",
  "stemv",
  "stitchTiles",
  "stopColor",
  "stopOpacity",
  "strikethroughPosition",
  "strikethroughThickness",
  "string",
  "stroke",
  "strokeDasharray",
  "strokeDashoffset",
  "strokeLinecap",
  "strokeLinejoin",
  "strokeMiterlimit",
  "strokeOpacity",
  "strokeWidth",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textAnchor",
  "textDecoration",
  "textLength",
  "textRendering",
  "to",
  "transform",
  "u1",
  "u2",
  "underlinePosition",
  "underlineThickness",
  "unicode",
  "unicodeBidi",
  "unicodeRange",
  "unitsPerEm",
  "vAlphabetic",
  "values",
  "vectorEffect",
  "version",
  "vertAdvY",
  "vertOriginX",
  "vertOriginY",
  "vHanging",
  "vIdeographic",
  "viewTarget",
  "visibility",
  "vMathematical",
  "widths",
  "wordSpacing",
  "writingMode",
  "x1",
  "x2",
  "x",
  "xChannelSelector",
  "xHeight",
  "xlinkActuate",
  "xlinkArcrole",
  "xlinkHref",
  "xlinkRole",
  "xlinkShow",
  "xlinkTitle",
  "xlinkType",
  "xmlBase",
  "xmlLang",
  "xmlns",
  "xmlnsXlink",
  "xmlSpace",
  "y1",
  "y2",
  "y",
  "yChannelSelector",
  "z",
  "zoomAndPan",
  "ref",
  "key",
  "angle"
], PolyElementKeys = ["points", "pathLength"], FilteredElementKeyMap = {
  svg: SVGContainerPropKeys,
  polygon: PolyElementKeys,
  polyline: PolyElementKeys
}, EventKeys = ["dangerouslySetInnerHTML", "onCopy", "onCopyCapture", "onCut", "onCutCapture", "onPaste", "onPasteCapture", "onCompositionEnd", "onCompositionEndCapture", "onCompositionStart", "onCompositionStartCapture", "onCompositionUpdate", "onCompositionUpdateCapture", "onFocus", "onFocusCapture", "onBlur", "onBlurCapture", "onChange", "onChangeCapture", "onBeforeInput", "onBeforeInputCapture", "onInput", "onInputCapture", "onReset", "onResetCapture", "onSubmit", "onSubmitCapture", "onInvalid", "onInvalidCapture", "onLoad", "onLoadCapture", "onError", "onErrorCapture", "onKeyDown", "onKeyDownCapture", "onKeyPress", "onKeyPressCapture", "onKeyUp", "onKeyUpCapture", "onAbort", "onAbortCapture", "onCanPlay", "onCanPlayCapture", "onCanPlayThrough", "onCanPlayThroughCapture", "onDurationChange", "onDurationChangeCapture", "onEmptied", "onEmptiedCapture", "onEncrypted", "onEncryptedCapture", "onEnded", "onEndedCapture", "onLoadedData", "onLoadedDataCapture", "onLoadedMetadata", "onLoadedMetadataCapture", "onLoadStart", "onLoadStartCapture", "onPause", "onPauseCapture", "onPlay", "onPlayCapture", "onPlaying", "onPlayingCapture", "onProgress", "onProgressCapture", "onRateChange", "onRateChangeCapture", "onSeeked", "onSeekedCapture", "onSeeking", "onSeekingCapture", "onStalled", "onStalledCapture", "onSuspend", "onSuspendCapture", "onTimeUpdate", "onTimeUpdateCapture", "onVolumeChange", "onVolumeChangeCapture", "onWaiting", "onWaitingCapture", "onAuxClick", "onAuxClickCapture", "onClick", "onClickCapture", "onContextMenu", "onContextMenuCapture", "onDoubleClick", "onDoubleClickCapture", "onDrag", "onDragCapture", "onDragEnd", "onDragEndCapture", "onDragEnter", "onDragEnterCapture", "onDragExit", "onDragExitCapture", "onDragLeave", "onDragLeaveCapture", "onDragOver", "onDragOverCapture", "onDragStart", "onDragStartCapture", "onDrop", "onDropCapture", "onMouseDown", "onMouseDownCapture", "onMouseEnter", "onMouseLeave", "onMouseMove", "onMouseMoveCapture", "onMouseOut", "onMouseOutCapture", "onMouseOver", "onMouseOverCapture", "onMouseUp", "onMouseUpCapture", "onSelect", "onSelectCapture", "onTouchCancel", "onTouchCancelCapture", "onTouchEnd", "onTouchEndCapture", "onTouchMove", "onTouchMoveCapture", "onTouchStart", "onTouchStartCapture", "onPointerDown", "onPointerDownCapture", "onPointerMove", "onPointerMoveCapture", "onPointerUp", "onPointerUpCapture", "onPointerCancel", "onPointerCancelCapture", "onPointerEnter", "onPointerEnterCapture", "onPointerLeave", "onPointerLeaveCapture", "onPointerOver", "onPointerOverCapture", "onPointerOut", "onPointerOutCapture", "onGotPointerCapture", "onGotPointerCaptureCapture", "onLostPointerCapture", "onLostPointerCaptureCapture", "onScroll", "onScrollCapture", "onWheel", "onWheelCapture", "onAnimationStart", "onAnimationStartCapture", "onAnimationEnd", "onAnimationEndCapture", "onAnimationIteration", "onAnimationIterationCapture", "onTransitionEnd", "onTransitionEndCapture"], adaptEventHandlers = function t(e, n) {
  if (!e || typeof e == "function" || typeof e == "boolean")
    return null;
  var o = e;
  if (/* @__PURE__ */ isValidElement(e) && (o = e.props), !isObject$8(o))
    return null;
  var l = {};
  return Object.keys(o).forEach(function(u) {
    EventKeys.includes(u) && (l[u] = n || function(f) {
      return o[u](o, f);
    });
  }), l;
}, getEventHandlerOfChild = function t(e, n, o) {
  return function(l) {
    return e(n, o, l), null;
  };
}, adaptEventsOfChild = function t(e, n, o) {
  if (!isObject$8(e) || _typeof$I(e) !== "object")
    return null;
  var l = null;
  return Object.keys(e).forEach(function(u) {
    var f = e[u];
    EventKeys.includes(u) && typeof f == "function" && (l || (l = {}), l[u] = getEventHandlerOfChild(f, n, o));
  }), l;
}, _excluded$i = ["children"], _excluded2$6 = ["children"];
function _objectWithoutProperties$i(t, e) {
  if (t == null) return {};
  var n = _objectWithoutPropertiesLoose$j(t, e), o, l;
  if (Object.getOwnPropertySymbols) {
    var u = Object.getOwnPropertySymbols(t);
    for (l = 0; l < u.length; l++)
      o = u[l], !(e.indexOf(o) >= 0) && Object.prototype.propertyIsEnumerable.call(t, o) && (n[o] = t[o]);
  }
  return n;
}
function _objectWithoutPropertiesLoose$j(t, e) {
  if (t == null) return {};
  var n = {}, o = Object.keys(t), l, u;
  for (u = 0; u < o.length; u++)
    l = o[u], !(e.indexOf(l) >= 0) && (n[l] = t[l]);
  return n;
}
var REACT_BROWSER_EVENT_MAP = {
  click: "onClick",
  mousedown: "onMouseDown",
  mouseup: "onMouseUp",
  mouseover: "onMouseOver",
  mousemove: "onMouseMove",
  mouseout: "onMouseOut",
  mouseenter: "onMouseEnter",
  mouseleave: "onMouseLeave",
  touchcancel: "onTouchCancel",
  touchend: "onTouchEnd",
  touchmove: "onTouchMove",
  touchstart: "onTouchStart"
}, getDisplayName = function t(e) {
  return typeof e == "string" ? e : e ? e.displayName || e.name || "Component" : "";
}, lastChildren = null, lastResult = null, toArray = function t(e) {
  if (e === lastChildren && Array.isArray(lastResult))
    return lastResult;
  var n = [];
  return Children.forEach(e, function(o) {
    isNil$1(o) || (reactIsExports.isFragment(o) ? n = n.concat(t(o.props.children)) : n.push(o));
  }), lastResult = n, lastChildren = e, n;
};
function findAllByType(t, e) {
  var n = [], o = [];
  return Array.isArray(e) ? o = e.map(function(l) {
    return getDisplayName(l);
  }) : o = [getDisplayName(e)], toArray(t).forEach(function(l) {
    var u = get$2(l, "type.displayName") || get$2(l, "type.name");
    o.indexOf(u) !== -1 && n.push(l);
  }), n;
}
function findChildByType(t, e) {
  var n = findAllByType(t, e);
  return n && n[0];
}
var validateWidthHeight = function t(e) {
  if (!e || !e.props)
    return !1;
  var n = e.props, o = n.width, l = n.height;
  return !(!isNumber(o) || o <= 0 || !isNumber(l) || l <= 0);
}, SVG_TAGS = ["a", "altGlyph", "altGlyphDef", "altGlyphItem", "animate", "animateColor", "animateMotion", "animateTransform", "circle", "clipPath", "color-profile", "cursor", "defs", "desc", "ellipse", "feBlend", "feColormatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "filter", "font", "font-face", "font-face-format", "font-face-name", "font-face-url", "foreignObject", "g", "glyph", "glyphRef", "hkern", "image", "line", "lineGradient", "marker", "mask", "metadata", "missing-glyph", "mpath", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "script", "set", "stop", "style", "svg", "switch", "symbol", "text", "textPath", "title", "tref", "tspan", "use", "view", "vkern"], isSvgElement = function t(e) {
  return e && e.type && isString$1(e.type) && SVG_TAGS.indexOf(e.type) >= 0;
}, isValidSpreadableProp = function t(e, n, o, l) {
  var u, f = (u = FilteredElementKeyMap == null ? void 0 : FilteredElementKeyMap[l]) !== null && u !== void 0 ? u : [];
  return !isFunction$3(e) && (l && f.includes(n) || SVGElementPropKeys.includes(n)) || o && EventKeys.includes(n);
}, filterProps = function t(e, n, o) {
  if (!e || typeof e == "function" || typeof e == "boolean")
    return null;
  var l = e;
  if (/* @__PURE__ */ isValidElement(e) && (l = e.props), !isObject$8(l))
    return null;
  var u = {};
  return Object.keys(l).forEach(function(f) {
    var h;
    isValidSpreadableProp((h = l) === null || h === void 0 ? void 0 : h[f], f, n, o) && (u[f] = l[f]);
  }), u;
}, isChildrenEqual = function t(e, n) {
  if (e === n)
    return !0;
  var o = Children.count(e);
  if (o !== Children.count(n))
    return !1;
  if (o === 0)
    return !0;
  if (o === 1)
    return isSingleChildEqual(Array.isArray(e) ? e[0] : e, Array.isArray(n) ? n[0] : n);
  for (var l = 0; l < o; l++) {
    var u = e[l], f = n[l];
    if (Array.isArray(u) || Array.isArray(f)) {
      if (!t(u, f))
        return !1;
    } else if (!isSingleChildEqual(u, f))
      return !1;
  }
  return !0;
}, isSingleChildEqual = function t(e, n) {
  if (isNil$1(e) && isNil$1(n))
    return !0;
  if (!isNil$1(e) && !isNil$1(n)) {
    var o = e.props || {}, l = o.children, u = _objectWithoutProperties$i(o, _excluded$i), f = n.props || {}, h = f.children, p = _objectWithoutProperties$i(f, _excluded2$6);
    return l && h ? shallowEqual(u, p) && isChildrenEqual(l, h) : !l && !h ? shallowEqual(u, p) : !1;
  }
  return !1;
}, renderByOrder = function t(e, n) {
  var o = [], l = {};
  return toArray(e).forEach(function(u, f) {
    if (isSvgElement(u))
      o.push(u);
    else if (u) {
      var h = getDisplayName(u.type), p = n[h] || {}, v = p.handler, g = p.once;
      if (v && (!g || !l[h])) {
        var w = v(u, h, f);
        o.push(w), l[h] = !0;
      }
    }
  }), o;
}, getReactEventByType = function t(e) {
  var n = e && e.type;
  return n && REACT_BROWSER_EVENT_MAP[n] ? REACT_BROWSER_EVENT_MAP[n] : null;
}, parseChildIndex = function t(e, n) {
  return toArray(n).indexOf(e);
}, _excluded$h = ["children", "width", "height", "viewBox", "className", "style", "title", "desc"];
function _extends$v() {
  return _extends$v = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }
    return t;
  }, _extends$v.apply(this, arguments);
}
function _objectWithoutProperties$h(t, e) {
  if (t == null) return {};
  var n = _objectWithoutPropertiesLoose$i(t, e), o, l;
  if (Object.getOwnPropertySymbols) {
    var u = Object.getOwnPropertySymbols(t);
    for (l = 0; l < u.length; l++)
      o = u[l], !(e.indexOf(o) >= 0) && Object.prototype.propertyIsEnumerable.call(t, o) && (n[o] = t[o]);
  }
  return n;
}
function _objectWithoutPropertiesLoose$i(t, e) {
  if (t == null) return {};
  var n = {}, o = Object.keys(t), l, u;
  for (u = 0; u < o.length; u++)
    l = o[u], !(e.indexOf(l) >= 0) && (n[l] = t[l]);
  return n;
}
function Surface(t) {
  var e = t.children, n = t.width, o = t.height, l = t.viewBox, u = t.className, f = t.style, h = t.title, p = t.desc, v = _objectWithoutProperties$h(t, _excluded$h), g = l || {
    width: n,
    height: o,
    x: 0,
    y: 0
  }, w = clsx$1("recharts-surface", u);
  return /* @__PURE__ */ React__default.createElement("svg", _extends$v({}, filterProps(v, !0, "svg"), {
    className: w,
    width: n,
    height: o,
    style: f,
    viewBox: "".concat(g.x, " ").concat(g.y, " ").concat(g.width, " ").concat(g.height)
  }), /* @__PURE__ */ React__default.createElement("title", null, h), /* @__PURE__ */ React__default.createElement("desc", null, p), e);
}
var _excluded$g = ["children", "className"];
function _extends$u() {
  return _extends$u = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }
    return t;
  }, _extends$u.apply(this, arguments);
}
function _objectWithoutProperties$g(t, e) {
  if (t == null) return {};
  var n = _objectWithoutPropertiesLoose$h(t, e), o, l;
  if (Object.getOwnPropertySymbols) {
    var u = Object.getOwnPropertySymbols(t);
    for (l = 0; l < u.length; l++)
      o = u[l], !(e.indexOf(o) >= 0) && Object.prototype.propertyIsEnumerable.call(t, o) && (n[o] = t[o]);
  }
  return n;
}
function _objectWithoutPropertiesLoose$h(t, e) {
  if (t == null) return {};
  var n = {}, o = Object.keys(t), l, u;
  for (u = 0; u < o.length; u++)
    l = o[u], !(e.indexOf(l) >= 0) && (n[l] = t[l]);
  return n;
}
var Layer = /* @__PURE__ */ React__default.forwardRef(function(t, e) {
  var n = t.children, o = t.className, l = _objectWithoutProperties$g(t, _excluded$g), u = clsx$1("recharts-layer", o);
  return /* @__PURE__ */ React__default.createElement("g", _extends$u({
    className: u
  }, filterProps(l, !0), {
    ref: e
  }), n);
}), isDev$1 = process.env.NODE_ENV !== "production", warn$2 = function t(e, n) {
  for (var o = arguments.length, l = new Array(o > 2 ? o - 2 : 0), u = 2; u < o; u++)
    l[u - 2] = arguments[u];
  if (isDev$1 && typeof console < "u" && console.warn && (n === void 0 && console.warn("LogUtils requires an error message argument"), !e))
    if (n === void 0)
      console.warn("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
    else {
      var f = 0;
      console.warn(n.replace(/%s/g, function() {
        return l[f++];
      }));
    }
};
function baseSlice$1(t, e, n) {
  var o = -1, l = t.length;
  e < 0 && (e = -e > l ? 0 : l + e), n = n > l ? l : n, n < 0 && (n += l), l = e > n ? 0 : n - e >>> 0, e >>>= 0;
  for (var u = Array(l); ++o < l; )
    u[o] = t[o + e];
  return u;
}
var _baseSlice = baseSlice$1, baseSlice = _baseSlice;
function castSlice$1(t, e, n) {
  var o = t.length;
  return n = n === void 0 ? o : n, !e && n >= o ? t : baseSlice(t, e, n);
}
var _castSlice = castSlice$1, rsAstralRange$1 = "\\ud800-\\udfff", rsComboMarksRange$1 = "\\u0300-\\u036f", reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$1 = "\\u20d0-\\u20ff", rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1, rsVarRange$1 = "\\ufe0e\\ufe0f", rsZWJ$1 = "\\u200d", reHasUnicode = RegExp("[" + rsZWJ$1 + rsAstralRange$1 + rsComboRange$1 + rsVarRange$1 + "]");
function hasUnicode$2(t) {
  return reHasUnicode.test(t);
}
var _hasUnicode = hasUnicode$2;
function asciiToArray$1(t) {
  return t.split("");
}
var _asciiToArray = asciiToArray$1, rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = "\\ufe0e\\ufe0f", rsAstral = "[" + rsAstralRange + "]", rsCombo = "[" + rsComboRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ = "\\u200d", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")", reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
function unicodeToArray$1(t) {
  return t.match(reUnicode) || [];
}
var _unicodeToArray = unicodeToArray$1, asciiToArray = _asciiToArray, hasUnicode$1 = _hasUnicode, unicodeToArray = _unicodeToArray;
function stringToArray$1(t) {
  return hasUnicode$1(t) ? unicodeToArray(t) : asciiToArray(t);
}
var _stringToArray = stringToArray$1, castSlice = _castSlice, hasUnicode = _hasUnicode, stringToArray = _stringToArray, toString$1 = toString_1;
function createCaseFirst$1(t) {
  return function(e) {
    e = toString$1(e);
    var n = hasUnicode(e) ? stringToArray(e) : void 0, o = n ? n[0] : e.charAt(0), l = n ? castSlice(n, 1).join("") : e.slice(1);
    return o[t]() + l;
  };
}
var _createCaseFirst = createCaseFirst$1, createCaseFirst = _createCaseFirst, upperFirst = createCaseFirst("toUpperCase"), upperFirst_1 = upperFirst;
const upperFirst$1 = /* @__PURE__ */ getDefaultExportFromCjs(upperFirst_1);
function constant$2(t) {
  return function() {
    return t;
  };
}
const cos = Math.cos, sin = Math.sin, sqrt$1 = Math.sqrt, pi$1 = Math.PI, tau$1 = 2 * pi$1, pi = Math.PI, tau = 2 * pi, epsilon = 1e-6, tauEpsilon = tau - epsilon;
function append(t) {
  this._ += t[0];
  for (let e = 1, n = t.length; e < n; ++e)
    this._ += arguments[e] + t[e];
}
function appendRound(t) {
  let e = Math.floor(t);
  if (!(e >= 0)) throw new Error(`invalid digits: ${t}`);
  if (e > 15) return append;
  const n = 10 ** e;
  return function(o) {
    this._ += o[0];
    for (let l = 1, u = o.length; l < u; ++l)
      this._ += Math.round(arguments[l] * n) / n + o[l];
  };
}
class Path {
  constructor(e) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "", this._append = e == null ? append : appendRound(e);
  }
  moveTo(e, n) {
    this._append`M${this._x0 = this._x1 = +e},${this._y0 = this._y1 = +n}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
  }
  lineTo(e, n) {
    this._append`L${this._x1 = +e},${this._y1 = +n}`;
  }
  quadraticCurveTo(e, n, o, l) {
    this._append`Q${+e},${+n},${this._x1 = +o},${this._y1 = +l}`;
  }
  bezierCurveTo(e, n, o, l, u, f) {
    this._append`C${+e},${+n},${+o},${+l},${this._x1 = +u},${this._y1 = +f}`;
  }
  arcTo(e, n, o, l, u) {
    if (e = +e, n = +n, o = +o, l = +l, u = +u, u < 0) throw new Error(`negative radius: ${u}`);
    let f = this._x1, h = this._y1, p = o - e, v = l - n, g = f - e, w = h - n, E = g * g + w * w;
    if (this._x1 === null)
      this._append`M${this._x1 = e},${this._y1 = n}`;
    else if (E > epsilon) if (!(Math.abs(w * p - v * g) > epsilon) || !u)
      this._append`L${this._x1 = e},${this._y1 = n}`;
    else {
      let T = o - f, R = l - h, _ = p * p + v * v, b = T * T + R * R, M = Math.sqrt(_), A = Math.sqrt(E), $ = u * Math.tan((pi - Math.acos((_ + E - b) / (2 * M * A))) / 2), S = $ / A, C = $ / M;
      Math.abs(S - 1) > epsilon && this._append`L${e + S * g},${n + S * w}`, this._append`A${u},${u},0,0,${+(w * T > g * R)},${this._x1 = e + C * p},${this._y1 = n + C * v}`;
    }
  }
  arc(e, n, o, l, u, f) {
    if (e = +e, n = +n, o = +o, f = !!f, o < 0) throw new Error(`negative radius: ${o}`);
    let h = o * Math.cos(l), p = o * Math.sin(l), v = e + h, g = n + p, w = 1 ^ f, E = f ? l - u : u - l;
    this._x1 === null ? this._append`M${v},${g}` : (Math.abs(this._x1 - v) > epsilon || Math.abs(this._y1 - g) > epsilon) && this._append`L${v},${g}`, o && (E < 0 && (E = E % tau + tau), E > tauEpsilon ? this._append`A${o},${o},0,1,${w},${e - h},${n - p}A${o},${o},0,1,${w},${this._x1 = v},${this._y1 = g}` : E > epsilon && this._append`A${o},${o},0,${+(E >= pi)},${w},${this._x1 = e + o * Math.cos(u)},${this._y1 = n + o * Math.sin(u)}`);
  }
  rect(e, n, o, l) {
    this._append`M${this._x0 = this._x1 = +e},${this._y0 = this._y1 = +n}h${o = +o}v${+l}h${-o}Z`;
  }
  toString() {
    return this._;
  }
}
function withPath(t) {
  let e = 3;
  return t.digits = function(n) {
    if (!arguments.length) return e;
    if (n == null)
      e = null;
    else {
      const o = Math.floor(n);
      if (!(o >= 0)) throw new RangeError(`invalid digits: ${n}`);
      e = o;
    }
    return t;
  }, () => new Path(e);
}
function array(t) {
  return typeof t == "object" && "length" in t ? t : Array.from(t);
}
function Linear(t) {
  this._context = t;
}
Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t, e) {
    switch (t = +t, e = +e, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(t, e);
        break;
    }
  }
};
function curveLinear(t) {
  return new Linear(t);
}
function x(t) {
  return t[0];
}
function y(t) {
  return t[1];
}
function shapeLine(t, e) {
  var n = constant$2(!0), o = null, l = curveLinear, u = null, f = withPath(h);
  t = typeof t == "function" ? t : t === void 0 ? x : constant$2(t), e = typeof e == "function" ? e : e === void 0 ? y : constant$2(e);
  function h(p) {
    var v, g = (p = array(p)).length, w, E = !1, T;
    for (o == null && (u = l(T = f())), v = 0; v <= g; ++v)
      !(v < g && n(w = p[v], v, p)) === E && ((E = !E) ? u.lineStart() : u.lineEnd()), E && u.point(+t(w, v, p), +e(w, v, p));
    if (T) return u = null, T + "" || null;
  }
  return h.x = function(p) {
    return arguments.length ? (t = typeof p == "function" ? p : constant$2(+p), h) : t;
  }, h.y = function(p) {
    return arguments.length ? (e = typeof p == "function" ? p : constant$2(+p), h) : e;
  }, h.defined = function(p) {
    return arguments.length ? (n = typeof p == "function" ? p : constant$2(!!p), h) : n;
  }, h.curve = function(p) {
    return arguments.length ? (l = p, o != null && (u = l(o)), h) : l;
  }, h.context = function(p) {
    return arguments.length ? (p == null ? o = u = null : u = l(o = p), h) : o;
  }, h;
}
function shapeArea(t, e, n) {
  var o = null, l = constant$2(!0), u = null, f = curveLinear, h = null, p = withPath(v);
  t = typeof t == "function" ? t : t === void 0 ? x : constant$2(+t), e = typeof e == "function" ? e : constant$2(e === void 0 ? 0 : +e), n = typeof n == "function" ? n : n === void 0 ? y : constant$2(+n);
  function v(w) {
    var E, T, R, _ = (w = array(w)).length, b, M = !1, A, $ = new Array(_), S = new Array(_);
    for (u == null && (h = f(A = p())), E = 0; E <= _; ++E) {
      if (!(E < _ && l(b = w[E], E, w)) === M)
        if (M = !M)
          T = E, h.areaStart(), h.lineStart();
        else {
          for (h.lineEnd(), h.lineStart(), R = E - 1; R >= T; --R)
            h.point($[R], S[R]);
          h.lineEnd(), h.areaEnd();
        }
      M && ($[E] = +t(b, E, w), S[E] = +e(b, E, w), h.point(o ? +o(b, E, w) : $[E], n ? +n(b, E, w) : S[E]));
    }
    if (A) return h = null, A + "" || null;
  }
  function g() {
    return shapeLine().defined(l).curve(f).context(u);
  }
  return v.x = function(w) {
    return arguments.length ? (t = typeof w == "function" ? w : constant$2(+w), o = null, v) : t;
  }, v.x0 = function(w) {
    return arguments.length ? (t = typeof w == "function" ? w : constant$2(+w), v) : t;
  }, v.x1 = function(w) {
    return arguments.length ? (o = w == null ? null : typeof w == "function" ? w : constant$2(+w), v) : o;
  }, v.y = function(w) {
    return arguments.length ? (e = typeof w == "function" ? w : constant$2(+w), n = null, v) : e;
  }, v.y0 = function(w) {
    return arguments.length ? (e = typeof w == "function" ? w : constant$2(+w), v) : e;
  }, v.y1 = function(w) {
    return arguments.length ? (n = w == null ? null : typeof w == "function" ? w : constant$2(+w), v) : n;
  }, v.lineX0 = v.lineY0 = function() {
    return g().x(t).y(e);
  }, v.lineY1 = function() {
    return g().x(t).y(n);
  }, v.lineX1 = function() {
    return g().x(o).y(e);
  }, v.defined = function(w) {
    return arguments.length ? (l = typeof w == "function" ? w : constant$2(!!w), v) : l;
  }, v.curve = function(w) {
    return arguments.length ? (f = w, u != null && (h = f(u)), v) : f;
  }, v.context = function(w) {
    return arguments.length ? (w == null ? u = h = null : h = f(u = w), v) : u;
  }, v;
}
class Bump {
  constructor(e, n) {
    this._context = e, this._x = n;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  }
  point(e, n) {
    switch (e = +e, n = +n, this._point) {
      case 0: {
        this._point = 1, this._line ? this._context.lineTo(e, n) : this._context.moveTo(e, n);
        break;
      }
      case 1:
        this._point = 2;
      default: {
        this._x ? this._context.bezierCurveTo(this._x0 = (this._x0 + e) / 2, this._y0, this._x0, n, e, n) : this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + n) / 2, e, this._y0, e, n);
        break;
      }
    }
    this._x0 = e, this._y0 = n;
  }
}
function bumpX(t) {
  return new Bump(t, !0);
}
function bumpY(t) {
  return new Bump(t, !1);
}
const symbolCircle = {
  draw(t, e) {
    const n = sqrt$1(e / pi$1);
    t.moveTo(n, 0), t.arc(0, 0, n, 0, tau$1);
  }
}, symbolCross = {
  draw(t, e) {
    const n = sqrt$1(e / 5) / 2;
    t.moveTo(-3 * n, -n), t.lineTo(-n, -n), t.lineTo(-n, -3 * n), t.lineTo(n, -3 * n), t.lineTo(n, -n), t.lineTo(3 * n, -n), t.lineTo(3 * n, n), t.lineTo(n, n), t.lineTo(n, 3 * n), t.lineTo(-n, 3 * n), t.lineTo(-n, n), t.lineTo(-3 * n, n), t.closePath();
  }
}, tan30 = sqrt$1(1 / 3), tan30_2 = tan30 * 2, symbolDiamond = {
  draw(t, e) {
    const n = sqrt$1(e / tan30_2), o = n * tan30;
    t.moveTo(0, -n), t.lineTo(o, 0), t.lineTo(0, n), t.lineTo(-o, 0), t.closePath();
  }
}, symbolSquare = {
  draw(t, e) {
    const n = sqrt$1(e), o = -n / 2;
    t.rect(o, o, n, n);
  }
}, ka = 0.8908130915292852, kr = sin(pi$1 / 10) / sin(7 * pi$1 / 10), kx = sin(tau$1 / 10) * kr, ky = -cos(tau$1 / 10) * kr, symbolStar = {
  draw(t, e) {
    const n = sqrt$1(e * ka), o = kx * n, l = ky * n;
    t.moveTo(0, -n), t.lineTo(o, l);
    for (let u = 1; u < 5; ++u) {
      const f = tau$1 * u / 5, h = cos(f), p = sin(f);
      t.lineTo(p * n, -h * n), t.lineTo(h * o - p * l, p * o + h * l);
    }
    t.closePath();
  }
}, sqrt3 = sqrt$1(3), symbolTriangle = {
  draw(t, e) {
    const n = -sqrt$1(e / (sqrt3 * 3));
    t.moveTo(0, n * 2), t.lineTo(-sqrt3 * n, -n), t.lineTo(sqrt3 * n, -n), t.closePath();
  }
}, c = -0.5, s = sqrt$1(3) / 2, k = 1 / sqrt$1(12), a = (k / 2 + 1) * 3, symbolWye = {
  draw(t, e) {
    const n = sqrt$1(e / a), o = n / 2, l = n * k, u = o, f = n * k + n, h = -u, p = f;
    t.moveTo(o, l), t.lineTo(u, f), t.lineTo(h, p), t.lineTo(c * o - s * l, s * o + c * l), t.lineTo(c * u - s * f, s * u + c * f), t.lineTo(c * h - s * p, s * h + c * p), t.lineTo(c * o + s * l, c * l - s * o), t.lineTo(c * u + s * f, c * f - s * u), t.lineTo(c * h + s * p, c * p - s * h), t.closePath();
  }
};
function Symbol$3(t, e) {
  let n = null, o = withPath(l);
  t = typeof t == "function" ? t : constant$2(t || symbolCircle), e = typeof e == "function" ? e : constant$2(e === void 0 ? 64 : +e);
  function l() {
    let u;
    if (n || (n = u = o()), t.apply(this, arguments).draw(n, +e.apply(this, arguments)), u) return n = null, u + "" || null;
  }
  return l.type = function(u) {
    return arguments.length ? (t = typeof u == "function" ? u : constant$2(u), l) : t;
  }, l.size = function(u) {
    return arguments.length ? (e = typeof u == "function" ? u : constant$2(+u), l) : e;
  }, l.context = function(u) {
    return arguments.length ? (n = u ?? null, l) : n;
  }, l;
}
function noop$2() {
}
function point$2(t, e, n) {
  t._context.bezierCurveTo(
    (2 * t._x0 + t._x1) / 3,
    (2 * t._y0 + t._y1) / 3,
    (t._x0 + 2 * t._x1) / 3,
    (t._y0 + 2 * t._y1) / 3,
    (t._x0 + 4 * t._x1 + e) / 6,
    (t._y0 + 4 * t._y1 + n) / 6
  );
}
function Basis(t) {
  this._context = t;
}
Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        point$2(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t, e) {
    switch (t = +t, e = +e, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        point$2(this, t, e);
        break;
    }
    this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = e;
  }
};
function curveBasis(t) {
  return new Basis(t);
}
function BasisClosed(t) {
  this._context = t;
}
BasisClosed.prototype = {
  areaStart: noop$2,
  areaEnd: noop$2,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2), this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3), this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3), this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(t, e) {
    switch (t = +t, e = +e, this._point) {
      case 0:
        this._point = 1, this._x2 = t, this._y2 = e;
        break;
      case 1:
        this._point = 2, this._x3 = t, this._y3 = e;
        break;
      case 2:
        this._point = 3, this._x4 = t, this._y4 = e, this._context.moveTo((this._x0 + 4 * this._x1 + t) / 6, (this._y0 + 4 * this._y1 + e) / 6);
        break;
      default:
        point$2(this, t, e);
        break;
    }
    this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = e;
  }
};
function curveBasisClosed(t) {
  return new BasisClosed(t);
}
function BasisOpen(t) {
  this._context = t;
}
BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t, e) {
    switch (t = +t, e = +e, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var n = (this._x0 + 4 * this._x1 + t) / 6, o = (this._y0 + 4 * this._y1 + e) / 6;
        this._line ? this._context.lineTo(n, o) : this._context.moveTo(n, o);
        break;
      case 3:
        this._point = 4;
      default:
        point$2(this, t, e);
        break;
    }
    this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = e;
  }
};
function curveBasisOpen(t) {
  return new BasisOpen(t);
}
function LinearClosed(t) {
  this._context = t;
}
LinearClosed.prototype = {
  areaStart: noop$2,
  areaEnd: noop$2,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    this._point && this._context.closePath();
  },
  point: function(t, e) {
    t = +t, e = +e, this._point ? this._context.lineTo(t, e) : (this._point = 1, this._context.moveTo(t, e));
  }
};
function curveLinearClosed(t) {
  return new LinearClosed(t);
}
function sign(t) {
  return t < 0 ? -1 : 1;
}
function slope3(t, e, n) {
  var o = t._x1 - t._x0, l = e - t._x1, u = (t._y1 - t._y0) / (o || l < 0 && -0), f = (n - t._y1) / (l || o < 0 && -0), h = (u * l + f * o) / (o + l);
  return (sign(u) + sign(f)) * Math.min(Math.abs(u), Math.abs(f), 0.5 * Math.abs(h)) || 0;
}
function slope2(t, e) {
  var n = t._x1 - t._x0;
  return n ? (3 * (t._y1 - t._y0) / n - e) / 2 : e;
}
function point$1(t, e, n) {
  var o = t._x0, l = t._y0, u = t._x1, f = t._y1, h = (u - o) / 3;
  t._context.bezierCurveTo(o + h, l + h * e, u - h, f - h * n, u, f);
}
function MonotoneX(t) {
  this._context = t;
}
MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        point$1(this, this._t0, slope2(this, this._t0));
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(t, e) {
    var n = NaN;
    if (t = +t, e = +e, !(t === this._x1 && e === this._y1)) {
      switch (this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, point$1(this, slope2(this, n = slope3(this, t, e)), n);
          break;
        default:
          point$1(this, this._t0, n = slope3(this, t, e));
          break;
      }
      this._x0 = this._x1, this._x1 = t, this._y0 = this._y1, this._y1 = e, this._t0 = n;
    }
  }
};
function MonotoneY(t) {
  this._context = new ReflectContext(t);
}
(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(t, e) {
  MonotoneX.prototype.point.call(this, e, t);
};
function ReflectContext(t) {
  this._context = t;
}
ReflectContext.prototype = {
  moveTo: function(t, e) {
    this._context.moveTo(e, t);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(t, e) {
    this._context.lineTo(e, t);
  },
  bezierCurveTo: function(t, e, n, o, l, u) {
    this._context.bezierCurveTo(e, t, o, n, u, l);
  }
};
function monotoneX(t) {
  return new MonotoneX(t);
}
function monotoneY(t) {
  return new MonotoneY(t);
}
function Natural(t) {
  this._context = t;
}
Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [], this._y = [];
  },
  lineEnd: function() {
    var t = this._x, e = this._y, n = t.length;
    if (n)
      if (this._line ? this._context.lineTo(t[0], e[0]) : this._context.moveTo(t[0], e[0]), n === 2)
        this._context.lineTo(t[1], e[1]);
      else
        for (var o = controlPoints(t), l = controlPoints(e), u = 0, f = 1; f < n; ++u, ++f)
          this._context.bezierCurveTo(o[0][u], l[0][u], o[1][u], l[1][u], t[f], e[f]);
    (this._line || this._line !== 0 && n === 1) && this._context.closePath(), this._line = 1 - this._line, this._x = this._y = null;
  },
  point: function(t, e) {
    this._x.push(+t), this._y.push(+e);
  }
};
function controlPoints(t) {
  var e, n = t.length - 1, o, l = new Array(n), u = new Array(n), f = new Array(n);
  for (l[0] = 0, u[0] = 2, f[0] = t[0] + 2 * t[1], e = 1; e < n - 1; ++e) l[e] = 1, u[e] = 4, f[e] = 4 * t[e] + 2 * t[e + 1];
  for (l[n - 1] = 2, u[n - 1] = 7, f[n - 1] = 8 * t[n - 1] + t[n], e = 1; e < n; ++e) o = l[e] / u[e - 1], u[e] -= o, f[e] -= o * f[e - 1];
  for (l[n - 1] = f[n - 1] / u[n - 1], e = n - 2; e >= 0; --e) l[e] = (f[e] - l[e + 1]) / u[e];
  for (u[n - 1] = (t[n] + l[n - 1]) / 2, e = 0; e < n - 1; ++e) u[e] = 2 * t[e + 1] - l[e + 1];
  return [l, u];
}
function curveNatural(t) {
  return new Natural(t);
}
function Step(t, e) {
  this._context = t, this._t = e;
}
Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN, this._point = 0;
  },
  lineEnd: function() {
    0 < this._t && this._t < 1 && this._point === 2 && this._context.lineTo(this._x, this._y), (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
  },
  point: function(t, e) {
    switch (t = +t, e = +e, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(t, e) : this._context.moveTo(t, e);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0)
          this._context.lineTo(this._x, e), this._context.lineTo(t, e);
        else {
          var n = this._x * (1 - this._t) + t * this._t;
          this._context.lineTo(n, this._y), this._context.lineTo(n, e);
        }
        break;
      }
    }
    this._x = t, this._y = e;
  }
};
function curveStep(t) {
  return new Step(t, 0.5);
}
function stepBefore(t) {
  return new Step(t, 0);
}
function stepAfter(t) {
  return new Step(t, 1);
}
function stackOffsetNone(t, e) {
  if ((f = t.length) > 1)
    for (var n = 1, o, l, u = t[e[0]], f, h = u.length; n < f; ++n)
      for (l = u, u = t[e[n]], o = 0; o < h; ++o)
        u[o][1] += u[o][0] = isNaN(l[o][1]) ? l[o][0] : l[o][1];
}
function stackOrderNone(t) {
  for (var e = t.length, n = new Array(e); --e >= 0; ) n[e] = e;
  return n;
}
function stackValue(t, e) {
  return t[e];
}
function stackSeries(t) {
  const e = [];
  return e.key = t, e;
}
function shapeStack() {
  var t = constant$2([]), e = stackOrderNone, n = stackOffsetNone, o = stackValue;
  function l(u) {
    var f = Array.from(t.apply(this, arguments), stackSeries), h, p = f.length, v = -1, g;
    for (const w of u)
      for (h = 0, ++v; h < p; ++h)
        (f[h][v] = [0, +o(w, f[h].key, v, u)]).data = w;
    for (h = 0, g = array(e(f)); h < p; ++h)
      f[g[h]].index = h;
    return n(f, g), f;
  }
  return l.keys = function(u) {
    return arguments.length ? (t = typeof u == "function" ? u : constant$2(Array.from(u)), l) : t;
  }, l.value = function(u) {
    return arguments.length ? (o = typeof u == "function" ? u : constant$2(+u), l) : o;
  }, l.order = function(u) {
    return arguments.length ? (e = u == null ? stackOrderNone : typeof u == "function" ? u : constant$2(Array.from(u)), l) : e;
  }, l.offset = function(u) {
    return arguments.length ? (n = u ?? stackOffsetNone, l) : n;
  }, l;
}
function stackOffsetExpand(t, e) {
  if ((o = t.length) > 0) {
    for (var n, o, l = 0, u = t[0].length, f; l < u; ++l) {
      for (f = n = 0; n < o; ++n) f += t[n][l][1] || 0;
      if (f) for (n = 0; n < o; ++n) t[n][l][1] /= f;
    }
    stackOffsetNone(t, e);
  }
}
function stackOffsetSilhouette(t, e) {
  if ((l = t.length) > 0) {
    for (var n = 0, o = t[e[0]], l, u = o.length; n < u; ++n) {
      for (var f = 0, h = 0; f < l; ++f) h += t[f][n][1] || 0;
      o[n][1] += o[n][0] = -h / 2;
    }
    stackOffsetNone(t, e);
  }
}
function stackOffsetWiggle(t, e) {
  if (!(!((f = t.length) > 0) || !((u = (l = t[e[0]]).length) > 0))) {
    for (var n = 0, o = 1, l, u, f; o < u; ++o) {
      for (var h = 0, p = 0, v = 0; h < f; ++h) {
        for (var g = t[e[h]], w = g[o][1] || 0, E = g[o - 1][1] || 0, T = (w - E) / 2, R = 0; R < h; ++R) {
          var _ = t[e[R]], b = _[o][1] || 0, M = _[o - 1][1] || 0;
          T += b - M;
        }
        p += w, v += T * w;
      }
      l[o - 1][1] += l[o - 1][0] = n, p && (n -= v / p);
    }
    l[o - 1][1] += l[o - 1][0] = n, stackOffsetNone(t, e);
  }
}
function _typeof$H(t) {
  "@babel/helpers - typeof";
  return _typeof$H = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof$H(t);
}
var _excluded$f = ["type", "size", "sizeType"];
function _extends$t() {
  return _extends$t = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }
    return t;
  }, _extends$t.apply(this, arguments);
}
function ownKeys$C(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(l) {
      return Object.getOwnPropertyDescriptor(t, l).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function _objectSpread$B(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ownKeys$C(Object(n), !0).forEach(function(o) {
      _defineProperty$F(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : ownKeys$C(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
function _defineProperty$F(t, e, n) {
  return e = _toPropertyKey$F(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function _toPropertyKey$F(t) {
  var e = _toPrimitive$F(t, "string");
  return _typeof$H(e) == "symbol" ? e : String(e);
}
function _toPrimitive$F(t, e) {
  if (_typeof$H(t) != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(t, e || "default");
    if (_typeof$H(o) != "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function _objectWithoutProperties$f(t, e) {
  if (t == null) return {};
  var n = _objectWithoutPropertiesLoose$g(t, e), o, l;
  if (Object.getOwnPropertySymbols) {
    var u = Object.getOwnPropertySymbols(t);
    for (l = 0; l < u.length; l++)
      o = u[l], !(e.indexOf(o) >= 0) && Object.prototype.propertyIsEnumerable.call(t, o) && (n[o] = t[o]);
  }
  return n;
}
function _objectWithoutPropertiesLoose$g(t, e) {
  if (t == null) return {};
  var n = {}, o = Object.keys(t), l, u;
  for (u = 0; u < o.length; u++)
    l = o[u], !(e.indexOf(l) >= 0) && (n[l] = t[l]);
  return n;
}
var symbolFactories = {
  symbolCircle,
  symbolCross,
  symbolDiamond,
  symbolSquare,
  symbolStar,
  symbolTriangle,
  symbolWye
}, RADIAN$2 = Math.PI / 180, getSymbolFactory = function t(e) {
  var n = "symbol".concat(upperFirst$1(e));
  return symbolFactories[n] || symbolCircle;
}, calculateAreaSize = function t(e, n, o) {
  if (n === "area")
    return e;
  switch (o) {
    case "cross":
      return 5 * e * e / 9;
    case "diamond":
      return 0.5 * e * e / Math.sqrt(3);
    case "square":
      return e * e;
    case "star": {
      var l = 18 * RADIAN$2;
      return 1.25 * e * e * (Math.tan(l) - Math.tan(l * 2) * Math.pow(Math.tan(l), 2));
    }
    case "triangle":
      return Math.sqrt(3) * e * e / 4;
    case "wye":
      return (21 - 10 * Math.sqrt(3)) * e * e / 8;
    default:
      return Math.PI * e * e / 4;
  }
}, registerSymbol = function t(e, n) {
  symbolFactories["symbol".concat(upperFirst$1(e))] = n;
}, Symbols = function t(e) {
  var n = e.type, o = n === void 0 ? "circle" : n, l = e.size, u = l === void 0 ? 64 : l, f = e.sizeType, h = f === void 0 ? "area" : f, p = _objectWithoutProperties$f(e, _excluded$f), v = _objectSpread$B(_objectSpread$B({}, p), {}, {
    type: o,
    size: u,
    sizeType: h
  }), g = function() {
    var b = getSymbolFactory(o), M = Symbol$3().type(b).size(calculateAreaSize(u, h, o));
    return M();
  }, w = v.className, E = v.cx, T = v.cy, R = filterProps(v, !0);
  return E === +E && T === +T && u === +u ? /* @__PURE__ */ React__default.createElement("path", _extends$t({}, R, {
    className: clsx$1("recharts-symbols", w),
    transform: "translate(".concat(E, ", ").concat(T, ")"),
    d: g()
  })) : null;
};
Symbols.registerSymbol = registerSymbol;
function _typeof$G(t) {
  "@babel/helpers - typeof";
  return _typeof$G = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof$G(t);
}
function _extends$s() {
  return _extends$s = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }
    return t;
  }, _extends$s.apply(this, arguments);
}
function ownKeys$B(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(l) {
      return Object.getOwnPropertyDescriptor(t, l).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function _objectSpread$A(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ownKeys$B(Object(n), !0).forEach(function(o) {
      _defineProperty$E(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : ownKeys$B(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
function _classCallCheck$f(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$f(t, e) {
  for (var n = 0; n < e.length; n++) {
    var o = e[n];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, _toPropertyKey$E(o.key), o);
  }
}
function _createClass$f(t, e, n) {
  return e && _defineProperties$f(t.prototype, e), Object.defineProperty(t, "prototype", { writable: !1 }), t;
}
function _callSuper$b(t, e, n) {
  return e = _getPrototypeOf$c(e), _possibleConstructorReturn$c(t, _isNativeReflectConstruct$c() ? Reflect.construct(e, n || [], _getPrototypeOf$c(t).constructor) : e.apply(t, n));
}
function _possibleConstructorReturn$c(t, e) {
  if (e && (_typeof$G(e) === "object" || typeof e == "function"))
    return e;
  if (e !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized$d(t);
}
function _assertThisInitialized$d(t) {
  if (t === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t;
}
function _isNativeReflectConstruct$c() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (_isNativeReflectConstruct$c = function() {
    return !!t;
  })();
}
function _getPrototypeOf$c(t) {
  return _getPrototypeOf$c = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
    return n.__proto__ || Object.getPrototypeOf(n);
  }, _getPrototypeOf$c(t);
}
function _inherits$c(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf$d(t, e);
}
function _setPrototypeOf$d(t, e) {
  return _setPrototypeOf$d = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(o, l) {
    return o.__proto__ = l, o;
  }, _setPrototypeOf$d(t, e);
}
function _defineProperty$E(t, e, n) {
  return e = _toPropertyKey$E(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function _toPropertyKey$E(t) {
  var e = _toPrimitive$E(t, "string");
  return _typeof$G(e) == "symbol" ? e : String(e);
}
function _toPrimitive$E(t, e) {
  if (_typeof$G(t) != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(t, e || "default");
    if (_typeof$G(o) != "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
var SIZE = 32, DefaultLegendContent = /* @__PURE__ */ function(t) {
  _inherits$c(e, t);
  function e() {
    return _classCallCheck$f(this, e), _callSuper$b(this, e, arguments);
  }
  return _createClass$f(e, [{
    key: "renderIcon",
    value: (
      /**
       * Render the path of icon
       * @param {Object} data Data of each legend item
       * @return {String} Path element
       */
      function(o) {
        var l = this.props.inactiveColor, u = SIZE / 2, f = SIZE / 6, h = SIZE / 3, p = o.inactive ? l : o.color;
        if (o.type === "plainline")
          return /* @__PURE__ */ React__default.createElement("line", {
            strokeWidth: 4,
            fill: "none",
            stroke: p,
            strokeDasharray: o.payload.strokeDasharray,
            x1: 0,
            y1: u,
            x2: SIZE,
            y2: u,
            className: "recharts-legend-icon"
          });
        if (o.type === "line")
          return /* @__PURE__ */ React__default.createElement("path", {
            strokeWidth: 4,
            fill: "none",
            stroke: p,
            d: "M0,".concat(u, "h").concat(h, `
            A`).concat(f, ",").concat(f, ",0,1,1,").concat(2 * h, ",").concat(u, `
            H`).concat(SIZE, "M").concat(2 * h, ",").concat(u, `
            A`).concat(f, ",").concat(f, ",0,1,1,").concat(h, ",").concat(u),
            className: "recharts-legend-icon"
          });
        if (o.type === "rect")
          return /* @__PURE__ */ React__default.createElement("path", {
            stroke: "none",
            fill: p,
            d: "M0,".concat(SIZE / 8, "h").concat(SIZE, "v").concat(SIZE * 3 / 4, "h").concat(-SIZE, "z"),
            className: "recharts-legend-icon"
          });
        if (/* @__PURE__ */ React__default.isValidElement(o.legendIcon)) {
          var v = _objectSpread$A({}, o);
          return delete v.legendIcon, /* @__PURE__ */ React__default.cloneElement(o.legendIcon, v);
        }
        return /* @__PURE__ */ React__default.createElement(Symbols, {
          fill: p,
          cx: u,
          cy: u,
          size: SIZE,
          sizeType: "diameter",
          type: o.type
        });
      }
    )
    /**
     * Draw items of legend
     * @return {ReactElement} Items
     */
  }, {
    key: "renderItems",
    value: function() {
      var o = this, l = this.props, u = l.payload, f = l.iconSize, h = l.layout, p = l.formatter, v = l.inactiveColor, g = {
        x: 0,
        y: 0,
        width: SIZE,
        height: SIZE
      }, w = {
        display: h === "horizontal" ? "inline-block" : "block",
        marginRight: 10
      }, E = {
        display: "inline-block",
        verticalAlign: "middle",
        marginRight: 4
      };
      return u.map(function(T, R) {
        var _ = T.formatter || p, b = clsx$1(_defineProperty$E(_defineProperty$E({
          "recharts-legend-item": !0
        }, "legend-item-".concat(R), !0), "inactive", T.inactive));
        if (T.type === "none")
          return null;
        var M = isFunction$3(T.value) ? null : T.value;
        warn$2(
          !isFunction$3(T.value),
          `The name property is also required when using a function for the dataKey of a chart's cartesian components. Ex: <Bar name="Name of my Data"/>`
          // eslint-disable-line max-len
        );
        var A = T.inactive ? v : T.color;
        return /* @__PURE__ */ React__default.createElement("li", _extends$s({
          className: b,
          style: w,
          key: "legend-item-".concat(R)
        }, adaptEventsOfChild(o.props, T, R)), /* @__PURE__ */ React__default.createElement(Surface, {
          width: f,
          height: f,
          viewBox: g,
          style: E
        }, o.renderIcon(T)), /* @__PURE__ */ React__default.createElement("span", {
          className: "recharts-legend-item-text",
          style: {
            color: A
          }
        }, _ ? _(M, T, R) : M));
      });
    }
  }, {
    key: "render",
    value: function() {
      var o = this.props, l = o.payload, u = o.layout, f = o.align;
      if (!l || !l.length)
        return null;
      var h = {
        padding: 0,
        margin: 0,
        textAlign: u === "horizontal" ? f : "left"
      };
      return /* @__PURE__ */ React__default.createElement("ul", {
        className: "recharts-default-legend",
        style: h
      }, this.renderItems());
    }
  }]), e;
}(PureComponent);
_defineProperty$E(DefaultLegendContent, "displayName", "Legend");
_defineProperty$E(DefaultLegendContent, "defaultProps", {
  iconSize: 14,
  layout: "horizontal",
  align: "center",
  verticalAlign: "middle",
  inactiveColor: "#ccc"
});
var ListCache$2 = _ListCache;
function stackClear$1() {
  this.__data__ = new ListCache$2(), this.size = 0;
}
var _stackClear = stackClear$1;
function stackDelete$1(t) {
  var e = this.__data__, n = e.delete(t);
  return this.size = e.size, n;
}
var _stackDelete = stackDelete$1;
function stackGet$1(t) {
  return this.__data__.get(t);
}
var _stackGet = stackGet$1;
function stackHas$1(t) {
  return this.__data__.has(t);
}
var _stackHas = stackHas$1, ListCache$1 = _ListCache, Map$2 = _Map, MapCache$1 = _MapCache, LARGE_ARRAY_SIZE$1 = 200;
function stackSet$1(t, e) {
  var n = this.__data__;
  if (n instanceof ListCache$1) {
    var o = n.__data__;
    if (!Map$2 || o.length < LARGE_ARRAY_SIZE$1 - 1)
      return o.push([t, e]), this.size = ++n.size, this;
    n = this.__data__ = new MapCache$1(o);
  }
  return n.set(t, e), this.size = n.size, this;
}
var _stackSet = stackSet$1, ListCache = _ListCache, stackClear = _stackClear, stackDelete = _stackDelete, stackGet = _stackGet, stackHas = _stackHas, stackSet = _stackSet;
function Stack$2(t) {
  var e = this.__data__ = new ListCache(t);
  this.size = e.size;
}
Stack$2.prototype.clear = stackClear;
Stack$2.prototype.delete = stackDelete;
Stack$2.prototype.get = stackGet;
Stack$2.prototype.has = stackHas;
Stack$2.prototype.set = stackSet;
var _Stack = Stack$2, HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd$1(t) {
  return this.__data__.set(t, HASH_UNDEFINED), this;
}
var _setCacheAdd = setCacheAdd$1;
function setCacheHas$1(t) {
  return this.__data__.has(t);
}
var _setCacheHas = setCacheHas$1, MapCache = _MapCache, setCacheAdd = _setCacheAdd, setCacheHas = _setCacheHas;
function SetCache$2(t) {
  var e = -1, n = t == null ? 0 : t.length;
  for (this.__data__ = new MapCache(); ++e < n; )
    this.add(t[e]);
}
SetCache$2.prototype.add = SetCache$2.prototype.push = setCacheAdd;
SetCache$2.prototype.has = setCacheHas;
var _SetCache = SetCache$2;
function arraySome$2(t, e) {
  for (var n = -1, o = t == null ? 0 : t.length; ++n < o; )
    if (e(t[n], n, t))
      return !0;
  return !1;
}
var _arraySome = arraySome$2;
function cacheHas$2(t, e) {
  return t.has(e);
}
var _cacheHas = cacheHas$2, SetCache$1 = _SetCache, arraySome$1 = _arraySome, cacheHas$1 = _cacheHas, COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
function equalArrays$2(t, e, n, o, l, u) {
  var f = n & COMPARE_PARTIAL_FLAG$5, h = t.length, p = e.length;
  if (h != p && !(f && p > h))
    return !1;
  var v = u.get(t), g = u.get(e);
  if (v && g)
    return v == e && g == t;
  var w = -1, E = !0, T = n & COMPARE_UNORDERED_FLAG$3 ? new SetCache$1() : void 0;
  for (u.set(t, e), u.set(e, t); ++w < h; ) {
    var R = t[w], _ = e[w];
    if (o)
      var b = f ? o(_, R, w, e, t, u) : o(R, _, w, t, e, u);
    if (b !== void 0) {
      if (b)
        continue;
      E = !1;
      break;
    }
    if (T) {
      if (!arraySome$1(e, function(M, A) {
        if (!cacheHas$1(T, A) && (R === M || l(R, M, n, o, u)))
          return T.push(A);
      })) {
        E = !1;
        break;
      }
    } else if (!(R === _ || l(R, _, n, o, u))) {
      E = !1;
      break;
    }
  }
  return u.delete(t), u.delete(e), E;
}
var _equalArrays = equalArrays$2, root$5 = _root, Uint8Array$2 = root$5.Uint8Array, _Uint8Array = Uint8Array$2;
function mapToArray$1(t) {
  var e = -1, n = Array(t.size);
  return t.forEach(function(o, l) {
    n[++e] = [l, o];
  }), n;
}
var _mapToArray = mapToArray$1;
function setToArray$3(t) {
  var e = -1, n = Array(t.size);
  return t.forEach(function(o) {
    n[++e] = o;
  }), n;
}
var _setToArray = setToArray$3, Symbol$2 = _Symbol, Uint8Array$1 = _Uint8Array, eq$1 = eq_1, equalArrays$1 = _equalArrays, mapToArray = _mapToArray, setToArray$2 = _setToArray, COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2, boolTag$2 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag = "[object Symbol]", arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", symbolProto = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function equalByTag$1(t, e, n, o, l, u, f) {
  switch (n) {
    case dataViewTag$2:
      if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset)
        return !1;
      t = t.buffer, e = e.buffer;
    case arrayBufferTag$1:
      return !(t.byteLength != e.byteLength || !u(new Uint8Array$1(t), new Uint8Array$1(e)));
    case boolTag$2:
    case dateTag$1:
    case numberTag$1:
      return eq$1(+t, +e);
    case errorTag$1:
      return t.name == e.name && t.message == e.message;
    case regexpTag$1:
    case stringTag$1:
      return t == e + "";
    case mapTag$2:
      var h = mapToArray;
    case setTag$2:
      var p = o & COMPARE_PARTIAL_FLAG$4;
      if (h || (h = setToArray$2), t.size != e.size && !p)
        return !1;
      var v = f.get(t);
      if (v)
        return v == e;
      o |= COMPARE_UNORDERED_FLAG$2, f.set(t, e);
      var g = equalArrays$1(h(t), h(e), o, l, u, f);
      return f.delete(t), g;
    case symbolTag:
      if (symbolValueOf)
        return symbolValueOf.call(t) == symbolValueOf.call(e);
  }
  return !1;
}
var _equalByTag = equalByTag$1;
function arrayPush$2(t, e) {
  for (var n = -1, o = e.length, l = t.length; ++n < o; )
    t[l + n] = e[n];
  return t;
}
var _arrayPush = arrayPush$2, arrayPush$1 = _arrayPush, isArray$a = isArray_1;
function baseGetAllKeys$1(t, e, n) {
  var o = e(t);
  return isArray$a(t) ? o : arrayPush$1(o, n(t));
}
var _baseGetAllKeys = baseGetAllKeys$1;
function arrayFilter$1(t, e) {
  for (var n = -1, o = t == null ? 0 : t.length, l = 0, u = []; ++n < o; ) {
    var f = t[n];
    e(f, n, t) && (u[l++] = f);
  }
  return u;
}
var _arrayFilter = arrayFilter$1;
function stubArray$1() {
  return [];
}
var stubArray_1 = stubArray$1, arrayFilter = _arrayFilter, stubArray = stubArray_1, objectProto$7 = Object.prototype, propertyIsEnumerable$1 = objectProto$7.propertyIsEnumerable, nativeGetSymbols = Object.getOwnPropertySymbols, getSymbols$1 = nativeGetSymbols ? function(t) {
  return t == null ? [] : (t = Object(t), arrayFilter(nativeGetSymbols(t), function(e) {
    return propertyIsEnumerable$1.call(t, e);
  }));
} : stubArray, _getSymbols = getSymbols$1;
function baseTimes$1(t, e) {
  for (var n = -1, o = Array(t); ++n < t; )
    o[n] = e(n);
  return o;
}
var _baseTimes = baseTimes$1, baseGetTag$4 = _baseGetTag, isObjectLike$5 = isObjectLike_1, argsTag$2 = "[object Arguments]";
function baseIsArguments$1(t) {
  return isObjectLike$5(t) && baseGetTag$4(t) == argsTag$2;
}
var _baseIsArguments = baseIsArguments$1, baseIsArguments = _baseIsArguments, isObjectLike$4 = isObjectLike_1, objectProto$6 = Object.prototype, hasOwnProperty$6 = objectProto$6.hasOwnProperty, propertyIsEnumerable = objectProto$6.propertyIsEnumerable, isArguments$3 = baseIsArguments(/* @__PURE__ */ function() {
  return arguments;
}()) ? baseIsArguments : function(t) {
  return isObjectLike$4(t) && hasOwnProperty$6.call(t, "callee") && !propertyIsEnumerable.call(t, "callee");
}, isArguments_1 = isArguments$3, isBuffer$2 = { exports: {} };
function stubFalse() {
  return !1;
}
var stubFalse_1 = stubFalse;
isBuffer$2.exports;
(function(t, e) {
  var n = _root, o = stubFalse_1, l = e && !e.nodeType && e, u = l && !0 && t && !t.nodeType && t, f = u && u.exports === l, h = f ? n.Buffer : void 0, p = h ? h.isBuffer : void 0, v = p || o;
  t.exports = v;
})(isBuffer$2, isBuffer$2.exports);
var isBufferExports = isBuffer$2.exports, MAX_SAFE_INTEGER$2 = 9007199254740991, reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex$3(t, e) {
  var n = typeof t;
  return e = e ?? MAX_SAFE_INTEGER$2, !!e && (n == "number" || n != "symbol" && reIsUint.test(t)) && t > -1 && t % 1 == 0 && t < e;
}
var _isIndex = isIndex$3, MAX_SAFE_INTEGER$1 = 9007199254740991;
function isLength$3(t) {
  return typeof t == "number" && t > -1 && t % 1 == 0 && t <= MAX_SAFE_INTEGER$1;
}
var isLength_1 = isLength$3, baseGetTag$3 = _baseGetTag, isLength$2 = isLength_1, isObjectLike$3 = isObjectLike_1, argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag$1 = "[object Map]", numberTag = "[object Number]", objectTag$3 = "[object Object]", regexpTag = "[object RegExp]", setTag$1 = "[object Set]", stringTag = "[object String]", weakMapTag$1 = "[object WeakMap]", arrayBufferTag = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]", typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = !0;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$1] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag$1] = typedArrayTags[numberTag] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag] = typedArrayTags[setTag$1] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag$1] = !1;
function baseIsTypedArray$1(t) {
  return isObjectLike$3(t) && isLength$2(t.length) && !!typedArrayTags[baseGetTag$3(t)];
}
var _baseIsTypedArray = baseIsTypedArray$1;
function baseUnary$2(t) {
  return function(e) {
    return t(e);
  };
}
var _baseUnary = baseUnary$2, _nodeUtil = { exports: {} };
_nodeUtil.exports;
(function(t, e) {
  var n = _freeGlobal, o = e && !e.nodeType && e, l = o && !0 && t && !t.nodeType && t, u = l && l.exports === o, f = u && n.process, h = function() {
    try {
      var p = l && l.require && l.require("util").types;
      return p || f && f.binding && f.binding("util");
    } catch {
    }
  }();
  t.exports = h;
})(_nodeUtil, _nodeUtil.exports);
var _nodeUtilExports = _nodeUtil.exports, baseIsTypedArray = _baseIsTypedArray, baseUnary$1 = _baseUnary, nodeUtil = _nodeUtilExports, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray, isTypedArray$3 = nodeIsTypedArray ? baseUnary$1(nodeIsTypedArray) : baseIsTypedArray, isTypedArray_1 = isTypedArray$3, baseTimes = _baseTimes, isArguments$2 = isArguments_1, isArray$9 = isArray_1, isBuffer$1 = isBufferExports, isIndex$2 = _isIndex, isTypedArray$2 = isTypedArray_1, objectProto$5 = Object.prototype, hasOwnProperty$5 = objectProto$5.hasOwnProperty;
function arrayLikeKeys$1(t, e) {
  var n = isArray$9(t), o = !n && isArguments$2(t), l = !n && !o && isBuffer$1(t), u = !n && !o && !l && isTypedArray$2(t), f = n || o || l || u, h = f ? baseTimes(t.length, String) : [], p = h.length;
  for (var v in t)
    (e || hasOwnProperty$5.call(t, v)) && !(f && // Safari 9 has enumerable `arguments.length` in strict mode.
    (v == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    l && (v == "offset" || v == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    u && (v == "buffer" || v == "byteLength" || v == "byteOffset") || // Skip index properties.
    isIndex$2(v, p))) && h.push(v);
  return h;
}
var _arrayLikeKeys = arrayLikeKeys$1, objectProto$4 = Object.prototype;
function isPrototype$1(t) {
  var e = t && t.constructor, n = typeof e == "function" && e.prototype || objectProto$4;
  return t === n;
}
var _isPrototype = isPrototype$1;
function overArg$2(t, e) {
  return function(n) {
    return t(e(n));
  };
}
var _overArg = overArg$2, overArg$1 = _overArg, nativeKeys$1 = overArg$1(Object.keys, Object), _nativeKeys = nativeKeys$1, isPrototype = _isPrototype, nativeKeys = _nativeKeys, objectProto$3 = Object.prototype, hasOwnProperty$4 = objectProto$3.hasOwnProperty;
function baseKeys$1(t) {
  if (!isPrototype(t))
    return nativeKeys(t);
  var e = [];
  for (var n in Object(t))
    hasOwnProperty$4.call(t, n) && n != "constructor" && e.push(n);
  return e;
}
var _baseKeys = baseKeys$1, isFunction = isFunction_1, isLength$1 = isLength_1;
function isArrayLike$5(t) {
  return t != null && isLength$1(t.length) && !isFunction(t);
}
var isArrayLike_1 = isArrayLike$5, arrayLikeKeys = _arrayLikeKeys, baseKeys = _baseKeys, isArrayLike$4 = isArrayLike_1;
function keys$5(t) {
  return isArrayLike$4(t) ? arrayLikeKeys(t) : baseKeys(t);
}
var keys_1 = keys$5, baseGetAllKeys = _baseGetAllKeys, getSymbols = _getSymbols, keys$4 = keys_1;
function getAllKeys$1(t) {
  return baseGetAllKeys(t, keys$4, getSymbols);
}
var _getAllKeys = getAllKeys$1, getAllKeys = _getAllKeys, COMPARE_PARTIAL_FLAG$3 = 1, objectProto$2 = Object.prototype, hasOwnProperty$3 = objectProto$2.hasOwnProperty;
function equalObjects$1(t, e, n, o, l, u) {
  var f = n & COMPARE_PARTIAL_FLAG$3, h = getAllKeys(t), p = h.length, v = getAllKeys(e), g = v.length;
  if (p != g && !f)
    return !1;
  for (var w = p; w--; ) {
    var E = h[w];
    if (!(f ? E in e : hasOwnProperty$3.call(e, E)))
      return !1;
  }
  var T = u.get(t), R = u.get(e);
  if (T && R)
    return T == e && R == t;
  var _ = !0;
  u.set(t, e), u.set(e, t);
  for (var b = f; ++w < p; ) {
    E = h[w];
    var M = t[E], A = e[E];
    if (o)
      var $ = f ? o(A, M, E, e, t, u) : o(M, A, E, t, e, u);
    if (!($ === void 0 ? M === A || l(M, A, n, o, u) : $)) {
      _ = !1;
      break;
    }
    b || (b = E == "constructor");
  }
  if (_ && !b) {
    var S = t.constructor, C = e.constructor;
    S != C && "constructor" in t && "constructor" in e && !(typeof S == "function" && S instanceof S && typeof C == "function" && C instanceof C) && (_ = !1);
  }
  return u.delete(t), u.delete(e), _;
}
var _equalObjects = equalObjects$1, getNative$4 = _getNative, root$4 = _root, DataView$2 = getNative$4(root$4, "DataView"), _DataView = DataView$2, getNative$3 = _getNative, root$3 = _root, Promise$2 = getNative$3(root$3, "Promise"), _Promise = Promise$2, getNative$2 = _getNative, root$2 = _root, Set$3 = getNative$2(root$2, "Set"), _Set = Set$3, getNative$1 = _getNative, root$1 = _root, WeakMap$2 = getNative$1(root$1, "WeakMap"), _WeakMap = WeakMap$2, DataView$1 = _DataView, Map$1 = _Map, Promise$1 = _Promise, Set$2 = _Set, WeakMap$1 = _WeakMap, baseGetTag$2 = _baseGetTag, toSource = _toSource, mapTag = "[object Map]", objectTag$2 = "[object Object]", promiseTag = "[object Promise]", setTag = "[object Set]", weakMapTag = "[object WeakMap]", dataViewTag = "[object DataView]", dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$2), weakMapCtorString = toSource(WeakMap$1), getTag$2 = baseGetTag$2;
(DataView$1 && getTag$2(new DataView$1(new ArrayBuffer(1))) != dataViewTag || Map$1 && getTag$2(new Map$1()) != mapTag || Promise$1 && getTag$2(Promise$1.resolve()) != promiseTag || Set$2 && getTag$2(new Set$2()) != setTag || WeakMap$1 && getTag$2(new WeakMap$1()) != weakMapTag) && (getTag$2 = function(t) {
  var e = baseGetTag$2(t), n = e == objectTag$2 ? t.constructor : void 0, o = n ? toSource(n) : "";
  if (o)
    switch (o) {
      case dataViewCtorString:
        return dataViewTag;
      case mapCtorString:
        return mapTag;
      case promiseCtorString:
        return promiseTag;
      case setCtorString:
        return setTag;
      case weakMapCtorString:
        return weakMapTag;
    }
  return e;
});
var _getTag = getTag$2, Stack$1 = _Stack, equalArrays = _equalArrays, equalByTag = _equalByTag, equalObjects = _equalObjects, getTag$1 = _getTag, isArray$8 = isArray_1, isBuffer = isBufferExports, isTypedArray$1 = isTypedArray_1, COMPARE_PARTIAL_FLAG$2 = 1, argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag$1 = "[object Object]", objectProto$1 = Object.prototype, hasOwnProperty$2 = objectProto$1.hasOwnProperty;
function baseIsEqualDeep$1(t, e, n, o, l, u) {
  var f = isArray$8(t), h = isArray$8(e), p = f ? arrayTag : getTag$1(t), v = h ? arrayTag : getTag$1(e);
  p = p == argsTag ? objectTag$1 : p, v = v == argsTag ? objectTag$1 : v;
  var g = p == objectTag$1, w = v == objectTag$1, E = p == v;
  if (E && isBuffer(t)) {
    if (!isBuffer(e))
      return !1;
    f = !0, g = !1;
  }
  if (E && !g)
    return u || (u = new Stack$1()), f || isTypedArray$1(t) ? equalArrays(t, e, n, o, l, u) : equalByTag(t, e, p, n, o, l, u);
  if (!(n & COMPARE_PARTIAL_FLAG$2)) {
    var T = g && hasOwnProperty$2.call(t, "__wrapped__"), R = w && hasOwnProperty$2.call(e, "__wrapped__");
    if (T || R) {
      var _ = T ? t.value() : t, b = R ? e.value() : e;
      return u || (u = new Stack$1()), l(_, b, n, o, u);
    }
  }
  return E ? (u || (u = new Stack$1()), equalObjects(t, e, n, o, l, u)) : !1;
}
var _baseIsEqualDeep = baseIsEqualDeep$1, baseIsEqualDeep = _baseIsEqualDeep, isObjectLike$2 = isObjectLike_1;
function baseIsEqual$3(t, e, n, o, l) {
  return t === e ? !0 : t == null || e == null || !isObjectLike$2(t) && !isObjectLike$2(e) ? t !== t && e !== e : baseIsEqualDeep(t, e, n, o, baseIsEqual$3, l);
}
var _baseIsEqual = baseIsEqual$3, Stack = _Stack, baseIsEqual$2 = _baseIsEqual, COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function baseIsMatch$1(t, e, n, o) {
  var l = n.length, u = l, f = !o;
  if (t == null)
    return !u;
  for (t = Object(t); l--; ) {
    var h = n[l];
    if (f && h[2] ? h[1] !== t[h[0]] : !(h[0] in t))
      return !1;
  }
  for (; ++l < u; ) {
    h = n[l];
    var p = h[0], v = t[p], g = h[1];
    if (f && h[2]) {
      if (v === void 0 && !(p in t))
        return !1;
    } else {
      var w = new Stack();
      if (o)
        var E = o(v, g, p, t, e, w);
      if (!(E === void 0 ? baseIsEqual$2(g, v, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, o, w) : E))
        return !1;
    }
  }
  return !0;
}
var _baseIsMatch = baseIsMatch$1, isObject$4 = isObject_1;
function isStrictComparable$2(t) {
  return t === t && !isObject$4(t);
}
var _isStrictComparable = isStrictComparable$2, isStrictComparable$1 = _isStrictComparable, keys$3 = keys_1;
function getMatchData$1(t) {
  for (var e = keys$3(t), n = e.length; n--; ) {
    var o = e[n], l = t[o];
    e[n] = [o, l, isStrictComparable$1(l)];
  }
  return e;
}
var _getMatchData = getMatchData$1;
function matchesStrictComparable$2(t, e) {
  return function(n) {
    return n == null ? !1 : n[t] === e && (e !== void 0 || t in Object(n));
  };
}
var _matchesStrictComparable = matchesStrictComparable$2, baseIsMatch = _baseIsMatch, getMatchData = _getMatchData, matchesStrictComparable$1 = _matchesStrictComparable;
function baseMatches$1(t) {
  var e = getMatchData(t);
  return e.length == 1 && e[0][2] ? matchesStrictComparable$1(e[0][0], e[0][1]) : function(n) {
    return n === t || baseIsMatch(n, t, e);
  };
}
var _baseMatches = baseMatches$1;
function baseHasIn$1(t, e) {
  return t != null && e in Object(t);
}
var _baseHasIn = baseHasIn$1, castPath = _castPath, isArguments$1 = isArguments_1, isArray$7 = isArray_1, isIndex$1 = _isIndex, isLength = isLength_1, toKey$2 = _toKey;
function hasPath$1(t, e, n) {
  e = castPath(e, t);
  for (var o = -1, l = e.length, u = !1; ++o < l; ) {
    var f = toKey$2(e[o]);
    if (!(u = t != null && n(t, f)))
      break;
    t = t[f];
  }
  return u || ++o != l ? u : (l = t == null ? 0 : t.length, !!l && isLength(l) && isIndex$1(f, l) && (isArray$7(t) || isArguments$1(t)));
}
var _hasPath = hasPath$1, baseHasIn = _baseHasIn, hasPath = _hasPath;
function hasIn$1(t, e) {
  return t != null && hasPath(t, e, baseHasIn);
}
var hasIn_1 = hasIn$1, baseIsEqual$1 = _baseIsEqual, get = get_1, hasIn = hasIn_1, isKey$1 = _isKey, isStrictComparable = _isStrictComparable, matchesStrictComparable = _matchesStrictComparable, toKey$1 = _toKey, COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
function baseMatchesProperty$1(t, e) {
  return isKey$1(t) && isStrictComparable(e) ? matchesStrictComparable(toKey$1(t), e) : function(n) {
    var o = get(n, t);
    return o === void 0 && o === e ? hasIn(n, t) : baseIsEqual$1(e, o, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}
var _baseMatchesProperty = baseMatchesProperty$1;
function identity$b(t) {
  return t;
}
var identity_1 = identity$b;
function baseProperty$1(t) {
  return function(e) {
    return e == null ? void 0 : e[t];
  };
}
var _baseProperty = baseProperty$1, baseGet$1 = _baseGet;
function basePropertyDeep$1(t) {
  return function(e) {
    return baseGet$1(e, t);
  };
}
var _basePropertyDeep = basePropertyDeep$1, baseProperty = _baseProperty, basePropertyDeep = _basePropertyDeep, isKey = _isKey, toKey = _toKey;
function property$1(t) {
  return isKey(t) ? baseProperty(toKey(t)) : basePropertyDeep(t);
}
var property_1 = property$1, baseMatches = _baseMatches, baseMatchesProperty = _baseMatchesProperty, identity$a = identity_1, isArray$6 = isArray_1, property = property_1;
function baseIteratee$a(t) {
  return typeof t == "function" ? t : t == null ? identity$a : typeof t == "object" ? isArray$6(t) ? baseMatchesProperty(t[0], t[1]) : baseMatches(t) : property(t);
}
var _baseIteratee = baseIteratee$a;
function baseFindIndex$2(t, e, n, o) {
  for (var l = t.length, u = n + (o ? 1 : -1); o ? u-- : ++u < l; )
    if (e(t[u], u, t))
      return u;
  return -1;
}
var _baseFindIndex = baseFindIndex$2;
function baseIsNaN$1(t) {
  return t !== t;
}
var _baseIsNaN = baseIsNaN$1;
function strictIndexOf$1(t, e, n) {
  for (var o = n - 1, l = t.length; ++o < l; )
    if (t[o] === e)
      return o;
  return -1;
}
var _strictIndexOf = strictIndexOf$1, baseFindIndex$1 = _baseFindIndex, baseIsNaN = _baseIsNaN, strictIndexOf = _strictIndexOf;
function baseIndexOf$1(t, e, n) {
  return e === e ? strictIndexOf(t, e, n) : baseFindIndex$1(t, baseIsNaN, n);
}
var _baseIndexOf = baseIndexOf$1, baseIndexOf = _baseIndexOf;
function arrayIncludes$1(t, e) {
  var n = t == null ? 0 : t.length;
  return !!n && baseIndexOf(t, e, 0) > -1;
}
var _arrayIncludes = arrayIncludes$1;
function arrayIncludesWith$1(t, e, n) {
  for (var o = -1, l = t == null ? 0 : t.length; ++o < l; )
    if (n(e, t[o]))
      return !0;
  return !1;
}
var _arrayIncludesWith = arrayIncludesWith$1;
function noop$1() {
}
var noop_1 = noop$1, Set$1 = _Set, noop = noop_1, setToArray$1 = _setToArray, INFINITY$1 = 1 / 0, createSet$1 = Set$1 && 1 / setToArray$1(new Set$1([, -0]))[1] == INFINITY$1 ? function(t) {
  return new Set$1(t);
} : noop, _createSet = createSet$1, SetCache = _SetCache, arrayIncludes = _arrayIncludes, arrayIncludesWith = _arrayIncludesWith, cacheHas = _cacheHas, createSet = _createSet, setToArray = _setToArray, LARGE_ARRAY_SIZE = 200;
function baseUniq$1(t, e, n) {
  var o = -1, l = arrayIncludes, u = t.length, f = !0, h = [], p = h;
  if (n)
    f = !1, l = arrayIncludesWith;
  else if (u >= LARGE_ARRAY_SIZE) {
    var v = e ? null : createSet(t);
    if (v)
      return setToArray(v);
    f = !1, l = cacheHas, p = new SetCache();
  } else
    p = e ? [] : h;
  e:
    for (; ++o < u; ) {
      var g = t[o], w = e ? e(g) : g;
      if (g = n || g !== 0 ? g : 0, f && w === w) {
        for (var E = p.length; E--; )
          if (p[E] === w)
            continue e;
        e && p.push(w), h.push(g);
      } else l(p, w, n) || (p !== h && p.push(w), h.push(g));
    }
  return h;
}
var _baseUniq = baseUniq$1, baseIteratee$9 = _baseIteratee, baseUniq = _baseUniq;
function uniqBy(t, e) {
  return t && t.length ? baseUniq(t, baseIteratee$9(e)) : [];
}
var uniqBy_1 = uniqBy;
const uniqBy$1 = /* @__PURE__ */ getDefaultExportFromCjs(uniqBy_1);
function getUniqPayload(t, e, n) {
  return e === !0 ? uniqBy$1(t, n) : isFunction$3(e) ? uniqBy$1(t, e) : t;
}
function _typeof$F(t) {
  "@babel/helpers - typeof";
  return _typeof$F = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof$F(t);
}
var _excluded$e = ["ref"];
function ownKeys$A(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(l) {
      return Object.getOwnPropertyDescriptor(t, l).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function _objectSpread$z(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ownKeys$A(Object(n), !0).forEach(function(o) {
      _defineProperty$D(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : ownKeys$A(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
function _classCallCheck$e(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$e(t, e) {
  for (var n = 0; n < e.length; n++) {
    var o = e[n];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, _toPropertyKey$D(o.key), o);
  }
}
function _createClass$e(t, e, n) {
  return e && _defineProperties$e(t.prototype, e), n && _defineProperties$e(t, n), Object.defineProperty(t, "prototype", { writable: !1 }), t;
}
function _callSuper$a(t, e, n) {
  return e = _getPrototypeOf$b(e), _possibleConstructorReturn$b(t, _isNativeReflectConstruct$b() ? Reflect.construct(e, n || [], _getPrototypeOf$b(t).constructor) : e.apply(t, n));
}
function _possibleConstructorReturn$b(t, e) {
  if (e && (_typeof$F(e) === "object" || typeof e == "function"))
    return e;
  if (e !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized$c(t);
}
function _isNativeReflectConstruct$b() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (_isNativeReflectConstruct$b = function() {
    return !!t;
  })();
}
function _getPrototypeOf$b(t) {
  return _getPrototypeOf$b = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
    return n.__proto__ || Object.getPrototypeOf(n);
  }, _getPrototypeOf$b(t);
}
function _assertThisInitialized$c(t) {
  if (t === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t;
}
function _inherits$b(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf$c(t, e);
}
function _setPrototypeOf$c(t, e) {
  return _setPrototypeOf$c = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(o, l) {
    return o.__proto__ = l, o;
  }, _setPrototypeOf$c(t, e);
}
function _defineProperty$D(t, e, n) {
  return e = _toPropertyKey$D(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function _toPropertyKey$D(t) {
  var e = _toPrimitive$D(t, "string");
  return _typeof$F(e) == "symbol" ? e : String(e);
}
function _toPrimitive$D(t, e) {
  if (_typeof$F(t) != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(t, e || "default");
    if (_typeof$F(o) != "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function _objectWithoutProperties$e(t, e) {
  if (t == null) return {};
  var n = _objectWithoutPropertiesLoose$f(t, e), o, l;
  if (Object.getOwnPropertySymbols) {
    var u = Object.getOwnPropertySymbols(t);
    for (l = 0; l < u.length; l++)
      o = u[l], !(e.indexOf(o) >= 0) && Object.prototype.propertyIsEnumerable.call(t, o) && (n[o] = t[o]);
  }
  return n;
}
function _objectWithoutPropertiesLoose$f(t, e) {
  if (t == null) return {};
  var n = {}, o = Object.keys(t), l, u;
  for (u = 0; u < o.length; u++)
    l = o[u], !(e.indexOf(l) >= 0) && (n[l] = t[l]);
  return n;
}
function defaultUniqBy$1(t) {
  return t.value;
}
function renderContent$1(t, e) {
  if (/* @__PURE__ */ React__default.isValidElement(t))
    return /* @__PURE__ */ React__default.cloneElement(t, e);
  if (typeof t == "function")
    return /* @__PURE__ */ React__default.createElement(t, e);
  e.ref;
  var n = _objectWithoutProperties$e(e, _excluded$e);
  return /* @__PURE__ */ React__default.createElement(DefaultLegendContent, n);
}
var EPS$1 = 1, Legend = /* @__PURE__ */ function(t) {
  _inherits$b(e, t);
  function e() {
    var n;
    _classCallCheck$e(this, e);
    for (var o = arguments.length, l = new Array(o), u = 0; u < o; u++)
      l[u] = arguments[u];
    return n = _callSuper$a(this, e, [].concat(l)), _defineProperty$D(_assertThisInitialized$c(n), "lastBoundingBox", {
      width: -1,
      height: -1
    }), n;
  }
  return _createClass$e(e, [{
    key: "componentDidMount",
    value: function() {
      this.updateBBox();
    }
  }, {
    key: "componentDidUpdate",
    value: function() {
      this.updateBBox();
    }
  }, {
    key: "getBBox",
    value: function() {
      if (this.wrapperNode && this.wrapperNode.getBoundingClientRect) {
        var o = this.wrapperNode.getBoundingClientRect();
        return o.height = this.wrapperNode.offsetHeight, o.width = this.wrapperNode.offsetWidth, o;
      }
      return null;
    }
  }, {
    key: "updateBBox",
    value: function() {
      var o = this.props.onBBoxUpdate, l = this.getBBox();
      l ? (Math.abs(l.width - this.lastBoundingBox.width) > EPS$1 || Math.abs(l.height - this.lastBoundingBox.height) > EPS$1) && (this.lastBoundingBox.width = l.width, this.lastBoundingBox.height = l.height, o && o(l)) : (this.lastBoundingBox.width !== -1 || this.lastBoundingBox.height !== -1) && (this.lastBoundingBox.width = -1, this.lastBoundingBox.height = -1, o && o(null));
    }
  }, {
    key: "getBBoxSnapshot",
    value: function() {
      return this.lastBoundingBox.width >= 0 && this.lastBoundingBox.height >= 0 ? _objectSpread$z({}, this.lastBoundingBox) : {
        width: 0,
        height: 0
      };
    }
  }, {
    key: "getDefaultPosition",
    value: function(o) {
      var l = this.props, u = l.layout, f = l.align, h = l.verticalAlign, p = l.margin, v = l.chartWidth, g = l.chartHeight, w, E;
      if (!o || (o.left === void 0 || o.left === null) && (o.right === void 0 || o.right === null))
        if (f === "center" && u === "vertical") {
          var T = this.getBBoxSnapshot();
          w = {
            left: ((v || 0) - T.width) / 2
          };
        } else
          w = f === "right" ? {
            right: p && p.right || 0
          } : {
            left: p && p.left || 0
          };
      if (!o || (o.top === void 0 || o.top === null) && (o.bottom === void 0 || o.bottom === null))
        if (h === "middle") {
          var R = this.getBBoxSnapshot();
          E = {
            top: ((g || 0) - R.height) / 2
          };
        } else
          E = h === "bottom" ? {
            bottom: p && p.bottom || 0
          } : {
            top: p && p.top || 0
          };
      return _objectSpread$z(_objectSpread$z({}, w), E);
    }
  }, {
    key: "render",
    value: function() {
      var o = this, l = this.props, u = l.content, f = l.width, h = l.height, p = l.wrapperStyle, v = l.payloadUniqBy, g = l.payload, w = _objectSpread$z(_objectSpread$z({
        position: "absolute",
        width: f || "auto",
        height: h || "auto"
      }, this.getDefaultPosition(p)), p);
      return /* @__PURE__ */ React__default.createElement("div", {
        className: "recharts-legend-wrapper",
        style: w,
        ref: function(T) {
          o.wrapperNode = T;
        }
      }, renderContent$1(u, _objectSpread$z(_objectSpread$z({}, this.props), {}, {
        payload: getUniqPayload(g, v, defaultUniqBy$1)
      })));
    }
  }], [{
    key: "getWithHeight",
    value: function(o, l) {
      var u = o.props.layout;
      return u === "vertical" && isNumber(o.props.height) ? {
        height: o.props.height
      } : u === "horizontal" ? {
        width: o.props.width || l
      } : null;
    }
  }]), e;
}(PureComponent);
_defineProperty$D(Legend, "displayName", "Legend");
_defineProperty$D(Legend, "defaultProps", {
  iconSize: 14,
  layout: "horizontal",
  align: "center",
  verticalAlign: "bottom"
});
var Symbol$1 = _Symbol, isArguments = isArguments_1, isArray$5 = isArray_1, spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
function isFlattenable$1(t) {
  return isArray$5(t) || isArguments(t) || !!(spreadableSymbol && t && t[spreadableSymbol]);
}
var _isFlattenable = isFlattenable$1, arrayPush = _arrayPush, isFlattenable = _isFlattenable;
function baseFlatten$2(t, e, n, o, l) {
  var u = -1, f = t.length;
  for (n || (n = isFlattenable), l || (l = []); ++u < f; ) {
    var h = t[u];
    e > 0 && n(h) ? e > 1 ? baseFlatten$2(h, e - 1, n, o, l) : arrayPush(l, h) : o || (l[l.length] = h);
  }
  return l;
}
var _baseFlatten = baseFlatten$2;
function createBaseFor$1(t) {
  return function(e, n, o) {
    for (var l = -1, u = Object(e), f = o(e), h = f.length; h--; ) {
      var p = f[t ? h : ++l];
      if (n(u[p], p, u) === !1)
        break;
    }
    return e;
  };
}
var _createBaseFor = createBaseFor$1, createBaseFor = _createBaseFor, baseFor$1 = createBaseFor(), _baseFor = baseFor$1, baseFor = _baseFor, keys$2 = keys_1;
function baseForOwn$2(t, e) {
  return t && baseFor(t, e, keys$2);
}
var _baseForOwn = baseForOwn$2, isArrayLike$3 = isArrayLike_1;
function createBaseEach$1(t, e) {
  return function(n, o) {
    if (n == null)
      return n;
    if (!isArrayLike$3(n))
      return t(n, o);
    for (var l = n.length, u = e ? l : -1, f = Object(n); (e ? u-- : ++u < l) && o(f[u], u, f) !== !1; )
      ;
    return n;
  };
}
var _createBaseEach = createBaseEach$1, baseForOwn$1 = _baseForOwn, createBaseEach = _createBaseEach, baseEach$3 = createBaseEach(baseForOwn$1), _baseEach = baseEach$3, baseEach$2 = _baseEach, isArrayLike$2 = isArrayLike_1;
function baseMap$2(t, e) {
  var n = -1, o = isArrayLike$2(t) ? Array(t.length) : [];
  return baseEach$2(t, function(l, u, f) {
    o[++n] = e(l, u, f);
  }), o;
}
var _baseMap = baseMap$2;
function baseSortBy$1(t, e) {
  var n = t.length;
  for (t.sort(e); n--; )
    t[n] = t[n].value;
  return t;
}
var _baseSortBy = baseSortBy$1, isSymbol$2 = isSymbol_1;
function compareAscending$1(t, e) {
  if (t !== e) {
    var n = t !== void 0, o = t === null, l = t === t, u = isSymbol$2(t), f = e !== void 0, h = e === null, p = e === e, v = isSymbol$2(e);
    if (!h && !v && !u && t > e || u && f && p && !h && !v || o && f && p || !n && p || !l)
      return 1;
    if (!o && !u && !v && t < e || v && n && l && !o && !u || h && n && l || !f && l || !p)
      return -1;
  }
  return 0;
}
var _compareAscending = compareAscending$1, compareAscending = _compareAscending;
function compareMultiple$1(t, e, n) {
  for (var o = -1, l = t.criteria, u = e.criteria, f = l.length, h = n.length; ++o < f; ) {
    var p = compareAscending(l[o], u[o]);
    if (p) {
      if (o >= h)
        return p;
      var v = n[o];
      return p * (v == "desc" ? -1 : 1);
    }
  }
  return t.index - e.index;
}
var _compareMultiple = compareMultiple$1, arrayMap$1 = _arrayMap, baseGet = _baseGet, baseIteratee$8 = _baseIteratee, baseMap$1 = _baseMap, baseSortBy = _baseSortBy, baseUnary = _baseUnary, compareMultiple = _compareMultiple, identity$9 = identity_1, isArray$4 = isArray_1;
function baseOrderBy$1(t, e, n) {
  e.length ? e = arrayMap$1(e, function(u) {
    return isArray$4(u) ? function(f) {
      return baseGet(f, u.length === 1 ? u[0] : u);
    } : u;
  }) : e = [identity$9];
  var o = -1;
  e = arrayMap$1(e, baseUnary(baseIteratee$8));
  var l = baseMap$1(t, function(u, f, h) {
    var p = arrayMap$1(e, function(v) {
      return v(u);
    });
    return { criteria: p, index: ++o, value: u };
  });
  return baseSortBy(l, function(u, f) {
    return compareMultiple(u, f, n);
  });
}
var _baseOrderBy = baseOrderBy$1;
function apply$1(t, e, n) {
  switch (n.length) {
    case 0:
      return t.call(e);
    case 1:
      return t.call(e, n[0]);
    case 2:
      return t.call(e, n[0], n[1]);
    case 3:
      return t.call(e, n[0], n[1], n[2]);
  }
  return t.apply(e, n);
}
var _apply = apply$1, apply = _apply, nativeMax$3 = Math.max;
function overRest$1(t, e, n) {
  return e = nativeMax$3(e === void 0 ? t.length - 1 : e, 0), function() {
    for (var o = arguments, l = -1, u = nativeMax$3(o.length - e, 0), f = Array(u); ++l < u; )
      f[l] = o[e + l];
    l = -1;
    for (var h = Array(e + 1); ++l < e; )
      h[l] = o[l];
    return h[e] = n(f), apply(t, this, h);
  };
}
var _overRest = overRest$1;
function constant$1(t) {
  return function() {
    return t;
  };
}
var constant_1 = constant$1, getNative = _getNative, defineProperty$2 = function() {
  try {
    var t = getNative(Object, "defineProperty");
    return t({}, "", {}), t;
  } catch {
  }
}(), _defineProperty$C = defineProperty$2, constant = constant_1, defineProperty$1 = _defineProperty$C, identity$8 = identity_1, baseSetToString$1 = defineProperty$1 ? function(t, e) {
  return defineProperty$1(t, "toString", {
    configurable: !0,
    enumerable: !1,
    value: constant(e),
    writable: !0
  });
} : identity$8, _baseSetToString = baseSetToString$1, HOT_COUNT = 800, HOT_SPAN = 16, nativeNow = Date.now;
function shortOut$1(t) {
  var e = 0, n = 0;
  return function() {
    var o = nativeNow(), l = HOT_SPAN - (o - n);
    if (n = o, l > 0) {
      if (++e >= HOT_COUNT)
        return arguments[0];
    } else
      e = 0;
    return t.apply(void 0, arguments);
  };
}
var _shortOut = shortOut$1, baseSetToString = _baseSetToString, shortOut = _shortOut, setToString$1 = shortOut(baseSetToString), _setToString = setToString$1, identity$7 = identity_1, overRest = _overRest, setToString = _setToString;
function baseRest$1(t, e) {
  return setToString(overRest(t, e, identity$7), t + "");
}
var _baseRest = baseRest$1, eq = eq_1, isArrayLike$1 = isArrayLike_1, isIndex = _isIndex, isObject$3 = isObject_1;
function isIterateeCall$4(t, e, n) {
  if (!isObject$3(n))
    return !1;
  var o = typeof e;
  return (o == "number" ? isArrayLike$1(n) && isIndex(e, n.length) : o == "string" && e in n) ? eq(n[e], t) : !1;
}
var _isIterateeCall = isIterateeCall$4, baseFlatten$1 = _baseFlatten, baseOrderBy = _baseOrderBy, baseRest = _baseRest, isIterateeCall$3 = _isIterateeCall, sortBy = baseRest(function(t, e) {
  if (t == null)
    return [];
  var n = e.length;
  return n > 1 && isIterateeCall$3(t, e[0], e[1]) ? e = [] : n > 2 && isIterateeCall$3(e[0], e[1], e[2]) && (e = [e[0]]), baseOrderBy(t, baseFlatten$1(e, 1), []);
}), sortBy_1 = sortBy;
const sortBy$1 = /* @__PURE__ */ getDefaultExportFromCjs(sortBy_1);
function _typeof$E(t) {
  "@babel/helpers - typeof";
  return _typeof$E = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof$E(t);
}
function _extends$r() {
  return _extends$r = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }
    return t;
  }, _extends$r.apply(this, arguments);
}
function _slicedToArray$c(t, e) {
  return _arrayWithHoles$d(t) || _iterableToArrayLimit$c(t, e) || _unsupportedIterableToArray$l(t, e) || _nonIterableRest$d();
}
function _nonIterableRest$d() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function _unsupportedIterableToArray$l(t, e) {
  if (t) {
    if (typeof t == "string") return _arrayLikeToArray$l(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$l(t, e);
  }
}
function _arrayLikeToArray$l(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, o = new Array(e); n < e; n++) o[n] = t[n];
  return o;
}
function _iterableToArrayLimit$c(t, e) {
  var n = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
  if (n != null) {
    var o, l, u, f, h = [], p = !0, v = !1;
    try {
      if (u = (n = n.call(t)).next, e !== 0) for (; !(p = (o = u.call(n)).done) && (h.push(o.value), h.length !== e); p = !0) ;
    } catch (g) {
      v = !0, l = g;
    } finally {
      try {
        if (!p && n.return != null && (f = n.return(), Object(f) !== f)) return;
      } finally {
        if (v) throw l;
      }
    }
    return h;
  }
}
function _arrayWithHoles$d(t) {
  if (Array.isArray(t)) return t;
}
function ownKeys$z(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(l) {
      return Object.getOwnPropertyDescriptor(t, l).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function _objectSpread$y(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ownKeys$z(Object(n), !0).forEach(function(o) {
      _defineProperty$B(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : ownKeys$z(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
function _defineProperty$B(t, e, n) {
  return e = _toPropertyKey$C(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function _toPropertyKey$C(t) {
  var e = _toPrimitive$C(t, "string");
  return _typeof$E(e) == "symbol" ? e : String(e);
}
function _toPrimitive$C(t, e) {
  if (_typeof$E(t) != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(t, e || "default");
    if (_typeof$E(o) != "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function defaultFormatter(t) {
  return Array.isArray(t) && isNumOrStr(t[0]) && isNumOrStr(t[1]) ? t.join(" ~ ") : t;
}
var DefaultTooltipContent = function t(e) {
  var n = e.separator, o = n === void 0 ? " : " : n, l = e.contentStyle, u = l === void 0 ? {} : l, f = e.itemStyle, h = f === void 0 ? {} : f, p = e.labelStyle, v = p === void 0 ? {} : p, g = e.payload, w = e.formatter, E = e.itemSorter, T = e.wrapperClassName, R = e.labelClassName, _ = e.label, b = e.labelFormatter, M = e.accessibilityLayer, A = M === void 0 ? !1 : M, $ = function() {
    if (g && g.length) {
      var G = {
        padding: 0,
        margin: 0
      }, B = (E ? sortBy$1(g, E) : g).map(function(F, H) {
        if (F.type === "none")
          return null;
        var W = _objectSpread$y({
          display: "block",
          paddingTop: 4,
          paddingBottom: 4,
          color: F.color || "#000"
        }, h), V = F.formatter || w || defaultFormatter, X = F.value, Z = F.name, Q = X, q = Z;
        if (V && Q != null && q != null) {
          var J = V(X, Z, F, H, g);
          if (Array.isArray(J)) {
            var ie = _slicedToArray$c(J, 2);
            Q = ie[0], q = ie[1];
          } else
            Q = J;
        }
        return (
          // eslint-disable-next-line react/no-array-index-key
          /* @__PURE__ */ React__default.createElement("li", {
            className: "recharts-tooltip-item",
            key: "tooltip-item-".concat(H),
            style: W
          }, isNumOrStr(q) ? /* @__PURE__ */ React__default.createElement("span", {
            className: "recharts-tooltip-item-name"
          }, q) : null, isNumOrStr(q) ? /* @__PURE__ */ React__default.createElement("span", {
            className: "recharts-tooltip-item-separator"
          }, o) : null, /* @__PURE__ */ React__default.createElement("span", {
            className: "recharts-tooltip-item-value"
          }, Q), /* @__PURE__ */ React__default.createElement("span", {
            className: "recharts-tooltip-item-unit"
          }, F.unit || ""))
        );
      });
      return /* @__PURE__ */ React__default.createElement("ul", {
        className: "recharts-tooltip-item-list",
        style: G
      }, B);
    }
    return null;
  }, S = _objectSpread$y({
    margin: 0,
    padding: 10,
    backgroundColor: "#fff",
    border: "1px solid #ccc",
    whiteSpace: "nowrap"
  }, u), C = _objectSpread$y({
    margin: 0
  }, v), D = !isNil$1(_), O = D ? _ : "", N = clsx$1("recharts-default-tooltip", T), j = clsx$1("recharts-tooltip-label", R);
  D && b && g !== void 0 && g !== null && (O = b(_, g));
  var L = A ? {
    role: "status",
    "aria-live": "assertive"
  } : {};
  return /* @__PURE__ */ React__default.createElement("div", _extends$r({
    className: N,
    style: S
  }, L), /* @__PURE__ */ React__default.createElement("p", {
    className: j,
    style: C
  }, /* @__PURE__ */ React__default.isValidElement(O) ? O : "".concat(O)), $());
};
function _typeof$D(t) {
  "@babel/helpers - typeof";
  return _typeof$D = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof$D(t);
}
function _defineProperty$A(t, e, n) {
  return e = _toPropertyKey$B(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function _toPropertyKey$B(t) {
  var e = _toPrimitive$B(t, "string");
  return _typeof$D(e) == "symbol" ? e : String(e);
}
function _toPrimitive$B(t, e) {
  if (_typeof$D(t) != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(t, e || "default");
    if (_typeof$D(o) != "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
var CSS_CLASS_PREFIX = "recharts-tooltip-wrapper", TOOLTIP_HIDDEN = {
  visibility: "hidden"
};
function getTooltipCSSClassName(t) {
  var e = t.coordinate, n = t.translateX, o = t.translateY;
  return clsx$1(CSS_CLASS_PREFIX, _defineProperty$A(_defineProperty$A(_defineProperty$A(_defineProperty$A({}, "".concat(CSS_CLASS_PREFIX, "-right"), isNumber(n) && e && isNumber(e.x) && n >= e.x), "".concat(CSS_CLASS_PREFIX, "-left"), isNumber(n) && e && isNumber(e.x) && n < e.x), "".concat(CSS_CLASS_PREFIX, "-bottom"), isNumber(o) && e && isNumber(e.y) && o >= e.y), "".concat(CSS_CLASS_PREFIX, "-top"), isNumber(o) && e && isNumber(e.y) && o < e.y));
}
function getTooltipTranslateXY(t) {
  var e = t.allowEscapeViewBox, n = t.coordinate, o = t.key, l = t.offsetTopLeft, u = t.position, f = t.reverseDirection, h = t.tooltipDimension, p = t.viewBox, v = t.viewBoxDimension;
  if (u && isNumber(u[o]))
    return u[o];
  var g = n[o] - h - l, w = n[o] + l;
  if (e[o])
    return f[o] ? g : w;
  if (f[o]) {
    var E = g, T = p[o];
    return E < T ? Math.max(w, p[o]) : Math.max(g, p[o]);
  }
  var R = w + h, _ = p[o] + v;
  return R > _ ? Math.max(g, p[o]) : Math.max(w, p[o]);
}
function getTransformStyle(t) {
  var e = t.translateX, n = t.translateY, o = t.useTranslate3d;
  return {
    transform: o ? "translate3d(".concat(e, "px, ").concat(n, "px, 0)") : "translate(".concat(e, "px, ").concat(n, "px)")
  };
}
function getTooltipTranslate(t) {
  var e = t.allowEscapeViewBox, n = t.coordinate, o = t.offsetTopLeft, l = t.position, u = t.reverseDirection, f = t.tooltipBox, h = t.useTranslate3d, p = t.viewBox, v, g, w;
  return f.height > 0 && f.width > 0 && n ? (g = getTooltipTranslateXY({
    allowEscapeViewBox: e,
    coordinate: n,
    key: "x",
    offsetTopLeft: o,
    position: l,
    reverseDirection: u,
    tooltipDimension: f.width,
    viewBox: p,
    viewBoxDimension: p.width
  }), w = getTooltipTranslateXY({
    allowEscapeViewBox: e,
    coordinate: n,
    key: "y",
    offsetTopLeft: o,
    position: l,
    reverseDirection: u,
    tooltipDimension: f.height,
    viewBox: p,
    viewBoxDimension: p.height
  }), v = getTransformStyle({
    translateX: g,
    translateY: w,
    useTranslate3d: h
  })) : v = TOOLTIP_HIDDEN, {
    cssProperties: v,
    cssClasses: getTooltipCSSClassName({
      translateX: g,
      translateY: w,
      coordinate: n
    })
  };
}
function _typeof$C(t) {
  "@babel/helpers - typeof";
  return _typeof$C = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof$C(t);
}
function ownKeys$y(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(l) {
      return Object.getOwnPropertyDescriptor(t, l).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function _objectSpread$x(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ownKeys$y(Object(n), !0).forEach(function(o) {
      _defineProperty$z(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : ownKeys$y(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
function _classCallCheck$d(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$d(t, e) {
  for (var n = 0; n < e.length; n++) {
    var o = e[n];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, _toPropertyKey$A(o.key), o);
  }
}
function _createClass$d(t, e, n) {
  return e && _defineProperties$d(t.prototype, e), Object.defineProperty(t, "prototype", { writable: !1 }), t;
}
function _callSuper$9(t, e, n) {
  return e = _getPrototypeOf$a(e), _possibleConstructorReturn$a(t, _isNativeReflectConstruct$a() ? Reflect.construct(e, n || [], _getPrototypeOf$a(t).constructor) : e.apply(t, n));
}
function _possibleConstructorReturn$a(t, e) {
  if (e && (_typeof$C(e) === "object" || typeof e == "function"))
    return e;
  if (e !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized$b(t);
}
function _isNativeReflectConstruct$a() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (_isNativeReflectConstruct$a = function() {
    return !!t;
  })();
}
function _getPrototypeOf$a(t) {
  return _getPrototypeOf$a = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
    return n.__proto__ || Object.getPrototypeOf(n);
  }, _getPrototypeOf$a(t);
}
function _assertThisInitialized$b(t) {
  if (t === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t;
}
function _inherits$a(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf$b(t, e);
}
function _setPrototypeOf$b(t, e) {
  return _setPrototypeOf$b = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(o, l) {
    return o.__proto__ = l, o;
  }, _setPrototypeOf$b(t, e);
}
function _defineProperty$z(t, e, n) {
  return e = _toPropertyKey$A(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function _toPropertyKey$A(t) {
  var e = _toPrimitive$A(t, "string");
  return _typeof$C(e) == "symbol" ? e : String(e);
}
function _toPrimitive$A(t, e) {
  if (_typeof$C(t) != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(t, e || "default");
    if (_typeof$C(o) != "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
var EPSILON = 1, TooltipBoundingBox = /* @__PURE__ */ function(t) {
  _inherits$a(e, t);
  function e() {
    var n;
    _classCallCheck$d(this, e);
    for (var o = arguments.length, l = new Array(o), u = 0; u < o; u++)
      l[u] = arguments[u];
    return n = _callSuper$9(this, e, [].concat(l)), _defineProperty$z(_assertThisInitialized$b(n), "state", {
      dismissed: !1,
      dismissedAtCoordinate: {
        x: 0,
        y: 0
      },
      lastBoundingBox: {
        width: -1,
        height: -1
      }
    }), _defineProperty$z(_assertThisInitialized$b(n), "handleKeyDown", function(f) {
      if (f.key === "Escape") {
        var h, p, v, g;
        n.setState({
          dismissed: !0,
          dismissedAtCoordinate: {
            x: (h = (p = n.props.coordinate) === null || p === void 0 ? void 0 : p.x) !== null && h !== void 0 ? h : 0,
            y: (v = (g = n.props.coordinate) === null || g === void 0 ? void 0 : g.y) !== null && v !== void 0 ? v : 0
          }
        });
      }
    }), n;
  }
  return _createClass$d(e, [{
    key: "updateBBox",
    value: function() {
      if (this.wrapperNode && this.wrapperNode.getBoundingClientRect) {
        var o = this.wrapperNode.getBoundingClientRect();
        (Math.abs(o.width - this.state.lastBoundingBox.width) > EPSILON || Math.abs(o.height - this.state.lastBoundingBox.height) > EPSILON) && this.setState({
          lastBoundingBox: {
            width: o.width,
            height: o.height
          }
        });
      } else (this.state.lastBoundingBox.width !== -1 || this.state.lastBoundingBox.height !== -1) && this.setState({
        lastBoundingBox: {
          width: -1,
          height: -1
        }
      });
    }
  }, {
    key: "componentDidMount",
    value: function() {
      document.addEventListener("keydown", this.handleKeyDown), this.updateBBox();
    }
  }, {
    key: "componentWillUnmount",
    value: function() {
      document.removeEventListener("keydown", this.handleKeyDown);
    }
  }, {
    key: "componentDidUpdate",
    value: function() {
      var o, l;
      this.props.active && this.updateBBox(), this.state.dismissed && (((o = this.props.coordinate) === null || o === void 0 ? void 0 : o.x) !== this.state.dismissedAtCoordinate.x || ((l = this.props.coordinate) === null || l === void 0 ? void 0 : l.y) !== this.state.dismissedAtCoordinate.y) && (this.state.dismissed = !1);
    }
  }, {
    key: "render",
    value: function() {
      var o = this, l = this.props, u = l.active, f = l.allowEscapeViewBox, h = l.animationDuration, p = l.animationEasing, v = l.children, g = l.coordinate, w = l.hasPayload, E = l.isAnimationActive, T = l.offset, R = l.position, _ = l.reverseDirection, b = l.useTranslate3d, M = l.viewBox, A = l.wrapperStyle, $ = getTooltipTranslate({
        allowEscapeViewBox: f,
        coordinate: g,
        offsetTopLeft: T,
        position: R,
        reverseDirection: _,
        tooltipBox: this.state.lastBoundingBox,
        useTranslate3d: b,
        viewBox: M
      }), S = $.cssClasses, C = $.cssProperties, D = _objectSpread$x(_objectSpread$x({
        transition: E && u ? "transform ".concat(h, "ms ").concat(p) : void 0
      }, C), {}, {
        pointerEvents: "none",
        visibility: !this.state.dismissed && u && w ? "visible" : "hidden",
        position: "absolute",
        top: 0,
        left: 0
      }, A);
      return (
        // This element allow listening to the `Escape` key.
        // See https://github.com/recharts/recharts/pull/2925
        /* @__PURE__ */ React__default.createElement("div", {
          tabIndex: -1,
          className: S,
          style: D,
          ref: function(N) {
            o.wrapperNode = N;
          }
        }, v)
      );
    }
  }]), e;
}(PureComponent), parseIsSsrByDefault = function t() {
  return !(typeof window < "u" && window.document && window.document.createElement && window.setTimeout);
}, Global = {
  isSsr: parseIsSsrByDefault(),
  get: function t(e) {
    return Global[e];
  },
  set: function t(e, n) {
    if (typeof e == "string")
      Global[e] = n;
    else {
      var o = Object.keys(e);
      o && o.length && o.forEach(function(l) {
        Global[l] = e[l];
      });
    }
  }
};
function _typeof$B(t) {
  "@babel/helpers - typeof";
  return _typeof$B = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof$B(t);
}
function ownKeys$x(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(l) {
      return Object.getOwnPropertyDescriptor(t, l).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function _objectSpread$w(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ownKeys$x(Object(n), !0).forEach(function(o) {
      _defineProperty$y(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : ownKeys$x(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
function _classCallCheck$c(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$c(t, e) {
  for (var n = 0; n < e.length; n++) {
    var o = e[n];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, _toPropertyKey$z(o.key), o);
  }
}
function _createClass$c(t, e, n) {
  return e && _defineProperties$c(t.prototype, e), Object.defineProperty(t, "prototype", { writable: !1 }), t;
}
function _callSuper$8(t, e, n) {
  return e = _getPrototypeOf$9(e), _possibleConstructorReturn$9(t, _isNativeReflectConstruct$9() ? Reflect.construct(e, n || [], _getPrototypeOf$9(t).constructor) : e.apply(t, n));
}
function _possibleConstructorReturn$9(t, e) {
  if (e && (_typeof$B(e) === "object" || typeof e == "function"))
    return e;
  if (e !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized$a(t);
}
function _assertThisInitialized$a(t) {
  if (t === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t;
}
function _isNativeReflectConstruct$9() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (_isNativeReflectConstruct$9 = function() {
    return !!t;
  })();
}
function _getPrototypeOf$9(t) {
  return _getPrototypeOf$9 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
    return n.__proto__ || Object.getPrototypeOf(n);
  }, _getPrototypeOf$9(t);
}
function _inherits$9(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf$a(t, e);
}
function _setPrototypeOf$a(t, e) {
  return _setPrototypeOf$a = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(o, l) {
    return o.__proto__ = l, o;
  }, _setPrototypeOf$a(t, e);
}
function _defineProperty$y(t, e, n) {
  return e = _toPropertyKey$z(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function _toPropertyKey$z(t) {
  var e = _toPrimitive$z(t, "string");
  return _typeof$B(e) == "symbol" ? e : String(e);
}
function _toPrimitive$z(t, e) {
  if (_typeof$B(t) != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(t, e || "default");
    if (_typeof$B(o) != "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function defaultUniqBy(t) {
  return t.dataKey;
}
function renderContent(t, e) {
  return /* @__PURE__ */ React__default.isValidElement(t) ? /* @__PURE__ */ React__default.cloneElement(t, e) : typeof t == "function" ? /* @__PURE__ */ React__default.createElement(t, e) : /* @__PURE__ */ React__default.createElement(DefaultTooltipContent, e);
}
var Tooltip = /* @__PURE__ */ function(t) {
  _inherits$9(e, t);
  function e() {
    return _classCallCheck$c(this, e), _callSuper$8(this, e, arguments);
  }
  return _createClass$c(e, [{
    key: "render",
    value: function() {
      var o = this, l = this.props, u = l.active, f = l.allowEscapeViewBox, h = l.animationDuration, p = l.animationEasing, v = l.content, g = l.coordinate, w = l.filterNull, E = l.isAnimationActive, T = l.offset, R = l.payload, _ = l.payloadUniqBy, b = l.position, M = l.reverseDirection, A = l.useTranslate3d, $ = l.viewBox, S = l.wrapperStyle, C = R ?? [];
      w && C.length && (C = getUniqPayload(R.filter(function(O) {
        return O.value != null && (O.hide !== !0 || o.props.includeHidden);
      }), _, defaultUniqBy));
      var D = C.length > 0;
      return /* @__PURE__ */ React__default.createElement(TooltipBoundingBox, {
        allowEscapeViewBox: f,
        animationDuration: h,
        animationEasing: p,
        isAnimationActive: E,
        active: u,
        coordinate: g,
        hasPayload: D,
        offset: T,
        position: b,
        reverseDirection: M,
        useTranslate3d: A,
        viewBox: $,
        wrapperStyle: S
      }, renderContent(v, _objectSpread$w(_objectSpread$w({}, this.props), {}, {
        payload: C
      })));
    }
  }]), e;
}(PureComponent);
_defineProperty$y(Tooltip, "displayName", "Tooltip");
_defineProperty$y(Tooltip, "defaultProps", {
  accessibilityLayer: !1,
  allowEscapeViewBox: {
    x: !1,
    y: !1
  },
  animationDuration: 400,
  animationEasing: "ease",
  contentStyle: {},
  coordinate: {
    x: 0,
    y: 0
  },
  cursor: !0,
  cursorStyle: {},
  filterNull: !0,
  isAnimationActive: !Global.isSsr,
  itemStyle: {},
  labelStyle: {},
  offset: 10,
  reverseDirection: {
    x: !1,
    y: !1
  },
  separator: " : ",
  trigger: "hover",
  useTranslate3d: !1,
  viewBox: {
    x: 0,
    y: 0,
    height: 0,
    width: 0
  },
  wrapperStyle: {}
});
var root = _root, now$1 = function() {
  return root.Date.now();
}, now_1 = now$1, reWhitespace = /\s/;
function trimmedEndIndex$1(t) {
  for (var e = t.length; e-- && reWhitespace.test(t.charAt(e)); )
    ;
  return e;
}
var _trimmedEndIndex = trimmedEndIndex$1, trimmedEndIndex = _trimmedEndIndex, reTrimStart = /^\s+/;
function baseTrim$1(t) {
  return t && t.slice(0, trimmedEndIndex(t) + 1).replace(reTrimStart, "");
}
var _baseTrim = baseTrim$1, baseTrim = _baseTrim, isObject$2 = isObject_1, isSymbol$1 = isSymbol_1, NAN = NaN, reIsBadHex = /^[-+]0x[0-9a-f]+$/i, reIsBinary = /^0b[01]+$/i, reIsOctal = /^0o[0-7]+$/i, freeParseInt = parseInt;
function toNumber$2(t) {
  if (typeof t == "number")
    return t;
  if (isSymbol$1(t))
    return NAN;
  if (isObject$2(t)) {
    var e = typeof t.valueOf == "function" ? t.valueOf() : t;
    t = isObject$2(e) ? e + "" : e;
  }
  if (typeof t != "string")
    return t === 0 ? t : +t;
  t = baseTrim(t);
  var n = reIsBinary.test(t);
  return n || reIsOctal.test(t) ? freeParseInt(t.slice(2), n ? 2 : 8) : reIsBadHex.test(t) ? NAN : +t;
}
var toNumber_1 = toNumber$2, isObject$1 = isObject_1, now = now_1, toNumber$1 = toNumber_1, FUNC_ERROR_TEXT$1 = "Expected a function", nativeMax$2 = Math.max, nativeMin = Math.min;
function debounce$1(t, e, n) {
  var o, l, u, f, h, p, v = 0, g = !1, w = !1, E = !0;
  if (typeof t != "function")
    throw new TypeError(FUNC_ERROR_TEXT$1);
  e = toNumber$1(e) || 0, isObject$1(n) && (g = !!n.leading, w = "maxWait" in n, u = w ? nativeMax$2(toNumber$1(n.maxWait) || 0, e) : u, E = "trailing" in n ? !!n.trailing : E);
  function T(D) {
    var O = o, N = l;
    return o = l = void 0, v = D, f = t.apply(N, O), f;
  }
  function R(D) {
    return v = D, h = setTimeout(M, e), g ? T(D) : f;
  }
  function _(D) {
    var O = D - p, N = D - v, j = e - O;
    return w ? nativeMin(j, u - N) : j;
  }
  function b(D) {
    var O = D - p, N = D - v;
    return p === void 0 || O >= e || O < 0 || w && N >= u;
  }
  function M() {
    var D = now();
    if (b(D))
      return A(D);
    h = setTimeout(M, _(D));
  }
  function A(D) {
    return h = void 0, E && o ? T(D) : (o = l = void 0, f);
  }
  function $() {
    h !== void 0 && clearTimeout(h), v = 0, o = p = l = h = void 0;
  }
  function S() {
    return h === void 0 ? f : A(now());
  }
  function C() {
    var D = now(), O = b(D);
    if (o = arguments, l = this, p = D, O) {
      if (h === void 0)
        return R(p);
      if (w)
        return clearTimeout(h), h = setTimeout(M, e), T(p);
    }
    return h === void 0 && (h = setTimeout(M, e)), f;
  }
  return C.cancel = $, C.flush = S, C;
}
var debounce_1 = debounce$1, debounce = debounce_1, isObject = isObject_1, FUNC_ERROR_TEXT = "Expected a function";
function throttle(t, e, n) {
  var o = !0, l = !0;
  if (typeof t != "function")
    throw new TypeError(FUNC_ERROR_TEXT);
  return isObject(n) && (o = "leading" in n ? !!n.leading : o, l = "trailing" in n ? !!n.trailing : l), debounce(t, e, {
    leading: o,
    maxWait: e,
    trailing: l
  });
}
var throttle_1 = throttle;
const throttle$1 = /* @__PURE__ */ getDefaultExportFromCjs(throttle_1);
function _typeof$A(t) {
  "@babel/helpers - typeof";
  return _typeof$A = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof$A(t);
}
function ownKeys$w(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(l) {
      return Object.getOwnPropertyDescriptor(t, l).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function _objectSpread$v(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ownKeys$w(Object(n), !0).forEach(function(o) {
      _defineProperty$x(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : ownKeys$w(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
function _defineProperty$x(t, e, n) {
  return e = _toPropertyKey$y(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function _toPropertyKey$y(t) {
  var e = _toPrimitive$y(t, "string");
  return _typeof$A(e) == "symbol" ? e : String(e);
}
function _toPrimitive$y(t, e) {
  if (_typeof$A(t) != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(t, e || "default");
    if (_typeof$A(o) != "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function _slicedToArray$b(t, e) {
  return _arrayWithHoles$c(t) || _iterableToArrayLimit$b(t, e) || _unsupportedIterableToArray$k(t, e) || _nonIterableRest$c();
}
function _nonIterableRest$c() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function _unsupportedIterableToArray$k(t, e) {
  if (t) {
    if (typeof t == "string") return _arrayLikeToArray$k(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$k(t, e);
  }
}
function _arrayLikeToArray$k(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, o = new Array(e); n < e; n++) o[n] = t[n];
  return o;
}
function _iterableToArrayLimit$b(t, e) {
  var n = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
  if (n != null) {
    var o, l, u, f, h = [], p = !0, v = !1;
    try {
      if (u = (n = n.call(t)).next, e !== 0) for (; !(p = (o = u.call(n)).done) && (h.push(o.value), h.length !== e); p = !0) ;
    } catch (g) {
      v = !0, l = g;
    } finally {
      try {
        if (!p && n.return != null && (f = n.return(), Object(f) !== f)) return;
      } finally {
        if (v) throw l;
      }
    }
    return h;
  }
}
function _arrayWithHoles$c(t) {
  if (Array.isArray(t)) return t;
}
var ResponsiveContainer = /* @__PURE__ */ forwardRef(function(t, e) {
  var n = t.aspect, o = t.initialDimension, l = o === void 0 ? {
    width: -1,
    height: -1
  } : o, u = t.width, f = u === void 0 ? "100%" : u, h = t.height, p = h === void 0 ? "100%" : h, v = t.minWidth, g = v === void 0 ? 0 : v, w = t.minHeight, E = t.maxHeight, T = t.children, R = t.debounce, _ = R === void 0 ? 0 : R, b = t.id, M = t.className, A = t.onResize, $ = t.style, S = $ === void 0 ? {} : $, C = useRef(null), D = useRef();
  D.current = A, useImperativeHandle(e, function() {
    return Object.defineProperty(C.current, "current", {
      get: function() {
        return console.warn("The usage of ref.current.current is deprecated and will no longer be supported."), C.current;
      },
      configurable: !0
    });
  });
  var O = useState({
    containerWidth: l.width,
    containerHeight: l.height
  }), N = _slicedToArray$b(O, 2), j = N[0], L = N[1], z = useCallback(function(B, F) {
    L(function(H) {
      var W = Math.round(B), V = Math.round(F);
      return H.containerWidth === W && H.containerHeight === V ? H : {
        containerWidth: W,
        containerHeight: V
      };
    });
  }, []);
  useEffect(function() {
    var B = function(Z) {
      var Q, q = Z[0].contentRect, J = q.width, ie = q.height;
      z(J, ie), (Q = D.current) === null || Q === void 0 || Q.call(D, J, ie);
    };
    _ > 0 && (B = throttle$1(B, _, {
      trailing: !0,
      leading: !1
    }));
    var F = new ResizeObserver(B), H = C.current.getBoundingClientRect(), W = H.width, V = H.height;
    return z(W, V), F.observe(C.current), function() {
      F.disconnect();
    };
  }, [z, _]);
  var G = useMemo(function() {
    var B = j.containerWidth, F = j.containerHeight;
    if (B < 0 || F < 0)
      return null;
    warn$2(isPercent(f) || isPercent(p), `The width(%s) and height(%s) are both fixed numbers,
       maybe you don't need to use a ResponsiveContainer.`, f, p), warn$2(!n || n > 0, "The aspect(%s) must be greater than zero.", n);
    var H = isPercent(f) ? B : f, W = isPercent(p) ? F : p;
    n && n > 0 && (H ? W = H / n : W && (H = W * n), E && W > E && (W = E)), warn$2(H > 0 || W > 0, `The width(%s) and height(%s) of chart should be greater than 0,
       please check the style of container, or the props width(%s) and height(%s),
       or add a minWidth(%s) or minHeight(%s) or use aspect(%s) to control the
       height and width.`, H, W, f, p, g, w, n);
    var V = !Array.isArray(T) && reactIsExports.isElement(T) && getDisplayName(T.type).endsWith("Chart");
    return React__default.Children.map(T, function(X) {
      return reactIsExports.isElement(X) ? /* @__PURE__ */ cloneElement(X, _objectSpread$v({
        width: H,
        height: W
      }, V ? {
        style: _objectSpread$v({
          height: "100%",
          width: "100%",
          maxHeight: W,
          maxWidth: H
        }, X.props.style)
      } : {})) : X;
    });
  }, [n, T, p, E, w, g, j, f]);
  return /* @__PURE__ */ React__default.createElement("div", {
    id: b ? "".concat(b) : void 0,
    className: clsx$1("recharts-responsive-container", M),
    style: _objectSpread$v(_objectSpread$v({}, S), {}, {
      width: f,
      height: p,
      minWidth: g,
      minHeight: w,
      maxHeight: E
    }),
    ref: C
  }, G);
}), Cell = function t(e) {
  return null;
};
Cell.displayName = "Cell";
function _typeof$z(t) {
  "@babel/helpers - typeof";
  return _typeof$z = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof$z(t);
}
function ownKeys$v(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(l) {
      return Object.getOwnPropertyDescriptor(t, l).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function _objectSpread$u(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ownKeys$v(Object(n), !0).forEach(function(o) {
      _defineProperty$w(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : ownKeys$v(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
function _defineProperty$w(t, e, n) {
  return e = _toPropertyKey$x(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function _toPropertyKey$x(t) {
  var e = _toPrimitive$x(t, "string");
  return _typeof$z(e) == "symbol" ? e : String(e);
}
function _toPrimitive$x(t, e) {
  if (_typeof$z(t) != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(t, e || "default");
    if (_typeof$z(o) != "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
var stringCache = {
  widthCache: {},
  cacheCount: 0
}, MAX_CACHE_NUM = 2e3, SPAN_STYLE = {
  position: "absolute",
  top: "-20000px",
  left: 0,
  padding: 0,
  margin: 0,
  border: "none",
  whiteSpace: "pre"
}, MEASUREMENT_SPAN_ID = "recharts_measurement_span";
function removeInvalidKeys(t) {
  var e = _objectSpread$u({}, t);
  return Object.keys(e).forEach(function(n) {
    e[n] || delete e[n];
  }), e;
}
var getStringSize = function t(e) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (e == null || Global.isSsr)
    return {
      width: 0,
      height: 0
    };
  var o = removeInvalidKeys(n), l = JSON.stringify({
    text: e,
    copyStyle: o
  });
  if (stringCache.widthCache[l])
    return stringCache.widthCache[l];
  try {
    var u = document.getElementById(MEASUREMENT_SPAN_ID);
    u || (u = document.createElement("span"), u.setAttribute("id", MEASUREMENT_SPAN_ID), u.setAttribute("aria-hidden", "true"), document.body.appendChild(u));
    var f = _objectSpread$u(_objectSpread$u({}, SPAN_STYLE), o);
    Object.assign(u.style, f), u.textContent = "".concat(e);
    var h = u.getBoundingClientRect(), p = {
      width: h.width,
      height: h.height
    };
    return stringCache.widthCache[l] = p, ++stringCache.cacheCount > MAX_CACHE_NUM && (stringCache.cacheCount = 0, stringCache.widthCache = {}), p;
  } catch {
    return {
      width: 0,
      height: 0
    };
  }
}, getOffset = function t(e) {
  return {
    top: e.top + window.scrollY - document.documentElement.clientTop,
    left: e.left + window.scrollX - document.documentElement.clientLeft
  };
};
function _typeof$y(t) {
  "@babel/helpers - typeof";
  return _typeof$y = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof$y(t);
}
function _slicedToArray$a(t, e) {
  return _arrayWithHoles$b(t) || _iterableToArrayLimit$a(t, e) || _unsupportedIterableToArray$j(t, e) || _nonIterableRest$b();
}
function _nonIterableRest$b() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function _unsupportedIterableToArray$j(t, e) {
  if (t) {
    if (typeof t == "string") return _arrayLikeToArray$j(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$j(t, e);
  }
}
function _arrayLikeToArray$j(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, o = new Array(e); n < e; n++) o[n] = t[n];
  return o;
}
function _iterableToArrayLimit$a(t, e) {
  var n = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
  if (n != null) {
    var o, l, u, f, h = [], p = !0, v = !1;
    try {
      if (u = (n = n.call(t)).next, e === 0) {
        if (Object(n) !== n) return;
        p = !1;
      } else for (; !(p = (o = u.call(n)).done) && (h.push(o.value), h.length !== e); p = !0) ;
    } catch (g) {
      v = !0, l = g;
    } finally {
      try {
        if (!p && n.return != null && (f = n.return(), Object(f) !== f)) return;
      } finally {
        if (v) throw l;
      }
    }
    return h;
  }
}
function _arrayWithHoles$b(t) {
  if (Array.isArray(t)) return t;
}
function _classCallCheck$b(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$b(t, e) {
  for (var n = 0; n < e.length; n++) {
    var o = e[n];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, _toPropertyKey$w(o.key), o);
  }
}
function _createClass$b(t, e, n) {
  return e && _defineProperties$b(t.prototype, e), n && _defineProperties$b(t, n), Object.defineProperty(t, "prototype", { writable: !1 }), t;
}
function _toPropertyKey$w(t) {
  var e = _toPrimitive$w(t, "string");
  return _typeof$y(e) == "symbol" ? e : String(e);
}
function _toPrimitive$w(t, e) {
  if (_typeof$y(t) != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(t, e);
    if (_typeof$y(o) != "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t);
}
var MULTIPLY_OR_DIVIDE_REGEX = /(-?\d+(?:\.\d+)?[a-zA-Z%]*)([*/])(-?\d+(?:\.\d+)?[a-zA-Z%]*)/, ADD_OR_SUBTRACT_REGEX = /(-?\d+(?:\.\d+)?[a-zA-Z%]*)([+-])(-?\d+(?:\.\d+)?[a-zA-Z%]*)/, CSS_LENGTH_UNIT_REGEX = /^px|cm|vh|vw|em|rem|%|mm|in|pt|pc|ex|ch|vmin|vmax|Q$/, NUM_SPLIT_REGEX = /(-?\d+(?:\.\d+)?)([a-zA-Z%]+)?/, CONVERSION_RATES = {
  cm: 96 / 2.54,
  mm: 96 / 25.4,
  pt: 96 / 72,
  pc: 96 / 6,
  in: 96,
  Q: 96 / (2.54 * 40),
  px: 1
}, FIXED_CSS_LENGTH_UNITS = Object.keys(CONVERSION_RATES), STR_NAN = "NaN";
function convertToPx(t, e) {
  return t * CONVERSION_RATES[e];
}
var DecimalCSS = /* @__PURE__ */ function() {
  function t(e, n) {
    _classCallCheck$b(this, t), this.num = e, this.unit = n, this.num = e, this.unit = n, Number.isNaN(e) && (this.unit = ""), n !== "" && !CSS_LENGTH_UNIT_REGEX.test(n) && (this.num = NaN, this.unit = ""), FIXED_CSS_LENGTH_UNITS.includes(n) && (this.num = convertToPx(e, n), this.unit = "px");
  }
  return _createClass$b(t, [{
    key: "add",
    value: function(n) {
      return this.unit !== n.unit ? new t(NaN, "") : new t(this.num + n.num, this.unit);
    }
  }, {
    key: "subtract",
    value: function(n) {
      return this.unit !== n.unit ? new t(NaN, "") : new t(this.num - n.num, this.unit);
    }
  }, {
    key: "multiply",
    value: function(n) {
      return this.unit !== "" && n.unit !== "" && this.unit !== n.unit ? new t(NaN, "") : new t(this.num * n.num, this.unit || n.unit);
    }
  }, {
    key: "divide",
    value: function(n) {
      return this.unit !== "" && n.unit !== "" && this.unit !== n.unit ? new t(NaN, "") : new t(this.num / n.num, this.unit || n.unit);
    }
  }, {
    key: "toString",
    value: function() {
      return "".concat(this.num).concat(this.unit);
    }
  }, {
    key: "isNaN",
    value: function() {
      return Number.isNaN(this.num);
    }
  }], [{
    key: "parse",
    value: function(n) {
      var o, l = (o = NUM_SPLIT_REGEX.exec(n)) !== null && o !== void 0 ? o : [], u = _slicedToArray$a(l, 3), f = u[1], h = u[2];
      return new t(parseFloat(f), h ?? "");
    }
  }]), t;
}();
function calculateArithmetic(t) {
  if (t.includes(STR_NAN))
    return STR_NAN;
  for (var e = t; e.includes("*") || e.includes("/"); ) {
    var n, o = (n = MULTIPLY_OR_DIVIDE_REGEX.exec(e)) !== null && n !== void 0 ? n : [], l = _slicedToArray$a(o, 4), u = l[1], f = l[2], h = l[3], p = DecimalCSS.parse(u ?? ""), v = DecimalCSS.parse(h ?? ""), g = f === "*" ? p.multiply(v) : p.divide(v);
    if (g.isNaN())
      return STR_NAN;
    e = e.replace(MULTIPLY_OR_DIVIDE_REGEX, g.toString());
  }
  for (; e.includes("+") || /.-\d+(?:\.\d+)?/.test(e); ) {
    var w, E = (w = ADD_OR_SUBTRACT_REGEX.exec(e)) !== null && w !== void 0 ? w : [], T = _slicedToArray$a(E, 4), R = T[1], _ = T[2], b = T[3], M = DecimalCSS.parse(R ?? ""), A = DecimalCSS.parse(b ?? ""), $ = _ === "+" ? M.add(A) : M.subtract(A);
    if ($.isNaN())
      return STR_NAN;
    e = e.replace(ADD_OR_SUBTRACT_REGEX, $.toString());
  }
  return e;
}
var PARENTHESES_REGEX = /\(([^()]*)\)/;
function calculateParentheses(t) {
  for (var e = t; e.includes("("); ) {
    var n = PARENTHESES_REGEX.exec(e), o = _slicedToArray$a(n, 2), l = o[1];
    e = e.replace(PARENTHESES_REGEX, calculateArithmetic(l));
  }
  return e;
}
function evaluateExpression(t) {
  var e = t.replace(/\s+/g, "");
  return e = calculateParentheses(e), e = calculateArithmetic(e), e;
}
function safeEvaluateExpression(t) {
  try {
    return evaluateExpression(t);
  } catch {
    return STR_NAN;
  }
}
function reduceCSSCalc(t) {
  var e = safeEvaluateExpression(t.slice(5, -1));
  return e === STR_NAN ? "" : e;
}
var _excluded$d = ["x", "y", "lineHeight", "capHeight", "scaleToFit", "textAnchor", "verticalAnchor", "fill"], _excluded2$5 = ["dx", "dy", "angle", "className", "breakAll"];
function _extends$q() {
  return _extends$q = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }
    return t;
  }, _extends$q.apply(this, arguments);
}
function _objectWithoutProperties$d(t, e) {
  if (t == null) return {};
  var n = _objectWithoutPropertiesLoose$e(t, e), o, l;
  if (Object.getOwnPropertySymbols) {
    var u = Object.getOwnPropertySymbols(t);
    for (l = 0; l < u.length; l++)
      o = u[l], !(e.indexOf(o) >= 0) && Object.prototype.propertyIsEnumerable.call(t, o) && (n[o] = t[o]);
  }
  return n;
}
function _objectWithoutPropertiesLoose$e(t, e) {
  if (t == null) return {};
  var n = {}, o = Object.keys(t), l, u;
  for (u = 0; u < o.length; u++)
    l = o[u], !(e.indexOf(l) >= 0) && (n[l] = t[l]);
  return n;
}
function _slicedToArray$9(t, e) {
  return _arrayWithHoles$a(t) || _iterableToArrayLimit$9(t, e) || _unsupportedIterableToArray$i(t, e) || _nonIterableRest$a();
}
function _nonIterableRest$a() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function _unsupportedIterableToArray$i(t, e) {
  if (t) {
    if (typeof t == "string") return _arrayLikeToArray$i(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$i(t, e);
  }
}
function _arrayLikeToArray$i(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, o = new Array(e); n < e; n++) o[n] = t[n];
  return o;
}
function _iterableToArrayLimit$9(t, e) {
  var n = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
  if (n != null) {
    var o, l, u, f, h = [], p = !0, v = !1;
    try {
      if (u = (n = n.call(t)).next, e === 0) {
        if (Object(n) !== n) return;
        p = !1;
      } else for (; !(p = (o = u.call(n)).done) && (h.push(o.value), h.length !== e); p = !0) ;
    } catch (g) {
      v = !0, l = g;
    } finally {
      try {
        if (!p && n.return != null && (f = n.return(), Object(f) !== f)) return;
      } finally {
        if (v) throw l;
      }
    }
    return h;
  }
}
function _arrayWithHoles$a(t) {
  if (Array.isArray(t)) return t;
}
var BREAKING_SPACES = /[ \f\n\r\t\v\u2028\u2029]+/, calculateWordWidths = function t(e) {
  var n = e.children, o = e.breakAll, l = e.style;
  try {
    var u = [];
    isNil$1(n) || (o ? u = n.toString().split("") : u = n.toString().split(BREAKING_SPACES));
    var f = u.map(function(p) {
      return {
        word: p,
        width: getStringSize(p, l).width
      };
    }), h = o ? 0 : getStringSize(" ", l).width;
    return {
      wordsWithComputedWidth: f,
      spaceWidth: h
    };
  } catch {
    return null;
  }
}, calculateWordsByLines = function t(e, n, o, l, u) {
  var f = e.maxLines, h = e.children, p = e.style, v = e.breakAll, g = isNumber(f), w = h, E = function() {
    var H = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return H.reduce(function(W, V) {
      var X = V.word, Z = V.width, Q = W[W.length - 1];
      if (Q && (l == null || u || Q.width + Z + o < Number(l)))
        Q.words.push(X), Q.width += Z + o;
      else {
        var q = {
          words: [X],
          width: Z
        };
        W.push(q);
      }
      return W;
    }, []);
  }, T = E(n), R = function(H) {
    return H.reduce(function(W, V) {
      return W.width > V.width ? W : V;
    });
  };
  if (!g)
    return T;
  for (var _ = "…", b = function(H) {
    var W = w.slice(0, H), V = calculateWordWidths({
      breakAll: v,
      style: p,
      children: W + _
    }).wordsWithComputedWidth, X = E(V), Z = X.length > f || R(X).width > Number(l);
    return [Z, X];
  }, M = 0, A = w.length - 1, $ = 0, S; M <= A && $ <= w.length - 1; ) {
    var C = Math.floor((M + A) / 2), D = C - 1, O = b(D), N = _slicedToArray$9(O, 2), j = N[0], L = N[1], z = b(C), G = _slicedToArray$9(z, 1), B = G[0];
    if (!j && !B && (M = C + 1), j && B && (A = C - 1), !j && B) {
      S = L;
      break;
    }
    $++;
  }
  return S || T;
}, getWordsWithoutCalculate = function t(e) {
  var n = isNil$1(e) ? [] : e.toString().split(BREAKING_SPACES);
  return [{
    words: n
  }];
}, getWordsByLines = function t(e) {
  var n = e.width, o = e.scaleToFit, l = e.children, u = e.style, f = e.breakAll, h = e.maxLines;
  if ((n || o) && !Global.isSsr) {
    var p, v, g = calculateWordWidths({
      breakAll: f,
      children: l,
      style: u
    });
    if (g) {
      var w = g.wordsWithComputedWidth, E = g.spaceWidth;
      p = w, v = E;
    } else
      return getWordsWithoutCalculate(l);
    return calculateWordsByLines({
      breakAll: f,
      children: l,
      maxLines: h,
      style: u
    }, p, v, n, o);
  }
  return getWordsWithoutCalculate(l);
}, DEFAULT_FILL = "#808080", Text = function t(e) {
  var n = e.x, o = n === void 0 ? 0 : n, l = e.y, u = l === void 0 ? 0 : l, f = e.lineHeight, h = f === void 0 ? "1em" : f, p = e.capHeight, v = p === void 0 ? "0.71em" : p, g = e.scaleToFit, w = g === void 0 ? !1 : g, E = e.textAnchor, T = E === void 0 ? "start" : E, R = e.verticalAnchor, _ = R === void 0 ? "end" : R, b = e.fill, M = b === void 0 ? DEFAULT_FILL : b, A = _objectWithoutProperties$d(e, _excluded$d), $ = useMemo(function() {
    return getWordsByLines({
      breakAll: A.breakAll,
      children: A.children,
      maxLines: A.maxLines,
      scaleToFit: w,
      style: A.style,
      width: A.width
    });
  }, [A.breakAll, A.children, A.maxLines, w, A.style, A.width]), S = A.dx, C = A.dy, D = A.angle, O = A.className, N = A.breakAll, j = _objectWithoutProperties$d(A, _excluded2$5);
  if (!isNumOrStr(o) || !isNumOrStr(u))
    return null;
  var L = o + (isNumber(S) ? S : 0), z = u + (isNumber(C) ? C : 0), G;
  switch (_) {
    case "start":
      G = reduceCSSCalc("calc(".concat(v, ")"));
      break;
    case "middle":
      G = reduceCSSCalc("calc(".concat(($.length - 1) / 2, " * -").concat(h, " + (").concat(v, " / 2))"));
      break;
    default:
      G = reduceCSSCalc("calc(".concat($.length - 1, " * -").concat(h, ")"));
      break;
  }
  var B = [];
  if (w) {
    var F = $[0].width, H = A.width;
    B.push("scale(".concat((isNumber(H) ? H / F : 1) / F, ")"));
  }
  return D && B.push("rotate(".concat(D, ", ").concat(L, ", ").concat(z, ")")), B.length && (j.transform = B.join(" ")), /* @__PURE__ */ React__default.createElement("text", _extends$q({}, filterProps(j, !0), {
    x: L,
    y: z,
    className: clsx$1("recharts-text", O),
    textAnchor: T,
    fill: M.includes("url") ? DEFAULT_FILL : M
  }), $.map(function(W, V) {
    var X = W.words.join(N ? "" : " ");
    return /* @__PURE__ */ React__default.createElement("tspan", {
      x: L,
      dy: V === 0 ? G : h,
      key: X
    }, X);
  }));
};
function ascending(t, e) {
  return t == null || e == null ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function descending(t, e) {
  return t == null || e == null ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function bisector(t) {
  let e, n, o;
  t.length !== 2 ? (e = ascending, n = (h, p) => ascending(t(h), p), o = (h, p) => t(h) - p) : (e = t === ascending || t === descending ? t : zero, n = t, o = t);
  function l(h, p, v = 0, g = h.length) {
    if (v < g) {
      if (e(p, p) !== 0) return g;
      do {
        const w = v + g >>> 1;
        n(h[w], p) < 0 ? v = w + 1 : g = w;
      } while (v < g);
    }
    return v;
  }
  function u(h, p, v = 0, g = h.length) {
    if (v < g) {
      if (e(p, p) !== 0) return g;
      do {
        const w = v + g >>> 1;
        n(h[w], p) <= 0 ? v = w + 1 : g = w;
      } while (v < g);
    }
    return v;
  }
  function f(h, p, v = 0, g = h.length) {
    const w = l(h, p, v, g - 1);
    return w > v && o(h[w - 1], p) > -o(h[w], p) ? w - 1 : w;
  }
  return { left: l, center: f, right: u };
}
function zero() {
  return 0;
}
function number$2(t) {
  return t === null ? NaN : +t;
}
function* numbers(t, e) {
  for (let n of t)
    n != null && (n = +n) >= n && (yield n);
}
const ascendingBisect = bisector(ascending), bisectRight = ascendingBisect.right;
bisector(number$2).center;
class InternMap extends Map {
  constructor(e, n = keyof) {
    if (super(), Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: n } }), e != null) for (const [o, l] of e) this.set(o, l);
  }
  get(e) {
    return super.get(intern_get(this, e));
  }
  has(e) {
    return super.has(intern_get(this, e));
  }
  set(e, n) {
    return super.set(intern_set(this, e), n);
  }
  delete(e) {
    return super.delete(intern_delete(this, e));
  }
}
function intern_get({ _intern: t, _key: e }, n) {
  const o = e(n);
  return t.has(o) ? t.get(o) : n;
}
function intern_set({ _intern: t, _key: e }, n) {
  const o = e(n);
  return t.has(o) ? t.get(o) : (t.set(o, n), n);
}
function intern_delete({ _intern: t, _key: e }, n) {
  const o = e(n);
  return t.has(o) && (n = t.get(o), t.delete(o)), n;
}
function keyof(t) {
  return t !== null && typeof t == "object" ? t.valueOf() : t;
}
function compareDefined(t = ascending) {
  if (t === ascending) return ascendingDefined;
  if (typeof t != "function") throw new TypeError("compare is not a function");
  return (e, n) => {
    const o = t(e, n);
    return o || o === 0 ? o : (t(n, n) === 0) - (t(e, e) === 0);
  };
}
function ascendingDefined(t, e) {
  return (t == null || !(t >= t)) - (e == null || !(e >= e)) || (t < e ? -1 : t > e ? 1 : 0);
}
const e10 = Math.sqrt(50), e5 = Math.sqrt(10), e2 = Math.sqrt(2);
function tickSpec(t, e, n) {
  const o = (e - t) / Math.max(0, n), l = Math.floor(Math.log10(o)), u = o / Math.pow(10, l), f = u >= e10 ? 10 : u >= e5 ? 5 : u >= e2 ? 2 : 1;
  let h, p, v;
  return l < 0 ? (v = Math.pow(10, -l) / f, h = Math.round(t * v), p = Math.round(e * v), h / v < t && ++h, p / v > e && --p, v = -v) : (v = Math.pow(10, l) * f, h = Math.round(t / v), p = Math.round(e / v), h * v < t && ++h, p * v > e && --p), p < h && 0.5 <= n && n < 2 ? tickSpec(t, e, n * 2) : [h, p, v];
}
function ticks(t, e, n) {
  if (e = +e, t = +t, n = +n, !(n > 0)) return [];
  if (t === e) return [t];
  const o = e < t, [l, u, f] = o ? tickSpec(e, t, n) : tickSpec(t, e, n);
  if (!(u >= l)) return [];
  const h = u - l + 1, p = new Array(h);
  if (o)
    if (f < 0) for (let v = 0; v < h; ++v) p[v] = (u - v) / -f;
    else for (let v = 0; v < h; ++v) p[v] = (u - v) * f;
  else if (f < 0) for (let v = 0; v < h; ++v) p[v] = (l + v) / -f;
  else for (let v = 0; v < h; ++v) p[v] = (l + v) * f;
  return p;
}
function tickIncrement(t, e, n) {
  return e = +e, t = +t, n = +n, tickSpec(t, e, n)[2];
}
function tickStep(t, e, n) {
  e = +e, t = +t, n = +n;
  const o = e < t, l = o ? tickIncrement(e, t, n) : tickIncrement(t, e, n);
  return (o ? -1 : 1) * (l < 0 ? 1 / -l : l);
}
function max$3(t, e) {
  let n;
  for (const o of t)
    o != null && (n < o || n === void 0 && o >= o) && (n = o);
  return n;
}
function min$3(t, e) {
  let n;
  for (const o of t)
    o != null && (n > o || n === void 0 && o >= o) && (n = o);
  return n;
}
function quickselect(t, e, n = 0, o = 1 / 0, l) {
  if (e = Math.floor(e), n = Math.floor(Math.max(0, n)), o = Math.floor(Math.min(t.length - 1, o)), !(n <= e && e <= o)) return t;
  for (l = l === void 0 ? ascendingDefined : compareDefined(l); o > n; ) {
    if (o - n > 600) {
      const p = o - n + 1, v = e - n + 1, g = Math.log(p), w = 0.5 * Math.exp(2 * g / 3), E = 0.5 * Math.sqrt(g * w * (p - w) / p) * (v - p / 2 < 0 ? -1 : 1), T = Math.max(n, Math.floor(e - v * w / p + E)), R = Math.min(o, Math.floor(e + (p - v) * w / p + E));
      quickselect(t, e, T, R, l);
    }
    const u = t[e];
    let f = n, h = o;
    for (swap(t, n, e), l(t[o], u) > 0 && swap(t, n, o); f < h; ) {
      for (swap(t, f, h), ++f, --h; l(t[f], u) < 0; ) ++f;
      for (; l(t[h], u) > 0; ) --h;
    }
    l(t[n], u) === 0 ? swap(t, n, h) : (++h, swap(t, h, o)), h <= e && (n = h + 1), e <= h && (o = h - 1);
  }
  return t;
}
function swap(t, e, n) {
  const o = t[e];
  t[e] = t[n], t[n] = o;
}
function quantile$1(t, e, n) {
  if (t = Float64Array.from(numbers(t)), !(!(o = t.length) || isNaN(e = +e))) {
    if (e <= 0 || o < 2) return min$3(t);
    if (e >= 1) return max$3(t);
    var o, l = (o - 1) * e, u = Math.floor(l), f = max$3(quickselect(t, u).subarray(0, u + 1)), h = min$3(t.subarray(u + 1));
    return f + (h - f) * (l - u);
  }
}
function quantileSorted(t, e, n = number$2) {
  if (!(!(o = t.length) || isNaN(e = +e))) {
    if (e <= 0 || o < 2) return +n(t[0], 0, t);
    if (e >= 1) return +n(t[o - 1], o - 1, t);
    var o, l = (o - 1) * e, u = Math.floor(l), f = +n(t[u], u, t), h = +n(t[u + 1], u + 1, t);
    return f + (h - f) * (l - u);
  }
}
function range$3(t, e, n) {
  t = +t, e = +e, n = (l = arguments.length) < 2 ? (e = t, t = 0, 1) : l < 3 ? 1 : +n;
  for (var o = -1, l = Math.max(0, Math.ceil((e - t) / n)) | 0, u = new Array(l); ++o < l; )
    u[o] = t + o * n;
  return u;
}
function initRange(t, e) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(t);
      break;
    default:
      this.range(e).domain(t);
      break;
  }
  return this;
}
function initInterpolator(t, e) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      typeof t == "function" ? this.interpolator(t) : this.range(t);
      break;
    }
    default: {
      this.domain(t), typeof e == "function" ? this.interpolator(e) : this.range(e);
      break;
    }
  }
  return this;
}
const implicit = Symbol("implicit");
function ordinal() {
  var t = new InternMap(), e = [], n = [], o = implicit;
  function l(u) {
    let f = t.get(u);
    if (f === void 0) {
      if (o !== implicit) return o;
      t.set(u, f = e.push(u) - 1);
    }
    return n[f % n.length];
  }
  return l.domain = function(u) {
    if (!arguments.length) return e.slice();
    e = [], t = new InternMap();
    for (const f of u)
      t.has(f) || t.set(f, e.push(f) - 1);
    return l;
  }, l.range = function(u) {
    return arguments.length ? (n = Array.from(u), l) : n.slice();
  }, l.unknown = function(u) {
    return arguments.length ? (o = u, l) : o;
  }, l.copy = function() {
    return ordinal(e, n).unknown(o);
  }, initRange.apply(l, arguments), l;
}
function band() {
  var t = ordinal().unknown(void 0), e = t.domain, n = t.range, o = 0, l = 1, u, f, h = !1, p = 0, v = 0, g = 0.5;
  delete t.unknown;
  function w() {
    var E = e().length, T = l < o, R = T ? l : o, _ = T ? o : l;
    u = (_ - R) / Math.max(1, E - p + v * 2), h && (u = Math.floor(u)), R += (_ - R - u * (E - p)) * g, f = u * (1 - p), h && (R = Math.round(R), f = Math.round(f));
    var b = range$3(E).map(function(M) {
      return R + u * M;
    });
    return n(T ? b.reverse() : b);
  }
  return t.domain = function(E) {
    return arguments.length ? (e(E), w()) : e();
  }, t.range = function(E) {
    return arguments.length ? ([o, l] = E, o = +o, l = +l, w()) : [o, l];
  }, t.rangeRound = function(E) {
    return [o, l] = E, o = +o, l = +l, h = !0, w();
  }, t.bandwidth = function() {
    return f;
  }, t.step = function() {
    return u;
  }, t.round = function(E) {
    return arguments.length ? (h = !!E, w()) : h;
  }, t.padding = function(E) {
    return arguments.length ? (p = Math.min(1, v = +E), w()) : p;
  }, t.paddingInner = function(E) {
    return arguments.length ? (p = Math.min(1, E), w()) : p;
  }, t.paddingOuter = function(E) {
    return arguments.length ? (v = +E, w()) : v;
  }, t.align = function(E) {
    return arguments.length ? (g = Math.max(0, Math.min(1, E)), w()) : g;
  }, t.copy = function() {
    return band(e(), [o, l]).round(h).paddingInner(p).paddingOuter(v).align(g);
  }, initRange.apply(w(), arguments);
}
function pointish(t) {
  var e = t.copy;
  return t.padding = t.paddingOuter, delete t.paddingInner, delete t.paddingOuter, t.copy = function() {
    return pointish(e());
  }, t;
}
function point() {
  return pointish(band.apply(null, arguments).paddingInner(1));
}
function constants(t) {
  return function() {
    return t;
  };
}
function number$1(t) {
  return +t;
}
var unit = [0, 1];
function identity$6(t) {
  return t;
}
function normalize(t, e) {
  return (e -= t = +t) ? function(n) {
    return (n - t) / e;
  } : constants(isNaN(e) ? NaN : 0.5);
}
function clamper(t, e) {
  var n;
  return t > e && (n = t, t = e, e = n), function(o) {
    return Math.max(t, Math.min(e, o));
  };
}
function bimap(t, e, n) {
  var o = t[0], l = t[1], u = e[0], f = e[1];
  return l < o ? (o = normalize(l, o), u = n(f, u)) : (o = normalize(o, l), u = n(u, f)), function(h) {
    return u(o(h));
  };
}
function polymap(t, e, n) {
  var o = Math.min(t.length, e.length) - 1, l = new Array(o), u = new Array(o), f = -1;
  for (t[o] < t[0] && (t = t.slice().reverse(), e = e.slice().reverse()); ++f < o; )
    l[f] = normalize(t[f], t[f + 1]), u[f] = n(e[f], e[f + 1]);
  return function(h) {
    var p = bisectRight(t, h, 1, o) - 1;
    return u[p](l[p](h));
  };
}
function copy$1(t, e) {
  return e.domain(t.domain()).range(t.range()).interpolate(t.interpolate()).clamp(t.clamp()).unknown(t.unknown());
}
function transformer$2() {
  var t = unit, e = unit, n = interpolate$1, o, l, u, f = identity$6, h, p, v;
  function g() {
    var E = Math.min(t.length, e.length);
    return f !== identity$6 && (f = clamper(t[0], t[E - 1])), h = E > 2 ? polymap : bimap, p = v = null, w;
  }
  function w(E) {
    return E == null || isNaN(E = +E) ? u : (p || (p = h(t.map(o), e, n)))(o(f(E)));
  }
  return w.invert = function(E) {
    return f(l((v || (v = h(e, t.map(o), interpolateNumber$2)))(E)));
  }, w.domain = function(E) {
    return arguments.length ? (t = Array.from(E, number$1), g()) : t.slice();
  }, w.range = function(E) {
    return arguments.length ? (e = Array.from(E), g()) : e.slice();
  }, w.rangeRound = function(E) {
    return e = Array.from(E), n = interpolateRound, g();
  }, w.clamp = function(E) {
    return arguments.length ? (f = E ? !0 : identity$6, g()) : f !== identity$6;
  }, w.interpolate = function(E) {
    return arguments.length ? (n = E, g()) : n;
  }, w.unknown = function(E) {
    return arguments.length ? (u = E, w) : u;
  }, function(E, T) {
    return o = E, l = T, g();
  };
}
function continuous() {
  return transformer$2()(identity$6, identity$6);
}
function formatDecimal(t) {
  return Math.abs(t = Math.round(t)) >= 1e21 ? t.toLocaleString("en").replace(/,/g, "") : t.toString(10);
}
function formatDecimalParts(t, e) {
  if ((n = (t = e ? t.toExponential(e - 1) : t.toExponential()).indexOf("e")) < 0) return null;
  var n, o = t.slice(0, n);
  return [
    o.length > 1 ? o[0] + o.slice(2) : o,
    +t.slice(n + 1)
  ];
}
function exponent(t) {
  return t = formatDecimalParts(Math.abs(t)), t ? t[1] : NaN;
}
function formatGroup(t, e) {
  return function(n, o) {
    for (var l = n.length, u = [], f = 0, h = t[0], p = 0; l > 0 && h > 0 && (p + h + 1 > o && (h = Math.max(1, o - p)), u.push(n.substring(l -= h, l + h)), !((p += h + 1) > o)); )
      h = t[f = (f + 1) % t.length];
    return u.reverse().join(e);
  };
}
function formatNumerals(t) {
  return function(e) {
    return e.replace(/[0-9]/g, function(n) {
      return t[+n];
    });
  };
}
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(t) {
  if (!(e = re.exec(t))) throw new Error("invalid format: " + t);
  var e;
  return new FormatSpecifier({
    fill: e[1],
    align: e[2],
    sign: e[3],
    symbol: e[4],
    zero: e[5],
    width: e[6],
    comma: e[7],
    precision: e[8] && e[8].slice(1),
    trim: e[9],
    type: e[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(t) {
  this.fill = t.fill === void 0 ? " " : t.fill + "", this.align = t.align === void 0 ? ">" : t.align + "", this.sign = t.sign === void 0 ? "-" : t.sign + "", this.symbol = t.symbol === void 0 ? "" : t.symbol + "", this.zero = !!t.zero, this.width = t.width === void 0 ? void 0 : +t.width, this.comma = !!t.comma, this.precision = t.precision === void 0 ? void 0 : +t.precision, this.trim = !!t.trim, this.type = t.type === void 0 ? "" : t.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function formatTrim(t) {
  e: for (var e = t.length, n = 1, o = -1, l; n < e; ++n)
    switch (t[n]) {
      case ".":
        o = l = n;
        break;
      case "0":
        o === 0 && (o = n), l = n;
        break;
      default:
        if (!+t[n]) break e;
        o > 0 && (o = 0);
        break;
    }
  return o > 0 ? t.slice(0, o) + t.slice(l + 1) : t;
}
var prefixExponent;
function formatPrefixAuto(t, e) {
  var n = formatDecimalParts(t, e);
  if (!n) return t + "";
  var o = n[0], l = n[1], u = l - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(l / 3))) * 3) + 1, f = o.length;
  return u === f ? o : u > f ? o + new Array(u - f + 1).join("0") : u > 0 ? o.slice(0, u) + "." + o.slice(u) : "0." + new Array(1 - u).join("0") + formatDecimalParts(t, Math.max(0, e + u - 1))[0];
}
function formatRounded(t, e) {
  var n = formatDecimalParts(t, e);
  if (!n) return t + "";
  var o = n[0], l = n[1];
  return l < 0 ? "0." + new Array(-l).join("0") + o : o.length > l + 1 ? o.slice(0, l + 1) + "." + o.slice(l + 1) : o + new Array(l - o.length + 2).join("0");
}
const formatTypes = {
  "%": (t, e) => (t * 100).toFixed(e),
  b: (t) => Math.round(t).toString(2),
  c: (t) => t + "",
  d: formatDecimal,
  e: (t, e) => t.toExponential(e),
  f: (t, e) => t.toFixed(e),
  g: (t, e) => t.toPrecision(e),
  o: (t) => Math.round(t).toString(8),
  p: (t, e) => formatRounded(t * 100, e),
  r: formatRounded,
  s: formatPrefixAuto,
  X: (t) => Math.round(t).toString(16).toUpperCase(),
  x: (t) => Math.round(t).toString(16)
};
function identity$5(t) {
  return t;
}
var map$3 = Array.prototype.map, prefixes = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function formatLocale$1(t) {
  var e = t.grouping === void 0 || t.thousands === void 0 ? identity$5 : formatGroup(map$3.call(t.grouping, Number), t.thousands + ""), n = t.currency === void 0 ? "" : t.currency[0] + "", o = t.currency === void 0 ? "" : t.currency[1] + "", l = t.decimal === void 0 ? "." : t.decimal + "", u = t.numerals === void 0 ? identity$5 : formatNumerals(map$3.call(t.numerals, String)), f = t.percent === void 0 ? "%" : t.percent + "", h = t.minus === void 0 ? "−" : t.minus + "", p = t.nan === void 0 ? "NaN" : t.nan + "";
  function v(w) {
    w = formatSpecifier(w);
    var E = w.fill, T = w.align, R = w.sign, _ = w.symbol, b = w.zero, M = w.width, A = w.comma, $ = w.precision, S = w.trim, C = w.type;
    C === "n" ? (A = !0, C = "g") : formatTypes[C] || ($ === void 0 && ($ = 12), S = !0, C = "g"), (b || E === "0" && T === "=") && (b = !0, E = "0", T = "=");
    var D = _ === "$" ? n : _ === "#" && /[boxX]/.test(C) ? "0" + C.toLowerCase() : "", O = _ === "$" ? o : /[%p]/.test(C) ? f : "", N = formatTypes[C], j = /[defgprs%]/.test(C);
    $ = $ === void 0 ? 6 : /[gprs]/.test(C) ? Math.max(1, Math.min(21, $)) : Math.max(0, Math.min(20, $));
    function L(z) {
      var G = D, B = O, F, H, W;
      if (C === "c")
        B = N(z) + B, z = "";
      else {
        z = +z;
        var V = z < 0 || 1 / z < 0;
        if (z = isNaN(z) ? p : N(Math.abs(z), $), S && (z = formatTrim(z)), V && +z == 0 && R !== "+" && (V = !1), G = (V ? R === "(" ? R : h : R === "-" || R === "(" ? "" : R) + G, B = (C === "s" ? prefixes[8 + prefixExponent / 3] : "") + B + (V && R === "(" ? ")" : ""), j) {
          for (F = -1, H = z.length; ++F < H; )
            if (W = z.charCodeAt(F), 48 > W || W > 57) {
              B = (W === 46 ? l + z.slice(F + 1) : z.slice(F)) + B, z = z.slice(0, F);
              break;
            }
        }
      }
      A && !b && (z = e(z, 1 / 0));
      var X = G.length + z.length + B.length, Z = X < M ? new Array(M - X + 1).join(E) : "";
      switch (A && b && (z = e(Z + z, Z.length ? M - B.length : 1 / 0), Z = ""), T) {
        case "<":
          z = G + z + B + Z;
          break;
        case "=":
          z = G + Z + z + B;
          break;
        case "^":
          z = Z.slice(0, X = Z.length >> 1) + G + z + B + Z.slice(X);
          break;
        default:
          z = Z + G + z + B;
          break;
      }
      return u(z);
    }
    return L.toString = function() {
      return w + "";
    }, L;
  }
  function g(w, E) {
    var T = v((w = formatSpecifier(w), w.type = "f", w)), R = Math.max(-8, Math.min(8, Math.floor(exponent(E) / 3))) * 3, _ = Math.pow(10, -R), b = prefixes[8 + R / 3];
    return function(M) {
      return T(_ * M) + b;
    };
  }
  return {
    format: v,
    formatPrefix: g
  };
}
var locale$1, format, formatPrefix;
defaultLocale$1({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale$1(t) {
  return locale$1 = formatLocale$1(t), format = locale$1.format, formatPrefix = locale$1.formatPrefix, locale$1;
}
function precisionFixed(t) {
  return Math.max(0, -exponent(Math.abs(t)));
}
function precisionPrefix(t, e) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(e) / 3))) * 3 - exponent(Math.abs(t)));
}
function precisionRound(t, e) {
  return t = Math.abs(t), e = Math.abs(e) - t, Math.max(0, exponent(e) - exponent(t)) + 1;
}
function tickFormat(t, e, n, o) {
  var l = tickStep(t, e, n), u;
  switch (o = formatSpecifier(o ?? ",f"), o.type) {
    case "s": {
      var f = Math.max(Math.abs(t), Math.abs(e));
      return o.precision == null && !isNaN(u = precisionPrefix(l, f)) && (o.precision = u), formatPrefix(o, f);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      o.precision == null && !isNaN(u = precisionRound(l, Math.max(Math.abs(t), Math.abs(e)))) && (o.precision = u - (o.type === "e"));
      break;
    }
    case "f":
    case "%": {
      o.precision == null && !isNaN(u = precisionFixed(l)) && (o.precision = u - (o.type === "%") * 2);
      break;
    }
  }
  return format(o);
}
function linearish(t) {
  var e = t.domain;
  return t.ticks = function(n) {
    var o = e();
    return ticks(o[0], o[o.length - 1], n ?? 10);
  }, t.tickFormat = function(n, o) {
    var l = e();
    return tickFormat(l[0], l[l.length - 1], n ?? 10, o);
  }, t.nice = function(n) {
    n == null && (n = 10);
    var o = e(), l = 0, u = o.length - 1, f = o[l], h = o[u], p, v, g = 10;
    for (h < f && (v = f, f = h, h = v, v = l, l = u, u = v); g-- > 0; ) {
      if (v = tickIncrement(f, h, n), v === p)
        return o[l] = f, o[u] = h, e(o);
      if (v > 0)
        f = Math.floor(f / v) * v, h = Math.ceil(h / v) * v;
      else if (v < 0)
        f = Math.ceil(f * v) / v, h = Math.floor(h * v) / v;
      else
        break;
      p = v;
    }
    return t;
  }, t;
}
function linear() {
  var t = continuous();
  return t.copy = function() {
    return copy$1(t, linear());
  }, initRange.apply(t, arguments), linearish(t);
}
function identity$4(t) {
  var e;
  function n(o) {
    return o == null || isNaN(o = +o) ? e : o;
  }
  return n.invert = n, n.domain = n.range = function(o) {
    return arguments.length ? (t = Array.from(o, number$1), n) : t.slice();
  }, n.unknown = function(o) {
    return arguments.length ? (e = o, n) : e;
  }, n.copy = function() {
    return identity$4(t).unknown(e);
  }, t = arguments.length ? Array.from(t, number$1) : [0, 1], linearish(n);
}
function nice(t, e) {
  t = t.slice();
  var n = 0, o = t.length - 1, l = t[n], u = t[o], f;
  return u < l && (f = n, n = o, o = f, f = l, l = u, u = f), t[n] = e.floor(l), t[o] = e.ceil(u), t;
}
function transformLog(t) {
  return Math.log(t);
}
function transformExp(t) {
  return Math.exp(t);
}
function transformLogn(t) {
  return -Math.log(-t);
}
function transformExpn(t) {
  return -Math.exp(-t);
}
function pow10(t) {
  return isFinite(t) ? +("1e" + t) : t < 0 ? 0 : t;
}
function powp(t) {
  return t === 10 ? pow10 : t === Math.E ? Math.exp : (e) => Math.pow(t, e);
}
function logp(t) {
  return t === Math.E ? Math.log : t === 10 && Math.log10 || t === 2 && Math.log2 || (t = Math.log(t), (e) => Math.log(e) / t);
}
function reflect(t) {
  return (e, n) => -t(-e, n);
}
function loggish(t) {
  const e = t(transformLog, transformExp), n = e.domain;
  let o = 10, l, u;
  function f() {
    return l = logp(o), u = powp(o), n()[0] < 0 ? (l = reflect(l), u = reflect(u), t(transformLogn, transformExpn)) : t(transformLog, transformExp), e;
  }
  return e.base = function(h) {
    return arguments.length ? (o = +h, f()) : o;
  }, e.domain = function(h) {
    return arguments.length ? (n(h), f()) : n();
  }, e.ticks = (h) => {
    const p = n();
    let v = p[0], g = p[p.length - 1];
    const w = g < v;
    w && ([v, g] = [g, v]);
    let E = l(v), T = l(g), R, _;
    const b = h == null ? 10 : +h;
    let M = [];
    if (!(o % 1) && T - E < b) {
      if (E = Math.floor(E), T = Math.ceil(T), v > 0) {
        for (; E <= T; ++E)
          for (R = 1; R < o; ++R)
            if (_ = E < 0 ? R / u(-E) : R * u(E), !(_ < v)) {
              if (_ > g) break;
              M.push(_);
            }
      } else for (; E <= T; ++E)
        for (R = o - 1; R >= 1; --R)
          if (_ = E > 0 ? R / u(-E) : R * u(E), !(_ < v)) {
            if (_ > g) break;
            M.push(_);
          }
      M.length * 2 < b && (M = ticks(v, g, b));
    } else
      M = ticks(E, T, Math.min(T - E, b)).map(u);
    return w ? M.reverse() : M;
  }, e.tickFormat = (h, p) => {
    if (h == null && (h = 10), p == null && (p = o === 10 ? "s" : ","), typeof p != "function" && (!(o % 1) && (p = formatSpecifier(p)).precision == null && (p.trim = !0), p = format(p)), h === 1 / 0) return p;
    const v = Math.max(1, o * h / e.ticks().length);
    return (g) => {
      let w = g / u(Math.round(l(g)));
      return w * o < o - 0.5 && (w *= o), w <= v ? p(g) : "";
    };
  }, e.nice = () => n(nice(n(), {
    floor: (h) => u(Math.floor(l(h))),
    ceil: (h) => u(Math.ceil(l(h)))
  })), e;
}
function log() {
  const t = loggish(transformer$2()).domain([1, 10]);
  return t.copy = () => copy$1(t, log()).base(t.base()), initRange.apply(t, arguments), t;
}
function transformSymlog(t) {
  return function(e) {
    return Math.sign(e) * Math.log1p(Math.abs(e / t));
  };
}
function transformSymexp(t) {
  return function(e) {
    return Math.sign(e) * Math.expm1(Math.abs(e)) * t;
  };
}
function symlogish(t) {
  var e = 1, n = t(transformSymlog(e), transformSymexp(e));
  return n.constant = function(o) {
    return arguments.length ? t(transformSymlog(e = +o), transformSymexp(e)) : e;
  }, linearish(n);
}
function symlog() {
  var t = symlogish(transformer$2());
  return t.copy = function() {
    return copy$1(t, symlog()).constant(t.constant());
  }, initRange.apply(t, arguments);
}
function transformPow(t) {
  return function(e) {
    return e < 0 ? -Math.pow(-e, t) : Math.pow(e, t);
  };
}
function transformSqrt(t) {
  return t < 0 ? -Math.sqrt(-t) : Math.sqrt(t);
}
function transformSquare(t) {
  return t < 0 ? -t * t : t * t;
}
function powish(t) {
  var e = t(identity$6, identity$6), n = 1;
  function o() {
    return n === 1 ? t(identity$6, identity$6) : n === 0.5 ? t(transformSqrt, transformSquare) : t(transformPow(n), transformPow(1 / n));
  }
  return e.exponent = function(l) {
    return arguments.length ? (n = +l, o()) : n;
  }, linearish(e);
}
function pow() {
  var t = powish(transformer$2());
  return t.copy = function() {
    return copy$1(t, pow()).exponent(t.exponent());
  }, initRange.apply(t, arguments), t;
}
function sqrt() {
  return pow.apply(null, arguments).exponent(0.5);
}
function square(t) {
  return Math.sign(t) * t * t;
}
function unsquare(t) {
  return Math.sign(t) * Math.sqrt(Math.abs(t));
}
function radial() {
  var t = continuous(), e = [0, 1], n = !1, o;
  function l(u) {
    var f = unsquare(t(u));
    return isNaN(f) ? o : n ? Math.round(f) : f;
  }
  return l.invert = function(u) {
    return t.invert(square(u));
  }, l.domain = function(u) {
    return arguments.length ? (t.domain(u), l) : t.domain();
  }, l.range = function(u) {
    return arguments.length ? (t.range((e = Array.from(u, number$1)).map(square)), l) : e.slice();
  }, l.rangeRound = function(u) {
    return l.range(u).round(!0);
  }, l.round = function(u) {
    return arguments.length ? (n = !!u, l) : n;
  }, l.clamp = function(u) {
    return arguments.length ? (t.clamp(u), l) : t.clamp();
  }, l.unknown = function(u) {
    return arguments.length ? (o = u, l) : o;
  }, l.copy = function() {
    return radial(t.domain(), e).round(n).clamp(t.clamp()).unknown(o);
  }, initRange.apply(l, arguments), linearish(l);
}
function quantile() {
  var t = [], e = [], n = [], o;
  function l() {
    var f = 0, h = Math.max(1, e.length);
    for (n = new Array(h - 1); ++f < h; ) n[f - 1] = quantileSorted(t, f / h);
    return u;
  }
  function u(f) {
    return f == null || isNaN(f = +f) ? o : e[bisectRight(n, f)];
  }
  return u.invertExtent = function(f) {
    var h = e.indexOf(f);
    return h < 0 ? [NaN, NaN] : [
      h > 0 ? n[h - 1] : t[0],
      h < n.length ? n[h] : t[t.length - 1]
    ];
  }, u.domain = function(f) {
    if (!arguments.length) return t.slice();
    t = [];
    for (let h of f) h != null && !isNaN(h = +h) && t.push(h);
    return t.sort(ascending), l();
  }, u.range = function(f) {
    return arguments.length ? (e = Array.from(f), l()) : e.slice();
  }, u.unknown = function(f) {
    return arguments.length ? (o = f, u) : o;
  }, u.quantiles = function() {
    return n.slice();
  }, u.copy = function() {
    return quantile().domain(t).range(e).unknown(o);
  }, initRange.apply(u, arguments);
}
function quantize() {
  var t = 0, e = 1, n = 1, o = [0.5], l = [0, 1], u;
  function f(p) {
    return p != null && p <= p ? l[bisectRight(o, p, 0, n)] : u;
  }
  function h() {
    var p = -1;
    for (o = new Array(n); ++p < n; ) o[p] = ((p + 1) * e - (p - n) * t) / (n + 1);
    return f;
  }
  return f.domain = function(p) {
    return arguments.length ? ([t, e] = p, t = +t, e = +e, h()) : [t, e];
  }, f.range = function(p) {
    return arguments.length ? (n = (l = Array.from(p)).length - 1, h()) : l.slice();
  }, f.invertExtent = function(p) {
    var v = l.indexOf(p);
    return v < 0 ? [NaN, NaN] : v < 1 ? [t, o[0]] : v >= n ? [o[n - 1], e] : [o[v - 1], o[v]];
  }, f.unknown = function(p) {
    return arguments.length && (u = p), f;
  }, f.thresholds = function() {
    return o.slice();
  }, f.copy = function() {
    return quantize().domain([t, e]).range(l).unknown(u);
  }, initRange.apply(linearish(f), arguments);
}
function threshold() {
  var t = [0.5], e = [0, 1], n, o = 1;
  function l(u) {
    return u != null && u <= u ? e[bisectRight(t, u, 0, o)] : n;
  }
  return l.domain = function(u) {
    return arguments.length ? (t = Array.from(u), o = Math.min(t.length, e.length - 1), l) : t.slice();
  }, l.range = function(u) {
    return arguments.length ? (e = Array.from(u), o = Math.min(t.length, e.length - 1), l) : e.slice();
  }, l.invertExtent = function(u) {
    var f = e.indexOf(u);
    return [t[f - 1], t[f]];
  }, l.unknown = function(u) {
    return arguments.length ? (n = u, l) : n;
  }, l.copy = function() {
    return threshold().domain(t).range(e).unknown(n);
  }, initRange.apply(l, arguments);
}
const t0 = /* @__PURE__ */ new Date(), t1 = /* @__PURE__ */ new Date();
function timeInterval(t, e, n, o) {
  function l(u) {
    return t(u = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+u)), u;
  }
  return l.floor = (u) => (t(u = /* @__PURE__ */ new Date(+u)), u), l.ceil = (u) => (t(u = new Date(u - 1)), e(u, 1), t(u), u), l.round = (u) => {
    const f = l(u), h = l.ceil(u);
    return u - f < h - u ? f : h;
  }, l.offset = (u, f) => (e(u = /* @__PURE__ */ new Date(+u), f == null ? 1 : Math.floor(f)), u), l.range = (u, f, h) => {
    const p = [];
    if (u = l.ceil(u), h = h == null ? 1 : Math.floor(h), !(u < f) || !(h > 0)) return p;
    let v;
    do
      p.push(v = /* @__PURE__ */ new Date(+u)), e(u, h), t(u);
    while (v < u && u < f);
    return p;
  }, l.filter = (u) => timeInterval((f) => {
    if (f >= f) for (; t(f), !u(f); ) f.setTime(f - 1);
  }, (f, h) => {
    if (f >= f)
      if (h < 0) for (; ++h <= 0; )
        for (; e(f, -1), !u(f); )
          ;
      else for (; --h >= 0; )
        for (; e(f, 1), !u(f); )
          ;
  }), n && (l.count = (u, f) => (t0.setTime(+u), t1.setTime(+f), t(t0), t(t1), Math.floor(n(t0, t1))), l.every = (u) => (u = Math.floor(u), !isFinite(u) || !(u > 0) ? null : u > 1 ? l.filter(o ? (f) => o(f) % u === 0 : (f) => l.count(0, f) % u === 0) : l)), l;
}
const millisecond = timeInterval(() => {
}, (t, e) => {
  t.setTime(+t + e);
}, (t, e) => e - t);
millisecond.every = (t) => (t = Math.floor(t), !isFinite(t) || !(t > 0) ? null : t > 1 ? timeInterval((e) => {
  e.setTime(Math.floor(e / t) * t);
}, (e, n) => {
  e.setTime(+e + n * t);
}, (e, n) => (n - e) / t) : millisecond);
millisecond.range;
const durationSecond = 1e3, durationMinute = durationSecond * 60, durationHour = durationMinute * 60, durationDay = durationHour * 24, durationWeek = durationDay * 7, durationMonth = durationDay * 30, durationYear = durationDay * 365, second = timeInterval((t) => {
  t.setTime(t - t.getMilliseconds());
}, (t, e) => {
  t.setTime(+t + e * durationSecond);
}, (t, e) => (e - t) / durationSecond, (t) => t.getUTCSeconds());
second.range;
const timeMinute = timeInterval((t) => {
  t.setTime(t - t.getMilliseconds() - t.getSeconds() * durationSecond);
}, (t, e) => {
  t.setTime(+t + e * durationMinute);
}, (t, e) => (e - t) / durationMinute, (t) => t.getMinutes());
timeMinute.range;
const utcMinute = timeInterval((t) => {
  t.setUTCSeconds(0, 0);
}, (t, e) => {
  t.setTime(+t + e * durationMinute);
}, (t, e) => (e - t) / durationMinute, (t) => t.getUTCMinutes());
utcMinute.range;
const timeHour = timeInterval((t) => {
  t.setTime(t - t.getMilliseconds() - t.getSeconds() * durationSecond - t.getMinutes() * durationMinute);
}, (t, e) => {
  t.setTime(+t + e * durationHour);
}, (t, e) => (e - t) / durationHour, (t) => t.getHours());
timeHour.range;
const utcHour = timeInterval((t) => {
  t.setUTCMinutes(0, 0, 0);
}, (t, e) => {
  t.setTime(+t + e * durationHour);
}, (t, e) => (e - t) / durationHour, (t) => t.getUTCHours());
utcHour.range;
const timeDay = timeInterval(
  (t) => t.setHours(0, 0, 0, 0),
  (t, e) => t.setDate(t.getDate() + e),
  (t, e) => (e - t - (e.getTimezoneOffset() - t.getTimezoneOffset()) * durationMinute) / durationDay,
  (t) => t.getDate() - 1
);
timeDay.range;
const utcDay = timeInterval((t) => {
  t.setUTCHours(0, 0, 0, 0);
}, (t, e) => {
  t.setUTCDate(t.getUTCDate() + e);
}, (t, e) => (e - t) / durationDay, (t) => t.getUTCDate() - 1);
utcDay.range;
const unixDay = timeInterval((t) => {
  t.setUTCHours(0, 0, 0, 0);
}, (t, e) => {
  t.setUTCDate(t.getUTCDate() + e);
}, (t, e) => (e - t) / durationDay, (t) => Math.floor(t / durationDay));
unixDay.range;
function timeWeekday(t) {
  return timeInterval((e) => {
    e.setDate(e.getDate() - (e.getDay() + 7 - t) % 7), e.setHours(0, 0, 0, 0);
  }, (e, n) => {
    e.setDate(e.getDate() + n * 7);
  }, (e, n) => (n - e - (n.getTimezoneOffset() - e.getTimezoneOffset()) * durationMinute) / durationWeek);
}
const timeSunday = timeWeekday(0), timeMonday = timeWeekday(1), timeTuesday = timeWeekday(2), timeWednesday = timeWeekday(3), timeThursday = timeWeekday(4), timeFriday = timeWeekday(5), timeSaturday = timeWeekday(6);
timeSunday.range;
timeMonday.range;
timeTuesday.range;
timeWednesday.range;
timeThursday.range;
timeFriday.range;
timeSaturday.range;
function utcWeekday(t) {
  return timeInterval((e) => {
    e.setUTCDate(e.getUTCDate() - (e.getUTCDay() + 7 - t) % 7), e.setUTCHours(0, 0, 0, 0);
  }, (e, n) => {
    e.setUTCDate(e.getUTCDate() + n * 7);
  }, (e, n) => (n - e) / durationWeek);
}
const utcSunday = utcWeekday(0), utcMonday = utcWeekday(1), utcTuesday = utcWeekday(2), utcWednesday = utcWeekday(3), utcThursday = utcWeekday(4), utcFriday = utcWeekday(5), utcSaturday = utcWeekday(6);
utcSunday.range;
utcMonday.range;
utcTuesday.range;
utcWednesday.range;
utcThursday.range;
utcFriday.range;
utcSaturday.range;
const timeMonth = timeInterval((t) => {
  t.setDate(1), t.setHours(0, 0, 0, 0);
}, (t, e) => {
  t.setMonth(t.getMonth() + e);
}, (t, e) => e.getMonth() - t.getMonth() + (e.getFullYear() - t.getFullYear()) * 12, (t) => t.getMonth());
timeMonth.range;
const utcMonth = timeInterval((t) => {
  t.setUTCDate(1), t.setUTCHours(0, 0, 0, 0);
}, (t, e) => {
  t.setUTCMonth(t.getUTCMonth() + e);
}, (t, e) => e.getUTCMonth() - t.getUTCMonth() + (e.getUTCFullYear() - t.getUTCFullYear()) * 12, (t) => t.getUTCMonth());
utcMonth.range;
const timeYear = timeInterval((t) => {
  t.setMonth(0, 1), t.setHours(0, 0, 0, 0);
}, (t, e) => {
  t.setFullYear(t.getFullYear() + e);
}, (t, e) => e.getFullYear() - t.getFullYear(), (t) => t.getFullYear());
timeYear.every = (t) => !isFinite(t = Math.floor(t)) || !(t > 0) ? null : timeInterval((e) => {
  e.setFullYear(Math.floor(e.getFullYear() / t) * t), e.setMonth(0, 1), e.setHours(0, 0, 0, 0);
}, (e, n) => {
  e.setFullYear(e.getFullYear() + n * t);
});
timeYear.range;
const utcYear = timeInterval((t) => {
  t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0);
}, (t, e) => {
  t.setUTCFullYear(t.getUTCFullYear() + e);
}, (t, e) => e.getUTCFullYear() - t.getUTCFullYear(), (t) => t.getUTCFullYear());
utcYear.every = (t) => !isFinite(t = Math.floor(t)) || !(t > 0) ? null : timeInterval((e) => {
  e.setUTCFullYear(Math.floor(e.getUTCFullYear() / t) * t), e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0);
}, (e, n) => {
  e.setUTCFullYear(e.getUTCFullYear() + n * t);
});
utcYear.range;
function ticker(t, e, n, o, l, u) {
  const f = [
    [second, 1, durationSecond],
    [second, 5, 5 * durationSecond],
    [second, 15, 15 * durationSecond],
    [second, 30, 30 * durationSecond],
    [u, 1, durationMinute],
    [u, 5, 5 * durationMinute],
    [u, 15, 15 * durationMinute],
    [u, 30, 30 * durationMinute],
    [l, 1, durationHour],
    [l, 3, 3 * durationHour],
    [l, 6, 6 * durationHour],
    [l, 12, 12 * durationHour],
    [o, 1, durationDay],
    [o, 2, 2 * durationDay],
    [n, 1, durationWeek],
    [e, 1, durationMonth],
    [e, 3, 3 * durationMonth],
    [t, 1, durationYear]
  ];
  function h(v, g, w) {
    const E = g < v;
    E && ([v, g] = [g, v]);
    const T = w && typeof w.range == "function" ? w : p(v, g, w), R = T ? T.range(v, +g + 1) : [];
    return E ? R.reverse() : R;
  }
  function p(v, g, w) {
    const E = Math.abs(g - v) / w, T = bisector(([, , b]) => b).right(f, E);
    if (T === f.length) return t.every(tickStep(v / durationYear, g / durationYear, w));
    if (T === 0) return millisecond.every(Math.max(tickStep(v, g, w), 1));
    const [R, _] = f[E / f[T - 1][2] < f[T][2] / E ? T - 1 : T];
    return R.every(_);
  }
  return [h, p];
}
const [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, unixDay, utcHour, utcMinute), [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute);
function localDate(t) {
  if (0 <= t.y && t.y < 100) {
    var e = new Date(-1, t.m, t.d, t.H, t.M, t.S, t.L);
    return e.setFullYear(t.y), e;
  }
  return new Date(t.y, t.m, t.d, t.H, t.M, t.S, t.L);
}
function utcDate(t) {
  if (0 <= t.y && t.y < 100) {
    var e = new Date(Date.UTC(-1, t.m, t.d, t.H, t.M, t.S, t.L));
    return e.setUTCFullYear(t.y), e;
  }
  return new Date(Date.UTC(t.y, t.m, t.d, t.H, t.M, t.S, t.L));
}
function newDate$1(t, e, n) {
  return { y: t, m: e, d: n, H: 0, M: 0, S: 0, L: 0 };
}
function formatLocale(t) {
  var e = t.dateTime, n = t.date, o = t.time, l = t.periods, u = t.days, f = t.shortDays, h = t.months, p = t.shortMonths, v = formatRe(l), g = formatLookup(l), w = formatRe(u), E = formatLookup(u), T = formatRe(f), R = formatLookup(f), _ = formatRe(h), b = formatLookup(h), M = formatRe(p), A = formatLookup(p), $ = {
    a: V,
    A: X,
    b: Z,
    B: Q,
    c: null,
    d: formatDayOfMonth,
    e: formatDayOfMonth,
    f: formatMicroseconds,
    g: formatYearISO,
    G: formatFullYearISO,
    H: formatHour24,
    I: formatHour12,
    j: formatDayOfYear,
    L: formatMilliseconds,
    m: formatMonthNumber,
    M: formatMinutes,
    p: q,
    q: J,
    Q: formatUnixTimestamp,
    s: formatUnixTimestampSeconds,
    S: formatSeconds,
    u: formatWeekdayNumberMonday,
    U: formatWeekNumberSunday,
    V: formatWeekNumberISO,
    w: formatWeekdayNumberSunday,
    W: formatWeekNumberMonday,
    x: null,
    X: null,
    y: formatYear,
    Y: formatFullYear,
    Z: formatZone,
    "%": formatLiteralPercent
  }, S = {
    a: ie,
    A: ne,
    b: ge,
    B: ye,
    c: null,
    d: formatUTCDayOfMonth,
    e: formatUTCDayOfMonth,
    f: formatUTCMicroseconds,
    g: formatUTCYearISO,
    G: formatUTCFullYearISO,
    H: formatUTCHour24,
    I: formatUTCHour12,
    j: formatUTCDayOfYear,
    L: formatUTCMilliseconds,
    m: formatUTCMonthNumber,
    M: formatUTCMinutes,
    p: xe,
    q: we,
    Q: formatUnixTimestamp,
    s: formatUnixTimestampSeconds,
    S: formatUTCSeconds,
    u: formatUTCWeekdayNumberMonday,
    U: formatUTCWeekNumberSunday,
    V: formatUTCWeekNumberISO,
    w: formatUTCWeekdayNumberSunday,
    W: formatUTCWeekNumberMonday,
    x: null,
    X: null,
    y: formatUTCYear,
    Y: formatUTCFullYear,
    Z: formatUTCZone,
    "%": formatLiteralPercent
  }, C = {
    a: L,
    A: z,
    b: G,
    B,
    c: F,
    d: parseDayOfMonth,
    e: parseDayOfMonth,
    f: parseMicroseconds,
    g: parseYear,
    G: parseFullYear,
    H: parseHour24,
    I: parseHour24,
    j: parseDayOfYear,
    L: parseMilliseconds,
    m: parseMonthNumber,
    M: parseMinutes,
    p: j,
    q: parseQuarter,
    Q: parseUnixTimestamp,
    s: parseUnixTimestampSeconds,
    S: parseSeconds,
    u: parseWeekdayNumberMonday,
    U: parseWeekNumberSunday,
    V: parseWeekNumberISO,
    w: parseWeekdayNumberSunday,
    W: parseWeekNumberMonday,
    x: H,
    X: W,
    y: parseYear,
    Y: parseFullYear,
    Z: parseZone,
    "%": parseLiteralPercent
  };
  $.x = D(n, $), $.X = D(o, $), $.c = D(e, $), S.x = D(n, S), S.X = D(o, S), S.c = D(e, S);
  function D(de, Te) {
    return function(Ce) {
      var ee = [], Ae = -1, be = 0, Fe = de.length, et, Ye, De;
      for (Ce instanceof Date || (Ce = /* @__PURE__ */ new Date(+Ce)); ++Ae < Fe; )
        de.charCodeAt(Ae) === 37 && (ee.push(de.slice(be, Ae)), (Ye = pads[et = de.charAt(++Ae)]) != null ? et = de.charAt(++Ae) : Ye = et === "e" ? " " : "0", (De = Te[et]) && (et = De(Ce, Ye)), ee.push(et), be = Ae + 1);
      return ee.push(de.slice(be, Ae)), ee.join("");
    };
  }
  function O(de, Te) {
    return function(Ce) {
      var ee = newDate$1(1900, void 0, 1), Ae = N(ee, de, Ce += "", 0), be, Fe;
      if (Ae != Ce.length) return null;
      if ("Q" in ee) return new Date(ee.Q);
      if ("s" in ee) return new Date(ee.s * 1e3 + ("L" in ee ? ee.L : 0));
      if (Te && !("Z" in ee) && (ee.Z = 0), "p" in ee && (ee.H = ee.H % 12 + ee.p * 12), ee.m === void 0 && (ee.m = "q" in ee ? ee.q : 0), "V" in ee) {
        if (ee.V < 1 || ee.V > 53) return null;
        "w" in ee || (ee.w = 1), "Z" in ee ? (be = utcDate(newDate$1(ee.y, 0, 1)), Fe = be.getUTCDay(), be = Fe > 4 || Fe === 0 ? utcMonday.ceil(be) : utcMonday(be), be = utcDay.offset(be, (ee.V - 1) * 7), ee.y = be.getUTCFullYear(), ee.m = be.getUTCMonth(), ee.d = be.getUTCDate() + (ee.w + 6) % 7) : (be = localDate(newDate$1(ee.y, 0, 1)), Fe = be.getDay(), be = Fe > 4 || Fe === 0 ? timeMonday.ceil(be) : timeMonday(be), be = timeDay.offset(be, (ee.V - 1) * 7), ee.y = be.getFullYear(), ee.m = be.getMonth(), ee.d = be.getDate() + (ee.w + 6) % 7);
      } else ("W" in ee || "U" in ee) && ("w" in ee || (ee.w = "u" in ee ? ee.u % 7 : "W" in ee ? 1 : 0), Fe = "Z" in ee ? utcDate(newDate$1(ee.y, 0, 1)).getUTCDay() : localDate(newDate$1(ee.y, 0, 1)).getDay(), ee.m = 0, ee.d = "W" in ee ? (ee.w + 6) % 7 + ee.W * 7 - (Fe + 5) % 7 : ee.w + ee.U * 7 - (Fe + 6) % 7);
      return "Z" in ee ? (ee.H += ee.Z / 100 | 0, ee.M += ee.Z % 100, utcDate(ee)) : localDate(ee);
    };
  }
  function N(de, Te, Ce, ee) {
    for (var Ae = 0, be = Te.length, Fe = Ce.length, et, Ye; Ae < be; ) {
      if (ee >= Fe) return -1;
      if (et = Te.charCodeAt(Ae++), et === 37) {
        if (et = Te.charAt(Ae++), Ye = C[et in pads ? Te.charAt(Ae++) : et], !Ye || (ee = Ye(de, Ce, ee)) < 0) return -1;
      } else if (et != Ce.charCodeAt(ee++))
        return -1;
    }
    return ee;
  }
  function j(de, Te, Ce) {
    var ee = v.exec(Te.slice(Ce));
    return ee ? (de.p = g.get(ee[0].toLowerCase()), Ce + ee[0].length) : -1;
  }
  function L(de, Te, Ce) {
    var ee = T.exec(Te.slice(Ce));
    return ee ? (de.w = R.get(ee[0].toLowerCase()), Ce + ee[0].length) : -1;
  }
  function z(de, Te, Ce) {
    var ee = w.exec(Te.slice(Ce));
    return ee ? (de.w = E.get(ee[0].toLowerCase()), Ce + ee[0].length) : -1;
  }
  function G(de, Te, Ce) {
    var ee = M.exec(Te.slice(Ce));
    return ee ? (de.m = A.get(ee[0].toLowerCase()), Ce + ee[0].length) : -1;
  }
  function B(de, Te, Ce) {
    var ee = _.exec(Te.slice(Ce));
    return ee ? (de.m = b.get(ee[0].toLowerCase()), Ce + ee[0].length) : -1;
  }
  function F(de, Te, Ce) {
    return N(de, e, Te, Ce);
  }
  function H(de, Te, Ce) {
    return N(de, n, Te, Ce);
  }
  function W(de, Te, Ce) {
    return N(de, o, Te, Ce);
  }
  function V(de) {
    return f[de.getDay()];
  }
  function X(de) {
    return u[de.getDay()];
  }
  function Z(de) {
    return p[de.getMonth()];
  }
  function Q(de) {
    return h[de.getMonth()];
  }
  function q(de) {
    return l[+(de.getHours() >= 12)];
  }
  function J(de) {
    return 1 + ~~(de.getMonth() / 3);
  }
  function ie(de) {
    return f[de.getUTCDay()];
  }
  function ne(de) {
    return u[de.getUTCDay()];
  }
  function ge(de) {
    return p[de.getUTCMonth()];
  }
  function ye(de) {
    return h[de.getUTCMonth()];
  }
  function xe(de) {
    return l[+(de.getUTCHours() >= 12)];
  }
  function we(de) {
    return 1 + ~~(de.getUTCMonth() / 3);
  }
  return {
    format: function(de) {
      var Te = D(de += "", $);
      return Te.toString = function() {
        return de;
      }, Te;
    },
    parse: function(de) {
      var Te = O(de += "", !1);
      return Te.toString = function() {
        return de;
      }, Te;
    },
    utcFormat: function(de) {
      var Te = D(de += "", S);
      return Te.toString = function() {
        return de;
      }, Te;
    },
    utcParse: function(de) {
      var Te = O(de += "", !0);
      return Te.toString = function() {
        return de;
      }, Te;
    }
  };
}
var pads = { "-": "", _: " ", 0: "0" }, numberRe = /^\s*\d+/, percentRe = /^%/, requoteRe = /[\\^$*+?|[\]().{}]/g;
function pad(t, e, n) {
  var o = t < 0 ? "-" : "", l = (o ? -t : t) + "", u = l.length;
  return o + (u < n ? new Array(n - u + 1).join(e) + l : l);
}
function requote(t) {
  return t.replace(requoteRe, "\\$&");
}
function formatRe(t) {
  return new RegExp("^(?:" + t.map(requote).join("|") + ")", "i");
}
function formatLookup(t) {
  return new Map(t.map((e, n) => [e.toLowerCase(), n]));
}
function parseWeekdayNumberSunday(t, e, n) {
  var o = numberRe.exec(e.slice(n, n + 1));
  return o ? (t.w = +o[0], n + o[0].length) : -1;
}
function parseWeekdayNumberMonday(t, e, n) {
  var o = numberRe.exec(e.slice(n, n + 1));
  return o ? (t.u = +o[0], n + o[0].length) : -1;
}
function parseWeekNumberSunday(t, e, n) {
  var o = numberRe.exec(e.slice(n, n + 2));
  return o ? (t.U = +o[0], n + o[0].length) : -1;
}
function parseWeekNumberISO(t, e, n) {
  var o = numberRe.exec(e.slice(n, n + 2));
  return o ? (t.V = +o[0], n + o[0].length) : -1;
}
function parseWeekNumberMonday(t, e, n) {
  var o = numberRe.exec(e.slice(n, n + 2));
  return o ? (t.W = +o[0], n + o[0].length) : -1;
}
function parseFullYear(t, e, n) {
  var o = numberRe.exec(e.slice(n, n + 4));
  return o ? (t.y = +o[0], n + o[0].length) : -1;
}
function parseYear(t, e, n) {
  var o = numberRe.exec(e.slice(n, n + 2));
  return o ? (t.y = +o[0] + (+o[0] > 68 ? 1900 : 2e3), n + o[0].length) : -1;
}
function parseZone(t, e, n) {
  var o = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(e.slice(n, n + 6));
  return o ? (t.Z = o[1] ? 0 : -(o[2] + (o[3] || "00")), n + o[0].length) : -1;
}
function parseQuarter(t, e, n) {
  var o = numberRe.exec(e.slice(n, n + 1));
  return o ? (t.q = o[0] * 3 - 3, n + o[0].length) : -1;
}
function parseMonthNumber(t, e, n) {
  var o = numberRe.exec(e.slice(n, n + 2));
  return o ? (t.m = o[0] - 1, n + o[0].length) : -1;
}
function parseDayOfMonth(t, e, n) {
  var o = numberRe.exec(e.slice(n, n + 2));
  return o ? (t.d = +o[0], n + o[0].length) : -1;
}
function parseDayOfYear(t, e, n) {
  var o = numberRe.exec(e.slice(n, n + 3));
  return o ? (t.m = 0, t.d = +o[0], n + o[0].length) : -1;
}
function parseHour24(t, e, n) {
  var o = numberRe.exec(e.slice(n, n + 2));
  return o ? (t.H = +o[0], n + o[0].length) : -1;
}
function parseMinutes(t, e, n) {
  var o = numberRe.exec(e.slice(n, n + 2));
  return o ? (t.M = +o[0], n + o[0].length) : -1;
}
function parseSeconds(t, e, n) {
  var o = numberRe.exec(e.slice(n, n + 2));
  return o ? (t.S = +o[0], n + o[0].length) : -1;
}
function parseMilliseconds(t, e, n) {
  var o = numberRe.exec(e.slice(n, n + 3));
  return o ? (t.L = +o[0], n + o[0].length) : -1;
}
function parseMicroseconds(t, e, n) {
  var o = numberRe.exec(e.slice(n, n + 6));
  return o ? (t.L = Math.floor(o[0] / 1e3), n + o[0].length) : -1;
}
function parseLiteralPercent(t, e, n) {
  var o = percentRe.exec(e.slice(n, n + 1));
  return o ? n + o[0].length : -1;
}
function parseUnixTimestamp(t, e, n) {
  var o = numberRe.exec(e.slice(n));
  return o ? (t.Q = +o[0], n + o[0].length) : -1;
}
function parseUnixTimestampSeconds(t, e, n) {
  var o = numberRe.exec(e.slice(n));
  return o ? (t.s = +o[0], n + o[0].length) : -1;
}
function formatDayOfMonth(t, e) {
  return pad(t.getDate(), e, 2);
}
function formatHour24(t, e) {
  return pad(t.getHours(), e, 2);
}
function formatHour12(t, e) {
  return pad(t.getHours() % 12 || 12, e, 2);
}
function formatDayOfYear(t, e) {
  return pad(1 + timeDay.count(timeYear(t), t), e, 3);
}
function formatMilliseconds(t, e) {
  return pad(t.getMilliseconds(), e, 3);
}
function formatMicroseconds(t, e) {
  return formatMilliseconds(t, e) + "000";
}
function formatMonthNumber(t, e) {
  return pad(t.getMonth() + 1, e, 2);
}
function formatMinutes(t, e) {
  return pad(t.getMinutes(), e, 2);
}
function formatSeconds(t, e) {
  return pad(t.getSeconds(), e, 2);
}
function formatWeekdayNumberMonday(t) {
  var e = t.getDay();
  return e === 0 ? 7 : e;
}
function formatWeekNumberSunday(t, e) {
  return pad(timeSunday.count(timeYear(t) - 1, t), e, 2);
}
function dISO(t) {
  var e = t.getDay();
  return e >= 4 || e === 0 ? timeThursday(t) : timeThursday.ceil(t);
}
function formatWeekNumberISO(t, e) {
  return t = dISO(t), pad(timeThursday.count(timeYear(t), t) + (timeYear(t).getDay() === 4), e, 2);
}
function formatWeekdayNumberSunday(t) {
  return t.getDay();
}
function formatWeekNumberMonday(t, e) {
  return pad(timeMonday.count(timeYear(t) - 1, t), e, 2);
}
function formatYear(t, e) {
  return pad(t.getFullYear() % 100, e, 2);
}
function formatYearISO(t, e) {
  return t = dISO(t), pad(t.getFullYear() % 100, e, 2);
}
function formatFullYear(t, e) {
  return pad(t.getFullYear() % 1e4, e, 4);
}
function formatFullYearISO(t, e) {
  var n = t.getDay();
  return t = n >= 4 || n === 0 ? timeThursday(t) : timeThursday.ceil(t), pad(t.getFullYear() % 1e4, e, 4);
}
function formatZone(t) {
  var e = t.getTimezoneOffset();
  return (e > 0 ? "-" : (e *= -1, "+")) + pad(e / 60 | 0, "0", 2) + pad(e % 60, "0", 2);
}
function formatUTCDayOfMonth(t, e) {
  return pad(t.getUTCDate(), e, 2);
}
function formatUTCHour24(t, e) {
  return pad(t.getUTCHours(), e, 2);
}
function formatUTCHour12(t, e) {
  return pad(t.getUTCHours() % 12 || 12, e, 2);
}
function formatUTCDayOfYear(t, e) {
  return pad(1 + utcDay.count(utcYear(t), t), e, 3);
}
function formatUTCMilliseconds(t, e) {
  return pad(t.getUTCMilliseconds(), e, 3);
}
function formatUTCMicroseconds(t, e) {
  return formatUTCMilliseconds(t, e) + "000";
}
function formatUTCMonthNumber(t, e) {
  return pad(t.getUTCMonth() + 1, e, 2);
}
function formatUTCMinutes(t, e) {
  return pad(t.getUTCMinutes(), e, 2);
}
function formatUTCSeconds(t, e) {
  return pad(t.getUTCSeconds(), e, 2);
}
function formatUTCWeekdayNumberMonday(t) {
  var e = t.getUTCDay();
  return e === 0 ? 7 : e;
}
function formatUTCWeekNumberSunday(t, e) {
  return pad(utcSunday.count(utcYear(t) - 1, t), e, 2);
}
function UTCdISO(t) {
  var e = t.getUTCDay();
  return e >= 4 || e === 0 ? utcThursday(t) : utcThursday.ceil(t);
}
function formatUTCWeekNumberISO(t, e) {
  return t = UTCdISO(t), pad(utcThursday.count(utcYear(t), t) + (utcYear(t).getUTCDay() === 4), e, 2);
}
function formatUTCWeekdayNumberSunday(t) {
  return t.getUTCDay();
}
function formatUTCWeekNumberMonday(t, e) {
  return pad(utcMonday.count(utcYear(t) - 1, t), e, 2);
}
function formatUTCYear(t, e) {
  return pad(t.getUTCFullYear() % 100, e, 2);
}
function formatUTCYearISO(t, e) {
  return t = UTCdISO(t), pad(t.getUTCFullYear() % 100, e, 2);
}
function formatUTCFullYear(t, e) {
  return pad(t.getUTCFullYear() % 1e4, e, 4);
}
function formatUTCFullYearISO(t, e) {
  var n = t.getUTCDay();
  return t = n >= 4 || n === 0 ? utcThursday(t) : utcThursday.ceil(t), pad(t.getUTCFullYear() % 1e4, e, 4);
}
function formatUTCZone() {
  return "+0000";
}
function formatLiteralPercent() {
  return "%";
}
function formatUnixTimestamp(t) {
  return +t;
}
function formatUnixTimestampSeconds(t) {
  return Math.floor(+t / 1e3);
}
var locale, timeFormat, utcFormat;
defaultLocale({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function defaultLocale(t) {
  return locale = formatLocale(t), timeFormat = locale.format, locale.parse, utcFormat = locale.utcFormat, locale.utcParse, locale;
}
function date(t) {
  return new Date(t);
}
function number(t) {
  return t instanceof Date ? +t : +/* @__PURE__ */ new Date(+t);
}
function calendar(t, e, n, o, l, u, f, h, p, v) {
  var g = continuous(), w = g.invert, E = g.domain, T = v(".%L"), R = v(":%S"), _ = v("%I:%M"), b = v("%I %p"), M = v("%a %d"), A = v("%b %d"), $ = v("%B"), S = v("%Y");
  function C(D) {
    return (p(D) < D ? T : h(D) < D ? R : f(D) < D ? _ : u(D) < D ? b : o(D) < D ? l(D) < D ? M : A : n(D) < D ? $ : S)(D);
  }
  return g.invert = function(D) {
    return new Date(w(D));
  }, g.domain = function(D) {
    return arguments.length ? E(Array.from(D, number)) : E().map(date);
  }, g.ticks = function(D) {
    var O = E();
    return t(O[0], O[O.length - 1], D ?? 10);
  }, g.tickFormat = function(D, O) {
    return O == null ? C : v(O);
  }, g.nice = function(D) {
    var O = E();
    return (!D || typeof D.range != "function") && (D = e(O[0], O[O.length - 1], D ?? 10)), D ? E(nice(O, D)) : g;
  }, g.copy = function() {
    return copy$1(g, calendar(t, e, n, o, l, u, f, h, p, v));
  }, g;
}
function time() {
  return initRange.apply(calendar(timeTicks, timeTickInterval, timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute, second, timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
function utcTime() {
  return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
}
function transformer$1() {
  var t = 0, e = 1, n, o, l, u, f = identity$6, h = !1, p;
  function v(w) {
    return w == null || isNaN(w = +w) ? p : f(l === 0 ? 0.5 : (w = (u(w) - n) * l, h ? Math.max(0, Math.min(1, w)) : w));
  }
  v.domain = function(w) {
    return arguments.length ? ([t, e] = w, n = u(t = +t), o = u(e = +e), l = n === o ? 0 : 1 / (o - n), v) : [t, e];
  }, v.clamp = function(w) {
    return arguments.length ? (h = !!w, v) : h;
  }, v.interpolator = function(w) {
    return arguments.length ? (f = w, v) : f;
  };
  function g(w) {
    return function(E) {
      var T, R;
      return arguments.length ? ([T, R] = E, f = w(T, R), v) : [f(0), f(1)];
    };
  }
  return v.range = g(interpolate$1), v.rangeRound = g(interpolateRound), v.unknown = function(w) {
    return arguments.length ? (p = w, v) : p;
  }, function(w) {
    return u = w, n = w(t), o = w(e), l = n === o ? 0 : 1 / (o - n), v;
  };
}
function copy(t, e) {
  return e.domain(t.domain()).interpolator(t.interpolator()).clamp(t.clamp()).unknown(t.unknown());
}
function sequential() {
  var t = linearish(transformer$1()(identity$6));
  return t.copy = function() {
    return copy(t, sequential());
  }, initInterpolator.apply(t, arguments);
}
function sequentialLog() {
  var t = loggish(transformer$1()).domain([1, 10]);
  return t.copy = function() {
    return copy(t, sequentialLog()).base(t.base());
  }, initInterpolator.apply(t, arguments);
}
function sequentialSymlog() {
  var t = symlogish(transformer$1());
  return t.copy = function() {
    return copy(t, sequentialSymlog()).constant(t.constant());
  }, initInterpolator.apply(t, arguments);
}
function sequentialPow() {
  var t = powish(transformer$1());
  return t.copy = function() {
    return copy(t, sequentialPow()).exponent(t.exponent());
  }, initInterpolator.apply(t, arguments);
}
function sequentialSqrt() {
  return sequentialPow.apply(null, arguments).exponent(0.5);
}
function sequentialQuantile() {
  var t = [], e = identity$6;
  function n(o) {
    if (o != null && !isNaN(o = +o)) return e((bisectRight(t, o, 1) - 1) / (t.length - 1));
  }
  return n.domain = function(o) {
    if (!arguments.length) return t.slice();
    t = [];
    for (let l of o) l != null && !isNaN(l = +l) && t.push(l);
    return t.sort(ascending), n;
  }, n.interpolator = function(o) {
    return arguments.length ? (e = o, n) : e;
  }, n.range = function() {
    return t.map((o, l) => e(l / (t.length - 1)));
  }, n.quantiles = function(o) {
    return Array.from({ length: o + 1 }, (l, u) => quantile$1(t, u / o));
  }, n.copy = function() {
    return sequentialQuantile(e).domain(t);
  }, initInterpolator.apply(n, arguments);
}
function transformer() {
  var t = 0, e = 0.5, n = 1, o = 1, l, u, f, h, p, v = identity$6, g, w = !1, E;
  function T(_) {
    return isNaN(_ = +_) ? E : (_ = 0.5 + ((_ = +g(_)) - u) * (o * _ < o * u ? h : p), v(w ? Math.max(0, Math.min(1, _)) : _));
  }
  T.domain = function(_) {
    return arguments.length ? ([t, e, n] = _, l = g(t = +t), u = g(e = +e), f = g(n = +n), h = l === u ? 0 : 0.5 / (u - l), p = u === f ? 0 : 0.5 / (f - u), o = u < l ? -1 : 1, T) : [t, e, n];
  }, T.clamp = function(_) {
    return arguments.length ? (w = !!_, T) : w;
  }, T.interpolator = function(_) {
    return arguments.length ? (v = _, T) : v;
  };
  function R(_) {
    return function(b) {
      var M, A, $;
      return arguments.length ? ([M, A, $] = b, v = piecewise(_, [M, A, $]), T) : [v(0), v(0.5), v(1)];
    };
  }
  return T.range = R(interpolate$1), T.rangeRound = R(interpolateRound), T.unknown = function(_) {
    return arguments.length ? (E = _, T) : E;
  }, function(_) {
    return g = _, l = _(t), u = _(e), f = _(n), h = l === u ? 0 : 0.5 / (u - l), p = u === f ? 0 : 0.5 / (f - u), o = u < l ? -1 : 1, T;
  };
}
function diverging() {
  var t = linearish(transformer()(identity$6));
  return t.copy = function() {
    return copy(t, diverging());
  }, initInterpolator.apply(t, arguments);
}
function divergingLog() {
  var t = loggish(transformer()).domain([0.1, 1, 10]);
  return t.copy = function() {
    return copy(t, divergingLog()).base(t.base());
  }, initInterpolator.apply(t, arguments);
}
function divergingSymlog() {
  var t = symlogish(transformer());
  return t.copy = function() {
    return copy(t, divergingSymlog()).constant(t.constant());
  }, initInterpolator.apply(t, arguments);
}
function divergingPow() {
  var t = powish(transformer());
  return t.copy = function() {
    return copy(t, divergingPow()).exponent(t.exponent());
  }, initInterpolator.apply(t, arguments);
}
function divergingSqrt() {
  return divergingPow.apply(null, arguments).exponent(0.5);
}
const d3Scales = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  scaleBand: band,
  scaleDiverging: diverging,
  scaleDivergingLog: divergingLog,
  scaleDivergingPow: divergingPow,
  scaleDivergingSqrt: divergingSqrt,
  scaleDivergingSymlog: divergingSymlog,
  scaleIdentity: identity$4,
  scaleImplicit: implicit,
  scaleLinear: linear,
  scaleLog: log,
  scaleOrdinal: ordinal,
  scalePoint: point,
  scalePow: pow,
  scaleQuantile: quantile,
  scaleQuantize: quantize,
  scaleRadial: radial,
  scaleSequential: sequential,
  scaleSequentialLog: sequentialLog,
  scaleSequentialPow: sequentialPow,
  scaleSequentialQuantile: sequentialQuantile,
  scaleSequentialSqrt: sequentialSqrt,
  scaleSequentialSymlog: sequentialSymlog,
  scaleSqrt: sqrt,
  scaleSymlog: symlog,
  scaleThreshold: threshold,
  scaleTime: time,
  scaleUtc: utcTime,
  tickFormat
}, Symbol.toStringTag, { value: "Module" }));
var isSymbol = isSymbol_1;
function baseExtremum$4(t, e, n) {
  for (var o = -1, l = t.length; ++o < l; ) {
    var u = t[o], f = e(u);
    if (f != null && (h === void 0 ? f === f && !isSymbol(f) : n(f, h)))
      var h = f, p = u;
  }
  return p;
}
var _baseExtremum = baseExtremum$4;
function baseGt$2(t, e) {
  return t > e;
}
var _baseGt = baseGt$2, baseExtremum$3 = _baseExtremum, baseGt$1 = _baseGt, identity$3 = identity_1;
function max$1(t) {
  return t && t.length ? baseExtremum$3(t, identity$3, baseGt$1) : void 0;
}
var max_1 = max$1;
const max$2 = /* @__PURE__ */ getDefaultExportFromCjs(max_1);
function baseLt$2(t, e) {
  return t < e;
}
var _baseLt = baseLt$2, baseExtremum$2 = _baseExtremum, baseLt$1 = _baseLt, identity$2 = identity_1;
function min$1(t) {
  return t && t.length ? baseExtremum$2(t, identity$2, baseLt$1) : void 0;
}
var min_1 = min$1;
const min$2 = /* @__PURE__ */ getDefaultExportFromCjs(min_1);
var arrayMap = _arrayMap, baseIteratee$7 = _baseIteratee, baseMap = _baseMap, isArray$3 = isArray_1;
function map$2(t, e) {
  var n = isArray$3(t) ? arrayMap : baseMap;
  return n(t, baseIteratee$7(e));
}
var map_1 = map$2, baseFlatten = _baseFlatten, map$1 = map_1;
function flatMap(t, e) {
  return baseFlatten(map$1(t, e), 1);
}
var flatMap_1 = flatMap;
const flatMap$1 = /* @__PURE__ */ getDefaultExportFromCjs(flatMap_1);
var baseIsEqual = _baseIsEqual;
function isEqual$1(t, e) {
  return baseIsEqual(t, e);
}
var isEqual_1 = isEqual$1;
const isEqual$2 = /* @__PURE__ */ getDefaultExportFromCjs(isEqual_1);
var MAX_DIGITS = 1e9, defaults = {
  // These values must be integers within the stated ranges (inclusive).
  // Most of these values can be changed during run-time using `Decimal.config`.
  // The maximum number of significant digits of the result of a calculation or base conversion.
  // E.g. `Decimal.config({ precision: 20 });`
  precision: 20,
  // 1 to MAX_DIGITS
  // The rounding mode used by default by `toInteger`, `toDecimalPlaces`, `toExponential`,
  // `toFixed`, `toPrecision` and `toSignificantDigits`.
  //
  // ROUND_UP         0 Away from zero.
  // ROUND_DOWN       1 Towards zero.
  // ROUND_CEIL       2 Towards +Infinity.
  // ROUND_FLOOR      3 Towards -Infinity.
  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
  //
  // E.g.
  // `Decimal.rounding = 4;`
  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
  rounding: 4,
  // 0 to 8
  // The exponent value at and beneath which `toString` returns exponential notation.
  // JavaScript numbers: -7
  toExpNeg: -7,
  // 0 to -MAX_E
  // The exponent value at and above which `toString` returns exponential notation.
  // JavaScript numbers: 21
  toExpPos: 21,
  // 0 to MAX_E
  // The natural logarithm of 10.
  // 115 digits
  LN10: "2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286"
}, Decimal, external = !0, decimalError = "[DecimalError] ", invalidArgument = decimalError + "Invalid argument: ", exponentOutOfRange = decimalError + "Exponent out of range: ", mathfloor = Math.floor, mathpow = Math.pow, isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, ONE, BASE = 1e7, LOG_BASE = 7, MAX_SAFE_INTEGER = 9007199254740991, MAX_E = mathfloor(MAX_SAFE_INTEGER / LOG_BASE), P = {};
P.absoluteValue = P.abs = function() {
  var t = new this.constructor(this);
  return t.s && (t.s = 1), t;
};
P.comparedTo = P.cmp = function(t) {
  var e, n, o, l, u = this;
  if (t = new u.constructor(t), u.s !== t.s) return u.s || -t.s;
  if (u.e !== t.e) return u.e > t.e ^ u.s < 0 ? 1 : -1;
  for (o = u.d.length, l = t.d.length, e = 0, n = o < l ? o : l; e < n; ++e)
    if (u.d[e] !== t.d[e]) return u.d[e] > t.d[e] ^ u.s < 0 ? 1 : -1;
  return o === l ? 0 : o > l ^ u.s < 0 ? 1 : -1;
};
P.decimalPlaces = P.dp = function() {
  var t = this, e = t.d.length - 1, n = (e - t.e) * LOG_BASE;
  if (e = t.d[e], e) for (; e % 10 == 0; e /= 10) n--;
  return n < 0 ? 0 : n;
};
P.dividedBy = P.div = function(t) {
  return divide(this, new this.constructor(t));
};
P.dividedToIntegerBy = P.idiv = function(t) {
  var e = this, n = e.constructor;
  return round$1(divide(e, new n(t), 0, 1), n.precision);
};
P.equals = P.eq = function(t) {
  return !this.cmp(t);
};
P.exponent = function() {
  return getBase10Exponent(this);
};
P.greaterThan = P.gt = function(t) {
  return this.cmp(t) > 0;
};
P.greaterThanOrEqualTo = P.gte = function(t) {
  return this.cmp(t) >= 0;
};
P.isInteger = P.isint = function() {
  return this.e > this.d.length - 2;
};
P.isNegative = P.isneg = function() {
  return this.s < 0;
};
P.isPositive = P.ispos = function() {
  return this.s > 0;
};
P.isZero = function() {
  return this.s === 0;
};
P.lessThan = P.lt = function(t) {
  return this.cmp(t) < 0;
};
P.lessThanOrEqualTo = P.lte = function(t) {
  return this.cmp(t) < 1;
};
P.logarithm = P.log = function(t) {
  var e, n = this, o = n.constructor, l = o.precision, u = l + 5;
  if (t === void 0)
    t = new o(10);
  else if (t = new o(t), t.s < 1 || t.eq(ONE)) throw Error(decimalError + "NaN");
  if (n.s < 1) throw Error(decimalError + (n.s ? "NaN" : "-Infinity"));
  return n.eq(ONE) ? new o(0) : (external = !1, e = divide(ln(n, u), ln(t, u), u), external = !0, round$1(e, l));
};
P.minus = P.sub = function(t) {
  var e = this;
  return t = new e.constructor(t), e.s == t.s ? subtract(e, t) : add(e, (t.s = -t.s, t));
};
P.modulo = P.mod = function(t) {
  var e, n = this, o = n.constructor, l = o.precision;
  if (t = new o(t), !t.s) throw Error(decimalError + "NaN");
  return n.s ? (external = !1, e = divide(n, t, 0, 1).times(t), external = !0, n.minus(e)) : round$1(new o(n), l);
};
P.naturalExponential = P.exp = function() {
  return exp(this);
};
P.naturalLogarithm = P.ln = function() {
  return ln(this);
};
P.negated = P.neg = function() {
  var t = new this.constructor(this);
  return t.s = -t.s || 0, t;
};
P.plus = P.add = function(t) {
  var e = this;
  return t = new e.constructor(t), e.s == t.s ? add(e, t) : subtract(e, (t.s = -t.s, t));
};
P.precision = P.sd = function(t) {
  var e, n, o, l = this;
  if (t !== void 0 && t !== !!t && t !== 1 && t !== 0) throw Error(invalidArgument + t);
  if (e = getBase10Exponent(l) + 1, o = l.d.length - 1, n = o * LOG_BASE + 1, o = l.d[o], o) {
    for (; o % 10 == 0; o /= 10) n--;
    for (o = l.d[0]; o >= 10; o /= 10) n++;
  }
  return t && e > n ? e : n;
};
P.squareRoot = P.sqrt = function() {
  var t, e, n, o, l, u, f, h = this, p = h.constructor;
  if (h.s < 1) {
    if (!h.s) return new p(0);
    throw Error(decimalError + "NaN");
  }
  for (t = getBase10Exponent(h), external = !1, l = Math.sqrt(+h), l == 0 || l == 1 / 0 ? (e = digitsToString(h.d), (e.length + t) % 2 == 0 && (e += "0"), l = Math.sqrt(e), t = mathfloor((t + 1) / 2) - (t < 0 || t % 2), l == 1 / 0 ? e = "5e" + t : (e = l.toExponential(), e = e.slice(0, e.indexOf("e") + 1) + t), o = new p(e)) : o = new p(l.toString()), n = p.precision, l = f = n + 3; ; )
    if (u = o, o = u.plus(divide(h, u, f + 2)).times(0.5), digitsToString(u.d).slice(0, f) === (e = digitsToString(o.d)).slice(0, f)) {
      if (e = e.slice(f - 3, f + 1), l == f && e == "4999") {
        if (round$1(u, n + 1, 0), u.times(u).eq(h)) {
          o = u;
          break;
        }
      } else if (e != "9999")
        break;
      f += 4;
    }
  return external = !0, round$1(o, n);
};
P.times = P.mul = function(t) {
  var e, n, o, l, u, f, h, p, v, g = this, w = g.constructor, E = g.d, T = (t = new w(t)).d;
  if (!g.s || !t.s) return new w(0);
  for (t.s *= g.s, n = g.e + t.e, p = E.length, v = T.length, p < v && (u = E, E = T, T = u, f = p, p = v, v = f), u = [], f = p + v, o = f; o--; ) u.push(0);
  for (o = v; --o >= 0; ) {
    for (e = 0, l = p + o; l > o; )
      h = u[l] + T[o] * E[l - o - 1] + e, u[l--] = h % BASE | 0, e = h / BASE | 0;
    u[l] = (u[l] + e) % BASE | 0;
  }
  for (; !u[--f]; ) u.pop();
  return e ? ++n : u.shift(), t.d = u, t.e = n, external ? round$1(t, w.precision) : t;
};
P.toDecimalPlaces = P.todp = function(t, e) {
  var n = this, o = n.constructor;
  return n = new o(n), t === void 0 ? n : (checkInt32(t, 0, MAX_DIGITS), e === void 0 ? e = o.rounding : checkInt32(e, 0, 8), round$1(n, t + getBase10Exponent(n) + 1, e));
};
P.toExponential = function(t, e) {
  var n, o = this, l = o.constructor;
  return t === void 0 ? n = toString(o, !0) : (checkInt32(t, 0, MAX_DIGITS), e === void 0 ? e = l.rounding : checkInt32(e, 0, 8), o = round$1(new l(o), t + 1, e), n = toString(o, !0, t + 1)), n;
};
P.toFixed = function(t, e) {
  var n, o, l = this, u = l.constructor;
  return t === void 0 ? toString(l) : (checkInt32(t, 0, MAX_DIGITS), e === void 0 ? e = u.rounding : checkInt32(e, 0, 8), o = round$1(new u(l), t + getBase10Exponent(l) + 1, e), n = toString(o.abs(), !1, t + getBase10Exponent(o) + 1), l.isneg() && !l.isZero() ? "-" + n : n);
};
P.toInteger = P.toint = function() {
  var t = this, e = t.constructor;
  return round$1(new e(t), getBase10Exponent(t) + 1, e.rounding);
};
P.toNumber = function() {
  return +this;
};
P.toPower = P.pow = function(t) {
  var e, n, o, l, u, f, h = this, p = h.constructor, v = 12, g = +(t = new p(t));
  if (!t.s) return new p(ONE);
  if (h = new p(h), !h.s) {
    if (t.s < 1) throw Error(decimalError + "Infinity");
    return h;
  }
  if (h.eq(ONE)) return h;
  if (o = p.precision, t.eq(ONE)) return round$1(h, o);
  if (e = t.e, n = t.d.length - 1, f = e >= n, u = h.s, f) {
    if ((n = g < 0 ? -g : g) <= MAX_SAFE_INTEGER) {
      for (l = new p(ONE), e = Math.ceil(o / LOG_BASE + 4), external = !1; n % 2 && (l = l.times(h), truncate(l.d, e)), n = mathfloor(n / 2), n !== 0; )
        h = h.times(h), truncate(h.d, e);
      return external = !0, t.s < 0 ? new p(ONE).div(l) : round$1(l, o);
    }
  } else if (u < 0) throw Error(decimalError + "NaN");
  return u = u < 0 && t.d[Math.max(e, n)] & 1 ? -1 : 1, h.s = 1, external = !1, l = t.times(ln(h, o + v)), external = !0, l = exp(l), l.s = u, l;
};
P.toPrecision = function(t, e) {
  var n, o, l = this, u = l.constructor;
  return t === void 0 ? (n = getBase10Exponent(l), o = toString(l, n <= u.toExpNeg || n >= u.toExpPos)) : (checkInt32(t, 1, MAX_DIGITS), e === void 0 ? e = u.rounding : checkInt32(e, 0, 8), l = round$1(new u(l), t, e), n = getBase10Exponent(l), o = toString(l, t <= n || n <= u.toExpNeg, t)), o;
};
P.toSignificantDigits = P.tosd = function(t, e) {
  var n = this, o = n.constructor;
  return t === void 0 ? (t = o.precision, e = o.rounding) : (checkInt32(t, 1, MAX_DIGITS), e === void 0 ? e = o.rounding : checkInt32(e, 0, 8)), round$1(new o(n), t, e);
};
P.toString = P.valueOf = P.val = P.toJSON = P[Symbol.for("nodejs.util.inspect.custom")] = function() {
  var t = this, e = getBase10Exponent(t), n = t.constructor;
  return toString(t, e <= n.toExpNeg || e >= n.toExpPos);
};
function add(t, e) {
  var n, o, l, u, f, h, p, v, g = t.constructor, w = g.precision;
  if (!t.s || !e.s)
    return e.s || (e = new g(t)), external ? round$1(e, w) : e;
  if (p = t.d, v = e.d, f = t.e, l = e.e, p = p.slice(), u = f - l, u) {
    for (u < 0 ? (o = p, u = -u, h = v.length) : (o = v, l = f, h = p.length), f = Math.ceil(w / LOG_BASE), h = f > h ? f + 1 : h + 1, u > h && (u = h, o.length = 1), o.reverse(); u--; ) o.push(0);
    o.reverse();
  }
  for (h = p.length, u = v.length, h - u < 0 && (u = h, o = v, v = p, p = o), n = 0; u; )
    n = (p[--u] = p[u] + v[u] + n) / BASE | 0, p[u] %= BASE;
  for (n && (p.unshift(n), ++l), h = p.length; p[--h] == 0; ) p.pop();
  return e.d = p, e.e = l, external ? round$1(e, w) : e;
}
function checkInt32(t, e, n) {
  if (t !== ~~t || t < e || t > n)
    throw Error(invalidArgument + t);
}
function digitsToString(t) {
  var e, n, o, l = t.length - 1, u = "", f = t[0];
  if (l > 0) {
    for (u += f, e = 1; e < l; e++)
      o = t[e] + "", n = LOG_BASE - o.length, n && (u += getZeroString(n)), u += o;
    f = t[e], o = f + "", n = LOG_BASE - o.length, n && (u += getZeroString(n));
  } else if (f === 0)
    return "0";
  for (; f % 10 === 0; ) f /= 10;
  return u + f;
}
var divide = /* @__PURE__ */ function() {
  function t(o, l) {
    var u, f = 0, h = o.length;
    for (o = o.slice(); h--; )
      u = o[h] * l + f, o[h] = u % BASE | 0, f = u / BASE | 0;
    return f && o.unshift(f), o;
  }
  function e(o, l, u, f) {
    var h, p;
    if (u != f)
      p = u > f ? 1 : -1;
    else
      for (h = p = 0; h < u; h++)
        if (o[h] != l[h]) {
          p = o[h] > l[h] ? 1 : -1;
          break;
        }
    return p;
  }
  function n(o, l, u) {
    for (var f = 0; u--; )
      o[u] -= f, f = o[u] < l[u] ? 1 : 0, o[u] = f * BASE + o[u] - l[u];
    for (; !o[0] && o.length > 1; ) o.shift();
  }
  return function(o, l, u, f) {
    var h, p, v, g, w, E, T, R, _, b, M, A, $, S, C, D, O, N, j = o.constructor, L = o.s == l.s ? 1 : -1, z = o.d, G = l.d;
    if (!o.s) return new j(o);
    if (!l.s) throw Error(decimalError + "Division by zero");
    for (p = o.e - l.e, O = G.length, C = z.length, T = new j(L), R = T.d = [], v = 0; G[v] == (z[v] || 0); ) ++v;
    if (G[v] > (z[v] || 0) && --p, u == null ? A = u = j.precision : f ? A = u + (getBase10Exponent(o) - getBase10Exponent(l)) + 1 : A = u, A < 0) return new j(0);
    if (A = A / LOG_BASE + 2 | 0, v = 0, O == 1)
      for (g = 0, G = G[0], A++; (v < C || g) && A--; v++)
        $ = g * BASE + (z[v] || 0), R[v] = $ / G | 0, g = $ % G | 0;
    else {
      for (g = BASE / (G[0] + 1) | 0, g > 1 && (G = t(G, g), z = t(z, g), O = G.length, C = z.length), S = O, _ = z.slice(0, O), b = _.length; b < O; ) _[b++] = 0;
      N = G.slice(), N.unshift(0), D = G[0], G[1] >= BASE / 2 && ++D;
      do
        g = 0, h = e(G, _, O, b), h < 0 ? (M = _[0], O != b && (M = M * BASE + (_[1] || 0)), g = M / D | 0, g > 1 ? (g >= BASE && (g = BASE - 1), w = t(G, g), E = w.length, b = _.length, h = e(w, _, E, b), h == 1 && (g--, n(w, O < E ? N : G, E))) : (g == 0 && (h = g = 1), w = G.slice()), E = w.length, E < b && w.unshift(0), n(_, w, b), h == -1 && (b = _.length, h = e(G, _, O, b), h < 1 && (g++, n(_, O < b ? N : G, b))), b = _.length) : h === 0 && (g++, _ = [0]), R[v++] = g, h && _[0] ? _[b++] = z[S] || 0 : (_ = [z[S]], b = 1);
      while ((S++ < C || _[0] !== void 0) && A--);
    }
    return R[0] || R.shift(), T.e = p, round$1(T, f ? u + getBase10Exponent(T) + 1 : u);
  };
}();
function exp(t, e) {
  var n, o, l, u, f, h, p = 0, v = 0, g = t.constructor, w = g.precision;
  if (getBase10Exponent(t) > 16) throw Error(exponentOutOfRange + getBase10Exponent(t));
  if (!t.s) return new g(ONE);
  for (e == null ? (external = !1, h = w) : h = e, f = new g(0.03125); t.abs().gte(0.1); )
    t = t.times(f), v += 5;
  for (o = Math.log(mathpow(2, v)) / Math.LN10 * 2 + 5 | 0, h += o, n = l = u = new g(ONE), g.precision = h; ; ) {
    if (l = round$1(l.times(t), h), n = n.times(++p), f = u.plus(divide(l, n, h)), digitsToString(f.d).slice(0, h) === digitsToString(u.d).slice(0, h)) {
      for (; v--; ) u = round$1(u.times(u), h);
      return g.precision = w, e == null ? (external = !0, round$1(u, w)) : u;
    }
    u = f;
  }
}
function getBase10Exponent(t) {
  for (var e = t.e * LOG_BASE, n = t.d[0]; n >= 10; n /= 10) e++;
  return e;
}
function getLn10(t, e, n) {
  if (e > t.LN10.sd())
    throw external = !0, n && (t.precision = n), Error(decimalError + "LN10 precision limit exceeded");
  return round$1(new t(t.LN10), e);
}
function getZeroString(t) {
  for (var e = ""; t--; ) e += "0";
  return e;
}
function ln(t, e) {
  var n, o, l, u, f, h, p, v, g, w = 1, E = 10, T = t, R = T.d, _ = T.constructor, b = _.precision;
  if (T.s < 1) throw Error(decimalError + (T.s ? "NaN" : "-Infinity"));
  if (T.eq(ONE)) return new _(0);
  if (e == null ? (external = !1, v = b) : v = e, T.eq(10))
    return e == null && (external = !0), getLn10(_, v);
  if (v += E, _.precision = v, n = digitsToString(R), o = n.charAt(0), u = getBase10Exponent(T), Math.abs(u) < 15e14) {
    for (; o < 7 && o != 1 || o == 1 && n.charAt(1) > 3; )
      T = T.times(t), n = digitsToString(T.d), o = n.charAt(0), w++;
    u = getBase10Exponent(T), o > 1 ? (T = new _("0." + n), u++) : T = new _(o + "." + n.slice(1));
  } else
    return p = getLn10(_, v + 2, b).times(u + ""), T = ln(new _(o + "." + n.slice(1)), v - E).plus(p), _.precision = b, e == null ? (external = !0, round$1(T, b)) : T;
  for (h = f = T = divide(T.minus(ONE), T.plus(ONE), v), g = round$1(T.times(T), v), l = 3; ; ) {
    if (f = round$1(f.times(g), v), p = h.plus(divide(f, new _(l), v)), digitsToString(p.d).slice(0, v) === digitsToString(h.d).slice(0, v))
      return h = h.times(2), u !== 0 && (h = h.plus(getLn10(_, v + 2, b).times(u + ""))), h = divide(h, new _(w), v), _.precision = b, e == null ? (external = !0, round$1(h, b)) : h;
    h = p, l += 2;
  }
}
function parseDecimal(t, e) {
  var n, o, l;
  for ((n = e.indexOf(".")) > -1 && (e = e.replace(".", "")), (o = e.search(/e/i)) > 0 ? (n < 0 && (n = o), n += +e.slice(o + 1), e = e.substring(0, o)) : n < 0 && (n = e.length), o = 0; e.charCodeAt(o) === 48; ) ++o;
  for (l = e.length; e.charCodeAt(l - 1) === 48; ) --l;
  if (e = e.slice(o, l), e) {
    if (l -= o, n = n - o - 1, t.e = mathfloor(n / LOG_BASE), t.d = [], o = (n + 1) % LOG_BASE, n < 0 && (o += LOG_BASE), o < l) {
      for (o && t.d.push(+e.slice(0, o)), l -= LOG_BASE; o < l; ) t.d.push(+e.slice(o, o += LOG_BASE));
      e = e.slice(o), o = LOG_BASE - e.length;
    } else
      o -= l;
    for (; o--; ) e += "0";
    if (t.d.push(+e), external && (t.e > MAX_E || t.e < -MAX_E)) throw Error(exponentOutOfRange + n);
  } else
    t.s = 0, t.e = 0, t.d = [0];
  return t;
}
function round$1(t, e, n) {
  var o, l, u, f, h, p, v, g, w = t.d;
  for (f = 1, u = w[0]; u >= 10; u /= 10) f++;
  if (o = e - f, o < 0)
    o += LOG_BASE, l = e, v = w[g = 0];
  else {
    if (g = Math.ceil((o + 1) / LOG_BASE), u = w.length, g >= u) return t;
    for (v = u = w[g], f = 1; u >= 10; u /= 10) f++;
    o %= LOG_BASE, l = o - LOG_BASE + f;
  }
  if (n !== void 0 && (u = mathpow(10, f - l - 1), h = v / u % 10 | 0, p = e < 0 || w[g + 1] !== void 0 || v % u, p = n < 4 ? (h || p) && (n == 0 || n == (t.s < 0 ? 3 : 2)) : h > 5 || h == 5 && (n == 4 || p || n == 6 && // Check whether the digit to the left of the rounding digit is odd.
  (o > 0 ? l > 0 ? v / mathpow(10, f - l) : 0 : w[g - 1]) % 10 & 1 || n == (t.s < 0 ? 8 : 7))), e < 1 || !w[0])
    return p ? (u = getBase10Exponent(t), w.length = 1, e = e - u - 1, w[0] = mathpow(10, (LOG_BASE - e % LOG_BASE) % LOG_BASE), t.e = mathfloor(-e / LOG_BASE) || 0) : (w.length = 1, w[0] = t.e = t.s = 0), t;
  if (o == 0 ? (w.length = g, u = 1, g--) : (w.length = g + 1, u = mathpow(10, LOG_BASE - o), w[g] = l > 0 ? (v / mathpow(10, f - l) % mathpow(10, l) | 0) * u : 0), p)
    for (; ; )
      if (g == 0) {
        (w[0] += u) == BASE && (w[0] = 1, ++t.e);
        break;
      } else {
        if (w[g] += u, w[g] != BASE) break;
        w[g--] = 0, u = 1;
      }
  for (o = w.length; w[--o] === 0; ) w.pop();
  if (external && (t.e > MAX_E || t.e < -MAX_E))
    throw Error(exponentOutOfRange + getBase10Exponent(t));
  return t;
}
function subtract(t, e) {
  var n, o, l, u, f, h, p, v, g, w, E = t.constructor, T = E.precision;
  if (!t.s || !e.s)
    return e.s ? e.s = -e.s : e = new E(t), external ? round$1(e, T) : e;
  if (p = t.d, w = e.d, o = e.e, v = t.e, p = p.slice(), f = v - o, f) {
    for (g = f < 0, g ? (n = p, f = -f, h = w.length) : (n = w, o = v, h = p.length), l = Math.max(Math.ceil(T / LOG_BASE), h) + 2, f > l && (f = l, n.length = 1), n.reverse(), l = f; l--; ) n.push(0);
    n.reverse();
  } else {
    for (l = p.length, h = w.length, g = l < h, g && (h = l), l = 0; l < h; l++)
      if (p[l] != w[l]) {
        g = p[l] < w[l];
        break;
      }
    f = 0;
  }
  for (g && (n = p, p = w, w = n, e.s = -e.s), h = p.length, l = w.length - h; l > 0; --l) p[h++] = 0;
  for (l = w.length; l > f; ) {
    if (p[--l] < w[l]) {
      for (u = l; u && p[--u] === 0; ) p[u] = BASE - 1;
      --p[u], p[l] += BASE;
    }
    p[l] -= w[l];
  }
  for (; p[--h] === 0; ) p.pop();
  for (; p[0] === 0; p.shift()) --o;
  return p[0] ? (e.d = p, e.e = o, external ? round$1(e, T) : e) : new E(0);
}
function toString(t, e, n) {
  var o, l = getBase10Exponent(t), u = digitsToString(t.d), f = u.length;
  return e ? (n && (o = n - f) > 0 ? u = u.charAt(0) + "." + u.slice(1) + getZeroString(o) : f > 1 && (u = u.charAt(0) + "." + u.slice(1)), u = u + (l < 0 ? "e" : "e+") + l) : l < 0 ? (u = "0." + getZeroString(-l - 1) + u, n && (o = n - f) > 0 && (u += getZeroString(o))) : l >= f ? (u += getZeroString(l + 1 - f), n && (o = n - l - 1) > 0 && (u = u + "." + getZeroString(o))) : ((o = l + 1) < f && (u = u.slice(0, o) + "." + u.slice(o)), n && (o = n - f) > 0 && (l + 1 === f && (u += "."), u += getZeroString(o))), t.s < 0 ? "-" + u : u;
}
function truncate(t, e) {
  if (t.length > e)
    return t.length = e, !0;
}
function clone(t) {
  var e, n, o;
  function l(u) {
    var f = this;
    if (!(f instanceof l)) return new l(u);
    if (f.constructor = l, u instanceof l) {
      f.s = u.s, f.e = u.e, f.d = (u = u.d) ? u.slice() : u;
      return;
    }
    if (typeof u == "number") {
      if (u * 0 !== 0)
        throw Error(invalidArgument + u);
      if (u > 0)
        f.s = 1;
      else if (u < 0)
        u = -u, f.s = -1;
      else {
        f.s = 0, f.e = 0, f.d = [0];
        return;
      }
      if (u === ~~u && u < 1e7) {
        f.e = 0, f.d = [u];
        return;
      }
      return parseDecimal(f, u.toString());
    } else if (typeof u != "string")
      throw Error(invalidArgument + u);
    if (u.charCodeAt(0) === 45 ? (u = u.slice(1), f.s = -1) : f.s = 1, isDecimal.test(u)) parseDecimal(f, u);
    else throw Error(invalidArgument + u);
  }
  if (l.prototype = P, l.ROUND_UP = 0, l.ROUND_DOWN = 1, l.ROUND_CEIL = 2, l.ROUND_FLOOR = 3, l.ROUND_HALF_UP = 4, l.ROUND_HALF_DOWN = 5, l.ROUND_HALF_EVEN = 6, l.ROUND_HALF_CEIL = 7, l.ROUND_HALF_FLOOR = 8, l.clone = clone, l.config = l.set = config, t === void 0 && (t = {}), t)
    for (o = ["precision", "rounding", "toExpNeg", "toExpPos", "LN10"], e = 0; e < o.length; ) t.hasOwnProperty(n = o[e++]) || (t[n] = this[n]);
  return l.config(t), l;
}
function config(t) {
  if (!t || typeof t != "object")
    throw Error(decimalError + "Object expected");
  var e, n, o, l = [
    "precision",
    1,
    MAX_DIGITS,
    "rounding",
    0,
    8,
    "toExpNeg",
    -1 / 0,
    0,
    "toExpPos",
    0,
    1 / 0
  ];
  for (e = 0; e < l.length; e += 3)
    if ((o = t[n = l[e]]) !== void 0)
      if (mathfloor(o) === o && o >= l[e + 1] && o <= l[e + 2]) this[n] = o;
      else throw Error(invalidArgument + n + ": " + o);
  if ((o = t[n = "LN10"]) !== void 0)
    if (o == Math.LN10) this[n] = new this(o);
    else throw Error(invalidArgument + n + ": " + o);
  return this;
}
var Decimal = clone(defaults);
ONE = new Decimal(1);
const Decimal$1 = Decimal;
function _toConsumableArray$b(t) {
  return _arrayWithoutHoles$b(t) || _iterableToArray$c(t) || _unsupportedIterableToArray$h(t) || _nonIterableSpread$b();
}
function _nonIterableSpread$b() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function _unsupportedIterableToArray$h(t, e) {
  if (t) {
    if (typeof t == "string") return _arrayLikeToArray$h(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$h(t, e);
  }
}
function _iterableToArray$c(t) {
  if (typeof Symbol < "u" && Symbol.iterator in Object(t)) return Array.from(t);
}
function _arrayWithoutHoles$b(t) {
  if (Array.isArray(t)) return _arrayLikeToArray$h(t);
}
function _arrayLikeToArray$h(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, o = new Array(e); n < e; n++)
    o[n] = t[n];
  return o;
}
var identity$1 = function t(e) {
  return e;
}, PLACE_HOLDER = {
  "@@functional/placeholder": !0
}, isPlaceHolder = function t(e) {
  return e === PLACE_HOLDER;
}, curry0 = function t(e) {
  return function n() {
    return arguments.length === 0 || arguments.length === 1 && isPlaceHolder(arguments.length <= 0 ? void 0 : arguments[0]) ? n : e.apply(void 0, arguments);
  };
}, curryN = function t(e, n) {
  return e === 1 ? n : curry0(function() {
    for (var o = arguments.length, l = new Array(o), u = 0; u < o; u++)
      l[u] = arguments[u];
    var f = l.filter(function(h) {
      return h !== PLACE_HOLDER;
    }).length;
    return f >= e ? n.apply(void 0, l) : t(e - f, curry0(function() {
      for (var h = arguments.length, p = new Array(h), v = 0; v < h; v++)
        p[v] = arguments[v];
      var g = l.map(function(w) {
        return isPlaceHolder(w) ? p.shift() : w;
      });
      return n.apply(void 0, _toConsumableArray$b(g).concat(p));
    }));
  });
}, curry = function t(e) {
  return curryN(e.length, e);
}, range$2 = function t(e, n) {
  for (var o = [], l = e; l < n; ++l)
    o[l - e] = l;
  return o;
}, map = curry(function(t, e) {
  return Array.isArray(e) ? e.map(t) : Object.keys(e).map(function(n) {
    return e[n];
  }).map(t);
}), compose = function t() {
  for (var e = arguments.length, n = new Array(e), o = 0; o < e; o++)
    n[o] = arguments[o];
  if (!n.length)
    return identity$1;
  var l = n.reverse(), u = l[0], f = l.slice(1);
  return function() {
    return f.reduce(function(h, p) {
      return p(h);
    }, u.apply(void 0, arguments));
  };
}, reverse = function t(e) {
  return Array.isArray(e) ? e.reverse() : e.split("").reverse.join("");
}, memoize = function t(e) {
  var n = null, o = null;
  return function() {
    for (var l = arguments.length, u = new Array(l), f = 0; f < l; f++)
      u[f] = arguments[f];
    return n && u.every(function(h, p) {
      return h === n[p];
    }) || (n = u, o = e.apply(void 0, u)), o;
  };
};
function getDigitCount(t) {
  var e;
  return t === 0 ? e = 1 : e = Math.floor(new Decimal$1(t).abs().log(10).toNumber()) + 1, e;
}
function rangeStep(t, e, n) {
  for (var o = new Decimal$1(t), l = 0, u = []; o.lt(e) && l < 1e5; )
    u.push(o.toNumber()), o = o.add(n), l++;
  return u;
}
var interpolateNumber = curry(function(t, e, n) {
  var o = +t, l = +e;
  return o + n * (l - o);
}), uninterpolateNumber = curry(function(t, e, n) {
  var o = e - +t;
  return o = o || 1 / 0, (n - t) / o;
}), uninterpolateTruncation = curry(function(t, e, n) {
  var o = e - +t;
  return o = o || 1 / 0, Math.max(0, Math.min(1, (n - t) / o));
});
const Arithmetic = {
  rangeStep,
  getDigitCount,
  interpolateNumber,
  uninterpolateNumber,
  uninterpolateTruncation
};
function _toConsumableArray$a(t) {
  return _arrayWithoutHoles$a(t) || _iterableToArray$b(t) || _unsupportedIterableToArray$g(t) || _nonIterableSpread$a();
}
function _nonIterableSpread$a() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function _iterableToArray$b(t) {
  if (typeof Symbol < "u" && Symbol.iterator in Object(t)) return Array.from(t);
}
function _arrayWithoutHoles$a(t) {
  if (Array.isArray(t)) return _arrayLikeToArray$g(t);
}
function _slicedToArray$8(t, e) {
  return _arrayWithHoles$9(t) || _iterableToArrayLimit$8(t, e) || _unsupportedIterableToArray$g(t, e) || _nonIterableRest$9();
}
function _nonIterableRest$9() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function _unsupportedIterableToArray$g(t, e) {
  if (t) {
    if (typeof t == "string") return _arrayLikeToArray$g(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$g(t, e);
  }
}
function _arrayLikeToArray$g(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, o = new Array(e); n < e; n++)
    o[n] = t[n];
  return o;
}
function _iterableToArrayLimit$8(t, e) {
  if (!(typeof Symbol > "u" || !(Symbol.iterator in Object(t)))) {
    var n = [], o = !0, l = !1, u = void 0;
    try {
      for (var f = t[Symbol.iterator](), h; !(o = (h = f.next()).done) && (n.push(h.value), !(e && n.length === e)); o = !0)
        ;
    } catch (p) {
      l = !0, u = p;
    } finally {
      try {
        !o && f.return != null && f.return();
      } finally {
        if (l) throw u;
      }
    }
    return n;
  }
}
function _arrayWithHoles$9(t) {
  if (Array.isArray(t)) return t;
}
function getValidInterval(t) {
  var e = _slicedToArray$8(t, 2), n = e[0], o = e[1], l = n, u = o;
  return n > o && (l = o, u = n), [l, u];
}
function getFormatStep(t, e, n) {
  if (t.lte(0))
    return new Decimal$1(0);
  var o = Arithmetic.getDigitCount(t.toNumber()), l = new Decimal$1(10).pow(o), u = t.div(l), f = o !== 1 ? 0.05 : 0.1, h = new Decimal$1(Math.ceil(u.div(f).toNumber())).add(n).mul(f), p = h.mul(l);
  return e ? p : new Decimal$1(Math.ceil(p));
}
function getTickOfSingleValue(t, e, n) {
  var o = 1, l = new Decimal$1(t);
  if (!l.isint() && n) {
    var u = Math.abs(t);
    u < 1 ? (o = new Decimal$1(10).pow(Arithmetic.getDigitCount(t) - 1), l = new Decimal$1(Math.floor(l.div(o).toNumber())).mul(o)) : u > 1 && (l = new Decimal$1(Math.floor(t)));
  } else t === 0 ? l = new Decimal$1(Math.floor((e - 1) / 2)) : n || (l = new Decimal$1(Math.floor(t)));
  var f = Math.floor((e - 1) / 2), h = compose(map(function(p) {
    return l.add(new Decimal$1(p - f).mul(o)).toNumber();
  }), range$2);
  return h(0, e);
}
function calculateStep(t, e, n, o) {
  var l = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
  if (!Number.isFinite((e - t) / (n - 1)))
    return {
      step: new Decimal$1(0),
      tickMin: new Decimal$1(0),
      tickMax: new Decimal$1(0)
    };
  var u = getFormatStep(new Decimal$1(e).sub(t).div(n - 1), o, l), f;
  t <= 0 && e >= 0 ? f = new Decimal$1(0) : (f = new Decimal$1(t).add(e).div(2), f = f.sub(new Decimal$1(f).mod(u)));
  var h = Math.ceil(f.sub(t).div(u).toNumber()), p = Math.ceil(new Decimal$1(e).sub(f).div(u).toNumber()), v = h + p + 1;
  return v > n ? calculateStep(t, e, n, o, l + 1) : (v < n && (p = e > 0 ? p + (n - v) : p, h = e > 0 ? h : h + (n - v)), {
    step: u,
    tickMin: f.sub(new Decimal$1(h).mul(u)),
    tickMax: f.add(new Decimal$1(p).mul(u))
  });
}
function getNiceTickValuesFn(t) {
  var e = _slicedToArray$8(t, 2), n = e[0], o = e[1], l = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 6, u = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, f = Math.max(l, 2), h = getValidInterval([n, o]), p = _slicedToArray$8(h, 2), v = p[0], g = p[1];
  if (v === -1 / 0 || g === 1 / 0) {
    var w = g === 1 / 0 ? [v].concat(_toConsumableArray$a(range$2(0, l - 1).map(function() {
      return 1 / 0;
    }))) : [].concat(_toConsumableArray$a(range$2(0, l - 1).map(function() {
      return -1 / 0;
    })), [g]);
    return n > o ? reverse(w) : w;
  }
  if (v === g)
    return getTickOfSingleValue(v, l, u);
  var E = calculateStep(v, g, f, u), T = E.step, R = E.tickMin, _ = E.tickMax, b = Arithmetic.rangeStep(R, _.add(new Decimal$1(0.1).mul(T)), T);
  return n > o ? reverse(b) : b;
}
function getTickValuesFixedDomainFn(t, e) {
  var n = _slicedToArray$8(t, 2), o = n[0], l = n[1], u = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, f = getValidInterval([o, l]), h = _slicedToArray$8(f, 2), p = h[0], v = h[1];
  if (p === -1 / 0 || v === 1 / 0)
    return [o, l];
  if (p === v)
    return [p];
  var g = Math.max(e, 2), w = getFormatStep(new Decimal$1(v).sub(p).div(g - 1), u, 0), E = [].concat(_toConsumableArray$a(Arithmetic.rangeStep(new Decimal$1(p), new Decimal$1(v).sub(new Decimal$1(0.99).mul(w)), w)), [v]);
  return o > l ? reverse(E) : E;
}
var getNiceTickValues = memoize(getNiceTickValuesFn), getTickValuesFixedDomain = memoize(getTickValuesFixedDomainFn), isProduction = process.env.NODE_ENV === "production", prefix = "Invariant failed";
function invariant(t, e) {
  if (isProduction)
    throw new Error(prefix);
  var n = typeof e == "function" ? e() : e, o = n ? "".concat(prefix, ": ").concat(n) : prefix;
  throw new Error(o);
}
var _excluded$c = ["offset", "layout", "width", "dataKey", "data", "dataPointFormatter", "xAxis", "yAxis"];
function _extends$p() {
  return _extends$p = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }
    return t;
  }, _extends$p.apply(this, arguments);
}
function _slicedToArray$7(t, e) {
  return _arrayWithHoles$8(t) || _iterableToArrayLimit$7(t, e) || _unsupportedIterableToArray$f(t, e) || _nonIterableRest$8();
}
function _nonIterableRest$8() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function _unsupportedIterableToArray$f(t, e) {
  if (t) {
    if (typeof t == "string") return _arrayLikeToArray$f(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$f(t, e);
  }
}
function _arrayLikeToArray$f(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, o = new Array(e); n < e; n++) o[n] = t[n];
  return o;
}
function _iterableToArrayLimit$7(t, e) {
  var n = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
  if (n != null) {
    var o, l, u, f, h = [], p = !0, v = !1;
    try {
      if (u = (n = n.call(t)).next, e !== 0) for (; !(p = (o = u.call(n)).done) && (h.push(o.value), h.length !== e); p = !0) ;
    } catch (g) {
      v = !0, l = g;
    } finally {
      try {
        if (!p && n.return != null && (f = n.return(), Object(f) !== f)) return;
      } finally {
        if (v) throw l;
      }
    }
    return h;
  }
}
function _arrayWithHoles$8(t) {
  if (Array.isArray(t)) return t;
}
function _objectWithoutProperties$c(t, e) {
  if (t == null) return {};
  var n = _objectWithoutPropertiesLoose$d(t, e), o, l;
  if (Object.getOwnPropertySymbols) {
    var u = Object.getOwnPropertySymbols(t);
    for (l = 0; l < u.length; l++)
      o = u[l], !(e.indexOf(o) >= 0) && Object.prototype.propertyIsEnumerable.call(t, o) && (n[o] = t[o]);
  }
  return n;
}
function _objectWithoutPropertiesLoose$d(t, e) {
  if (t == null) return {};
  var n = {}, o = Object.keys(t), l, u;
  for (u = 0; u < o.length; u++)
    l = o[u], !(e.indexOf(l) >= 0) && (n[l] = t[l]);
  return n;
}
function ErrorBar(t) {
  var e = t.offset, n = t.layout, o = t.width, l = t.dataKey, u = t.data, f = t.dataPointFormatter, h = t.xAxis, p = t.yAxis, v = _objectWithoutProperties$c(t, _excluded$c), g = filterProps(v, !1);
  t.direction === "x" && h.type !== "number" && (process.env.NODE_ENV !== "production" ? invariant(!1, 'ErrorBar requires Axis type property to be "number".') : invariant());
  var w = u.map(function(E) {
    var T = f(E, l), R = T.x, _ = T.y, b = T.value, M = T.errorVal;
    if (!M)
      return null;
    var A = [], $, S;
    if (Array.isArray(M)) {
      var C = _slicedToArray$7(M, 2);
      $ = C[0], S = C[1];
    } else
      $ = S = M;
    if (n === "vertical") {
      var D = h.scale, O = _ + e, N = O + o, j = O - o, L = D(b - $), z = D(b + S);
      A.push({
        x1: z,
        y1: N,
        x2: z,
        y2: j
      }), A.push({
        x1: L,
        y1: O,
        x2: z,
        y2: O
      }), A.push({
        x1: L,
        y1: N,
        x2: L,
        y2: j
      });
    } else if (n === "horizontal") {
      var G = p.scale, B = R + e, F = B - o, H = B + o, W = G(b - $), V = G(b + S);
      A.push({
        x1: F,
        y1: V,
        x2: H,
        y2: V
      }), A.push({
        x1: B,
        y1: W,
        x2: B,
        y2: V
      }), A.push({
        x1: F,
        y1: W,
        x2: H,
        y2: W
      });
    }
    return /* @__PURE__ */ React__default.createElement(Layer, _extends$p({
      className: "recharts-errorBar",
      key: "bar-".concat(A.map(function(X) {
        return "".concat(X.x1, "-").concat(X.x2, "-").concat(X.y1, "-").concat(X.y2);
      }))
    }, g), A.map(function(X) {
      return /* @__PURE__ */ React__default.createElement("line", _extends$p({}, X, {
        key: "line-".concat(X.x1, "-").concat(X.x2, "-").concat(X.y1, "-").concat(X.y2)
      }));
    }));
  });
  return /* @__PURE__ */ React__default.createElement(Layer, {
    className: "recharts-errorBars"
  }, w);
}
ErrorBar.defaultProps = {
  stroke: "black",
  strokeWidth: 1.5,
  width: 5,
  offset: 0,
  layout: "horizontal"
};
ErrorBar.displayName = "ErrorBar";
function _typeof$x(t) {
  "@babel/helpers - typeof";
  return _typeof$x = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof$x(t);
}
function ownKeys$u(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(l) {
      return Object.getOwnPropertyDescriptor(t, l).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function _objectSpread$t(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ownKeys$u(Object(n), !0).forEach(function(o) {
      _defineProperty$v(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : ownKeys$u(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
function _defineProperty$v(t, e, n) {
  return e = _toPropertyKey$v(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function _toPropertyKey$v(t) {
  var e = _toPrimitive$v(t, "string");
  return _typeof$x(e) == "symbol" ? e : String(e);
}
function _toPrimitive$v(t, e) {
  if (_typeof$x(t) != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(t, e || "default");
    if (_typeof$x(o) != "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
var getLegendProps = function t(e) {
  var n = e.children, o = e.formattedGraphicalItems, l = e.legendWidth, u = e.legendContent, f = findChildByType(n, Legend);
  if (!f)
    return null;
  var h;
  return f.props && f.props.payload ? h = f.props && f.props.payload : u === "children" ? h = (o || []).reduce(function(p, v) {
    var g = v.item, w = v.props, E = w.sectors || w.data || [];
    return p.concat(E.map(function(T) {
      return {
        type: f.props.iconType || g.props.legendType,
        value: T.name,
        color: T.fill,
        payload: T
      };
    }));
  }, []) : h = (o || []).map(function(p) {
    var v = p.item, g = v.props, w = g.dataKey, E = g.name, T = g.legendType, R = g.hide;
    return {
      inactive: R,
      dataKey: w,
      type: f.props.iconType || T || "square",
      color: getMainColorOfGraphicItem(v),
      value: E || w,
      // @ts-expect-error property strokeDasharray is required in Payload but optional in props
      payload: v.props
    };
  }), _objectSpread$t(_objectSpread$t(_objectSpread$t({}, f.props), Legend.getWithHeight(f, l)), {}, {
    payload: h,
    item: f
  });
};
function _typeof$w(t) {
  "@babel/helpers - typeof";
  return _typeof$w = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof$w(t);
}
function ownKeys$t(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(l) {
      return Object.getOwnPropertyDescriptor(t, l).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function _objectSpread$s(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ownKeys$t(Object(n), !0).forEach(function(o) {
      _defineProperty$u(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : ownKeys$t(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
function _defineProperty$u(t, e, n) {
  return e = _toPropertyKey$u(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function _toPropertyKey$u(t) {
  var e = _toPrimitive$u(t, "string");
  return _typeof$w(e) == "symbol" ? e : String(e);
}
function _toPrimitive$u(t, e) {
  if (_typeof$w(t) != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(t, e || "default");
    if (_typeof$w(o) != "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function _toConsumableArray$9(t) {
  return _arrayWithoutHoles$9(t) || _iterableToArray$a(t) || _unsupportedIterableToArray$e(t) || _nonIterableSpread$9();
}
function _nonIterableSpread$9() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function _unsupportedIterableToArray$e(t, e) {
  if (t) {
    if (typeof t == "string") return _arrayLikeToArray$e(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$e(t, e);
  }
}
function _iterableToArray$a(t) {
  if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
}
function _arrayWithoutHoles$9(t) {
  if (Array.isArray(t)) return _arrayLikeToArray$e(t);
}
function _arrayLikeToArray$e(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, o = new Array(e); n < e; n++) o[n] = t[n];
  return o;
}
function getValueByDataKey(t, e, n) {
  return isNil$1(t) || isNil$1(e) ? n : isNumOrStr(e) ? get$2(t, e, n) : isFunction$3(e) ? e(t) : n;
}
function getDomainOfDataByKey(t, e, n, o) {
  var l = flatMap$1(t, function(h) {
    return getValueByDataKey(h, e);
  });
  if (n === "number") {
    var u = l.filter(function(h) {
      return isNumber(h) || parseFloat(h);
    });
    return u.length ? [min$2(u), max$2(u)] : [1 / 0, -1 / 0];
  }
  var f = o ? l.filter(function(h) {
    return !isNil$1(h);
  }) : l;
  return f.map(function(h) {
    return isNumOrStr(h) || h instanceof Date ? h : "";
  });
}
var calculateActiveTickIndex = function t(e) {
  var n, o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], l = arguments.length > 2 ? arguments[2] : void 0, u = arguments.length > 3 ? arguments[3] : void 0, f = -1, h = (n = o == null ? void 0 : o.length) !== null && n !== void 0 ? n : 0;
  if (h <= 1)
    return 0;
  if (u && u.axisType === "angleAxis" && Math.abs(Math.abs(u.range[1] - u.range[0]) - 360) <= 1e-6)
    for (var p = u.range, v = 0; v < h; v++) {
      var g = v > 0 ? l[v - 1].coordinate : l[h - 1].coordinate, w = l[v].coordinate, E = v >= h - 1 ? l[0].coordinate : l[v + 1].coordinate, T = void 0;
      if (mathSign(w - g) !== mathSign(E - w)) {
        var R = [];
        if (mathSign(E - w) === mathSign(p[1] - p[0])) {
          T = E;
          var _ = w + p[1] - p[0];
          R[0] = Math.min(_, (_ + g) / 2), R[1] = Math.max(_, (_ + g) / 2);
        } else {
          T = g;
          var b = E + p[1] - p[0];
          R[0] = Math.min(w, (b + w) / 2), R[1] = Math.max(w, (b + w) / 2);
        }
        var M = [Math.min(w, (T + w) / 2), Math.max(w, (T + w) / 2)];
        if (e > M[0] && e <= M[1] || e >= R[0] && e <= R[1]) {
          f = l[v].index;
          break;
        }
      } else {
        var A = Math.min(g, E), $ = Math.max(g, E);
        if (e > (A + w) / 2 && e <= ($ + w) / 2) {
          f = l[v].index;
          break;
        }
      }
    }
  else
    for (var S = 0; S < h; S++)
      if (S === 0 && e <= (o[S].coordinate + o[S + 1].coordinate) / 2 || S > 0 && S < h - 1 && e > (o[S].coordinate + o[S - 1].coordinate) / 2 && e <= (o[S].coordinate + o[S + 1].coordinate) / 2 || S === h - 1 && e > (o[S].coordinate + o[S - 1].coordinate) / 2) {
        f = o[S].index;
        break;
      }
  return f;
}, getMainColorOfGraphicItem = function t(e) {
  var n = e, o = n.type.displayName, l = e.props, u = l.stroke, f = l.fill, h;
  switch (o) {
    case "Line":
      h = u;
      break;
    case "Area":
    case "Radar":
      h = u && u !== "none" ? u : f;
      break;
    default:
      h = f;
      break;
  }
  return h;
}, getBarSizeList = function t(e) {
  var n = e.barSize, o = e.totalSize, l = e.stackGroups, u = l === void 0 ? {} : l;
  if (!u)
    return {};
  for (var f = {}, h = Object.keys(u), p = 0, v = h.length; p < v; p++)
    for (var g = u[h[p]].stackGroups, w = Object.keys(g), E = 0, T = w.length; E < T; E++) {
      var R = g[w[E]], _ = R.items, b = R.cateAxisId, M = _.filter(function(C) {
        return getDisplayName(C.type).indexOf("Bar") >= 0;
      });
      if (M && M.length) {
        var A = M[0].props.barSize, $ = M[0].props[b];
        f[$] || (f[$] = []);
        var S = isNil$1(A) ? n : A;
        f[$].push({
          item: M[0],
          stackList: M.slice(1),
          barSize: isNil$1(S) ? void 0 : getPercentValue(S, o, 0)
        });
      }
    }
  return f;
}, getBarPosition = function t(e) {
  var n = e.barGap, o = e.barCategoryGap, l = e.bandSize, u = e.sizeList, f = u === void 0 ? [] : u, h = e.maxBarSize, p = f.length;
  if (p < 1) return null;
  var v = getPercentValue(n, l, 0, !0), g, w = [];
  if (f[0].barSize === +f[0].barSize) {
    var E = !1, T = l / p, R = f.reduce(function(S, C) {
      return S + C.barSize || 0;
    }, 0);
    R += (p - 1) * v, R >= l && (R -= (p - 1) * v, v = 0), R >= l && T > 0 && (E = !0, T *= 0.9, R = p * T);
    var _ = (l - R) / 2 >> 0, b = {
      offset: _ - v,
      size: 0
    };
    g = f.reduce(function(S, C) {
      var D = {
        item: C.item,
        position: {
          offset: b.offset + b.size + v,
          // @ts-expect-error the type check above does not check for type number explicitly
          size: E ? T : C.barSize
        }
      }, O = [].concat(_toConsumableArray$9(S), [D]);
      return b = O[O.length - 1].position, C.stackList && C.stackList.length && C.stackList.forEach(function(N) {
        O.push({
          item: N,
          position: b
        });
      }), O;
    }, w);
  } else {
    var M = getPercentValue(o, l, 0, !0);
    l - 2 * M - (p - 1) * v <= 0 && (v = 0);
    var A = (l - 2 * M - (p - 1) * v) / p;
    A > 1 && (A >>= 0);
    var $ = h === +h ? Math.min(A, h) : A;
    g = f.reduce(function(S, C, D) {
      var O = [].concat(_toConsumableArray$9(S), [{
        item: C.item,
        position: {
          offset: M + (A + v) * D + (A - $) / 2,
          size: $
        }
      }]);
      return C.stackList && C.stackList.length && C.stackList.forEach(function(N) {
        O.push({
          item: N,
          position: O[O.length - 1].position
        });
      }), O;
    }, w);
  }
  return g;
}, appendOffsetOfLegend = function t(e, n, o, l) {
  var u = o.children, f = o.width, h = o.margin, p = f - (h.left || 0) - (h.right || 0), v = getLegendProps({
    children: u,
    legendWidth: p
  });
  if (v) {
    var g = l || {}, w = g.width, E = g.height, T = v.align, R = v.verticalAlign, _ = v.layout;
    if ((_ === "vertical" || _ === "horizontal" && R === "middle") && T !== "center" && isNumber(e[T]))
      return _objectSpread$s(_objectSpread$s({}, e), {}, _defineProperty$u({}, T, e[T] + (w || 0)));
    if ((_ === "horizontal" || _ === "vertical" && T === "center") && R !== "middle" && isNumber(e[R]))
      return _objectSpread$s(_objectSpread$s({}, e), {}, _defineProperty$u({}, R, e[R] + (E || 0)));
  }
  return e;
}, isErrorBarRelevantForAxis = function t(e, n, o) {
  return isNil$1(n) ? !0 : e === "horizontal" ? n === "yAxis" : e === "vertical" || o === "x" ? n === "xAxis" : o === "y" ? n === "yAxis" : !0;
}, getDomainOfErrorBars = function t(e, n, o, l, u) {
  var f = n.props.children, h = findAllByType(f, ErrorBar).filter(function(v) {
    return isErrorBarRelevantForAxis(l, u, v.props.direction);
  });
  if (h && h.length) {
    var p = h.map(function(v) {
      return v.props.dataKey;
    });
    return e.reduce(function(v, g) {
      var w = getValueByDataKey(g, o);
      if (isNil$1(w)) return v;
      var E = Array.isArray(w) ? [min$2(w), max$2(w)] : [w, w], T = p.reduce(function(R, _) {
        var b = getValueByDataKey(g, _, 0), M = E[0] - Math.abs(Array.isArray(b) ? b[0] : b), A = E[1] + Math.abs(Array.isArray(b) ? b[1] : b);
        return [Math.min(M, R[0]), Math.max(A, R[1])];
      }, [1 / 0, -1 / 0]);
      return [Math.min(T[0], v[0]), Math.max(T[1], v[1])];
    }, [1 / 0, -1 / 0]);
  }
  return null;
}, parseErrorBarsOfAxis = function t(e, n, o, l, u) {
  var f = n.map(function(h) {
    return getDomainOfErrorBars(e, h, o, u, l);
  }).filter(function(h) {
    return !isNil$1(h);
  });
  return f && f.length ? f.reduce(function(h, p) {
    return [Math.min(h[0], p[0]), Math.max(h[1], p[1])];
  }, [1 / 0, -1 / 0]) : null;
}, getDomainOfItemsWithSameAxis = function t(e, n, o, l, u) {
  var f = n.map(function(p) {
    var v = p.props.dataKey;
    return o === "number" && v && getDomainOfErrorBars(e, p, v, l) || getDomainOfDataByKey(e, v, o, u);
  });
  if (o === "number")
    return f.reduce(
      // @ts-expect-error if (type === number) means that the domain is numerical type
      // - but this link is missing in the type definition
      function(p, v) {
        return [Math.min(p[0], v[0]), Math.max(p[1], v[1])];
      },
      [1 / 0, -1 / 0]
    );
  var h = {};
  return f.reduce(function(p, v) {
    for (var g = 0, w = v.length; g < w; g++)
      h[v[g]] || (h[v[g]] = !0, p.push(v[g]));
    return p;
  }, []);
}, isCategoricalAxis = function t(e, n) {
  return e === "horizontal" && n === "xAxis" || e === "vertical" && n === "yAxis" || e === "centric" && n === "angleAxis" || e === "radial" && n === "radiusAxis";
}, getCoordinatesOfGrid = function t(e, n, o, l) {
  if (l)
    return e.map(function(p) {
      return p.coordinate;
    });
  var u, f, h = e.map(function(p) {
    return p.coordinate === n && (u = !0), p.coordinate === o && (f = !0), p.coordinate;
  });
  return u || h.push(n), f || h.push(o), h;
}, getTicksOfAxis = function t(e, n, o) {
  if (!e) return null;
  var l = e.scale, u = e.duplicateDomain, f = e.type, h = e.range, p = e.realScaleType === "scaleBand" ? l.bandwidth() / 2 : 2, v = (n || o) && f === "category" && l.bandwidth ? l.bandwidth() / p : 0;
  if (v = e.axisType === "angleAxis" && (h == null ? void 0 : h.length) >= 2 ? mathSign(h[0] - h[1]) * 2 * v : v, n && (e.ticks || e.niceTicks)) {
    var g = (e.ticks || e.niceTicks).map(function(w) {
      var E = u ? u.indexOf(w) : w;
      return {
        // If the scaleContent is not a number, the coordinate will be NaN.
        // That could be the case for example with a PointScale and a string as domain.
        coordinate: l(E) + v,
        value: w,
        offset: v
      };
    });
    return g.filter(function(w) {
      return !isNan(w.coordinate);
    });
  }
  return e.isCategorical && e.categoricalDomain ? e.categoricalDomain.map(function(w, E) {
    return {
      coordinate: l(w) + v,
      value: w,
      index: E,
      offset: v
    };
  }) : l.ticks && !o ? l.ticks(e.tickCount).map(function(w) {
    return {
      coordinate: l(w) + v,
      value: w,
      offset: v
    };
  }) : l.domain().map(function(w, E) {
    return {
      coordinate: l(w) + v,
      value: u ? u[w] : w,
      index: E,
      offset: v
    };
  });
}, handlerWeakMap = /* @__PURE__ */ new WeakMap(), combineEventHandlers = function t(e, n) {
  if (typeof n != "function")
    return e;
  handlerWeakMap.has(e) || handlerWeakMap.set(e, /* @__PURE__ */ new WeakMap());
  var o = handlerWeakMap.get(e);
  if (o.has(n))
    return o.get(n);
  var l = function() {
    e.apply(void 0, arguments), n.apply(void 0, arguments);
  };
  return o.set(n, l), l;
}, parseScale = function t(e, n, o) {
  var l = e.scale, u = e.type, f = e.layout, h = e.axisType;
  if (l === "auto")
    return f === "radial" && h === "radiusAxis" ? {
      scale: band(),
      realScaleType: "band"
    } : f === "radial" && h === "angleAxis" ? {
      scale: linear(),
      realScaleType: "linear"
    } : u === "category" && n && (n.indexOf("LineChart") >= 0 || n.indexOf("AreaChart") >= 0 || n.indexOf("ComposedChart") >= 0 && !o) ? {
      scale: point(),
      realScaleType: "point"
    } : u === "category" ? {
      scale: band(),
      realScaleType: "band"
    } : {
      scale: linear(),
      realScaleType: "linear"
    };
  if (isString$1(l)) {
    var p = "scale".concat(upperFirst$1(l));
    return {
      scale: (d3Scales[p] || point)(),
      realScaleType: d3Scales[p] ? p : "point"
    };
  }
  return isFunction$3(l) ? {
    scale: l
  } : {
    scale: point(),
    realScaleType: "point"
  };
}, EPS = 1e-4, checkDomainOfScale = function t(e) {
  var n = e.domain();
  if (!(!n || n.length <= 2)) {
    var o = n.length, l = e.range(), u = Math.min(l[0], l[1]) - EPS, f = Math.max(l[0], l[1]) + EPS, h = e(n[0]), p = e(n[o - 1]);
    (h < u || h > f || p < u || p > f) && e.domain([n[0], n[o - 1]]);
  }
}, findPositionOfBar = function t(e, n) {
  if (!e)
    return null;
  for (var o = 0, l = e.length; o < l; o++)
    if (e[o].item === n)
      return e[o].position;
  return null;
}, truncateByDomain = function t(e, n) {
  if (!n || n.length !== 2 || !isNumber(n[0]) || !isNumber(n[1]))
    return e;
  var o = Math.min(n[0], n[1]), l = Math.max(n[0], n[1]), u = [e[0], e[1]];
  return (!isNumber(e[0]) || e[0] < o) && (u[0] = o), (!isNumber(e[1]) || e[1] > l) && (u[1] = l), u[0] > l && (u[0] = l), u[1] < o && (u[1] = o), u;
}, offsetSign = function t(e) {
  var n = e.length;
  if (!(n <= 0))
    for (var o = 0, l = e[0].length; o < l; ++o)
      for (var u = 0, f = 0, h = 0; h < n; ++h) {
        var p = isNan(e[h][o][1]) ? e[h][o][0] : e[h][o][1];
        p >= 0 ? (e[h][o][0] = u, e[h][o][1] = u + p, u = e[h][o][1]) : (e[h][o][0] = f, e[h][o][1] = f + p, f = e[h][o][1]);
      }
}, offsetPositive = function t(e) {
  var n = e.length;
  if (!(n <= 0))
    for (var o = 0, l = e[0].length; o < l; ++o)
      for (var u = 0, f = 0; f < n; ++f) {
        var h = isNan(e[f][o][1]) ? e[f][o][0] : e[f][o][1];
        h >= 0 ? (e[f][o][0] = u, e[f][o][1] = u + h, u = e[f][o][1]) : (e[f][o][0] = 0, e[f][o][1] = 0);
      }
}, STACK_OFFSET_MAP = {
  sign: offsetSign,
  // @ts-expect-error definitelytyped types are incorrect
  expand: stackOffsetExpand,
  // @ts-expect-error definitelytyped types are incorrect
  none: stackOffsetNone,
  // @ts-expect-error definitelytyped types are incorrect
  silhouette: stackOffsetSilhouette,
  // @ts-expect-error definitelytyped types are incorrect
  wiggle: stackOffsetWiggle,
  positive: offsetPositive
}, getStackedData = function t(e, n, o) {
  var l = n.map(function(h) {
    return h.props.dataKey;
  }), u = STACK_OFFSET_MAP[o], f = shapeStack().keys(l).value(function(h, p) {
    return +getValueByDataKey(h, p, 0);
  }).order(stackOrderNone).offset(u);
  return f(e);
}, getStackGroupsByAxisId = function t(e, n, o, l, u, f) {
  if (!e)
    return null;
  var h = f ? n.reverse() : n, p = {}, v = h.reduce(function(w, E) {
    var T = E.props, R = T.stackId, _ = T.hide;
    if (_)
      return w;
    var b = E.props[o], M = w[b] || {
      hasStack: !1,
      stackGroups: {}
    };
    if (isNumOrStr(R)) {
      var A = M.stackGroups[R] || {
        numericAxisId: o,
        cateAxisId: l,
        items: []
      };
      A.items.push(E), M.hasStack = !0, M.stackGroups[R] = A;
    } else
      M.stackGroups[uniqueId("_stackId_")] = {
        numericAxisId: o,
        cateAxisId: l,
        items: [E]
      };
    return _objectSpread$s(_objectSpread$s({}, w), {}, _defineProperty$u({}, b, M));
  }, p), g = {};
  return Object.keys(v).reduce(function(w, E) {
    var T = v[E];
    if (T.hasStack) {
      var R = {};
      T.stackGroups = Object.keys(T.stackGroups).reduce(function(_, b) {
        var M = T.stackGroups[b];
        return _objectSpread$s(_objectSpread$s({}, _), {}, _defineProperty$u({}, b, {
          numericAxisId: o,
          cateAxisId: l,
          items: M.items,
          stackedData: getStackedData(e, M.items, u)
        }));
      }, R);
    }
    return _objectSpread$s(_objectSpread$s({}, w), {}, _defineProperty$u({}, E, T));
  }, g);
}, getTicksOfScale = function t(e, n) {
  var o = n.realScaleType, l = n.type, u = n.tickCount, f = n.originalDomain, h = n.allowDecimals, p = o || n.scale;
  if (p !== "auto" && p !== "linear")
    return null;
  if (u && l === "number" && f && (f[0] === "auto" || f[1] === "auto")) {
    var v = e.domain();
    if (!v.length)
      return null;
    var g = getNiceTickValues(v, u, h);
    return e.domain([min$2(g), max$2(g)]), {
      niceTicks: g
    };
  }
  if (u && l === "number") {
    var w = e.domain(), E = getTickValuesFixedDomain(w, u, h);
    return {
      niceTicks: E
    };
  }
  return null;
}, getCateCoordinateOfBar = function t(e) {
  var n = e.axis, o = e.ticks, l = e.offset, u = e.bandSize, f = e.entry, h = e.index;
  if (n.type === "category")
    return o[h] ? o[h].coordinate + l : null;
  var p = getValueByDataKey(f, n.dataKey, n.domain[h]);
  return isNil$1(p) ? null : n.scale(p) - u / 2 + l;
}, getBaseValueOfBar = function t(e) {
  var n = e.numericAxis, o = n.scale.domain();
  if (n.type === "number") {
    var l = Math.min(o[0], o[1]), u = Math.max(o[0], o[1]);
    return l <= 0 && u >= 0 ? 0 : u < 0 ? u : l;
  }
  return o[0];
}, getStackedDataOfItem = function t(e, n) {
  var o = e.props.stackId;
  if (isNumOrStr(o)) {
    var l = n[o];
    if (l) {
      var u = l.items.indexOf(e);
      return u >= 0 ? l.stackedData[u] : null;
    }
  }
  return null;
}, getDomainOfSingle = function t(e) {
  return e.reduce(function(n, o) {
    return [min$2(o.concat([n[0]]).filter(isNumber)), max$2(o.concat([n[1]]).filter(isNumber))];
  }, [1 / 0, -1 / 0]);
}, getDomainOfStackGroups = function t(e, n, o) {
  return Object.keys(e).reduce(function(l, u) {
    var f = e[u], h = f.stackedData, p = h.reduce(function(v, g) {
      var w = getDomainOfSingle(g.slice(n, o + 1));
      return [Math.min(v[0], w[0]), Math.max(v[1], w[1])];
    }, [1 / 0, -1 / 0]);
    return [Math.min(p[0], l[0]), Math.max(p[1], l[1])];
  }, [1 / 0, -1 / 0]).map(function(l) {
    return l === 1 / 0 || l === -1 / 0 ? 0 : l;
  });
}, MIN_VALUE_REG = /^dataMin[\s]*-[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/, MAX_VALUE_REG = /^dataMax[\s]*\+[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/, parseSpecifiedDomain = function t(e, n, o) {
  if (isFunction$3(e))
    return e(n, o);
  if (!Array.isArray(e))
    return n;
  var l = [];
  if (isNumber(e[0]))
    l[0] = o ? e[0] : Math.min(e[0], n[0]);
  else if (MIN_VALUE_REG.test(e[0])) {
    var u = +MIN_VALUE_REG.exec(e[0])[1];
    l[0] = n[0] - u;
  } else isFunction$3(e[0]) ? l[0] = e[0](n[0]) : l[0] = n[0];
  if (isNumber(e[1]))
    l[1] = o ? e[1] : Math.max(e[1], n[1]);
  else if (MAX_VALUE_REG.test(e[1])) {
    var f = +MAX_VALUE_REG.exec(e[1])[1];
    l[1] = n[1] + f;
  } else isFunction$3(e[1]) ? l[1] = e[1](n[1]) : l[1] = n[1];
  return l;
}, getBandSizeOfAxis = function t(e, n, o) {
  if (e && e.scale && e.scale.bandwidth) {
    var l = e.scale.bandwidth();
    if (!o || l > 0)
      return l;
  }
  if (e && n && n.length >= 2) {
    for (var u = sortBy$1(n, function(w) {
      return w.coordinate;
    }), f = 1 / 0, h = 1, p = u.length; h < p; h++) {
      var v = u[h], g = u[h - 1];
      f = Math.min((v.coordinate || 0) - (g.coordinate || 0), f);
    }
    return f === 1 / 0 ? 0 : f;
  }
  return o ? void 0 : 0;
}, parseDomainOfCategoryAxis = function t(e, n, o) {
  return !e || !e.length || isEqual$2(e, get$2(o, "type.defaultProps.domain")) ? n : e;
}, getTooltipItem = function t(e, n) {
  var o = e.props, l = o.dataKey, u = o.name, f = o.unit, h = o.formatter, p = o.tooltipType, v = o.chartType, g = o.hide;
  return _objectSpread$s(_objectSpread$s({}, filterProps(e, !1)), {}, {
    dataKey: l,
    unit: f,
    formatter: h,
    name: u || l,
    color: getMainColorOfGraphicItem(e),
    value: getValueByDataKey(n, l),
    type: p,
    payload: n,
    chartType: v,
    hide: g
  });
};
function _typeof$v(t) {
  "@babel/helpers - typeof";
  return _typeof$v = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof$v(t);
}
function ownKeys$s(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(l) {
      return Object.getOwnPropertyDescriptor(t, l).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function _objectSpread$r(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ownKeys$s(Object(n), !0).forEach(function(o) {
      _defineProperty$t(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : ownKeys$s(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
function _defineProperty$t(t, e, n) {
  return e = _toPropertyKey$t(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function _toPropertyKey$t(t) {
  var e = _toPrimitive$t(t, "string");
  return _typeof$v(e) == "symbol" ? e : String(e);
}
function _toPrimitive$t(t, e) {
  if (_typeof$v(t) != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(t, e || "default");
    if (_typeof$v(o) != "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function _slicedToArray$6(t, e) {
  return _arrayWithHoles$7(t) || _iterableToArrayLimit$6(t, e) || _unsupportedIterableToArray$d(t, e) || _nonIterableRest$7();
}
function _nonIterableRest$7() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function _unsupportedIterableToArray$d(t, e) {
  if (t) {
    if (typeof t == "string") return _arrayLikeToArray$d(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$d(t, e);
  }
}
function _arrayLikeToArray$d(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, o = new Array(e); n < e; n++) o[n] = t[n];
  return o;
}
function _iterableToArrayLimit$6(t, e) {
  var n = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
  if (n != null) {
    var o, l, u, f, h = [], p = !0, v = !1;
    try {
      if (u = (n = n.call(t)).next, e !== 0) for (; !(p = (o = u.call(n)).done) && (h.push(o.value), h.length !== e); p = !0) ;
    } catch (g) {
      v = !0, l = g;
    } finally {
      try {
        if (!p && n.return != null && (f = n.return(), Object(f) !== f)) return;
      } finally {
        if (v) throw l;
      }
    }
    return h;
  }
}
function _arrayWithHoles$7(t) {
  if (Array.isArray(t)) return t;
}
var RADIAN$1 = Math.PI / 180, radianToDegree = function t(e) {
  return e * 180 / Math.PI;
}, polarToCartesian = function t(e, n, o, l) {
  return {
    x: e + Math.cos(-RADIAN$1 * l) * o,
    y: n + Math.sin(-RADIAN$1 * l) * o
  };
}, getMaxRadius = function t(e, n) {
  var o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
  return Math.min(Math.abs(e - (o.left || 0) - (o.right || 0)), Math.abs(n - (o.top || 0) - (o.bottom || 0))) / 2;
}, formatAxisMap$1 = function t(e, n, o, l, u) {
  var f = e.width, h = e.height, p = e.startAngle, v = e.endAngle, g = getPercentValue(e.cx, f, f / 2), w = getPercentValue(e.cy, h, h / 2), E = getMaxRadius(f, h, o), T = getPercentValue(e.innerRadius, E, 0), R = getPercentValue(e.outerRadius, E, E * 0.8), _ = Object.keys(n);
  return _.reduce(function(b, M) {
    var A = n[M], $ = A.domain, S = A.reversed, C;
    if (isNil$1(A.range))
      l === "angleAxis" ? C = [p, v] : l === "radiusAxis" && (C = [T, R]), S && (C = [C[1], C[0]]);
    else {
      C = A.range;
      var D = C, O = _slicedToArray$6(D, 2);
      p = O[0], v = O[1];
    }
    var N = parseScale(A, u), j = N.realScaleType, L = N.scale;
    L.domain($).range(C), checkDomainOfScale(L);
    var z = getTicksOfScale(L, _objectSpread$r(_objectSpread$r({}, A), {}, {
      realScaleType: j
    })), G = _objectSpread$r(_objectSpread$r(_objectSpread$r({}, A), z), {}, {
      range: C,
      radius: R,
      realScaleType: j,
      scale: L,
      cx: g,
      cy: w,
      innerRadius: T,
      outerRadius: R,
      startAngle: p,
      endAngle: v
    });
    return _objectSpread$r(_objectSpread$r({}, b), {}, _defineProperty$t({}, M, G));
  }, {});
}, distanceBetweenPoints = function t(e, n) {
  var o = e.x, l = e.y, u = n.x, f = n.y;
  return Math.sqrt(Math.pow(o - u, 2) + Math.pow(l - f, 2));
}, getAngleOfPoint = function t(e, n) {
  var o = e.x, l = e.y, u = n.cx, f = n.cy, h = distanceBetweenPoints({
    x: o,
    y: l
  }, {
    x: u,
    y: f
  });
  if (h <= 0)
    return {
      radius: h
    };
  var p = (o - u) / h, v = Math.acos(p);
  return l > f && (v = 2 * Math.PI - v), {
    radius: h,
    angle: radianToDegree(v),
    angleInRadian: v
  };
}, formatAngleOfSector = function t(e) {
  var n = e.startAngle, o = e.endAngle, l = Math.floor(n / 360), u = Math.floor(o / 360), f = Math.min(l, u);
  return {
    startAngle: n - f * 360,
    endAngle: o - f * 360
  };
}, reverseFormatAngleOfSetor = function t(e, n) {
  var o = n.startAngle, l = n.endAngle, u = Math.floor(o / 360), f = Math.floor(l / 360), h = Math.min(u, f);
  return e + h * 360;
}, inRangeOfSector = function t(e, n) {
  var o = e.x, l = e.y, u = getAngleOfPoint({
    x: o,
    y: l
  }, n), f = u.radius, h = u.angle, p = n.innerRadius, v = n.outerRadius;
  if (f < p || f > v)
    return !1;
  if (f === 0)
    return !0;
  var g = formatAngleOfSector(n), w = g.startAngle, E = g.endAngle, T = h, R;
  if (w <= E) {
    for (; T > E; )
      T -= 360;
    for (; T < w; )
      T += 360;
    R = T >= w && T <= E;
  } else {
    for (; T > w; )
      T -= 360;
    for (; T < E; )
      T += 360;
    R = T >= E && T <= w;
  }
  return R ? _objectSpread$r(_objectSpread$r({}, n), {}, {
    radius: f,
    angle: reverseFormatAngleOfSetor(T, n)
  }) : null;
}, getTickClassName = function t(e) {
  return !/* @__PURE__ */ isValidElement(e) && !isFunction$3(e) && typeof e != "boolean" ? e.className : "";
};
function _typeof$u(t) {
  "@babel/helpers - typeof";
  return _typeof$u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof$u(t);
}
var _excluded$b = ["offset"];
function _toConsumableArray$8(t) {
  return _arrayWithoutHoles$8(t) || _iterableToArray$9(t) || _unsupportedIterableToArray$c(t) || _nonIterableSpread$8();
}
function _nonIterableSpread$8() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function _unsupportedIterableToArray$c(t, e) {
  if (t) {
    if (typeof t == "string") return _arrayLikeToArray$c(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$c(t, e);
  }
}
function _iterableToArray$9(t) {
  if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
}
function _arrayWithoutHoles$8(t) {
  if (Array.isArray(t)) return _arrayLikeToArray$c(t);
}
function _arrayLikeToArray$c(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, o = new Array(e); n < e; n++) o[n] = t[n];
  return o;
}
function _objectWithoutProperties$b(t, e) {
  if (t == null) return {};
  var n = _objectWithoutPropertiesLoose$c(t, e), o, l;
  if (Object.getOwnPropertySymbols) {
    var u = Object.getOwnPropertySymbols(t);
    for (l = 0; l < u.length; l++)
      o = u[l], !(e.indexOf(o) >= 0) && Object.prototype.propertyIsEnumerable.call(t, o) && (n[o] = t[o]);
  }
  return n;
}
function _objectWithoutPropertiesLoose$c(t, e) {
  if (t == null) return {};
  var n = {}, o = Object.keys(t), l, u;
  for (u = 0; u < o.length; u++)
    l = o[u], !(e.indexOf(l) >= 0) && (n[l] = t[l]);
  return n;
}
function ownKeys$r(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(l) {
      return Object.getOwnPropertyDescriptor(t, l).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function _objectSpread$q(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ownKeys$r(Object(n), !0).forEach(function(o) {
      _defineProperty$s(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : ownKeys$r(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
function _defineProperty$s(t, e, n) {
  return e = _toPropertyKey$s(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function _toPropertyKey$s(t) {
  var e = _toPrimitive$s(t, "string");
  return _typeof$u(e) == "symbol" ? e : String(e);
}
function _toPrimitive$s(t, e) {
  if (_typeof$u(t) != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(t, e || "default");
    if (_typeof$u(o) != "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function _extends$o() {
  return _extends$o = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }
    return t;
  }, _extends$o.apply(this, arguments);
}
var getLabel = function t(e) {
  var n = e.value, o = e.formatter, l = isNil$1(e.children) ? n : e.children;
  return isFunction$3(o) ? o(l) : l;
}, getDeltaAngle$1 = function t(e, n) {
  var o = mathSign(n - e), l = Math.min(Math.abs(n - e), 360);
  return o * l;
}, renderRadialLabel = function t(e, n, o) {
  var l = e.position, u = e.viewBox, f = e.offset, h = e.className, p = u, v = p.cx, g = p.cy, w = p.innerRadius, E = p.outerRadius, T = p.startAngle, R = p.endAngle, _ = p.clockWise, b = (w + E) / 2, M = getDeltaAngle$1(T, R), A = M >= 0 ? 1 : -1, $, S;
  l === "insideStart" ? ($ = T + A * f, S = _) : l === "insideEnd" ? ($ = R - A * f, S = !_) : l === "end" && ($ = R + A * f, S = _), S = M <= 0 ? S : !S;
  var C = polarToCartesian(v, g, b, $), D = polarToCartesian(v, g, b, $ + (S ? 1 : -1) * 359), O = "M".concat(C.x, ",").concat(C.y, `
    A`).concat(b, ",").concat(b, ",0,1,").concat(S ? 0 : 1, `,
    `).concat(D.x, ",").concat(D.y), N = isNil$1(e.id) ? uniqueId("recharts-radial-line-") : e.id;
  return /* @__PURE__ */ React__default.createElement("text", _extends$o({}, o, {
    dominantBaseline: "central",
    className: clsx$1("recharts-radial-bar-label", h)
  }), /* @__PURE__ */ React__default.createElement("defs", null, /* @__PURE__ */ React__default.createElement("path", {
    id: N,
    d: O
  })), /* @__PURE__ */ React__default.createElement("textPath", {
    xlinkHref: "#".concat(N)
  }, n));
}, getAttrsOfPolarLabel = function t(e) {
  var n = e.viewBox, o = e.offset, l = e.position, u = n, f = u.cx, h = u.cy, p = u.innerRadius, v = u.outerRadius, g = u.startAngle, w = u.endAngle, E = (g + w) / 2;
  if (l === "outside") {
    var T = polarToCartesian(f, h, v + o, E), R = T.x, _ = T.y;
    return {
      x: R,
      y: _,
      textAnchor: R >= f ? "start" : "end",
      verticalAnchor: "middle"
    };
  }
  if (l === "center")
    return {
      x: f,
      y: h,
      textAnchor: "middle",
      verticalAnchor: "middle"
    };
  if (l === "centerTop")
    return {
      x: f,
      y: h,
      textAnchor: "middle",
      verticalAnchor: "start"
    };
  if (l === "centerBottom")
    return {
      x: f,
      y: h,
      textAnchor: "middle",
      verticalAnchor: "end"
    };
  var b = (p + v) / 2, M = polarToCartesian(f, h, b, E), A = M.x, $ = M.y;
  return {
    x: A,
    y: $,
    textAnchor: "middle",
    verticalAnchor: "middle"
  };
}, getAttrsOfCartesianLabel = function t(e) {
  var n = e.viewBox, o = e.parentViewBox, l = e.offset, u = e.position, f = n, h = f.x, p = f.y, v = f.width, g = f.height, w = g >= 0 ? 1 : -1, E = w * l, T = w > 0 ? "end" : "start", R = w > 0 ? "start" : "end", _ = v >= 0 ? 1 : -1, b = _ * l, M = _ > 0 ? "end" : "start", A = _ > 0 ? "start" : "end";
  if (u === "top") {
    var $ = {
      x: h + v / 2,
      y: p - w * l,
      textAnchor: "middle",
      verticalAnchor: T
    };
    return _objectSpread$q(_objectSpread$q({}, $), o ? {
      height: Math.max(p - o.y, 0),
      width: v
    } : {});
  }
  if (u === "bottom") {
    var S = {
      x: h + v / 2,
      y: p + g + E,
      textAnchor: "middle",
      verticalAnchor: R
    };
    return _objectSpread$q(_objectSpread$q({}, S), o ? {
      height: Math.max(o.y + o.height - (p + g), 0),
      width: v
    } : {});
  }
  if (u === "left") {
    var C = {
      x: h - b,
      y: p + g / 2,
      textAnchor: M,
      verticalAnchor: "middle"
    };
    return _objectSpread$q(_objectSpread$q({}, C), o ? {
      width: Math.max(C.x - o.x, 0),
      height: g
    } : {});
  }
  if (u === "right") {
    var D = {
      x: h + v + b,
      y: p + g / 2,
      textAnchor: A,
      verticalAnchor: "middle"
    };
    return _objectSpread$q(_objectSpread$q({}, D), o ? {
      width: Math.max(o.x + o.width - D.x, 0),
      height: g
    } : {});
  }
  var O = o ? {
    width: v,
    height: g
  } : {};
  return u === "insideLeft" ? _objectSpread$q({
    x: h + b,
    y: p + g / 2,
    textAnchor: A,
    verticalAnchor: "middle"
  }, O) : u === "insideRight" ? _objectSpread$q({
    x: h + v - b,
    y: p + g / 2,
    textAnchor: M,
    verticalAnchor: "middle"
  }, O) : u === "insideTop" ? _objectSpread$q({
    x: h + v / 2,
    y: p + E,
    textAnchor: "middle",
    verticalAnchor: R
  }, O) : u === "insideBottom" ? _objectSpread$q({
    x: h + v / 2,
    y: p + g - E,
    textAnchor: "middle",
    verticalAnchor: T
  }, O) : u === "insideTopLeft" ? _objectSpread$q({
    x: h + b,
    y: p + E,
    textAnchor: A,
    verticalAnchor: R
  }, O) : u === "insideTopRight" ? _objectSpread$q({
    x: h + v - b,
    y: p + E,
    textAnchor: M,
    verticalAnchor: R
  }, O) : u === "insideBottomLeft" ? _objectSpread$q({
    x: h + b,
    y: p + g - E,
    textAnchor: A,
    verticalAnchor: T
  }, O) : u === "insideBottomRight" ? _objectSpread$q({
    x: h + v - b,
    y: p + g - E,
    textAnchor: M,
    verticalAnchor: T
  }, O) : isObject$8(u) && (isNumber(u.x) || isPercent(u.x)) && (isNumber(u.y) || isPercent(u.y)) ? _objectSpread$q({
    x: h + getPercentValue(u.x, v),
    y: p + getPercentValue(u.y, g),
    textAnchor: "end",
    verticalAnchor: "end"
  }, O) : _objectSpread$q({
    x: h + v / 2,
    y: p + g / 2,
    textAnchor: "middle",
    verticalAnchor: "middle"
  }, O);
}, isPolar = function t(e) {
  return "cx" in e && isNumber(e.cx);
};
function Label(t) {
  var e = t.offset, n = e === void 0 ? 5 : e, o = _objectWithoutProperties$b(t, _excluded$b), l = _objectSpread$q({
    offset: n
  }, o), u = l.viewBox, f = l.position, h = l.value, p = l.children, v = l.content, g = l.className, w = g === void 0 ? "" : g, E = l.textBreakAll;
  if (!u || isNil$1(h) && isNil$1(p) && !/* @__PURE__ */ isValidElement(v) && !isFunction$3(v))
    return null;
  if (/* @__PURE__ */ isValidElement(v))
    return /* @__PURE__ */ cloneElement(v, l);
  var T;
  if (isFunction$3(v)) {
    if (T = /* @__PURE__ */ createElement(v, l), /* @__PURE__ */ isValidElement(T))
      return T;
  } else
    T = getLabel(l);
  var R = isPolar(u), _ = filterProps(l, !0);
  if (R && (f === "insideStart" || f === "insideEnd" || f === "end"))
    return renderRadialLabel(l, T, _);
  var b = R ? getAttrsOfPolarLabel(l) : getAttrsOfCartesianLabel(l);
  return /* @__PURE__ */ React__default.createElement(Text, _extends$o({
    className: clsx$1("recharts-label", w)
  }, _, b, {
    breakAll: E
  }), T);
}
Label.displayName = "Label";
var parseViewBox = function t(e) {
  var n = e.cx, o = e.cy, l = e.angle, u = e.startAngle, f = e.endAngle, h = e.r, p = e.radius, v = e.innerRadius, g = e.outerRadius, w = e.x, E = e.y, T = e.top, R = e.left, _ = e.width, b = e.height, M = e.clockWise, A = e.labelViewBox;
  if (A)
    return A;
  if (isNumber(_) && isNumber(b)) {
    if (isNumber(w) && isNumber(E))
      return {
        x: w,
        y: E,
        width: _,
        height: b
      };
    if (isNumber(T) && isNumber(R))
      return {
        x: T,
        y: R,
        width: _,
        height: b
      };
  }
  return isNumber(w) && isNumber(E) ? {
    x: w,
    y: E,
    width: 0,
    height: 0
  } : isNumber(n) && isNumber(o) ? {
    cx: n,
    cy: o,
    startAngle: u || l || 0,
    endAngle: f || l || 0,
    innerRadius: v || 0,
    outerRadius: g || p || h || 0,
    clockWise: M
  } : e.viewBox ? e.viewBox : {};
}, parseLabel = function t(e, n) {
  return e ? e === !0 ? /* @__PURE__ */ React__default.createElement(Label, {
    key: "label-implicit",
    viewBox: n
  }) : isNumOrStr(e) ? /* @__PURE__ */ React__default.createElement(Label, {
    key: "label-implicit",
    viewBox: n,
    value: e
  }) : /* @__PURE__ */ isValidElement(e) ? e.type === Label ? /* @__PURE__ */ cloneElement(e, {
    key: "label-implicit",
    viewBox: n
  }) : /* @__PURE__ */ React__default.createElement(Label, {
    key: "label-implicit",
    content: e,
    viewBox: n
  }) : isFunction$3(e) ? /* @__PURE__ */ React__default.createElement(Label, {
    key: "label-implicit",
    content: e,
    viewBox: n
  }) : isObject$8(e) ? /* @__PURE__ */ React__default.createElement(Label, _extends$o({
    viewBox: n
  }, e, {
    key: "label-implicit"
  })) : null : null;
}, renderCallByParent$1 = function t(e, n) {
  var o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
  if (!e || !e.children && o && !e.label)
    return null;
  var l = e.children, u = parseViewBox(e), f = findAllByType(l, Label).map(function(p, v) {
    return /* @__PURE__ */ cloneElement(p, {
      viewBox: n || u,
      // eslint-disable-next-line react/no-array-index-key
      key: "label-".concat(v)
    });
  });
  if (!o)
    return f;
  var h = parseLabel(e.label, n || u);
  return [h].concat(_toConsumableArray$8(f));
};
Label.parseViewBox = parseViewBox;
Label.renderCallByParent = renderCallByParent$1;
function last(t) {
  var e = t == null ? 0 : t.length;
  return e ? t[e - 1] : void 0;
}
var last_1 = last;
const last$1 = /* @__PURE__ */ getDefaultExportFromCjs(last_1);
function _typeof$t(t) {
  "@babel/helpers - typeof";
  return _typeof$t = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof$t(t);
}
var _excluded$a = ["valueAccessor"], _excluded2$4 = ["data", "dataKey", "clockWise", "id", "textBreakAll"];
function _toConsumableArray$7(t) {
  return _arrayWithoutHoles$7(t) || _iterableToArray$8(t) || _unsupportedIterableToArray$b(t) || _nonIterableSpread$7();
}
function _nonIterableSpread$7() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function _unsupportedIterableToArray$b(t, e) {
  if (t) {
    if (typeof t == "string") return _arrayLikeToArray$b(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$b(t, e);
  }
}
function _iterableToArray$8(t) {
  if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
}
function _arrayWithoutHoles$7(t) {
  if (Array.isArray(t)) return _arrayLikeToArray$b(t);
}
function _arrayLikeToArray$b(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, o = new Array(e); n < e; n++) o[n] = t[n];
  return o;
}
function _extends$n() {
  return _extends$n = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }
    return t;
  }, _extends$n.apply(this, arguments);
}
function ownKeys$q(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(l) {
      return Object.getOwnPropertyDescriptor(t, l).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function _objectSpread$p(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ownKeys$q(Object(n), !0).forEach(function(o) {
      _defineProperty$r(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : ownKeys$q(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
function _defineProperty$r(t, e, n) {
  return e = _toPropertyKey$r(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function _toPropertyKey$r(t) {
  var e = _toPrimitive$r(t, "string");
  return _typeof$t(e) == "symbol" ? e : String(e);
}
function _toPrimitive$r(t, e) {
  if (_typeof$t(t) != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(t, e || "default");
    if (_typeof$t(o) != "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function _objectWithoutProperties$a(t, e) {
  if (t == null) return {};
  var n = _objectWithoutPropertiesLoose$b(t, e), o, l;
  if (Object.getOwnPropertySymbols) {
    var u = Object.getOwnPropertySymbols(t);
    for (l = 0; l < u.length; l++)
      o = u[l], !(e.indexOf(o) >= 0) && Object.prototype.propertyIsEnumerable.call(t, o) && (n[o] = t[o]);
  }
  return n;
}
function _objectWithoutPropertiesLoose$b(t, e) {
  if (t == null) return {};
  var n = {}, o = Object.keys(t), l, u;
  for (u = 0; u < o.length; u++)
    l = o[u], !(e.indexOf(l) >= 0) && (n[l] = t[l]);
  return n;
}
var defaultAccessor = function t(e) {
  return Array.isArray(e.value) ? last$1(e.value) : e.value;
};
function LabelList(t) {
  var e = t.valueAccessor, n = e === void 0 ? defaultAccessor : e, o = _objectWithoutProperties$a(t, _excluded$a), l = o.data, u = o.dataKey, f = o.clockWise, h = o.id, p = o.textBreakAll, v = _objectWithoutProperties$a(o, _excluded2$4);
  return !l || !l.length ? null : /* @__PURE__ */ React__default.createElement(Layer, {
    className: "recharts-label-list"
  }, l.map(function(g, w) {
    var E = isNil$1(u) ? n(g, w) : getValueByDataKey(g && g.payload, u), T = isNil$1(h) ? {} : {
      id: "".concat(h, "-").concat(w)
    };
    return /* @__PURE__ */ React__default.createElement(Label, _extends$n({}, filterProps(g, !0), v, T, {
      parentViewBox: g.parentViewBox,
      value: E,
      textBreakAll: p,
      viewBox: Label.parseViewBox(isNil$1(f) ? g : _objectSpread$p(_objectSpread$p({}, g), {}, {
        clockWise: f
      })),
      key: "label-".concat(w),
      index: w
    }));
  }));
}
LabelList.displayName = "LabelList";
function parseLabelList(t, e) {
  return t ? t === !0 ? /* @__PURE__ */ React__default.createElement(LabelList, {
    key: "labelList-implicit",
    data: e
  }) : /* @__PURE__ */ React__default.isValidElement(t) || isFunction$3(t) ? /* @__PURE__ */ React__default.createElement(LabelList, {
    key: "labelList-implicit",
    data: e,
    content: t
  }) : isObject$8(t) ? /* @__PURE__ */ React__default.createElement(LabelList, _extends$n({
    data: e
  }, t, {
    key: "labelList-implicit"
  })) : null : null;
}
function renderCallByParent(t, e) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
  if (!t || !t.children && n && !t.label)
    return null;
  var o = t.children, l = findAllByType(o, LabelList).map(function(f, h) {
    return /* @__PURE__ */ cloneElement(f, {
      data: e,
      // eslint-disable-next-line react/no-array-index-key
      key: "labelList-".concat(h)
    });
  });
  if (!n)
    return l;
  var u = parseLabelList(t.label, e);
  return [u].concat(_toConsumableArray$7(l));
}
LabelList.renderCallByParent = renderCallByParent;
function _typeof$s(t) {
  "@babel/helpers - typeof";
  return _typeof$s = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof$s(t);
}
function _extends$m() {
  return _extends$m = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }
    return t;
  }, _extends$m.apply(this, arguments);
}
function ownKeys$p(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(l) {
      return Object.getOwnPropertyDescriptor(t, l).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function _objectSpread$o(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ownKeys$p(Object(n), !0).forEach(function(o) {
      _defineProperty$q(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : ownKeys$p(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
function _defineProperty$q(t, e, n) {
  return e = _toPropertyKey$q(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function _toPropertyKey$q(t) {
  var e = _toPrimitive$q(t, "string");
  return _typeof$s(e) == "symbol" ? e : String(e);
}
function _toPrimitive$q(t, e) {
  if (_typeof$s(t) != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(t, e || "default");
    if (_typeof$s(o) != "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
var getDeltaAngle = function t(e, n) {
  var o = mathSign(n - e), l = Math.min(Math.abs(n - e), 359.999);
  return o * l;
}, getTangentCircle = function t(e) {
  var n = e.cx, o = e.cy, l = e.radius, u = e.angle, f = e.sign, h = e.isExternal, p = e.cornerRadius, v = e.cornerIsExternal, g = p * (h ? 1 : -1) + l, w = Math.asin(p / g) / RADIAN$1, E = v ? u : u + f * w, T = polarToCartesian(n, o, g, E), R = polarToCartesian(n, o, l, E), _ = v ? u - f * w : u, b = polarToCartesian(n, o, g * Math.cos(w * RADIAN$1), _);
  return {
    center: T,
    circleTangency: R,
    lineTangency: b,
    theta: w
  };
}, getSectorPath = function t(e) {
  var n = e.cx, o = e.cy, l = e.innerRadius, u = e.outerRadius, f = e.startAngle, h = e.endAngle, p = getDeltaAngle(f, h), v = f + p, g = polarToCartesian(n, o, u, f), w = polarToCartesian(n, o, u, v), E = "M ".concat(g.x, ",").concat(g.y, `
    A `).concat(u, ",").concat(u, `,0,
    `).concat(+(Math.abs(p) > 180), ",").concat(+(f > v), `,
    `).concat(w.x, ",").concat(w.y, `
  `);
  if (l > 0) {
    var T = polarToCartesian(n, o, l, f), R = polarToCartesian(n, o, l, v);
    E += "L ".concat(R.x, ",").concat(R.y, `
            A `).concat(l, ",").concat(l, `,0,
            `).concat(+(Math.abs(p) > 180), ",").concat(+(f <= v), `,
            `).concat(T.x, ",").concat(T.y, " Z");
  } else
    E += "L ".concat(n, ",").concat(o, " Z");
  return E;
}, getSectorWithCorner = function t(e) {
  var n = e.cx, o = e.cy, l = e.innerRadius, u = e.outerRadius, f = e.cornerRadius, h = e.forceCornerRadius, p = e.cornerIsExternal, v = e.startAngle, g = e.endAngle, w = mathSign(g - v), E = getTangentCircle({
    cx: n,
    cy: o,
    radius: u,
    angle: v,
    sign: w,
    cornerRadius: f,
    cornerIsExternal: p
  }), T = E.circleTangency, R = E.lineTangency, _ = E.theta, b = getTangentCircle({
    cx: n,
    cy: o,
    radius: u,
    angle: g,
    sign: -w,
    cornerRadius: f,
    cornerIsExternal: p
  }), M = b.circleTangency, A = b.lineTangency, $ = b.theta, S = p ? Math.abs(v - g) : Math.abs(v - g) - _ - $;
  if (S < 0)
    return h ? "M ".concat(R.x, ",").concat(R.y, `
        a`).concat(f, ",").concat(f, ",0,0,1,").concat(f * 2, `,0
        a`).concat(f, ",").concat(f, ",0,0,1,").concat(-f * 2, `,0
      `) : getSectorPath({
      cx: n,
      cy: o,
      innerRadius: l,
      outerRadius: u,
      startAngle: v,
      endAngle: g
    });
  var C = "M ".concat(R.x, ",").concat(R.y, `
    A`).concat(f, ",").concat(f, ",0,0,").concat(+(w < 0), ",").concat(T.x, ",").concat(T.y, `
    A`).concat(u, ",").concat(u, ",0,").concat(+(S > 180), ",").concat(+(w < 0), ",").concat(M.x, ",").concat(M.y, `
    A`).concat(f, ",").concat(f, ",0,0,").concat(+(w < 0), ",").concat(A.x, ",").concat(A.y, `
  `);
  if (l > 0) {
    var D = getTangentCircle({
      cx: n,
      cy: o,
      radius: l,
      angle: v,
      sign: w,
      isExternal: !0,
      cornerRadius: f,
      cornerIsExternal: p
    }), O = D.circleTangency, N = D.lineTangency, j = D.theta, L = getTangentCircle({
      cx: n,
      cy: o,
      radius: l,
      angle: g,
      sign: -w,
      isExternal: !0,
      cornerRadius: f,
      cornerIsExternal: p
    }), z = L.circleTangency, G = L.lineTangency, B = L.theta, F = p ? Math.abs(v - g) : Math.abs(v - g) - j - B;
    if (F < 0 && f === 0)
      return "".concat(C, "L").concat(n, ",").concat(o, "Z");
    C += "L".concat(G.x, ",").concat(G.y, `
      A`).concat(f, ",").concat(f, ",0,0,").concat(+(w < 0), ",").concat(z.x, ",").concat(z.y, `
      A`).concat(l, ",").concat(l, ",0,").concat(+(F > 180), ",").concat(+(w > 0), ",").concat(O.x, ",").concat(O.y, `
      A`).concat(f, ",").concat(f, ",0,0,").concat(+(w < 0), ",").concat(N.x, ",").concat(N.y, "Z");
  } else
    C += "L".concat(n, ",").concat(o, "Z");
  return C;
}, defaultProps$3 = {
  cx: 0,
  cy: 0,
  innerRadius: 0,
  outerRadius: 0,
  startAngle: 0,
  endAngle: 0,
  cornerRadius: 0,
  forceCornerRadius: !1,
  cornerIsExternal: !1
}, Sector = function t(e) {
  var n = _objectSpread$o(_objectSpread$o({}, defaultProps$3), e), o = n.cx, l = n.cy, u = n.innerRadius, f = n.outerRadius, h = n.cornerRadius, p = n.forceCornerRadius, v = n.cornerIsExternal, g = n.startAngle, w = n.endAngle, E = n.className;
  if (f < u || g === w)
    return null;
  var T = clsx$1("recharts-sector", E), R = f - u, _ = getPercentValue(h, R, 0, !0), b;
  return _ > 0 && Math.abs(g - w) < 360 ? b = getSectorWithCorner({
    cx: o,
    cy: l,
    innerRadius: u,
    outerRadius: f,
    cornerRadius: Math.min(_, R / 2),
    forceCornerRadius: p,
    cornerIsExternal: v,
    startAngle: g,
    endAngle: w
  }) : b = getSectorPath({
    cx: o,
    cy: l,
    innerRadius: u,
    outerRadius: f,
    startAngle: g,
    endAngle: w
  }), /* @__PURE__ */ React__default.createElement("path", _extends$m({}, filterProps(n, !0), {
    className: T,
    d: b,
    role: "img"
  }));
};
function _typeof$r(t) {
  "@babel/helpers - typeof";
  return _typeof$r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof$r(t);
}
function _extends$l() {
  return _extends$l = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }
    return t;
  }, _extends$l.apply(this, arguments);
}
function ownKeys$o(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(l) {
      return Object.getOwnPropertyDescriptor(t, l).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function _objectSpread$n(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ownKeys$o(Object(n), !0).forEach(function(o) {
      _defineProperty$p(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : ownKeys$o(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
function _defineProperty$p(t, e, n) {
  return e = _toPropertyKey$p(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function _toPropertyKey$p(t) {
  var e = _toPrimitive$p(t, "string");
  return _typeof$r(e) == "symbol" ? e : String(e);
}
function _toPrimitive$p(t, e) {
  if (_typeof$r(t) != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(t, e || "default");
    if (_typeof$r(o) != "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
var CURVE_FACTORIES = {
  curveBasisClosed,
  curveBasisOpen,
  curveBasis,
  curveBumpX: bumpX,
  curveBumpY: bumpY,
  curveLinearClosed,
  curveLinear,
  curveMonotoneX: monotoneX,
  curveMonotoneY: monotoneY,
  curveNatural,
  curveStep,
  curveStepAfter: stepAfter,
  curveStepBefore: stepBefore
}, defined = function t(e) {
  return e.x === +e.x && e.y === +e.y;
}, getX = function t(e) {
  return e.x;
}, getY = function t(e) {
  return e.y;
}, getCurveFactory = function t(e, n) {
  if (isFunction$3(e))
    return e;
  var o = "curve".concat(upperFirst$1(e));
  return (o === "curveMonotone" || o === "curveBump") && n ? CURVE_FACTORIES["".concat(o).concat(n === "vertical" ? "Y" : "X")] : CURVE_FACTORIES[o] || curveLinear;
}, getPath$1 = function t(e) {
  var n = e.type, o = n === void 0 ? "linear" : n, l = e.points, u = l === void 0 ? [] : l, f = e.baseLine, h = e.layout, p = e.connectNulls, v = p === void 0 ? !1 : p, g = getCurveFactory(o, h), w = v ? u.filter(function(_) {
    return defined(_);
  }) : u, E;
  if (Array.isArray(f)) {
    var T = v ? f.filter(function(_) {
      return defined(_);
    }) : f, R = w.map(function(_, b) {
      return _objectSpread$n(_objectSpread$n({}, _), {}, {
        base: T[b]
      });
    });
    return h === "vertical" ? E = shapeArea().y(getY).x1(getX).x0(function(_) {
      return _.base.x;
    }) : E = shapeArea().x(getX).y1(getY).y0(function(_) {
      return _.base.y;
    }), E.defined(defined).curve(g), E(R);
  }
  return h === "vertical" && isNumber(f) ? E = shapeArea().y(getY).x1(getX).x0(f) : isNumber(f) ? E = shapeArea().x(getX).y1(getY).y0(f) : E = shapeLine().x(getX).y(getY), E.defined(defined).curve(g), E(w);
}, Curve = function t(e) {
  var n = e.className, o = e.points, l = e.path, u = e.pathRef;
  if ((!o || !o.length) && !l)
    return null;
  var f = o && o.length ? getPath$1(e) : l;
  return /* @__PURE__ */ React__default.createElement("path", _extends$l({}, filterProps(e, !1), adaptEventHandlers(e), {
    className: clsx$1("recharts-curve", n),
    d: f,
    ref: u
  }));
}, getOwnPropertyNames = Object.getOwnPropertyNames, getOwnPropertySymbols = Object.getOwnPropertySymbols, hasOwnProperty$1 = Object.prototype.hasOwnProperty;
function combineComparators(t, e) {
  return function(o, l, u) {
    return t(o, l, u) && e(o, l, u);
  };
}
function createIsCircular(t) {
  return function(n, o, l) {
    if (!n || !o || typeof n != "object" || typeof o != "object")
      return t(n, o, l);
    var u = l.cache, f = u.get(n), h = u.get(o);
    if (f && h)
      return f === o && h === n;
    u.set(n, o), u.set(o, n);
    var p = t(n, o, l);
    return u.delete(n), u.delete(o), p;
  };
}
function getStrictProperties(t) {
  return getOwnPropertyNames(t).concat(getOwnPropertySymbols(t));
}
var hasOwn = Object.hasOwn || function(t, e) {
  return hasOwnProperty$1.call(t, e);
};
function sameValueZeroEqual(t, e) {
  return t || e ? t === e : t === e || t !== t && e !== e;
}
var OWNER = "_owner", getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor, keys$1 = Object.keys;
function areArraysEqual(t, e, n) {
  var o = t.length;
  if (e.length !== o)
    return !1;
  for (; o-- > 0; )
    if (!n.equals(t[o], e[o], o, o, t, e, n))
      return !1;
  return !0;
}
function areDatesEqual(t, e) {
  return sameValueZeroEqual(t.getTime(), e.getTime());
}
function areMapsEqual(t, e, n) {
  if (t.size !== e.size)
    return !1;
  for (var o = {}, l = t.entries(), u = 0, f, h; (f = l.next()) && !f.done; ) {
    for (var p = e.entries(), v = !1, g = 0; (h = p.next()) && !h.done; ) {
      var w = f.value, E = w[0], T = w[1], R = h.value, _ = R[0], b = R[1];
      !v && !o[g] && (v = n.equals(E, _, u, g, t, e, n) && n.equals(T, b, E, _, t, e, n)) && (o[g] = !0), g++;
    }
    if (!v)
      return !1;
    u++;
  }
  return !0;
}
function areObjectsEqual(t, e, n) {
  var o = keys$1(t), l = o.length;
  if (keys$1(e).length !== l)
    return !1;
  for (var u; l-- > 0; )
    if (u = o[l], u === OWNER && (t.$$typeof || e.$$typeof) && t.$$typeof !== e.$$typeof || !hasOwn(e, u) || !n.equals(t[u], e[u], u, u, t, e, n))
      return !1;
  return !0;
}
function areObjectsEqualStrict(t, e, n) {
  var o = getStrictProperties(t), l = o.length;
  if (getStrictProperties(e).length !== l)
    return !1;
  for (var u, f, h; l-- > 0; )
    if (u = o[l], u === OWNER && (t.$$typeof || e.$$typeof) && t.$$typeof !== e.$$typeof || !hasOwn(e, u) || !n.equals(t[u], e[u], u, u, t, e, n) || (f = getOwnPropertyDescriptor(t, u), h = getOwnPropertyDescriptor(e, u), (f || h) && (!f || !h || f.configurable !== h.configurable || f.enumerable !== h.enumerable || f.writable !== h.writable)))
      return !1;
  return !0;
}
function arePrimitiveWrappersEqual(t, e) {
  return sameValueZeroEqual(t.valueOf(), e.valueOf());
}
function areRegExpsEqual(t, e) {
  return t.source === e.source && t.flags === e.flags;
}
function areSetsEqual(t, e, n) {
  if (t.size !== e.size)
    return !1;
  for (var o = {}, l = t.values(), u, f; (u = l.next()) && !u.done; ) {
    for (var h = e.values(), p = !1, v = 0; (f = h.next()) && !f.done; )
      !p && !o[v] && (p = n.equals(u.value, f.value, u.value, f.value, t, e, n)) && (o[v] = !0), v++;
    if (!p)
      return !1;
  }
  return !0;
}
function areTypedArraysEqual(t, e) {
  var n = t.length;
  if (e.length !== n)
    return !1;
  for (; n-- > 0; )
    if (t[n] !== e[n])
      return !1;
  return !0;
}
var ARGUMENTS_TAG = "[object Arguments]", BOOLEAN_TAG = "[object Boolean]", DATE_TAG = "[object Date]", MAP_TAG = "[object Map]", NUMBER_TAG = "[object Number]", OBJECT_TAG = "[object Object]", REG_EXP_TAG = "[object RegExp]", SET_TAG = "[object Set]", STRING_TAG = "[object String]", isArray$2 = Array.isArray, isTypedArray = typeof ArrayBuffer == "function" && ArrayBuffer.isView ? ArrayBuffer.isView : null, assign = Object.assign, getTag = Object.prototype.toString.call.bind(Object.prototype.toString);
function createEqualityComparator(t) {
  var e = t.areArraysEqual, n = t.areDatesEqual, o = t.areMapsEqual, l = t.areObjectsEqual, u = t.arePrimitiveWrappersEqual, f = t.areRegExpsEqual, h = t.areSetsEqual, p = t.areTypedArraysEqual;
  return function(g, w, E) {
    if (g === w)
      return !0;
    if (g == null || w == null || typeof g != "object" || typeof w != "object")
      return g !== g && w !== w;
    var T = g.constructor;
    if (T !== w.constructor)
      return !1;
    if (T === Object)
      return l(g, w, E);
    if (isArray$2(g))
      return e(g, w, E);
    if (isTypedArray != null && isTypedArray(g))
      return p(g, w, E);
    if (T === Date)
      return n(g, w, E);
    if (T === RegExp)
      return f(g, w, E);
    if (T === Map)
      return o(g, w, E);
    if (T === Set)
      return h(g, w, E);
    var R = getTag(g);
    return R === DATE_TAG ? n(g, w, E) : R === REG_EXP_TAG ? f(g, w, E) : R === MAP_TAG ? o(g, w, E) : R === SET_TAG ? h(g, w, E) : R === OBJECT_TAG ? typeof g.then != "function" && typeof w.then != "function" && l(g, w, E) : R === ARGUMENTS_TAG ? l(g, w, E) : R === BOOLEAN_TAG || R === NUMBER_TAG || R === STRING_TAG ? u(g, w, E) : !1;
  };
}
function createEqualityComparatorConfig(t) {
  var e = t.circular, n = t.createCustomConfig, o = t.strict, l = {
    areArraysEqual: o ? areObjectsEqualStrict : areArraysEqual,
    areDatesEqual,
    areMapsEqual: o ? combineComparators(areMapsEqual, areObjectsEqualStrict) : areMapsEqual,
    areObjectsEqual: o ? areObjectsEqualStrict : areObjectsEqual,
    arePrimitiveWrappersEqual,
    areRegExpsEqual,
    areSetsEqual: o ? combineComparators(areSetsEqual, areObjectsEqualStrict) : areSetsEqual,
    areTypedArraysEqual: o ? areObjectsEqualStrict : areTypedArraysEqual
  };
  if (n && (l = assign({}, l, n(l))), e) {
    var u = createIsCircular(l.areArraysEqual), f = createIsCircular(l.areMapsEqual), h = createIsCircular(l.areObjectsEqual), p = createIsCircular(l.areSetsEqual);
    l = assign({}, l, {
      areArraysEqual: u,
      areMapsEqual: f,
      areObjectsEqual: h,
      areSetsEqual: p
    });
  }
  return l;
}
function createInternalEqualityComparator(t) {
  return function(e, n, o, l, u, f, h) {
    return t(e, n, h);
  };
}
function createIsEqual(t) {
  var e = t.circular, n = t.comparator, o = t.createState, l = t.equals, u = t.strict;
  if (o)
    return function(p, v) {
      var g = o(), w = g.cache, E = w === void 0 ? e ? /* @__PURE__ */ new WeakMap() : void 0 : w, T = g.meta;
      return n(p, v, {
        cache: E,
        equals: l,
        meta: T,
        strict: u
      });
    };
  if (e)
    return function(p, v) {
      return n(p, v, {
        cache: /* @__PURE__ */ new WeakMap(),
        equals: l,
        meta: void 0,
        strict: u
      });
    };
  var f = {
    cache: void 0,
    equals: l,
    meta: void 0,
    strict: u
  };
  return function(p, v) {
    return n(p, v, f);
  };
}
var deepEqual$1 = createCustomEqual();
createCustomEqual({ strict: !0 });
createCustomEqual({ circular: !0 });
createCustomEqual({
  circular: !0,
  strict: !0
});
createCustomEqual({
  createInternalComparator: function() {
    return sameValueZeroEqual;
  }
});
createCustomEqual({
  strict: !0,
  createInternalComparator: function() {
    return sameValueZeroEqual;
  }
});
createCustomEqual({
  circular: !0,
  createInternalComparator: function() {
    return sameValueZeroEqual;
  }
});
createCustomEqual({
  circular: !0,
  createInternalComparator: function() {
    return sameValueZeroEqual;
  },
  strict: !0
});
function createCustomEqual(t) {
  t === void 0 && (t = {});
  var e = t.circular, n = e === void 0 ? !1 : e, o = t.createInternalComparator, l = t.createState, u = t.strict, f = u === void 0 ? !1 : u, h = createEqualityComparatorConfig(t), p = createEqualityComparator(h), v = o ? o(p) : createInternalEqualityComparator(p);
  return createIsEqual({ circular: n, comparator: p, createState: l, equals: v, strict: f });
}
function safeRequestAnimationFrame(t) {
  typeof requestAnimationFrame < "u" && requestAnimationFrame(t);
}
function setRafTimeout(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = -1, o = function l(u) {
    n < 0 && (n = u), u - n > e ? (t(u), n = -1) : safeRequestAnimationFrame(l);
  };
  requestAnimationFrame(o);
}
function _typeof$q(t) {
  "@babel/helpers - typeof";
  return _typeof$q = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof$q(t);
}
function _toArray(t) {
  return _arrayWithHoles$6(t) || _iterableToArray$7(t) || _unsupportedIterableToArray$a(t) || _nonIterableRest$6();
}
function _nonIterableRest$6() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function _unsupportedIterableToArray$a(t, e) {
  if (t) {
    if (typeof t == "string") return _arrayLikeToArray$a(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$a(t, e);
  }
}
function _arrayLikeToArray$a(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, o = new Array(e); n < e; n++) o[n] = t[n];
  return o;
}
function _iterableToArray$7(t) {
  if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
}
function _arrayWithHoles$6(t) {
  if (Array.isArray(t)) return t;
}
function createAnimateManager() {
  var t = {}, e = function() {
    return null;
  }, n = !1, o = function l(u) {
    if (!n) {
      if (Array.isArray(u)) {
        if (!u.length)
          return;
        var f = u, h = _toArray(f), p = h[0], v = h.slice(1);
        if (typeof p == "number") {
          setRafTimeout(l.bind(null, v), p);
          return;
        }
        l(p), setRafTimeout(l.bind(null, v));
        return;
      }
      _typeof$q(u) === "object" && (t = u, e(t)), typeof u == "function" && u();
    }
  };
  return {
    stop: function() {
      n = !0;
    },
    start: function(u) {
      n = !1, o(u);
    },
    subscribe: function(u) {
      return e = u, function() {
        e = function() {
          return null;
        };
      };
    }
  };
}
function _typeof$p(t) {
  "@babel/helpers - typeof";
  return _typeof$p = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof$p(t);
}
function ownKeys$n(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(l) {
      return Object.getOwnPropertyDescriptor(t, l).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function _objectSpread$m(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ownKeys$n(Object(n), !0).forEach(function(o) {
      _defineProperty$o(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : ownKeys$n(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
function _defineProperty$o(t, e, n) {
  return e = _toPropertyKey$o(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function _toPropertyKey$o(t) {
  var e = _toPrimitive$o(t, "string");
  return _typeof$p(e) === "symbol" ? e : String(e);
}
function _toPrimitive$o(t, e) {
  if (_typeof$p(t) !== "object" || t === null) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(t, e || "default");
    if (_typeof$p(o) !== "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
var getIntersectionKeys = function t(e, n) {
  return [Object.keys(e), Object.keys(n)].reduce(function(o, l) {
    return o.filter(function(u) {
      return l.includes(u);
    });
  });
}, identity = function t(e) {
  return e;
}, getDashCase = function t(e) {
  return e.replace(/([A-Z])/g, function(n) {
    return "-".concat(n.toLowerCase());
  });
}, mapObject = function t(e, n) {
  return Object.keys(n).reduce(function(o, l) {
    return _objectSpread$m(_objectSpread$m({}, o), {}, _defineProperty$o({}, l, e(l, n[l])));
  }, {});
}, getTransitionVal = function t(e, n, o) {
  return e.map(function(l) {
    return "".concat(getDashCase(l), " ").concat(n, "ms ").concat(o);
  }).join(",");
}, isDev = process.env.NODE_ENV !== "production", warn$1 = function t(e, n, o, l, u, f, h, p) {
  if (isDev && typeof console < "u" && console.warn && (n === void 0 && console.warn("LogUtils requires an error message argument"), !e))
    if (n === void 0)
      console.warn("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
    else {
      var v = [o, l, u, f, h, p], g = 0;
      console.warn(n.replace(/%s/g, function() {
        return v[g++];
      }));
    }
};
function _slicedToArray$5(t, e) {
  return _arrayWithHoles$5(t) || _iterableToArrayLimit$5(t, e) || _unsupportedIterableToArray$9(t, e) || _nonIterableRest$5();
}
function _nonIterableRest$5() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function _iterableToArrayLimit$5(t, e) {
  var n = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
  if (n != null) {
    var o, l, u, f, h = [], p = !0, v = !1;
    try {
      if (u = (n = n.call(t)).next, e !== 0) for (; !(p = (o = u.call(n)).done) && (h.push(o.value), h.length !== e); p = !0) ;
    } catch (g) {
      v = !0, l = g;
    } finally {
      try {
        if (!p && n.return != null && (f = n.return(), Object(f) !== f)) return;
      } finally {
        if (v) throw l;
      }
    }
    return h;
  }
}
function _arrayWithHoles$5(t) {
  if (Array.isArray(t)) return t;
}
function _toConsumableArray$6(t) {
  return _arrayWithoutHoles$6(t) || _iterableToArray$6(t) || _unsupportedIterableToArray$9(t) || _nonIterableSpread$6();
}
function _nonIterableSpread$6() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function _unsupportedIterableToArray$9(t, e) {
  if (t) {
    if (typeof t == "string") return _arrayLikeToArray$9(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$9(t, e);
  }
}
function _iterableToArray$6(t) {
  if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
}
function _arrayWithoutHoles$6(t) {
  if (Array.isArray(t)) return _arrayLikeToArray$9(t);
}
function _arrayLikeToArray$9(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, o = new Array(e); n < e; n++) o[n] = t[n];
  return o;
}
var ACCURACY = 1e-4, cubicBezierFactor = function t(e, n) {
  return [0, 3 * e, 3 * n - 6 * e, 3 * e - 3 * n + 1];
}, multyTime = function t(e, n) {
  return e.map(function(o, l) {
    return o * Math.pow(n, l);
  }).reduce(function(o, l) {
    return o + l;
  });
}, cubicBezier = function t(e, n) {
  return function(o) {
    var l = cubicBezierFactor(e, n);
    return multyTime(l, o);
  };
}, derivativeCubicBezier = function t(e, n) {
  return function(o) {
    var l = cubicBezierFactor(e, n), u = [].concat(_toConsumableArray$6(l.map(function(f, h) {
      return f * h;
    }).slice(1)), [0]);
    return multyTime(u, o);
  };
}, configBezier = function t() {
  for (var e = arguments.length, n = new Array(e), o = 0; o < e; o++)
    n[o] = arguments[o];
  var l = n[0], u = n[1], f = n[2], h = n[3];
  if (n.length === 1)
    switch (n[0]) {
      case "linear":
        l = 0, u = 0, f = 1, h = 1;
        break;
      case "ease":
        l = 0.25, u = 0.1, f = 0.25, h = 1;
        break;
      case "ease-in":
        l = 0.42, u = 0, f = 1, h = 1;
        break;
      case "ease-out":
        l = 0.42, u = 0, f = 0.58, h = 1;
        break;
      case "ease-in-out":
        l = 0, u = 0, f = 0.58, h = 1;
        break;
      default: {
        var p = n[0].split("(");
        if (p[0] === "cubic-bezier" && p[1].split(")")[0].split(",").length === 4) {
          var v = p[1].split(")")[0].split(",").map(function(b) {
            return parseFloat(b);
          }), g = _slicedToArray$5(v, 4);
          l = g[0], u = g[1], f = g[2], h = g[3];
        } else
          warn$1(!1, "[configBezier]: arguments should be one of oneOf 'linear', 'ease', 'ease-in', 'ease-out', 'ease-in-out','cubic-bezier(x1,y1,x2,y2)', instead received %s", n);
      }
    }
  warn$1([l, f, u, h].every(function(b) {
    return typeof b == "number" && b >= 0 && b <= 1;
  }), "[configBezier]: arguments should be x1, y1, x2, y2 of [0, 1] instead received %s", n);
  var w = cubicBezier(l, f), E = cubicBezier(u, h), T = derivativeCubicBezier(l, f), R = function(M) {
    return M > 1 ? 1 : M < 0 ? 0 : M;
  }, _ = function(M) {
    for (var A = M > 1 ? 1 : M, $ = A, S = 0; S < 8; ++S) {
      var C = w($) - A, D = T($);
      if (Math.abs(C - A) < ACCURACY || D < ACCURACY)
        return E($);
      $ = R($ - C / D);
    }
    return E($);
  };
  return _.isStepper = !1, _;
}, configSpring = function t() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = e.stiff, o = n === void 0 ? 100 : n, l = e.damping, u = l === void 0 ? 8 : l, f = e.dt, h = f === void 0 ? 17 : f, p = function(g, w, E) {
    var T = -(g - w) * o, R = E * u, _ = E + (T - R) * h / 1e3, b = E * h / 1e3 + g;
    return Math.abs(b - w) < ACCURACY && Math.abs(_) < ACCURACY ? [w, 0] : [b, _];
  };
  return p.isStepper = !0, p.dt = h, p;
}, configEasing = function t() {
  for (var e = arguments.length, n = new Array(e), o = 0; o < e; o++)
    n[o] = arguments[o];
  var l = n[0];
  if (typeof l == "string")
    switch (l) {
      case "ease":
      case "ease-in-out":
      case "ease-out":
      case "ease-in":
      case "linear":
        return configBezier(l);
      case "spring":
        return configSpring();
      default:
        if (l.split("(")[0] === "cubic-bezier")
          return configBezier(l);
        warn$1(!1, "[configEasing]: first argument should be one of 'ease', 'ease-in', 'ease-out', 'ease-in-out','cubic-bezier(x1,y1,x2,y2)', 'linear' and 'spring', instead  received %s", n);
    }
  return typeof l == "function" ? l : (warn$1(!1, "[configEasing]: first argument type should be function or string, instead received %s", n), null);
};
function _typeof$o(t) {
  "@babel/helpers - typeof";
  return _typeof$o = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof$o(t);
}
function _toConsumableArray$5(t) {
  return _arrayWithoutHoles$5(t) || _iterableToArray$5(t) || _unsupportedIterableToArray$8(t) || _nonIterableSpread$5();
}
function _nonIterableSpread$5() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function _iterableToArray$5(t) {
  if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
}
function _arrayWithoutHoles$5(t) {
  if (Array.isArray(t)) return _arrayLikeToArray$8(t);
}
function ownKeys$m(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(l) {
      return Object.getOwnPropertyDescriptor(t, l).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function _objectSpread$l(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ownKeys$m(Object(n), !0).forEach(function(o) {
      _defineProperty$n(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : ownKeys$m(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
function _defineProperty$n(t, e, n) {
  return e = _toPropertyKey$n(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function _toPropertyKey$n(t) {
  var e = _toPrimitive$n(t, "string");
  return _typeof$o(e) === "symbol" ? e : String(e);
}
function _toPrimitive$n(t, e) {
  if (_typeof$o(t) !== "object" || t === null) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(t, e || "default");
    if (_typeof$o(o) !== "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function _slicedToArray$4(t, e) {
  return _arrayWithHoles$4(t) || _iterableToArrayLimit$4(t, e) || _unsupportedIterableToArray$8(t, e) || _nonIterableRest$4();
}
function _nonIterableRest$4() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function _unsupportedIterableToArray$8(t, e) {
  if (t) {
    if (typeof t == "string") return _arrayLikeToArray$8(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$8(t, e);
  }
}
function _arrayLikeToArray$8(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, o = new Array(e); n < e; n++) o[n] = t[n];
  return o;
}
function _iterableToArrayLimit$4(t, e) {
  var n = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
  if (n != null) {
    var o, l, u, f, h = [], p = !0, v = !1;
    try {
      if (u = (n = n.call(t)).next, e !== 0) for (; !(p = (o = u.call(n)).done) && (h.push(o.value), h.length !== e); p = !0) ;
    } catch (g) {
      v = !0, l = g;
    } finally {
      try {
        if (!p && n.return != null && (f = n.return(), Object(f) !== f)) return;
      } finally {
        if (v) throw l;
      }
    }
    return h;
  }
}
function _arrayWithHoles$4(t) {
  if (Array.isArray(t)) return t;
}
var alpha = function t(e, n, o) {
  return e + (n - e) * o;
}, needContinue = function t(e) {
  var n = e.from, o = e.to;
  return n !== o;
}, calStepperVals = function t(e, n, o) {
  var l = mapObject(function(u, f) {
    if (needContinue(f)) {
      var h = e(f.from, f.to, f.velocity), p = _slicedToArray$4(h, 2), v = p[0], g = p[1];
      return _objectSpread$l(_objectSpread$l({}, f), {}, {
        from: v,
        velocity: g
      });
    }
    return f;
  }, n);
  return o < 1 ? mapObject(function(u, f) {
    return needContinue(f) ? _objectSpread$l(_objectSpread$l({}, f), {}, {
      velocity: alpha(f.velocity, l[u].velocity, o),
      from: alpha(f.from, l[u].from, o)
    }) : f;
  }, n) : t(e, l, o - 1);
};
const configUpdate = function(t, e, n, o, l) {
  var u = getIntersectionKeys(t, e), f = u.reduce(function(b, M) {
    return _objectSpread$l(_objectSpread$l({}, b), {}, _defineProperty$n({}, M, [t[M], e[M]]));
  }, {}), h = u.reduce(function(b, M) {
    return _objectSpread$l(_objectSpread$l({}, b), {}, _defineProperty$n({}, M, {
      from: t[M],
      velocity: 0,
      to: e[M]
    }));
  }, {}), p = -1, v, g, w = function() {
    return null;
  }, E = function() {
    return mapObject(function(M, A) {
      return A.from;
    }, h);
  }, T = function() {
    return !Object.values(h).filter(needContinue).length;
  }, R = function(M) {
    v || (v = M);
    var A = M - v, $ = A / n.dt;
    h = calStepperVals(n, h, $), l(_objectSpread$l(_objectSpread$l(_objectSpread$l({}, t), e), E())), v = M, T() || (p = requestAnimationFrame(w));
  }, _ = function(M) {
    g || (g = M);
    var A = (M - g) / o, $ = mapObject(function(C, D) {
      return alpha.apply(void 0, _toConsumableArray$5(D).concat([n(A)]));
    }, f);
    if (l(_objectSpread$l(_objectSpread$l(_objectSpread$l({}, t), e), $)), A < 1)
      p = requestAnimationFrame(w);
    else {
      var S = mapObject(function(C, D) {
        return alpha.apply(void 0, _toConsumableArray$5(D).concat([n(1)]));
      }, f);
      l(_objectSpread$l(_objectSpread$l(_objectSpread$l({}, t), e), S));
    }
  };
  return w = n.isStepper ? R : _, function() {
    return requestAnimationFrame(w), function() {
      cancelAnimationFrame(p);
    };
  };
};
function _typeof$n(t) {
  "@babel/helpers - typeof";
  return _typeof$n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof$n(t);
}
var _excluded$9 = ["children", "begin", "duration", "attributeName", "easing", "isActive", "steps", "from", "to", "canBegin", "onAnimationEnd", "shouldReAnimate", "onAnimationReStart"];
function _objectWithoutProperties$9(t, e) {
  if (t == null) return {};
  var n = _objectWithoutPropertiesLoose$a(t, e), o, l;
  if (Object.getOwnPropertySymbols) {
    var u = Object.getOwnPropertySymbols(t);
    for (l = 0; l < u.length; l++)
      o = u[l], !(e.indexOf(o) >= 0) && Object.prototype.propertyIsEnumerable.call(t, o) && (n[o] = t[o]);
  }
  return n;
}
function _objectWithoutPropertiesLoose$a(t, e) {
  if (t == null) return {};
  var n = {}, o = Object.keys(t), l, u;
  for (u = 0; u < o.length; u++)
    l = o[u], !(e.indexOf(l) >= 0) && (n[l] = t[l]);
  return n;
}
function _toConsumableArray$4(t) {
  return _arrayWithoutHoles$4(t) || _iterableToArray$4(t) || _unsupportedIterableToArray$7(t) || _nonIterableSpread$4();
}
function _nonIterableSpread$4() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function _unsupportedIterableToArray$7(t, e) {
  if (t) {
    if (typeof t == "string") return _arrayLikeToArray$7(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$7(t, e);
  }
}
function _iterableToArray$4(t) {
  if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
}
function _arrayWithoutHoles$4(t) {
  if (Array.isArray(t)) return _arrayLikeToArray$7(t);
}
function _arrayLikeToArray$7(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, o = new Array(e); n < e; n++) o[n] = t[n];
  return o;
}
function ownKeys$l(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(l) {
      return Object.getOwnPropertyDescriptor(t, l).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function _objectSpread$k(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ownKeys$l(Object(n), !0).forEach(function(o) {
      _defineProperty$m(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : ownKeys$l(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
function _defineProperty$m(t, e, n) {
  return e = _toPropertyKey$m(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function _classCallCheck$a(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$a(t, e) {
  for (var n = 0; n < e.length; n++) {
    var o = e[n];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, _toPropertyKey$m(o.key), o);
  }
}
function _createClass$a(t, e, n) {
  return e && _defineProperties$a(t.prototype, e), Object.defineProperty(t, "prototype", { writable: !1 }), t;
}
function _toPropertyKey$m(t) {
  var e = _toPrimitive$m(t, "string");
  return _typeof$n(e) === "symbol" ? e : String(e);
}
function _toPrimitive$m(t, e) {
  if (_typeof$n(t) !== "object" || t === null) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(t, e || "default");
    if (_typeof$n(o) !== "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function _inherits$8(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf$9(t, e);
}
function _setPrototypeOf$9(t, e) {
  return _setPrototypeOf$9 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(o, l) {
    return o.__proto__ = l, o;
  }, _setPrototypeOf$9(t, e);
}
function _createSuper(t) {
  var e = _isNativeReflectConstruct$8();
  return function() {
    var o = _getPrototypeOf$8(t), l;
    if (e) {
      var u = _getPrototypeOf$8(this).constructor;
      l = Reflect.construct(o, arguments, u);
    } else
      l = o.apply(this, arguments);
    return _possibleConstructorReturn$8(this, l);
  };
}
function _possibleConstructorReturn$8(t, e) {
  if (e && (_typeof$n(e) === "object" || typeof e == "function"))
    return e;
  if (e !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized$9(t);
}
function _assertThisInitialized$9(t) {
  if (t === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t;
}
function _isNativeReflectConstruct$8() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
  if (typeof Proxy == "function") return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function _getPrototypeOf$8(t) {
  return _getPrototypeOf$8 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
    return n.__proto__ || Object.getPrototypeOf(n);
  }, _getPrototypeOf$8(t);
}
var Animate = /* @__PURE__ */ function(t) {
  _inherits$8(n, t);
  var e = _createSuper(n);
  function n(o, l) {
    var u;
    _classCallCheck$a(this, n), u = e.call(this, o, l);
    var f = u.props, h = f.isActive, p = f.attributeName, v = f.from, g = f.to, w = f.steps, E = f.children, T = f.duration;
    if (u.handleStyleChange = u.handleStyleChange.bind(_assertThisInitialized$9(u)), u.changeStyle = u.changeStyle.bind(_assertThisInitialized$9(u)), !h || T <= 0)
      return u.state = {
        style: {}
      }, typeof E == "function" && (u.state = {
        style: g
      }), _possibleConstructorReturn$8(u);
    if (w && w.length)
      u.state = {
        style: w[0].style
      };
    else if (v) {
      if (typeof E == "function")
        return u.state = {
          style: v
        }, _possibleConstructorReturn$8(u);
      u.state = {
        style: p ? _defineProperty$m({}, p, v) : v
      };
    } else
      u.state = {
        style: {}
      };
    return u;
  }
  return _createClass$a(n, [{
    key: "componentDidMount",
    value: function() {
      var l = this.props, u = l.isActive, f = l.canBegin;
      this.mounted = !0, !(!u || !f) && this.runAnimation(this.props);
    }
  }, {
    key: "componentDidUpdate",
    value: function(l) {
      var u = this.props, f = u.isActive, h = u.canBegin, p = u.attributeName, v = u.shouldReAnimate, g = u.to, w = u.from, E = this.state.style;
      if (h) {
        if (!f) {
          var T = {
            style: p ? _defineProperty$m({}, p, g) : g
          };
          this.state && E && (p && E[p] !== g || !p && E !== g) && this.setState(T);
          return;
        }
        if (!(deepEqual$1(l.to, g) && l.canBegin && l.isActive)) {
          var R = !l.canBegin || !l.isActive;
          this.manager && this.manager.stop(), this.stopJSAnimation && this.stopJSAnimation();
          var _ = R || v ? w : l.to;
          if (this.state && E) {
            var b = {
              style: p ? _defineProperty$m({}, p, _) : _
            };
            (p && E[p] !== _ || !p && E !== _) && this.setState(b);
          }
          this.runAnimation(_objectSpread$k(_objectSpread$k({}, this.props), {}, {
            from: _,
            begin: 0
          }));
        }
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function() {
      this.mounted = !1;
      var l = this.props.onAnimationEnd;
      this.unSubscribe && this.unSubscribe(), this.manager && (this.manager.stop(), this.manager = null), this.stopJSAnimation && this.stopJSAnimation(), l && l();
    }
  }, {
    key: "handleStyleChange",
    value: function(l) {
      this.changeStyle(l);
    }
  }, {
    key: "changeStyle",
    value: function(l) {
      this.mounted && this.setState({
        style: l
      });
    }
  }, {
    key: "runJSAnimation",
    value: function(l) {
      var u = this, f = l.from, h = l.to, p = l.duration, v = l.easing, g = l.begin, w = l.onAnimationEnd, E = l.onAnimationStart, T = configUpdate(f, h, configEasing(v), p, this.changeStyle), R = function() {
        u.stopJSAnimation = T();
      };
      this.manager.start([E, g, R, p, w]);
    }
  }, {
    key: "runStepAnimation",
    value: function(l) {
      var u = this, f = l.steps, h = l.begin, p = l.onAnimationStart, v = f[0], g = v.style, w = v.duration, E = w === void 0 ? 0 : w, T = function(_, b, M) {
        if (M === 0)
          return _;
        var A = b.duration, $ = b.easing, S = $ === void 0 ? "ease" : $, C = b.style, D = b.properties, O = b.onAnimationEnd, N = M > 0 ? f[M - 1] : b, j = D || Object.keys(C);
        if (typeof S == "function" || S === "spring")
          return [].concat(_toConsumableArray$4(_), [u.runJSAnimation.bind(u, {
            from: N.style,
            to: C,
            duration: A,
            easing: S
          }), A]);
        var L = getTransitionVal(j, A, S), z = _objectSpread$k(_objectSpread$k(_objectSpread$k({}, N.style), C), {}, {
          transition: L
        });
        return [].concat(_toConsumableArray$4(_), [z, A, O]).filter(identity);
      };
      return this.manager.start([p].concat(_toConsumableArray$4(f.reduce(T, [g, Math.max(E, h)])), [l.onAnimationEnd]));
    }
  }, {
    key: "runAnimation",
    value: function(l) {
      this.manager || (this.manager = createAnimateManager());
      var u = l.begin, f = l.duration, h = l.attributeName, p = l.to, v = l.easing, g = l.onAnimationStart, w = l.onAnimationEnd, E = l.steps, T = l.children, R = this.manager;
      if (this.unSubscribe = R.subscribe(this.handleStyleChange), typeof v == "function" || typeof T == "function" || v === "spring") {
        this.runJSAnimation(l);
        return;
      }
      if (E.length > 1) {
        this.runStepAnimation(l);
        return;
      }
      var _ = h ? _defineProperty$m({}, h, p) : p, b = getTransitionVal(Object.keys(_), f, v);
      R.start([g, u, _objectSpread$k(_objectSpread$k({}, _), {}, {
        transition: b
      }), f, w]);
    }
  }, {
    key: "render",
    value: function() {
      var l = this.props, u = l.children;
      l.begin;
      var f = l.duration;
      l.attributeName, l.easing;
      var h = l.isActive;
      l.steps, l.from, l.to, l.canBegin, l.onAnimationEnd, l.shouldReAnimate, l.onAnimationReStart;
      var p = _objectWithoutProperties$9(l, _excluded$9), v = Children.count(u), g = this.state.style;
      if (typeof u == "function")
        return u(g);
      if (!h || v === 0 || f <= 0)
        return u;
      var w = function(T) {
        var R = T.props, _ = R.style, b = _ === void 0 ? {} : _, M = R.className, A = /* @__PURE__ */ cloneElement(T, _objectSpread$k(_objectSpread$k({}, p), {}, {
          style: _objectSpread$k(_objectSpread$k({}, b), g),
          className: M
        }));
        return A;
      };
      return v === 1 ? w(Children.only(u)) : /* @__PURE__ */ React__default.createElement("div", null, Children.map(u, function(E) {
        return w(E);
      }));
    }
  }]), n;
}(PureComponent);
Animate.displayName = "Animate";
Animate.defaultProps = {
  begin: 0,
  duration: 1e3,
  from: "",
  to: "",
  attributeName: "",
  easing: "ease",
  isActive: !0,
  canBegin: !0,
  steps: [],
  onAnimationEnd: function t() {
  },
  onAnimationStart: function t() {
  }
};
Animate.propTypes = {
  from: PropTypes.oneOfType([PropTypes.object, PropTypes.string]),
  to: PropTypes.oneOfType([PropTypes.object, PropTypes.string]),
  attributeName: PropTypes.string,
  // animation duration
  duration: PropTypes.number,
  begin: PropTypes.number,
  easing: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),
  steps: PropTypes.arrayOf(PropTypes.shape({
    duration: PropTypes.number.isRequired,
    style: PropTypes.object.isRequired,
    easing: PropTypes.oneOfType([PropTypes.oneOf(["ease", "ease-in", "ease-out", "ease-in-out", "linear"]), PropTypes.func]),
    // transition css properties(dash case), optional
    properties: PropTypes.arrayOf("string"),
    onAnimationEnd: PropTypes.func
  })),
  children: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),
  isActive: PropTypes.bool,
  canBegin: PropTypes.bool,
  onAnimationEnd: PropTypes.func,
  // decide if it should reanimate with initial from style when props change
  shouldReAnimate: PropTypes.bool,
  onAnimationStart: PropTypes.func,
  onAnimationReStart: PropTypes.func
};
PropTypes.object, PropTypes.object, PropTypes.object, PropTypes.element;
PropTypes.object, PropTypes.object, PropTypes.object, PropTypes.oneOfType([PropTypes.array, PropTypes.element]), PropTypes.any;
function _typeof$m(t) {
  "@babel/helpers - typeof";
  return _typeof$m = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof$m(t);
}
function _extends$k() {
  return _extends$k = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }
    return t;
  }, _extends$k.apply(this, arguments);
}
function _slicedToArray$3(t, e) {
  return _arrayWithHoles$3(t) || _iterableToArrayLimit$3(t, e) || _unsupportedIterableToArray$6(t, e) || _nonIterableRest$3();
}
function _nonIterableRest$3() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function _unsupportedIterableToArray$6(t, e) {
  if (t) {
    if (typeof t == "string") return _arrayLikeToArray$6(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$6(t, e);
  }
}
function _arrayLikeToArray$6(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, o = new Array(e); n < e; n++) o[n] = t[n];
  return o;
}
function _iterableToArrayLimit$3(t, e) {
  var n = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
  if (n != null) {
    var o, l, u, f, h = [], p = !0, v = !1;
    try {
      if (u = (n = n.call(t)).next, e !== 0) for (; !(p = (o = u.call(n)).done) && (h.push(o.value), h.length !== e); p = !0) ;
    } catch (g) {
      v = !0, l = g;
    } finally {
      try {
        if (!p && n.return != null && (f = n.return(), Object(f) !== f)) return;
      } finally {
        if (v) throw l;
      }
    }
    return h;
  }
}
function _arrayWithHoles$3(t) {
  if (Array.isArray(t)) return t;
}
function ownKeys$k(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(l) {
      return Object.getOwnPropertyDescriptor(t, l).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function _objectSpread$j(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ownKeys$k(Object(n), !0).forEach(function(o) {
      _defineProperty$l(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : ownKeys$k(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
function _defineProperty$l(t, e, n) {
  return e = _toPropertyKey$l(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function _toPropertyKey$l(t) {
  var e = _toPrimitive$l(t, "string");
  return _typeof$m(e) == "symbol" ? e : String(e);
}
function _toPrimitive$l(t, e) {
  if (_typeof$m(t) != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(t, e || "default");
    if (_typeof$m(o) != "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
var getRectanglePath = function t(e, n, o, l, u) {
  var f = Math.min(Math.abs(o) / 2, Math.abs(l) / 2), h = l >= 0 ? 1 : -1, p = o >= 0 ? 1 : -1, v = l >= 0 && o >= 0 || l < 0 && o < 0 ? 1 : 0, g;
  if (f > 0 && u instanceof Array) {
    for (var w = [0, 0, 0, 0], E = 0, T = 4; E < T; E++)
      w[E] = u[E] > f ? f : u[E];
    g = "M".concat(e, ",").concat(n + h * w[0]), w[0] > 0 && (g += "A ".concat(w[0], ",").concat(w[0], ",0,0,").concat(v, ",").concat(e + p * w[0], ",").concat(n)), g += "L ".concat(e + o - p * w[1], ",").concat(n), w[1] > 0 && (g += "A ".concat(w[1], ",").concat(w[1], ",0,0,").concat(v, `,
        `).concat(e + o, ",").concat(n + h * w[1])), g += "L ".concat(e + o, ",").concat(n + l - h * w[2]), w[2] > 0 && (g += "A ".concat(w[2], ",").concat(w[2], ",0,0,").concat(v, `,
        `).concat(e + o - p * w[2], ",").concat(n + l)), g += "L ".concat(e + p * w[3], ",").concat(n + l), w[3] > 0 && (g += "A ".concat(w[3], ",").concat(w[3], ",0,0,").concat(v, `,
        `).concat(e, ",").concat(n + l - h * w[3])), g += "Z";
  } else if (f > 0 && u === +u && u > 0) {
    var R = Math.min(f, u);
    g = "M ".concat(e, ",").concat(n + h * R, `
            A `).concat(R, ",").concat(R, ",0,0,").concat(v, ",").concat(e + p * R, ",").concat(n, `
            L `).concat(e + o - p * R, ",").concat(n, `
            A `).concat(R, ",").concat(R, ",0,0,").concat(v, ",").concat(e + o, ",").concat(n + h * R, `
            L `).concat(e + o, ",").concat(n + l - h * R, `
            A `).concat(R, ",").concat(R, ",0,0,").concat(v, ",").concat(e + o - p * R, ",").concat(n + l, `
            L `).concat(e + p * R, ",").concat(n + l, `
            A `).concat(R, ",").concat(R, ",0,0,").concat(v, ",").concat(e, ",").concat(n + l - h * R, " Z");
  } else
    g = "M ".concat(e, ",").concat(n, " h ").concat(o, " v ").concat(l, " h ").concat(-o, " Z");
  return g;
}, isInRectangle = function t(e, n) {
  if (!e || !n)
    return !1;
  var o = e.x, l = e.y, u = n.x, f = n.y, h = n.width, p = n.height;
  if (Math.abs(h) > 0 && Math.abs(p) > 0) {
    var v = Math.min(u, u + h), g = Math.max(u, u + h), w = Math.min(f, f + p), E = Math.max(f, f + p);
    return o >= v && o <= g && l >= w && l <= E;
  }
  return !1;
}, defaultProps$2 = {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  // The radius of border
  // The radius of four corners when radius is a number
  // The radius of left-top, right-top, right-bottom, left-bottom when radius is an array
  radius: 0,
  isAnimationActive: !1,
  isUpdateAnimationActive: !1,
  animationBegin: 0,
  animationDuration: 1500,
  animationEasing: "ease"
}, Rectangle = function t(e) {
  var n = _objectSpread$j(_objectSpread$j({}, defaultProps$2), e), o = useRef(), l = useState(-1), u = _slicedToArray$3(l, 2), f = u[0], h = u[1];
  useEffect(function() {
    if (o.current && o.current.getTotalLength)
      try {
        var S = o.current.getTotalLength();
        S && h(S);
      } catch {
      }
  }, []);
  var p = n.x, v = n.y, g = n.width, w = n.height, E = n.radius, T = n.className, R = n.animationEasing, _ = n.animationDuration, b = n.animationBegin, M = n.isAnimationActive, A = n.isUpdateAnimationActive;
  if (p !== +p || v !== +v || g !== +g || w !== +w || g === 0 || w === 0)
    return null;
  var $ = clsx$1("recharts-rectangle", T);
  return A ? /* @__PURE__ */ React__default.createElement(Animate, {
    canBegin: f > 0,
    from: {
      width: g,
      height: w,
      x: p,
      y: v
    },
    to: {
      width: g,
      height: w,
      x: p,
      y: v
    },
    duration: _,
    animationEasing: R,
    isActive: A
  }, function(S) {
    var C = S.width, D = S.height, O = S.x, N = S.y;
    return /* @__PURE__ */ React__default.createElement(Animate, {
      canBegin: f > 0,
      from: "0px ".concat(f === -1 ? 1 : f, "px"),
      to: "".concat(f, "px 0px"),
      attributeName: "strokeDasharray",
      begin: b,
      duration: _,
      isActive: M,
      easing: R
    }, /* @__PURE__ */ React__default.createElement("path", _extends$k({}, filterProps(n, !0), {
      className: $,
      d: getRectanglePath(O, N, C, D, E),
      ref: o
    })));
  }) : /* @__PURE__ */ React__default.createElement("path", _extends$k({}, filterProps(n, !0), {
    className: $,
    d: getRectanglePath(p, v, g, w, E)
  }));
}, _excluded$8 = ["points", "className", "baseLinePoints", "connectNulls"];
function _extends$j() {
  return _extends$j = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }
    return t;
  }, _extends$j.apply(this, arguments);
}
function _objectWithoutProperties$8(t, e) {
  if (t == null) return {};
  var n = _objectWithoutPropertiesLoose$9(t, e), o, l;
  if (Object.getOwnPropertySymbols) {
    var u = Object.getOwnPropertySymbols(t);
    for (l = 0; l < u.length; l++)
      o = u[l], !(e.indexOf(o) >= 0) && Object.prototype.propertyIsEnumerable.call(t, o) && (n[o] = t[o]);
  }
  return n;
}
function _objectWithoutPropertiesLoose$9(t, e) {
  if (t == null) return {};
  var n = {}, o = Object.keys(t), l, u;
  for (u = 0; u < o.length; u++)
    l = o[u], !(e.indexOf(l) >= 0) && (n[l] = t[l]);
  return n;
}
function _toConsumableArray$3(t) {
  return _arrayWithoutHoles$3(t) || _iterableToArray$3(t) || _unsupportedIterableToArray$5(t) || _nonIterableSpread$3();
}
function _nonIterableSpread$3() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function _unsupportedIterableToArray$5(t, e) {
  if (t) {
    if (typeof t == "string") return _arrayLikeToArray$5(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$5(t, e);
  }
}
function _iterableToArray$3(t) {
  if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
}
function _arrayWithoutHoles$3(t) {
  if (Array.isArray(t)) return _arrayLikeToArray$5(t);
}
function _arrayLikeToArray$5(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, o = new Array(e); n < e; n++) o[n] = t[n];
  return o;
}
var isValidatePoint = function t(e) {
  return e && e.x === +e.x && e.y === +e.y;
}, getParsedPoints = function t() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], n = [[]];
  return e.forEach(function(o) {
    isValidatePoint(o) ? n[n.length - 1].push(o) : n[n.length - 1].length > 0 && n.push([]);
  }), isValidatePoint(e[0]) && n[n.length - 1].push(e[0]), n[n.length - 1].length <= 0 && (n = n.slice(0, -1)), n;
}, getSinglePolygonPath = function t(e, n) {
  var o = getParsedPoints(e);
  n && (o = [o.reduce(function(u, f) {
    return [].concat(_toConsumableArray$3(u), _toConsumableArray$3(f));
  }, [])]);
  var l = o.map(function(u) {
    return u.reduce(function(f, h, p) {
      return "".concat(f).concat(p === 0 ? "M" : "L").concat(h.x, ",").concat(h.y);
    }, "");
  }).join("");
  return o.length === 1 ? "".concat(l, "Z") : l;
}, getRanglePath = function t(e, n, o) {
  var l = getSinglePolygonPath(e, o);
  return "".concat(l.slice(-1) === "Z" ? l.slice(0, -1) : l, "L").concat(getSinglePolygonPath(n.reverse(), o).slice(1));
}, Polygon = function t(e) {
  var n = e.points, o = e.className, l = e.baseLinePoints, u = e.connectNulls, f = _objectWithoutProperties$8(e, _excluded$8);
  if (!n || !n.length)
    return null;
  var h = clsx$1("recharts-polygon", o);
  if (l && l.length) {
    var p = f.stroke && f.stroke !== "none", v = getRanglePath(n, l, u);
    return /* @__PURE__ */ React__default.createElement("g", {
      className: h
    }, /* @__PURE__ */ React__default.createElement("path", _extends$j({}, filterProps(f, !0), {
      fill: v.slice(-1) === "Z" ? f.fill : "none",
      stroke: "none",
      d: v
    })), p ? /* @__PURE__ */ React__default.createElement("path", _extends$j({}, filterProps(f, !0), {
      fill: "none",
      d: getSinglePolygonPath(n, u)
    })) : null, p ? /* @__PURE__ */ React__default.createElement("path", _extends$j({}, filterProps(f, !0), {
      fill: "none",
      d: getSinglePolygonPath(l, u)
    })) : null);
  }
  var g = getSinglePolygonPath(n, u);
  return /* @__PURE__ */ React__default.createElement("path", _extends$j({}, filterProps(f, !0), {
    fill: g.slice(-1) === "Z" ? f.fill : "none",
    className: h,
    d: g
  }));
};
function _extends$i() {
  return _extends$i = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }
    return t;
  }, _extends$i.apply(this, arguments);
}
var Dot = function t(e) {
  var n = e.cx, o = e.cy, l = e.r, u = e.className, f = clsx$1("recharts-dot", u);
  return n === +n && o === +o && l === +l ? /* @__PURE__ */ React__default.createElement("circle", _extends$i({}, filterProps(e, !1), adaptEventHandlers(e), {
    className: f,
    cx: n,
    cy: o,
    r: l
  })) : null;
};
function _typeof$l(t) {
  "@babel/helpers - typeof";
  return _typeof$l = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof$l(t);
}
var _excluded$7 = ["x", "y", "top", "left", "width", "height", "className"];
function _extends$h() {
  return _extends$h = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }
    return t;
  }, _extends$h.apply(this, arguments);
}
function ownKeys$j(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(l) {
      return Object.getOwnPropertyDescriptor(t, l).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function _objectSpread$i(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ownKeys$j(Object(n), !0).forEach(function(o) {
      _defineProperty$k(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : ownKeys$j(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
function _defineProperty$k(t, e, n) {
  return e = _toPropertyKey$k(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function _toPropertyKey$k(t) {
  var e = _toPrimitive$k(t, "string");
  return _typeof$l(e) == "symbol" ? e : String(e);
}
function _toPrimitive$k(t, e) {
  if (_typeof$l(t) != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(t, e || "default");
    if (_typeof$l(o) != "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function _objectWithoutProperties$7(t, e) {
  if (t == null) return {};
  var n = _objectWithoutPropertiesLoose$8(t, e), o, l;
  if (Object.getOwnPropertySymbols) {
    var u = Object.getOwnPropertySymbols(t);
    for (l = 0; l < u.length; l++)
      o = u[l], !(e.indexOf(o) >= 0) && Object.prototype.propertyIsEnumerable.call(t, o) && (n[o] = t[o]);
  }
  return n;
}
function _objectWithoutPropertiesLoose$8(t, e) {
  if (t == null) return {};
  var n = {}, o = Object.keys(t), l, u;
  for (u = 0; u < o.length; u++)
    l = o[u], !(e.indexOf(l) >= 0) && (n[l] = t[l]);
  return n;
}
var getPath = function t(e, n, o, l, u, f) {
  return "M".concat(e, ",").concat(u, "v").concat(l, "M").concat(f, ",").concat(n, "h").concat(o);
}, Cross = function t(e) {
  var n = e.x, o = n === void 0 ? 0 : n, l = e.y, u = l === void 0 ? 0 : l, f = e.top, h = f === void 0 ? 0 : f, p = e.left, v = p === void 0 ? 0 : p, g = e.width, w = g === void 0 ? 0 : g, E = e.height, T = E === void 0 ? 0 : E, R = e.className, _ = _objectWithoutProperties$7(e, _excluded$7), b = _objectSpread$i({
    x: o,
    y: u,
    top: h,
    left: v,
    width: w,
    height: T
  }, _);
  return !isNumber(o) || !isNumber(u) || !isNumber(w) || !isNumber(T) || !isNumber(h) || !isNumber(v) ? null : /* @__PURE__ */ React__default.createElement("path", _extends$h({}, filterProps(b, !0), {
    className: clsx$1("recharts-cross", R),
    d: getPath(o, u, w, T, h, v)
  }));
}, baseExtremum$1 = _baseExtremum, baseGt = _baseGt, baseIteratee$6 = _baseIteratee;
function maxBy(t, e) {
  return t && t.length ? baseExtremum$1(t, baseIteratee$6(e), baseGt) : void 0;
}
var maxBy_1 = maxBy;
const maxBy$1 = /* @__PURE__ */ getDefaultExportFromCjs(maxBy_1);
var baseExtremum = _baseExtremum, baseIteratee$5 = _baseIteratee, baseLt = _baseLt;
function minBy(t, e) {
  return t && t.length ? baseExtremum(t, baseIteratee$5(e), baseLt) : void 0;
}
var minBy_1 = minBy;
const minBy$1 = /* @__PURE__ */ getDefaultExportFromCjs(minBy_1);
var _excluded$6 = ["cx", "cy", "angle", "ticks", "axisLine"], _excluded2$3 = ["ticks", "tick", "angle", "tickFormatter", "stroke"];
function _typeof$k(t) {
  "@babel/helpers - typeof";
  return _typeof$k = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof$k(t);
}
function _extends$g() {
  return _extends$g = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }
    return t;
  }, _extends$g.apply(this, arguments);
}
function ownKeys$i(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(l) {
      return Object.getOwnPropertyDescriptor(t, l).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function _objectSpread$h(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ownKeys$i(Object(n), !0).forEach(function(o) {
      _defineProperty$j(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : ownKeys$i(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
function _objectWithoutProperties$6(t, e) {
  if (t == null) return {};
  var n = _objectWithoutPropertiesLoose$7(t, e), o, l;
  if (Object.getOwnPropertySymbols) {
    var u = Object.getOwnPropertySymbols(t);
    for (l = 0; l < u.length; l++)
      o = u[l], !(e.indexOf(o) >= 0) && Object.prototype.propertyIsEnumerable.call(t, o) && (n[o] = t[o]);
  }
  return n;
}
function _objectWithoutPropertiesLoose$7(t, e) {
  if (t == null) return {};
  var n = {}, o = Object.keys(t), l, u;
  for (u = 0; u < o.length; u++)
    l = o[u], !(e.indexOf(l) >= 0) && (n[l] = t[l]);
  return n;
}
function _classCallCheck$9(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$9(t, e) {
  for (var n = 0; n < e.length; n++) {
    var o = e[n];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, _toPropertyKey$j(o.key), o);
  }
}
function _createClass$9(t, e, n) {
  return e && _defineProperties$9(t.prototype, e), n && _defineProperties$9(t, n), Object.defineProperty(t, "prototype", { writable: !1 }), t;
}
function _callSuper$7(t, e, n) {
  return e = _getPrototypeOf$7(e), _possibleConstructorReturn$7(t, _isNativeReflectConstruct$7() ? Reflect.construct(e, n || [], _getPrototypeOf$7(t).constructor) : e.apply(t, n));
}
function _possibleConstructorReturn$7(t, e) {
  if (e && (_typeof$k(e) === "object" || typeof e == "function"))
    return e;
  if (e !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized$8(t);
}
function _assertThisInitialized$8(t) {
  if (t === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t;
}
function _isNativeReflectConstruct$7() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (_isNativeReflectConstruct$7 = function() {
    return !!t;
  })();
}
function _getPrototypeOf$7(t) {
  return _getPrototypeOf$7 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
    return n.__proto__ || Object.getPrototypeOf(n);
  }, _getPrototypeOf$7(t);
}
function _inherits$7(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf$8(t, e);
}
function _setPrototypeOf$8(t, e) {
  return _setPrototypeOf$8 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(o, l) {
    return o.__proto__ = l, o;
  }, _setPrototypeOf$8(t, e);
}
function _defineProperty$j(t, e, n) {
  return e = _toPropertyKey$j(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function _toPropertyKey$j(t) {
  var e = _toPrimitive$j(t, "string");
  return _typeof$k(e) == "symbol" ? e : String(e);
}
function _toPrimitive$j(t, e) {
  if (_typeof$k(t) != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(t, e || "default");
    if (_typeof$k(o) != "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
var PolarRadiusAxis = /* @__PURE__ */ function(t) {
  _inherits$7(e, t);
  function e() {
    return _classCallCheck$9(this, e), _callSuper$7(this, e, arguments);
  }
  return _createClass$9(e, [{
    key: "getTickValueCoord",
    value: (
      /**
       * Calculate the coordinate of tick
       * @param  {Number} coordinate The radius of tick
       * @return {Object} (x, y)
       */
      function(o) {
        var l = o.coordinate, u = this.props, f = u.angle, h = u.cx, p = u.cy;
        return polarToCartesian(h, p, l, f);
      }
    )
  }, {
    key: "getTickTextAnchor",
    value: function() {
      var o = this.props.orientation, l;
      switch (o) {
        case "left":
          l = "end";
          break;
        case "right":
          l = "start";
          break;
        default:
          l = "middle";
          break;
      }
      return l;
    }
  }, {
    key: "getViewBox",
    value: function() {
      var o = this.props, l = o.cx, u = o.cy, f = o.angle, h = o.ticks, p = maxBy$1(h, function(g) {
        return g.coordinate || 0;
      }), v = minBy$1(h, function(g) {
        return g.coordinate || 0;
      });
      return {
        cx: l,
        cy: u,
        startAngle: f,
        endAngle: f,
        innerRadius: v.coordinate || 0,
        outerRadius: p.coordinate || 0
      };
    }
  }, {
    key: "renderAxisLine",
    value: function() {
      var o = this.props, l = o.cx, u = o.cy, f = o.angle, h = o.ticks, p = o.axisLine, v = _objectWithoutProperties$6(o, _excluded$6), g = h.reduce(function(R, _) {
        return [Math.min(R[0], _.coordinate), Math.max(R[1], _.coordinate)];
      }, [1 / 0, -1 / 0]), w = polarToCartesian(l, u, g[0], f), E = polarToCartesian(l, u, g[1], f), T = _objectSpread$h(_objectSpread$h(_objectSpread$h({}, filterProps(v, !1)), {}, {
        fill: "none"
      }, filterProps(p, !1)), {}, {
        x1: w.x,
        y1: w.y,
        x2: E.x,
        y2: E.y
      });
      return /* @__PURE__ */ React__default.createElement("line", _extends$g({
        className: "recharts-polar-radius-axis-line"
      }, T));
    }
  }, {
    key: "renderTicks",
    value: function() {
      var o = this, l = this.props, u = l.ticks, f = l.tick, h = l.angle, p = l.tickFormatter, v = l.stroke, g = _objectWithoutProperties$6(l, _excluded2$3), w = this.getTickTextAnchor(), E = filterProps(g, !1), T = filterProps(f, !1), R = u.map(function(_, b) {
        var M = o.getTickValueCoord(_), A = _objectSpread$h(_objectSpread$h(_objectSpread$h(_objectSpread$h({
          textAnchor: w,
          transform: "rotate(".concat(90 - h, ", ").concat(M.x, ", ").concat(M.y, ")")
        }, E), {}, {
          stroke: "none",
          fill: v
        }, T), {}, {
          index: b
        }, M), {}, {
          payload: _
        });
        return /* @__PURE__ */ React__default.createElement(Layer, _extends$g({
          className: clsx$1("recharts-polar-radius-axis-tick", getTickClassName(f)),
          key: "tick-".concat(_.coordinate)
        }, adaptEventsOfChild(o.props, _, b)), e.renderTickItem(f, A, p ? p(_.value, b) : _.value));
      });
      return /* @__PURE__ */ React__default.createElement(Layer, {
        className: "recharts-polar-radius-axis-ticks"
      }, R);
    }
  }, {
    key: "render",
    value: function() {
      var o = this.props, l = o.ticks, u = o.axisLine, f = o.tick;
      return !l || !l.length ? null : /* @__PURE__ */ React__default.createElement(Layer, {
        className: clsx$1("recharts-polar-radius-axis", this.props.className)
      }, u && this.renderAxisLine(), f && this.renderTicks(), Label.renderCallByParent(this.props, this.getViewBox()));
    }
  }], [{
    key: "renderTickItem",
    value: function(o, l, u) {
      var f;
      return /* @__PURE__ */ React__default.isValidElement(o) ? f = /* @__PURE__ */ React__default.cloneElement(o, l) : isFunction$3(o) ? f = o(l) : f = /* @__PURE__ */ React__default.createElement(Text, _extends$g({}, l, {
        className: "recharts-polar-radius-axis-tick-value"
      }), u), f;
    }
  }]), e;
}(PureComponent);
_defineProperty$j(PolarRadiusAxis, "displayName", "PolarRadiusAxis");
_defineProperty$j(PolarRadiusAxis, "axisType", "radiusAxis");
_defineProperty$j(PolarRadiusAxis, "defaultProps", {
  type: "number",
  radiusAxisId: 0,
  cx: 0,
  cy: 0,
  angle: 0,
  orientation: "right",
  stroke: "#ccc",
  axisLine: !0,
  tick: !0,
  tickCount: 5,
  allowDataOverflow: !1,
  scale: "auto",
  allowDuplicatedCategory: !0
});
function _typeof$j(t) {
  "@babel/helpers - typeof";
  return _typeof$j = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof$j(t);
}
function _extends$f() {
  return _extends$f = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }
    return t;
  }, _extends$f.apply(this, arguments);
}
function ownKeys$h(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(l) {
      return Object.getOwnPropertyDescriptor(t, l).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function _objectSpread$g(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ownKeys$h(Object(n), !0).forEach(function(o) {
      _defineProperty$i(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : ownKeys$h(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
function _classCallCheck$8(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$8(t, e) {
  for (var n = 0; n < e.length; n++) {
    var o = e[n];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, _toPropertyKey$i(o.key), o);
  }
}
function _createClass$8(t, e, n) {
  return e && _defineProperties$8(t.prototype, e), n && _defineProperties$8(t, n), Object.defineProperty(t, "prototype", { writable: !1 }), t;
}
function _callSuper$6(t, e, n) {
  return e = _getPrototypeOf$6(e), _possibleConstructorReturn$6(t, _isNativeReflectConstruct$6() ? Reflect.construct(e, n || [], _getPrototypeOf$6(t).constructor) : e.apply(t, n));
}
function _possibleConstructorReturn$6(t, e) {
  if (e && (_typeof$j(e) === "object" || typeof e == "function"))
    return e;
  if (e !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized$7(t);
}
function _assertThisInitialized$7(t) {
  if (t === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t;
}
function _isNativeReflectConstruct$6() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (_isNativeReflectConstruct$6 = function() {
    return !!t;
  })();
}
function _getPrototypeOf$6(t) {
  return _getPrototypeOf$6 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
    return n.__proto__ || Object.getPrototypeOf(n);
  }, _getPrototypeOf$6(t);
}
function _inherits$6(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf$7(t, e);
}
function _setPrototypeOf$7(t, e) {
  return _setPrototypeOf$7 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(o, l) {
    return o.__proto__ = l, o;
  }, _setPrototypeOf$7(t, e);
}
function _defineProperty$i(t, e, n) {
  return e = _toPropertyKey$i(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function _toPropertyKey$i(t) {
  var e = _toPrimitive$i(t, "string");
  return _typeof$j(e) == "symbol" ? e : String(e);
}
function _toPrimitive$i(t, e) {
  if (_typeof$j(t) != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(t, e || "default");
    if (_typeof$j(o) != "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
var RADIAN = Math.PI / 180, eps = 1e-5, PolarAngleAxis = /* @__PURE__ */ function(t) {
  _inherits$6(e, t);
  function e() {
    return _classCallCheck$8(this, e), _callSuper$6(this, e, arguments);
  }
  return _createClass$8(e, [{
    key: "getTickLineCoord",
    value: (
      /**
       * Calculate the coordinate of line endpoint
       * @param  {Object} data The Data if ticks
       * @return {Object} (x0, y0): The start point of text,
       *                  (x1, y1): The end point close to text,
       *                  (x2, y2): The end point close to axis
       */
      function(o) {
        var l = this.props, u = l.cx, f = l.cy, h = l.radius, p = l.orientation, v = l.tickSize, g = v || 8, w = polarToCartesian(u, f, h, o.coordinate), E = polarToCartesian(u, f, h + (p === "inner" ? -1 : 1) * g, o.coordinate);
        return {
          x1: w.x,
          y1: w.y,
          x2: E.x,
          y2: E.y
        };
      }
    )
    /**
     * Get the text-anchor of each tick
     * @param  {Object} data Data of ticks
     * @return {String} text-anchor
     */
  }, {
    key: "getTickTextAnchor",
    value: function(o) {
      var l = this.props.orientation, u = Math.cos(-o.coordinate * RADIAN), f;
      return u > eps ? f = l === "outer" ? "start" : "end" : u < -eps ? f = l === "outer" ? "end" : "start" : f = "middle", f;
    }
  }, {
    key: "renderAxisLine",
    value: function() {
      var o = this.props, l = o.cx, u = o.cy, f = o.radius, h = o.axisLine, p = o.axisLineType, v = _objectSpread$g(_objectSpread$g({}, filterProps(this.props, !1)), {}, {
        fill: "none"
      }, filterProps(h, !1));
      if (p === "circle")
        return /* @__PURE__ */ React__default.createElement(Dot, _extends$f({
          className: "recharts-polar-angle-axis-line"
        }, v, {
          cx: l,
          cy: u,
          r: f
        }));
      var g = this.props.ticks, w = g.map(function(E) {
        return polarToCartesian(l, u, f, E.coordinate);
      });
      return /* @__PURE__ */ React__default.createElement(Polygon, _extends$f({
        className: "recharts-polar-angle-axis-line"
      }, v, {
        points: w
      }));
    }
  }, {
    key: "renderTicks",
    value: function() {
      var o = this, l = this.props, u = l.ticks, f = l.tick, h = l.tickLine, p = l.tickFormatter, v = l.stroke, g = filterProps(this.props, !1), w = filterProps(f, !1), E = _objectSpread$g(_objectSpread$g({}, g), {}, {
        fill: "none"
      }, filterProps(h, !1)), T = u.map(function(R, _) {
        var b = o.getTickLineCoord(R), M = o.getTickTextAnchor(R), A = _objectSpread$g(_objectSpread$g(_objectSpread$g({
          textAnchor: M
        }, g), {}, {
          stroke: "none",
          fill: v
        }, w), {}, {
          index: _,
          payload: R,
          x: b.x2,
          y: b.y2
        });
        return /* @__PURE__ */ React__default.createElement(Layer, _extends$f({
          className: clsx$1("recharts-polar-angle-axis-tick", getTickClassName(f)),
          key: "tick-".concat(R.coordinate)
        }, adaptEventsOfChild(o.props, R, _)), h && /* @__PURE__ */ React__default.createElement("line", _extends$f({
          className: "recharts-polar-angle-axis-tick-line"
        }, E, b)), f && e.renderTickItem(f, A, p ? p(R.value, _) : R.value));
      });
      return /* @__PURE__ */ React__default.createElement(Layer, {
        className: "recharts-polar-angle-axis-ticks"
      }, T);
    }
  }, {
    key: "render",
    value: function() {
      var o = this.props, l = o.ticks, u = o.radius, f = o.axisLine;
      return u <= 0 || !l || !l.length ? null : /* @__PURE__ */ React__default.createElement(Layer, {
        className: clsx$1("recharts-polar-angle-axis", this.props.className)
      }, f && this.renderAxisLine(), this.renderTicks());
    }
  }], [{
    key: "renderTickItem",
    value: function(o, l, u) {
      var f;
      return /* @__PURE__ */ React__default.isValidElement(o) ? f = /* @__PURE__ */ React__default.cloneElement(o, l) : isFunction$3(o) ? f = o(l) : f = /* @__PURE__ */ React__default.createElement(Text, _extends$f({}, l, {
        className: "recharts-polar-angle-axis-tick-value"
      }), u), f;
    }
  }]), e;
}(PureComponent);
_defineProperty$i(PolarAngleAxis, "displayName", "PolarAngleAxis");
_defineProperty$i(PolarAngleAxis, "axisType", "angleAxis");
_defineProperty$i(PolarAngleAxis, "defaultProps", {
  type: "category",
  angleAxisId: 0,
  scale: "auto",
  cx: 0,
  cy: 0,
  orientation: "outer",
  axisLine: !0,
  tickLine: !0,
  tickSize: 8,
  tick: !0,
  hide: !1,
  allowDuplicatedCategory: !0
});
var overArg = _overArg, getPrototype$1 = overArg(Object.getPrototypeOf, Object), _getPrototype = getPrototype$1, baseGetTag$1 = _baseGetTag, getPrototype = _getPrototype, isObjectLike$1 = isObjectLike_1, objectTag = "[object Object]", funcProto = Function.prototype, objectProto = Object.prototype, funcToString = funcProto.toString, hasOwnProperty = objectProto.hasOwnProperty, objectCtorString = funcToString.call(Object);
function isPlainObject(t) {
  if (!isObjectLike$1(t) || baseGetTag$1(t) != objectTag)
    return !1;
  var e = getPrototype(t);
  if (e === null)
    return !0;
  var n = hasOwnProperty.call(e, "constructor") && e.constructor;
  return typeof n == "function" && n instanceof n && funcToString.call(n) == objectCtorString;
}
var isPlainObject_1 = isPlainObject;
const isPlainObject$1 = /* @__PURE__ */ getDefaultExportFromCjs(isPlainObject_1);
var baseGetTag = _baseGetTag, isObjectLike = isObjectLike_1, boolTag = "[object Boolean]";
function isBoolean(t) {
  return t === !0 || t === !1 || isObjectLike(t) && baseGetTag(t) == boolTag;
}
var isBoolean_1 = isBoolean;
const isBoolean$1 = /* @__PURE__ */ getDefaultExportFromCjs(isBoolean_1);
function _typeof$i(t) {
  "@babel/helpers - typeof";
  return _typeof$i = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof$i(t);
}
function _extends$e() {
  return _extends$e = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }
    return t;
  }, _extends$e.apply(this, arguments);
}
function _slicedToArray$2(t, e) {
  return _arrayWithHoles$2(t) || _iterableToArrayLimit$2(t, e) || _unsupportedIterableToArray$4(t, e) || _nonIterableRest$2();
}
function _nonIterableRest$2() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function _unsupportedIterableToArray$4(t, e) {
  if (t) {
    if (typeof t == "string") return _arrayLikeToArray$4(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(t, e);
  }
}
function _arrayLikeToArray$4(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, o = new Array(e); n < e; n++) o[n] = t[n];
  return o;
}
function _iterableToArrayLimit$2(t, e) {
  var n = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
  if (n != null) {
    var o, l, u, f, h = [], p = !0, v = !1;
    try {
      if (u = (n = n.call(t)).next, e !== 0) for (; !(p = (o = u.call(n)).done) && (h.push(o.value), h.length !== e); p = !0) ;
    } catch (g) {
      v = !0, l = g;
    } finally {
      try {
        if (!p && n.return != null && (f = n.return(), Object(f) !== f)) return;
      } finally {
        if (v) throw l;
      }
    }
    return h;
  }
}
function _arrayWithHoles$2(t) {
  if (Array.isArray(t)) return t;
}
function ownKeys$g(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(l) {
      return Object.getOwnPropertyDescriptor(t, l).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function _objectSpread$f(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ownKeys$g(Object(n), !0).forEach(function(o) {
      _defineProperty$h(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : ownKeys$g(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
function _defineProperty$h(t, e, n) {
  return e = _toPropertyKey$h(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function _toPropertyKey$h(t) {
  var e = _toPrimitive$h(t, "string");
  return _typeof$i(e) == "symbol" ? e : String(e);
}
function _toPrimitive$h(t, e) {
  if (_typeof$i(t) != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(t, e || "default");
    if (_typeof$i(o) != "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
var getTrapezoidPath = function t(e, n, o, l, u) {
  var f = o - l, h;
  return h = "M ".concat(e, ",").concat(n), h += "L ".concat(e + o, ",").concat(n), h += "L ".concat(e + o - f / 2, ",").concat(n + u), h += "L ".concat(e + o - f / 2 - l, ",").concat(n + u), h += "L ".concat(e, ",").concat(n, " Z"), h;
}, defaultProps$1 = {
  x: 0,
  y: 0,
  upperWidth: 0,
  lowerWidth: 0,
  height: 0,
  isUpdateAnimationActive: !1,
  animationBegin: 0,
  animationDuration: 1500,
  animationEasing: "ease"
}, Trapezoid = function t(e) {
  var n = _objectSpread$f(_objectSpread$f({}, defaultProps$1), e), o = useRef(), l = useState(-1), u = _slicedToArray$2(l, 2), f = u[0], h = u[1];
  useEffect(function() {
    if (o.current && o.current.getTotalLength)
      try {
        var $ = o.current.getTotalLength();
        $ && h($);
      } catch {
      }
  }, []);
  var p = n.x, v = n.y, g = n.upperWidth, w = n.lowerWidth, E = n.height, T = n.className, R = n.animationEasing, _ = n.animationDuration, b = n.animationBegin, M = n.isUpdateAnimationActive;
  if (p !== +p || v !== +v || g !== +g || w !== +w || E !== +E || g === 0 && w === 0 || E === 0)
    return null;
  var A = clsx$1("recharts-trapezoid", T);
  return M ? /* @__PURE__ */ React__default.createElement(Animate, {
    canBegin: f > 0,
    from: {
      upperWidth: 0,
      lowerWidth: 0,
      height: E,
      x: p,
      y: v
    },
    to: {
      upperWidth: g,
      lowerWidth: w,
      height: E,
      x: p,
      y: v
    },
    duration: _,
    animationEasing: R,
    isActive: M
  }, function($) {
    var S = $.upperWidth, C = $.lowerWidth, D = $.height, O = $.x, N = $.y;
    return /* @__PURE__ */ React__default.createElement(Animate, {
      canBegin: f > 0,
      from: "0px ".concat(f === -1 ? 1 : f, "px"),
      to: "".concat(f, "px 0px"),
      attributeName: "strokeDasharray",
      begin: b,
      duration: _,
      easing: R
    }, /* @__PURE__ */ React__default.createElement("path", _extends$e({}, filterProps(n, !0), {
      className: A,
      d: getTrapezoidPath(O, N, S, C, D),
      ref: o
    })));
  }) : /* @__PURE__ */ React__default.createElement("g", null, /* @__PURE__ */ React__default.createElement("path", _extends$e({}, filterProps(n, !0), {
    className: A,
    d: getTrapezoidPath(p, v, g, w, E)
  })));
}, _excluded$5 = ["option", "shapeType", "propTransformer", "activeClassName", "isActive"];
function _typeof$h(t) {
  "@babel/helpers - typeof";
  return _typeof$h = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof$h(t);
}
function _objectWithoutProperties$5(t, e) {
  if (t == null) return {};
  var n = _objectWithoutPropertiesLoose$6(t, e), o, l;
  if (Object.getOwnPropertySymbols) {
    var u = Object.getOwnPropertySymbols(t);
    for (l = 0; l < u.length; l++)
      o = u[l], !(e.indexOf(o) >= 0) && Object.prototype.propertyIsEnumerable.call(t, o) && (n[o] = t[o]);
  }
  return n;
}
function _objectWithoutPropertiesLoose$6(t, e) {
  if (t == null) return {};
  var n = {}, o = Object.keys(t), l, u;
  for (u = 0; u < o.length; u++)
    l = o[u], !(e.indexOf(l) >= 0) && (n[l] = t[l]);
  return n;
}
function ownKeys$f(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(l) {
      return Object.getOwnPropertyDescriptor(t, l).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function _objectSpread$e(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ownKeys$f(Object(n), !0).forEach(function(o) {
      _defineProperty$g(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : ownKeys$f(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
function _defineProperty$g(t, e, n) {
  return e = _toPropertyKey$g(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function _toPropertyKey$g(t) {
  var e = _toPrimitive$g(t, "string");
  return _typeof$h(e) == "symbol" ? e : String(e);
}
function _toPrimitive$g(t, e) {
  if (_typeof$h(t) != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(t, e || "default");
    if (_typeof$h(o) != "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function defaultPropTransformer(t, e) {
  return _objectSpread$e(_objectSpread$e({}, e), t);
}
function isSymbolsProps(t, e) {
  return t === "symbols";
}
function ShapeSelector(t) {
  var e = t.shapeType, n = t.elementProps;
  switch (e) {
    case "rectangle":
      return /* @__PURE__ */ React__default.createElement(Rectangle, n);
    case "trapezoid":
      return /* @__PURE__ */ React__default.createElement(Trapezoid, n);
    case "sector":
      return /* @__PURE__ */ React__default.createElement(Sector, n);
    case "symbols":
      if (isSymbolsProps(e))
        return /* @__PURE__ */ React__default.createElement(Symbols, n);
      break;
    default:
      return null;
  }
}
function getPropsFromShapeOption(t) {
  return /* @__PURE__ */ isValidElement(t) ? t.props : t;
}
function Shape(t) {
  var e = t.option, n = t.shapeType, o = t.propTransformer, l = o === void 0 ? defaultPropTransformer : o, u = t.activeClassName, f = u === void 0 ? "recharts-active-shape" : u, h = t.isActive, p = _objectWithoutProperties$5(t, _excluded$5), v;
  if (/* @__PURE__ */ isValidElement(e))
    v = /* @__PURE__ */ cloneElement(e, _objectSpread$e(_objectSpread$e({}, p), getPropsFromShapeOption(e)));
  else if (isFunction$3(e))
    v = e(p);
  else if (isPlainObject$1(e) && !isBoolean$1(e)) {
    var g = l(e, p);
    v = /* @__PURE__ */ React__default.createElement(ShapeSelector, {
      shapeType: n,
      elementProps: g
    });
  } else {
    var w = p;
    v = /* @__PURE__ */ React__default.createElement(ShapeSelector, {
      shapeType: n,
      elementProps: w
    });
  }
  return h ? /* @__PURE__ */ React__default.createElement(Layer, {
    className: f
  }, v) : v;
}
function isFunnel(t, e) {
  return e != null && "trapezoids" in t.props;
}
function isPie(t, e) {
  return e != null && "sectors" in t.props;
}
function isScatter(t, e) {
  return e != null && "points" in t.props;
}
function compareFunnel(t, e) {
  var n, o, l = t.x === (e == null || (n = e.labelViewBox) === null || n === void 0 ? void 0 : n.x) || t.x === e.x, u = t.y === (e == null || (o = e.labelViewBox) === null || o === void 0 ? void 0 : o.y) || t.y === e.y;
  return l && u;
}
function comparePie(t, e) {
  var n = t.endAngle === e.endAngle, o = t.startAngle === e.startAngle;
  return n && o;
}
function compareScatter(t, e) {
  var n = t.x === e.x, o = t.y === e.y, l = t.z === e.z;
  return n && o && l;
}
function getComparisonFn(t, e) {
  var n;
  return isFunnel(t, e) ? n = compareFunnel : isPie(t, e) ? n = comparePie : isScatter(t, e) && (n = compareScatter), n;
}
function getShapeDataKey(t, e) {
  var n;
  return isFunnel(t, e) ? n = "trapezoids" : isPie(t, e) ? n = "sectors" : isScatter(t, e) && (n = "points"), n;
}
function getActiveShapeTooltipPayload(t, e) {
  if (isFunnel(t, e)) {
    var n;
    return (n = e.tooltipPayload) === null || n === void 0 || (n = n[0]) === null || n === void 0 || (n = n.payload) === null || n === void 0 ? void 0 : n.payload;
  }
  if (isPie(t, e)) {
    var o;
    return (o = e.tooltipPayload) === null || o === void 0 || (o = o[0]) === null || o === void 0 || (o = o.payload) === null || o === void 0 ? void 0 : o.payload;
  }
  return isScatter(t, e) ? e.payload : {};
}
function getActiveShapeIndexForTooltip(t) {
  var e = t.activeTooltipItem, n = t.graphicalItem, o = t.itemData, l = getShapeDataKey(n, e), u = getActiveShapeTooltipPayload(n, e), f = o.filter(function(p, v) {
    var g = isEqual$2(u, p), w = n.props[l].filter(function(R) {
      var _ = getComparisonFn(n, e);
      return _(R, e);
    }), E = n.props[l].indexOf(w[w.length - 1]), T = v === E;
    return g && T;
  }), h = o.indexOf(f[f.length - 1]);
  return h;
}
var _Pie;
function _typeof$g(t) {
  "@babel/helpers - typeof";
  return _typeof$g = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof$g(t);
}
function _extends$d() {
  return _extends$d = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }
    return t;
  }, _extends$d.apply(this, arguments);
}
function ownKeys$e(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(l) {
      return Object.getOwnPropertyDescriptor(t, l).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function _objectSpread$d(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ownKeys$e(Object(n), !0).forEach(function(o) {
      _defineProperty$f(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : ownKeys$e(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
function _classCallCheck$7(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$7(t, e) {
  for (var n = 0; n < e.length; n++) {
    var o = e[n];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, _toPropertyKey$f(o.key), o);
  }
}
function _createClass$7(t, e, n) {
  return e && _defineProperties$7(t.prototype, e), n && _defineProperties$7(t, n), Object.defineProperty(t, "prototype", { writable: !1 }), t;
}
function _callSuper$5(t, e, n) {
  return e = _getPrototypeOf$5(e), _possibleConstructorReturn$5(t, _isNativeReflectConstruct$5() ? Reflect.construct(e, n || [], _getPrototypeOf$5(t).constructor) : e.apply(t, n));
}
function _possibleConstructorReturn$5(t, e) {
  if (e && (_typeof$g(e) === "object" || typeof e == "function"))
    return e;
  if (e !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized$6(t);
}
function _isNativeReflectConstruct$5() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (_isNativeReflectConstruct$5 = function() {
    return !!t;
  })();
}
function _getPrototypeOf$5(t) {
  return _getPrototypeOf$5 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
    return n.__proto__ || Object.getPrototypeOf(n);
  }, _getPrototypeOf$5(t);
}
function _assertThisInitialized$6(t) {
  if (t === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t;
}
function _inherits$5(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf$6(t, e);
}
function _setPrototypeOf$6(t, e) {
  return _setPrototypeOf$6 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(o, l) {
    return o.__proto__ = l, o;
  }, _setPrototypeOf$6(t, e);
}
function _defineProperty$f(t, e, n) {
  return e = _toPropertyKey$f(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function _toPropertyKey$f(t) {
  var e = _toPrimitive$f(t, "string");
  return _typeof$g(e) == "symbol" ? e : String(e);
}
function _toPrimitive$f(t, e) {
  if (_typeof$g(t) != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(t, e || "default");
    if (_typeof$g(o) != "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
var Pie = /* @__PURE__ */ function(t) {
  _inherits$5(e, t);
  function e(n) {
    var o;
    return _classCallCheck$7(this, e), o = _callSuper$5(this, e, [n]), _defineProperty$f(_assertThisInitialized$6(o), "pieRef", null), _defineProperty$f(_assertThisInitialized$6(o), "sectorRefs", []), _defineProperty$f(_assertThisInitialized$6(o), "id", uniqueId("recharts-pie-")), _defineProperty$f(_assertThisInitialized$6(o), "handleAnimationEnd", function() {
      var l = o.props.onAnimationEnd;
      o.setState({
        isAnimationFinished: !0
      }), isFunction$3(l) && l();
    }), _defineProperty$f(_assertThisInitialized$6(o), "handleAnimationStart", function() {
      var l = o.props.onAnimationStart;
      o.setState({
        isAnimationFinished: !1
      }), isFunction$3(l) && l();
    }), o.state = {
      isAnimationFinished: !n.isAnimationActive,
      prevIsAnimationActive: n.isAnimationActive,
      prevAnimationId: n.animationId,
      sectorToFocus: 0
    }, o;
  }
  return _createClass$7(e, [{
    key: "isActiveIndex",
    value: function(o) {
      var l = this.props.activeIndex;
      return Array.isArray(l) ? l.indexOf(o) !== -1 : o === l;
    }
  }, {
    key: "hasActiveIndex",
    value: function() {
      var o = this.props.activeIndex;
      return Array.isArray(o) ? o.length !== 0 : o || o === 0;
    }
  }, {
    key: "renderLabels",
    value: function(o) {
      var l = this.props.isAnimationActive;
      if (l && !this.state.isAnimationFinished)
        return null;
      var u = this.props, f = u.label, h = u.labelLine, p = u.dataKey, v = u.valueKey, g = filterProps(this.props, !1), w = filterProps(f, !1), E = filterProps(h, !1), T = f && f.offsetRadius || 20, R = o.map(function(_, b) {
        var M = (_.startAngle + _.endAngle) / 2, A = polarToCartesian(_.cx, _.cy, _.outerRadius + T, M), $ = _objectSpread$d(_objectSpread$d(_objectSpread$d(_objectSpread$d({}, g), _), {}, {
          stroke: "none"
        }, w), {}, {
          index: b,
          textAnchor: e.getTextAnchor(A.x, _.cx)
        }, A), S = _objectSpread$d(_objectSpread$d(_objectSpread$d(_objectSpread$d({}, g), _), {}, {
          fill: "none",
          stroke: _.fill
        }, E), {}, {
          index: b,
          points: [polarToCartesian(_.cx, _.cy, _.outerRadius, M), A],
          key: "line"
        }), C = p;
        return isNil$1(p) && isNil$1(v) ? C = "value" : isNil$1(p) && (C = v), // eslint-disable-next-line react/no-array-index-key
        /* @__PURE__ */ React__default.createElement(Layer, {
          key: "label-".concat(_.startAngle, "-").concat(_.endAngle, "-").concat(_.midAngle, "-").concat(b)
        }, h && e.renderLabelLineItem(h, S), e.renderLabelItem(f, $, getValueByDataKey(_, C)));
      });
      return /* @__PURE__ */ React__default.createElement(Layer, {
        className: "recharts-pie-labels"
      }, R);
    }
  }, {
    key: "renderSectorsStatically",
    value: function(o) {
      var l = this, u = this.props, f = u.activeShape, h = u.blendStroke, p = u.inactiveShape;
      return o.map(function(v, g) {
        if ((v == null ? void 0 : v.startAngle) === 0 && (v == null ? void 0 : v.endAngle) === 0 && o.length !== 1) return null;
        var w = l.isActiveIndex(g), E = p && l.hasActiveIndex() ? p : null, T = w ? f : E, R = _objectSpread$d(_objectSpread$d({}, v), {}, {
          stroke: h ? v.fill : v.stroke,
          tabIndex: -1
        });
        return /* @__PURE__ */ React__default.createElement(Layer, _extends$d({
          ref: function(b) {
            b && !l.sectorRefs.includes(b) && l.sectorRefs.push(b);
          },
          tabIndex: -1,
          className: "recharts-pie-sector"
        }, adaptEventsOfChild(l.props, v, g), {
          // eslint-disable-next-line react/no-array-index-key
          key: "sector-".concat(v == null ? void 0 : v.startAngle, "-").concat(v == null ? void 0 : v.endAngle, "-").concat(v.midAngle, "-").concat(g)
        }), /* @__PURE__ */ React__default.createElement(Shape, _extends$d({
          option: T,
          isActive: w,
          shapeType: "sector"
        }, R)));
      });
    }
  }, {
    key: "renderSectorsWithAnimation",
    value: function() {
      var o = this, l = this.props, u = l.sectors, f = l.isAnimationActive, h = l.animationBegin, p = l.animationDuration, v = l.animationEasing, g = l.animationId, w = this.state, E = w.prevSectors, T = w.prevIsAnimationActive;
      return /* @__PURE__ */ React__default.createElement(Animate, {
        begin: h,
        duration: p,
        isActive: f,
        easing: v,
        from: {
          t: 0
        },
        to: {
          t: 1
        },
        key: "pie-".concat(g, "-").concat(T),
        onAnimationStart: this.handleAnimationStart,
        onAnimationEnd: this.handleAnimationEnd
      }, function(R) {
        var _ = R.t, b = [], M = u && u[0], A = M.startAngle;
        return u.forEach(function($, S) {
          var C = E && E[S], D = S > 0 ? get$2($, "paddingAngle", 0) : 0;
          if (C) {
            var O = interpolateNumber$1(C.endAngle - C.startAngle, $.endAngle - $.startAngle), N = _objectSpread$d(_objectSpread$d({}, $), {}, {
              startAngle: A + D,
              endAngle: A + O(_) + D
            });
            b.push(N), A = N.endAngle;
          } else {
            var j = $.endAngle, L = $.startAngle, z = interpolateNumber$1(0, j - L), G = z(_), B = _objectSpread$d(_objectSpread$d({}, $), {}, {
              startAngle: A + D,
              endAngle: A + G + D
            });
            b.push(B), A = B.endAngle;
          }
        }), /* @__PURE__ */ React__default.createElement(Layer, null, o.renderSectorsStatically(b));
      });
    }
  }, {
    key: "attachKeyboardHandlers",
    value: function(o) {
      var l = this;
      o.onkeydown = function(u) {
        if (!u.altKey)
          switch (u.key) {
            case "ArrowLeft": {
              var f = ++l.state.sectorToFocus % l.sectorRefs.length;
              l.sectorRefs[f].focus(), l.setState({
                sectorToFocus: f
              });
              break;
            }
            case "ArrowRight": {
              var h = --l.state.sectorToFocus < 0 ? l.sectorRefs.length - 1 : l.state.sectorToFocus % l.sectorRefs.length;
              l.sectorRefs[h].focus(), l.setState({
                sectorToFocus: h
              });
              break;
            }
            case "Escape": {
              l.sectorRefs[l.state.sectorToFocus].blur(), l.setState({
                sectorToFocus: 0
              });
              break;
            }
          }
      };
    }
  }, {
    key: "renderSectors",
    value: function() {
      var o = this.props, l = o.sectors, u = o.isAnimationActive, f = this.state.prevSectors;
      return u && l && l.length && (!f || !isEqual$2(f, l)) ? this.renderSectorsWithAnimation() : this.renderSectorsStatically(l);
    }
  }, {
    key: "componentDidMount",
    value: function() {
      this.pieRef && this.attachKeyboardHandlers(this.pieRef);
    }
  }, {
    key: "render",
    value: function() {
      var o = this, l = this.props, u = l.hide, f = l.sectors, h = l.className, p = l.label, v = l.cx, g = l.cy, w = l.innerRadius, E = l.outerRadius, T = l.isAnimationActive, R = this.state.isAnimationFinished;
      if (u || !f || !f.length || !isNumber(v) || !isNumber(g) || !isNumber(w) || !isNumber(E))
        return null;
      var _ = clsx$1("recharts-pie", h);
      return /* @__PURE__ */ React__default.createElement(Layer, {
        tabIndex: this.props.rootTabIndex,
        className: _,
        ref: function(M) {
          o.pieRef = M;
        }
      }, this.renderSectors(), p && this.renderLabels(f), Label.renderCallByParent(this.props, null, !1), (!T || R) && LabelList.renderCallByParent(this.props, f, !1));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function(o, l) {
      return l.prevIsAnimationActive !== o.isAnimationActive ? {
        prevIsAnimationActive: o.isAnimationActive,
        prevAnimationId: o.animationId,
        curSectors: o.sectors,
        prevSectors: [],
        isAnimationFinished: !0
      } : o.isAnimationActive && o.animationId !== l.prevAnimationId ? {
        prevAnimationId: o.animationId,
        curSectors: o.sectors,
        prevSectors: l.curSectors,
        isAnimationFinished: !0
      } : o.sectors !== l.curSectors ? {
        curSectors: o.sectors,
        isAnimationFinished: !0
      } : null;
    }
  }, {
    key: "getTextAnchor",
    value: function(o, l) {
      return o > l ? "start" : o < l ? "end" : "middle";
    }
  }, {
    key: "renderLabelLineItem",
    value: function(o, l) {
      if (/* @__PURE__ */ React__default.isValidElement(o))
        return /* @__PURE__ */ React__default.cloneElement(o, l);
      if (isFunction$3(o))
        return o(l);
      var u = clsx$1("recharts-pie-label-line", typeof o != "boolean" ? o.className : "");
      return /* @__PURE__ */ React__default.createElement(Curve, _extends$d({}, l, {
        type: "linear",
        className: u
      }));
    }
  }, {
    key: "renderLabelItem",
    value: function(o, l, u) {
      if (/* @__PURE__ */ React__default.isValidElement(o))
        return /* @__PURE__ */ React__default.cloneElement(o, l);
      var f = u;
      if (isFunction$3(o) && (f = o(l), /* @__PURE__ */ React__default.isValidElement(f)))
        return f;
      var h = clsx$1("recharts-pie-label-text", typeof o != "boolean" && !isFunction$3(o) ? o.className : "");
      return /* @__PURE__ */ React__default.createElement(Text, _extends$d({}, l, {
        alignmentBaseline: "middle",
        className: h
      }), f);
    }
  }]), e;
}(PureComponent);
_Pie = Pie;
_defineProperty$f(Pie, "displayName", "Pie");
_defineProperty$f(Pie, "defaultProps", {
  stroke: "#fff",
  fill: "#808080",
  legendType: "rect",
  cx: "50%",
  cy: "50%",
  startAngle: 0,
  endAngle: 360,
  innerRadius: 0,
  outerRadius: "80%",
  paddingAngle: 0,
  labelLine: !0,
  hide: !1,
  minAngle: 0,
  isAnimationActive: !Global.isSsr,
  animationBegin: 400,
  animationDuration: 1500,
  animationEasing: "ease",
  nameKey: "name",
  blendStroke: !1,
  rootTabIndex: 0
});
_defineProperty$f(Pie, "parseDeltaAngle", function(t, e) {
  var n = mathSign(e - t), o = Math.min(Math.abs(e - t), 360);
  return n * o;
});
_defineProperty$f(Pie, "getRealPieData", function(t) {
  var e = t.props, n = e.data, o = e.children, l = filterProps(t.props, !1), u = findAllByType(o, Cell);
  return n && n.length ? n.map(function(f, h) {
    return _objectSpread$d(_objectSpread$d(_objectSpread$d({
      payload: f
    }, l), f), u && u[h] && u[h].props);
  }) : u && u.length ? u.map(function(f) {
    return _objectSpread$d(_objectSpread$d({}, l), f.props);
  }) : [];
});
_defineProperty$f(Pie, "parseCoordinateOfPie", function(t, e) {
  var n = e.top, o = e.left, l = e.width, u = e.height, f = getMaxRadius(l, u), h = o + getPercentValue(t.props.cx, l, l / 2), p = n + getPercentValue(t.props.cy, u, u / 2), v = getPercentValue(t.props.innerRadius, f, 0), g = getPercentValue(t.props.outerRadius, f, f * 0.8), w = t.props.maxRadius || Math.sqrt(l * l + u * u) / 2;
  return {
    cx: h,
    cy: p,
    innerRadius: v,
    outerRadius: g,
    maxRadius: w
  };
});
_defineProperty$f(Pie, "getComposedData", function(t) {
  var e = t.item, n = t.offset, o = _Pie.getRealPieData(e);
  if (!o || !o.length)
    return null;
  var l = e.props, u = l.cornerRadius, f = l.startAngle, h = l.endAngle, p = l.paddingAngle, v = l.dataKey, g = l.nameKey, w = l.valueKey, E = l.tooltipType, T = Math.abs(e.props.minAngle), R = _Pie.parseCoordinateOfPie(e, n), _ = _Pie.parseDeltaAngle(f, h), b = Math.abs(_), M = v;
  isNil$1(v) && isNil$1(w) ? (warn$2(!1, `Use "dataKey" to specify the value of pie,
      the props "valueKey" will be deprecated in 1.1.0`), M = "value") : isNil$1(v) && (warn$2(!1, `Use "dataKey" to specify the value of pie,
      the props "valueKey" will be deprecated in 1.1.0`), M = w);
  var A = o.filter(function(N) {
    return getValueByDataKey(N, M, 0) !== 0;
  }).length, $ = (b >= 360 ? A : A - 1) * p, S = b - A * T - $, C = o.reduce(function(N, j) {
    var L = getValueByDataKey(j, M, 0);
    return N + (isNumber(L) ? L : 0);
  }, 0), D;
  if (C > 0) {
    var O;
    D = o.map(function(N, j) {
      var L = getValueByDataKey(N, M, 0), z = getValueByDataKey(N, g, j), G = (isNumber(L) ? L : 0) / C, B;
      j ? B = O.endAngle + mathSign(_) * p * (L !== 0 ? 1 : 0) : B = f;
      var F = B + mathSign(_) * ((L !== 0 ? T : 0) + G * S), H = (B + F) / 2, W = (R.innerRadius + R.outerRadius) / 2, V = [{
        name: z,
        value: L,
        payload: N,
        dataKey: M,
        type: E
      }], X = polarToCartesian(R.cx, R.cy, W, H);
      return O = _objectSpread$d(_objectSpread$d(_objectSpread$d({
        percent: G,
        cornerRadius: u,
        name: z,
        tooltipPayload: V,
        midAngle: H,
        middleRadius: W,
        tooltipPosition: X
      }, N), R), {}, {
        value: getValueByDataKey(N, M),
        startAngle: B,
        endAngle: F,
        payload: N,
        paddingAngle: mathSign(_) * p
      }), O;
    });
  }
  return _objectSpread$d(_objectSpread$d({}, R), {}, {
    sectors: D,
    data: o
  });
});
var nativeCeil = Math.ceil, nativeMax$1 = Math.max;
function baseRange$1(t, e, n, o) {
  for (var l = -1, u = nativeMax$1(nativeCeil((e - t) / (n || 1)), 0), f = Array(u); u--; )
    f[o ? u : ++l] = t, t += n;
  return f;
}
var _baseRange = baseRange$1, toNumber = toNumber_1, INFINITY = 1 / 0, MAX_INTEGER = 17976931348623157e292;
function toFinite$2(t) {
  if (!t)
    return t === 0 ? t : 0;
  if (t = toNumber(t), t === INFINITY || t === -INFINITY) {
    var e = t < 0 ? -1 : 1;
    return e * MAX_INTEGER;
  }
  return t === t ? t : 0;
}
var toFinite_1 = toFinite$2, baseRange = _baseRange, isIterateeCall$2 = _isIterateeCall, toFinite$1 = toFinite_1;
function createRange$1(t) {
  return function(e, n, o) {
    return o && typeof o != "number" && isIterateeCall$2(e, n, o) && (n = o = void 0), e = toFinite$1(e), n === void 0 ? (n = e, e = 0) : n = toFinite$1(n), o = o === void 0 ? e < n ? 1 : -1 : toFinite$1(o), baseRange(e, n, o, t);
  };
}
var _createRange = createRange$1, createRange = _createRange, range = createRange(), range_1 = range;
const range$1 = /* @__PURE__ */ getDefaultExportFromCjs(range_1);
function _typeof$f(t) {
  "@babel/helpers - typeof";
  return _typeof$f = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof$f(t);
}
function ownKeys$d(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(l) {
      return Object.getOwnPropertyDescriptor(t, l).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function _objectSpread$c(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ownKeys$d(Object(n), !0).forEach(function(o) {
      _defineProperty$e(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : ownKeys$d(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
function _defineProperty$e(t, e, n) {
  return e = _toPropertyKey$e(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function _toPropertyKey$e(t) {
  var e = _toPrimitive$e(t, "string");
  return _typeof$f(e) == "symbol" ? e : String(e);
}
function _toPrimitive$e(t, e) {
  if (_typeof$f(t) != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(t, e || "default");
    if (_typeof$f(o) != "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
var PREFIX_LIST = ["Webkit", "Moz", "O", "ms"], generatePrefixStyle = function t(e, n) {
  var o = e.replace(/(\w)/, function(u) {
    return u.toUpperCase();
  }), l = PREFIX_LIST.reduce(function(u, f) {
    return _objectSpread$c(_objectSpread$c({}, u), {}, _defineProperty$e({}, f + o, n));
  }, {});
  return l[e] = n, l;
};
function _typeof$e(t) {
  "@babel/helpers - typeof";
  return _typeof$e = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof$e(t);
}
function _extends$c() {
  return _extends$c = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }
    return t;
  }, _extends$c.apply(this, arguments);
}
function ownKeys$c(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(l) {
      return Object.getOwnPropertyDescriptor(t, l).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function _objectSpread$b(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ownKeys$c(Object(n), !0).forEach(function(o) {
      _defineProperty$d(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : ownKeys$c(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
function _classCallCheck$6(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$6(t, e) {
  for (var n = 0; n < e.length; n++) {
    var o = e[n];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, _toPropertyKey$d(o.key), o);
  }
}
function _createClass$6(t, e, n) {
  return e && _defineProperties$6(t.prototype, e), n && _defineProperties$6(t, n), Object.defineProperty(t, "prototype", { writable: !1 }), t;
}
function _callSuper$4(t, e, n) {
  return e = _getPrototypeOf$4(e), _possibleConstructorReturn$4(t, _isNativeReflectConstruct$4() ? Reflect.construct(e, n || [], _getPrototypeOf$4(t).constructor) : e.apply(t, n));
}
function _possibleConstructorReturn$4(t, e) {
  if (e && (_typeof$e(e) === "object" || typeof e == "function"))
    return e;
  if (e !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized$5(t);
}
function _isNativeReflectConstruct$4() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (_isNativeReflectConstruct$4 = function() {
    return !!t;
  })();
}
function _getPrototypeOf$4(t) {
  return _getPrototypeOf$4 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
    return n.__proto__ || Object.getPrototypeOf(n);
  }, _getPrototypeOf$4(t);
}
function _assertThisInitialized$5(t) {
  if (t === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t;
}
function _inherits$4(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf$5(t, e);
}
function _setPrototypeOf$5(t, e) {
  return _setPrototypeOf$5 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(o, l) {
    return o.__proto__ = l, o;
  }, _setPrototypeOf$5(t, e);
}
function _defineProperty$d(t, e, n) {
  return e = _toPropertyKey$d(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function _toPropertyKey$d(t) {
  var e = _toPrimitive$d(t, "string");
  return _typeof$e(e) == "symbol" ? e : String(e);
}
function _toPrimitive$d(t, e) {
  if (_typeof$e(t) != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(t, e || "default");
    if (_typeof$e(o) != "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
var createScale = function t(e) {
  var n = e.data, o = e.startIndex, l = e.endIndex, u = e.x, f = e.width, h = e.travellerWidth;
  if (!n || !n.length)
    return {};
  var p = n.length, v = point().domain(range$1(0, p)).range([u, u + f - h]), g = v.domain().map(function(w) {
    return v(w);
  });
  return {
    isTextActive: !1,
    isSlideMoving: !1,
    isTravellerMoving: !1,
    isTravellerFocused: !1,
    startX: v(o),
    endX: v(l),
    scale: v,
    scaleValues: g
  };
}, isTouch = function t(e) {
  return e.changedTouches && !!e.changedTouches.length;
}, Brush = /* @__PURE__ */ function(t) {
  _inherits$4(e, t);
  function e(n) {
    var o;
    return _classCallCheck$6(this, e), o = _callSuper$4(this, e, [n]), _defineProperty$d(_assertThisInitialized$5(o), "handleDrag", function(l) {
      o.leaveTimer && (clearTimeout(o.leaveTimer), o.leaveTimer = null), o.state.isTravellerMoving ? o.handleTravellerMove(l) : o.state.isSlideMoving && o.handleSlideDrag(l);
    }), _defineProperty$d(_assertThisInitialized$5(o), "handleTouchMove", function(l) {
      l.changedTouches != null && l.changedTouches.length > 0 && o.handleDrag(l.changedTouches[0]);
    }), _defineProperty$d(_assertThisInitialized$5(o), "handleDragEnd", function() {
      o.setState({
        isTravellerMoving: !1,
        isSlideMoving: !1
      }, function() {
        var l = o.props, u = l.endIndex, f = l.onDragEnd, h = l.startIndex;
        f == null || f({
          endIndex: u,
          startIndex: h
        });
      }), o.detachDragEndListener();
    }), _defineProperty$d(_assertThisInitialized$5(o), "handleLeaveWrapper", function() {
      (o.state.isTravellerMoving || o.state.isSlideMoving) && (o.leaveTimer = window.setTimeout(o.handleDragEnd, o.props.leaveTimeOut));
    }), _defineProperty$d(_assertThisInitialized$5(o), "handleEnterSlideOrTraveller", function() {
      o.setState({
        isTextActive: !0
      });
    }), _defineProperty$d(_assertThisInitialized$5(o), "handleLeaveSlideOrTraveller", function() {
      o.setState({
        isTextActive: !1
      });
    }), _defineProperty$d(_assertThisInitialized$5(o), "handleSlideDragStart", function(l) {
      var u = isTouch(l) ? l.changedTouches[0] : l;
      o.setState({
        isTravellerMoving: !1,
        isSlideMoving: !0,
        slideMoveStartX: u.pageX
      }), o.attachDragEndListener();
    }), o.travellerDragStartHandlers = {
      startX: o.handleTravellerDragStart.bind(_assertThisInitialized$5(o), "startX"),
      endX: o.handleTravellerDragStart.bind(_assertThisInitialized$5(o), "endX")
    }, o.state = {}, o;
  }
  return _createClass$6(e, [{
    key: "componentWillUnmount",
    value: function() {
      this.leaveTimer && (clearTimeout(this.leaveTimer), this.leaveTimer = null), this.detachDragEndListener();
    }
  }, {
    key: "getIndex",
    value: function(o) {
      var l = o.startX, u = o.endX, f = this.state.scaleValues, h = this.props, p = h.gap, v = h.data, g = v.length - 1, w = Math.min(l, u), E = Math.max(l, u), T = e.getIndexInRange(f, w), R = e.getIndexInRange(f, E);
      return {
        startIndex: T - T % p,
        endIndex: R === g ? g : R - R % p
      };
    }
  }, {
    key: "getTextOfTick",
    value: function(o) {
      var l = this.props, u = l.data, f = l.tickFormatter, h = l.dataKey, p = getValueByDataKey(u[o], h, o);
      return isFunction$3(f) ? f(p, o) : p;
    }
  }, {
    key: "attachDragEndListener",
    value: function() {
      window.addEventListener("mouseup", this.handleDragEnd, !0), window.addEventListener("touchend", this.handleDragEnd, !0), window.addEventListener("mousemove", this.handleDrag, !0);
    }
  }, {
    key: "detachDragEndListener",
    value: function() {
      window.removeEventListener("mouseup", this.handleDragEnd, !0), window.removeEventListener("touchend", this.handleDragEnd, !0), window.removeEventListener("mousemove", this.handleDrag, !0);
    }
  }, {
    key: "handleSlideDrag",
    value: function(o) {
      var l = this.state, u = l.slideMoveStartX, f = l.startX, h = l.endX, p = this.props, v = p.x, g = p.width, w = p.travellerWidth, E = p.startIndex, T = p.endIndex, R = p.onChange, _ = o.pageX - u;
      _ > 0 ? _ = Math.min(_, v + g - w - h, v + g - w - f) : _ < 0 && (_ = Math.max(_, v - f, v - h));
      var b = this.getIndex({
        startX: f + _,
        endX: h + _
      });
      (b.startIndex !== E || b.endIndex !== T) && R && R(b), this.setState({
        startX: f + _,
        endX: h + _,
        slideMoveStartX: o.pageX
      });
    }
  }, {
    key: "handleTravellerDragStart",
    value: function(o, l) {
      var u = isTouch(l) ? l.changedTouches[0] : l;
      this.setState({
        isSlideMoving: !1,
        isTravellerMoving: !0,
        movingTravellerId: o,
        brushMoveStartX: u.pageX
      }), this.attachDragEndListener();
    }
  }, {
    key: "handleTravellerMove",
    value: function(o) {
      var l = this.state, u = l.brushMoveStartX, f = l.movingTravellerId, h = l.endX, p = l.startX, v = this.state[f], g = this.props, w = g.x, E = g.width, T = g.travellerWidth, R = g.onChange, _ = g.gap, b = g.data, M = {
        startX: this.state.startX,
        endX: this.state.endX
      }, A = o.pageX - u;
      A > 0 ? A = Math.min(A, w + E - T - v) : A < 0 && (A = Math.max(A, w - v)), M[f] = v + A;
      var $ = this.getIndex(M), S = $.startIndex, C = $.endIndex, D = function() {
        var N = b.length - 1;
        return f === "startX" && (h > p ? S % _ === 0 : C % _ === 0) || h < p && C === N || f === "endX" && (h > p ? C % _ === 0 : S % _ === 0) || h > p && C === N;
      };
      this.setState(_defineProperty$d(_defineProperty$d({}, f, v + A), "brushMoveStartX", o.pageX), function() {
        R && D() && R($);
      });
    }
  }, {
    key: "handleTravellerMoveKeyboard",
    value: function(o, l) {
      var u = this, f = this.state, h = f.scaleValues, p = f.startX, v = f.endX, g = this.state[l], w = h.indexOf(g);
      if (w !== -1) {
        var E = w + o;
        if (!(E === -1 || E >= h.length)) {
          var T = h[E];
          l === "startX" && T >= v || l === "endX" && T <= p || this.setState(_defineProperty$d({}, l, T), function() {
            u.props.onChange(u.getIndex({
              startX: u.state.startX,
              endX: u.state.endX
            }));
          });
        }
      }
    }
  }, {
    key: "renderBackground",
    value: function() {
      var o = this.props, l = o.x, u = o.y, f = o.width, h = o.height, p = o.fill, v = o.stroke;
      return /* @__PURE__ */ React__default.createElement("rect", {
        stroke: v,
        fill: p,
        x: l,
        y: u,
        width: f,
        height: h
      });
    }
  }, {
    key: "renderPanorama",
    value: function() {
      var o = this.props, l = o.x, u = o.y, f = o.width, h = o.height, p = o.data, v = o.children, g = o.padding, w = Children.only(v);
      return w ? /* @__PURE__ */ React__default.cloneElement(w, {
        x: l,
        y: u,
        width: f,
        height: h,
        margin: g,
        compact: !0,
        data: p
      }) : null;
    }
  }, {
    key: "renderTravellerLayer",
    value: function(o, l) {
      var u, f, h = this, p = this.props, v = p.y, g = p.travellerWidth, w = p.height, E = p.traveller, T = p.ariaLabel, R = p.data, _ = p.startIndex, b = p.endIndex, M = Math.max(o, this.props.x), A = _objectSpread$b(_objectSpread$b({}, filterProps(this.props, !1)), {}, {
        x: M,
        y: v,
        width: g,
        height: w
      }), $ = T || "Min value: ".concat((u = R[_]) === null || u === void 0 ? void 0 : u.name, ", Max value: ").concat((f = R[b]) === null || f === void 0 ? void 0 : f.name);
      return /* @__PURE__ */ React__default.createElement(Layer, {
        tabIndex: 0,
        role: "slider",
        "aria-label": $,
        "aria-valuenow": o,
        className: "recharts-brush-traveller",
        onMouseEnter: this.handleEnterSlideOrTraveller,
        onMouseLeave: this.handleLeaveSlideOrTraveller,
        onMouseDown: this.travellerDragStartHandlers[l],
        onTouchStart: this.travellerDragStartHandlers[l],
        onKeyDown: function(C) {
          ["ArrowLeft", "ArrowRight"].includes(C.key) && (C.preventDefault(), C.stopPropagation(), h.handleTravellerMoveKeyboard(C.key === "ArrowRight" ? 1 : -1, l));
        },
        onFocus: function() {
          h.setState({
            isTravellerFocused: !0
          });
        },
        onBlur: function() {
          h.setState({
            isTravellerFocused: !1
          });
        },
        style: {
          cursor: "col-resize"
        }
      }, e.renderTraveller(E, A));
    }
  }, {
    key: "renderSlide",
    value: function(o, l) {
      var u = this.props, f = u.y, h = u.height, p = u.stroke, v = u.travellerWidth, g = Math.min(o, l) + v, w = Math.max(Math.abs(l - o) - v, 0);
      return /* @__PURE__ */ React__default.createElement("rect", {
        className: "recharts-brush-slide",
        onMouseEnter: this.handleEnterSlideOrTraveller,
        onMouseLeave: this.handleLeaveSlideOrTraveller,
        onMouseDown: this.handleSlideDragStart,
        onTouchStart: this.handleSlideDragStart,
        style: {
          cursor: "move"
        },
        stroke: "none",
        fill: p,
        fillOpacity: 0.2,
        x: g,
        y: f,
        width: w,
        height: h
      });
    }
  }, {
    key: "renderText",
    value: function() {
      var o = this.props, l = o.startIndex, u = o.endIndex, f = o.y, h = o.height, p = o.travellerWidth, v = o.stroke, g = this.state, w = g.startX, E = g.endX, T = 5, R = {
        pointerEvents: "none",
        fill: v
      };
      return /* @__PURE__ */ React__default.createElement(Layer, {
        className: "recharts-brush-texts"
      }, /* @__PURE__ */ React__default.createElement(Text, _extends$c({
        textAnchor: "end",
        verticalAnchor: "middle",
        x: Math.min(w, E) - T,
        y: f + h / 2
      }, R), this.getTextOfTick(l)), /* @__PURE__ */ React__default.createElement(Text, _extends$c({
        textAnchor: "start",
        verticalAnchor: "middle",
        x: Math.max(w, E) + p + T,
        y: f + h / 2
      }, R), this.getTextOfTick(u)));
    }
  }, {
    key: "render",
    value: function() {
      var o = this.props, l = o.data, u = o.className, f = o.children, h = o.x, p = o.y, v = o.width, g = o.height, w = o.alwaysShowText, E = this.state, T = E.startX, R = E.endX, _ = E.isTextActive, b = E.isSlideMoving, M = E.isTravellerMoving, A = E.isTravellerFocused;
      if (!l || !l.length || !isNumber(h) || !isNumber(p) || !isNumber(v) || !isNumber(g) || v <= 0 || g <= 0)
        return null;
      var $ = clsx$1("recharts-brush", u), S = React__default.Children.count(f) === 1, C = generatePrefixStyle("userSelect", "none");
      return /* @__PURE__ */ React__default.createElement(Layer, {
        className: $,
        onMouseLeave: this.handleLeaveWrapper,
        onTouchMove: this.handleTouchMove,
        style: C
      }, this.renderBackground(), S && this.renderPanorama(), this.renderSlide(T, R), this.renderTravellerLayer(T, "startX"), this.renderTravellerLayer(R, "endX"), (_ || b || M || A || w) && this.renderText());
    }
  }], [{
    key: "renderDefaultTraveller",
    value: function(o) {
      var l = o.x, u = o.y, f = o.width, h = o.height, p = o.stroke, v = Math.floor(u + h / 2) - 1;
      return /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, /* @__PURE__ */ React__default.createElement("rect", {
        x: l,
        y: u,
        width: f,
        height: h,
        fill: p,
        stroke: "none"
      }), /* @__PURE__ */ React__default.createElement("line", {
        x1: l + 1,
        y1: v,
        x2: l + f - 1,
        y2: v,
        fill: "none",
        stroke: "#fff"
      }), /* @__PURE__ */ React__default.createElement("line", {
        x1: l + 1,
        y1: v + 2,
        x2: l + f - 1,
        y2: v + 2,
        fill: "none",
        stroke: "#fff"
      }));
    }
  }, {
    key: "renderTraveller",
    value: function(o, l) {
      var u;
      return /* @__PURE__ */ React__default.isValidElement(o) ? u = /* @__PURE__ */ React__default.cloneElement(o, l) : isFunction$3(o) ? u = o(l) : u = e.renderDefaultTraveller(l), u;
    }
  }, {
    key: "getDerivedStateFromProps",
    value: function(o, l) {
      var u = o.data, f = o.width, h = o.x, p = o.travellerWidth, v = o.updateId, g = o.startIndex, w = o.endIndex;
      if (u !== l.prevData || v !== l.prevUpdateId)
        return _objectSpread$b({
          prevData: u,
          prevTravellerWidth: p,
          prevUpdateId: v,
          prevX: h,
          prevWidth: f
        }, u && u.length ? createScale({
          data: u,
          width: f,
          x: h,
          travellerWidth: p,
          startIndex: g,
          endIndex: w
        }) : {
          scale: null,
          scaleValues: null
        });
      if (l.scale && (f !== l.prevWidth || h !== l.prevX || p !== l.prevTravellerWidth)) {
        l.scale.range([h, h + f - p]);
        var E = l.scale.domain().map(function(T) {
          return l.scale(T);
        });
        return {
          prevData: u,
          prevTravellerWidth: p,
          prevUpdateId: v,
          prevX: h,
          prevWidth: f,
          startX: l.scale(o.startIndex),
          endX: l.scale(o.endIndex),
          scaleValues: E
        };
      }
      return null;
    }
  }, {
    key: "getIndexInRange",
    value: function(o, l) {
      for (var u = o.length, f = 0, h = u - 1; h - f > 1; ) {
        var p = Math.floor((f + h) / 2);
        o[p] > l ? h = p : f = p;
      }
      return l >= o[h] ? h : f;
    }
  }]), e;
}(PureComponent);
_defineProperty$d(Brush, "displayName", "Brush");
_defineProperty$d(Brush, "defaultProps", {
  height: 40,
  travellerWidth: 5,
  gap: 1,
  fill: "#fff",
  stroke: "#666",
  padding: {
    top: 1,
    right: 1,
    bottom: 1,
    left: 1
  },
  leaveTimeOut: 1e3,
  alwaysShowText: !1
});
var baseEach$1 = _baseEach;
function baseSome$1(t, e) {
  var n;
  return baseEach$1(t, function(o, l, u) {
    return n = e(o, l, u), !n;
  }), !!n;
}
var _baseSome = baseSome$1, arraySome = _arraySome, baseIteratee$4 = _baseIteratee, baseSome = _baseSome, isArray$1 = isArray_1, isIterateeCall$1 = _isIterateeCall;
function some(t, e, n) {
  var o = isArray$1(t) ? arraySome : baseSome;
  return n && isIterateeCall$1(t, e, n) && (e = void 0), o(t, baseIteratee$4(e));
}
var some_1 = some;
const some$1 = /* @__PURE__ */ getDefaultExportFromCjs(some_1);
var ifOverflowMatches = function t(e, n) {
  var o = e.alwaysShow, l = e.ifOverflow;
  return o && (l = "extendDomain"), l === n;
}, defineProperty = _defineProperty$C;
function baseAssignValue$1(t, e, n) {
  e == "__proto__" && defineProperty ? defineProperty(t, e, {
    configurable: !0,
    enumerable: !0,
    value: n,
    writable: !0
  }) : t[e] = n;
}
var _baseAssignValue = baseAssignValue$1, baseAssignValue = _baseAssignValue, baseForOwn = _baseForOwn, baseIteratee$3 = _baseIteratee;
function mapValues(t, e) {
  var n = {};
  return e = baseIteratee$3(e), baseForOwn(t, function(o, l, u) {
    baseAssignValue(n, l, e(o, l, u));
  }), n;
}
var mapValues_1 = mapValues;
const mapValues$1 = /* @__PURE__ */ getDefaultExportFromCjs(mapValues_1);
function arrayEvery$1(t, e) {
  for (var n = -1, o = t == null ? 0 : t.length; ++n < o; )
    if (!e(t[n], n, t))
      return !1;
  return !0;
}
var _arrayEvery = arrayEvery$1, baseEach = _baseEach;
function baseEvery$1(t, e) {
  var n = !0;
  return baseEach(t, function(o, l, u) {
    return n = !!e(o, l, u), n;
  }), n;
}
var _baseEvery = baseEvery$1, arrayEvery = _arrayEvery, baseEvery = _baseEvery, baseIteratee$2 = _baseIteratee, isArray = isArray_1, isIterateeCall = _isIterateeCall;
function every(t, e, n) {
  var o = isArray(t) ? arrayEvery : baseEvery;
  return n && isIterateeCall(t, e, n) && (e = void 0), o(t, baseIteratee$2(e));
}
var every_1 = every;
const every$1 = /* @__PURE__ */ getDefaultExportFromCjs(every_1);
var _excluded$4 = ["x", "y"];
function _typeof$d(t) {
  "@babel/helpers - typeof";
  return _typeof$d = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof$d(t);
}
function _extends$b() {
  return _extends$b = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }
    return t;
  }, _extends$b.apply(this, arguments);
}
function ownKeys$b(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(l) {
      return Object.getOwnPropertyDescriptor(t, l).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function _objectSpread$a(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ownKeys$b(Object(n), !0).forEach(function(o) {
      _defineProperty$c(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : ownKeys$b(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
function _defineProperty$c(t, e, n) {
  return e = _toPropertyKey$c(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function _toPropertyKey$c(t) {
  var e = _toPrimitive$c(t, "string");
  return _typeof$d(e) == "symbol" ? e : String(e);
}
function _toPrimitive$c(t, e) {
  if (_typeof$d(t) != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(t, e || "default");
    if (_typeof$d(o) != "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function _objectWithoutProperties$4(t, e) {
  if (t == null) return {};
  var n = _objectWithoutPropertiesLoose$5(t, e), o, l;
  if (Object.getOwnPropertySymbols) {
    var u = Object.getOwnPropertySymbols(t);
    for (l = 0; l < u.length; l++)
      o = u[l], !(e.indexOf(o) >= 0) && Object.prototype.propertyIsEnumerable.call(t, o) && (n[o] = t[o]);
  }
  return n;
}
function _objectWithoutPropertiesLoose$5(t, e) {
  if (t == null) return {};
  var n = {}, o = Object.keys(t), l, u;
  for (u = 0; u < o.length; u++)
    l = o[u], !(e.indexOf(l) >= 0) && (n[l] = t[l]);
  return n;
}
function typeguardBarRectangleProps(t, e) {
  var n = t.x, o = t.y, l = _objectWithoutProperties$4(t, _excluded$4), u = "".concat(n), f = parseInt(u, 10), h = "".concat(o), p = parseInt(h, 10), v = "".concat(e.height || l.height), g = parseInt(v, 10), w = "".concat(e.width || l.width), E = parseInt(w, 10);
  return _objectSpread$a(_objectSpread$a(_objectSpread$a(_objectSpread$a(_objectSpread$a({}, e), l), f ? {
    x: f
  } : {}), p ? {
    y: p
  } : {}), {}, {
    height: g,
    width: E,
    name: e.name,
    radius: e.radius
  });
}
function BarRectangle(t) {
  return /* @__PURE__ */ React__default.createElement(Shape, _extends$b({
    shapeType: "rectangle",
    propTransformer: typeguardBarRectangleProps,
    activeClassName: "recharts-active-bar"
  }, t));
}
var minPointSizeCallback = function t(e) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  return function(o, l) {
    if (typeof e == "number") return e;
    var u = typeof o == "number";
    return u ? e(o, l) : (u || (process.env.NODE_ENV !== "production" ? invariant(!1, "minPointSize callback function received a value with type of ".concat(_typeof$d(o), ". Currently only numbers are supported.")) : invariant()), n);
  };
}, _excluded$3 = ["value", "background"], _Bar;
function _typeof$c(t) {
  "@babel/helpers - typeof";
  return _typeof$c = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof$c(t);
}
function _objectWithoutProperties$3(t, e) {
  if (t == null) return {};
  var n = _objectWithoutPropertiesLoose$4(t, e), o, l;
  if (Object.getOwnPropertySymbols) {
    var u = Object.getOwnPropertySymbols(t);
    for (l = 0; l < u.length; l++)
      o = u[l], !(e.indexOf(o) >= 0) && Object.prototype.propertyIsEnumerable.call(t, o) && (n[o] = t[o]);
  }
  return n;
}
function _objectWithoutPropertiesLoose$4(t, e) {
  if (t == null) return {};
  var n = {}, o = Object.keys(t), l, u;
  for (u = 0; u < o.length; u++)
    l = o[u], !(e.indexOf(l) >= 0) && (n[l] = t[l]);
  return n;
}
function _extends$a() {
  return _extends$a = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }
    return t;
  }, _extends$a.apply(this, arguments);
}
function ownKeys$a(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(l) {
      return Object.getOwnPropertyDescriptor(t, l).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function _objectSpread$9(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ownKeys$a(Object(n), !0).forEach(function(o) {
      _defineProperty$b(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : ownKeys$a(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
function _classCallCheck$5(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$5(t, e) {
  for (var n = 0; n < e.length; n++) {
    var o = e[n];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, _toPropertyKey$b(o.key), o);
  }
}
function _createClass$5(t, e, n) {
  return e && _defineProperties$5(t.prototype, e), n && _defineProperties$5(t, n), Object.defineProperty(t, "prototype", { writable: !1 }), t;
}
function _callSuper$3(t, e, n) {
  return e = _getPrototypeOf$3(e), _possibleConstructorReturn$3(t, _isNativeReflectConstruct$3() ? Reflect.construct(e, n || [], _getPrototypeOf$3(t).constructor) : e.apply(t, n));
}
function _possibleConstructorReturn$3(t, e) {
  if (e && (_typeof$c(e) === "object" || typeof e == "function"))
    return e;
  if (e !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized$4(t);
}
function _isNativeReflectConstruct$3() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (_isNativeReflectConstruct$3 = function() {
    return !!t;
  })();
}
function _getPrototypeOf$3(t) {
  return _getPrototypeOf$3 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
    return n.__proto__ || Object.getPrototypeOf(n);
  }, _getPrototypeOf$3(t);
}
function _assertThisInitialized$4(t) {
  if (t === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t;
}
function _inherits$3(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf$4(t, e);
}
function _setPrototypeOf$4(t, e) {
  return _setPrototypeOf$4 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(o, l) {
    return o.__proto__ = l, o;
  }, _setPrototypeOf$4(t, e);
}
function _defineProperty$b(t, e, n) {
  return e = _toPropertyKey$b(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function _toPropertyKey$b(t) {
  var e = _toPrimitive$b(t, "string");
  return _typeof$c(e) == "symbol" ? e : String(e);
}
function _toPrimitive$b(t, e) {
  if (_typeof$c(t) != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(t, e || "default");
    if (_typeof$c(o) != "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
var Bar = /* @__PURE__ */ function(t) {
  _inherits$3(e, t);
  function e() {
    var n;
    _classCallCheck$5(this, e);
    for (var o = arguments.length, l = new Array(o), u = 0; u < o; u++)
      l[u] = arguments[u];
    return n = _callSuper$3(this, e, [].concat(l)), _defineProperty$b(_assertThisInitialized$4(n), "state", {
      isAnimationFinished: !1
    }), _defineProperty$b(_assertThisInitialized$4(n), "id", uniqueId("recharts-bar-")), _defineProperty$b(_assertThisInitialized$4(n), "handleAnimationEnd", function() {
      var f = n.props.onAnimationEnd;
      n.setState({
        isAnimationFinished: !0
      }), f && f();
    }), _defineProperty$b(_assertThisInitialized$4(n), "handleAnimationStart", function() {
      var f = n.props.onAnimationStart;
      n.setState({
        isAnimationFinished: !1
      }), f && f();
    }), n;
  }
  return _createClass$5(e, [{
    key: "renderRectanglesStatically",
    value: function(o) {
      var l = this, u = this.props, f = u.shape, h = u.dataKey, p = u.activeIndex, v = u.activeBar, g = filterProps(this.props, !1);
      return o && o.map(function(w, E) {
        var T = E === p, R = T ? v : f, _ = _objectSpread$9(_objectSpread$9(_objectSpread$9({}, g), w), {}, {
          isActive: T,
          option: R,
          index: E,
          dataKey: h,
          onAnimationStart: l.handleAnimationStart,
          onAnimationEnd: l.handleAnimationEnd
        });
        return /* @__PURE__ */ React__default.createElement(Layer, _extends$a({
          className: "recharts-bar-rectangle"
        }, adaptEventsOfChild(l.props, w, E), {
          key: "rectangle-".concat(w == null ? void 0 : w.x, "-").concat(w == null ? void 0 : w.y, "-").concat(w == null ? void 0 : w.value)
        }), /* @__PURE__ */ React__default.createElement(BarRectangle, _));
      });
    }
  }, {
    key: "renderRectanglesWithAnimation",
    value: function() {
      var o = this, l = this.props, u = l.data, f = l.layout, h = l.isAnimationActive, p = l.animationBegin, v = l.animationDuration, g = l.animationEasing, w = l.animationId, E = this.state.prevData;
      return /* @__PURE__ */ React__default.createElement(Animate, {
        begin: p,
        duration: v,
        isActive: h,
        easing: g,
        from: {
          t: 0
        },
        to: {
          t: 1
        },
        key: "bar-".concat(w),
        onAnimationEnd: this.handleAnimationEnd,
        onAnimationStart: this.handleAnimationStart
      }, function(T) {
        var R = T.t, _ = u.map(function(b, M) {
          var A = E && E[M];
          if (A) {
            var $ = interpolateNumber$1(A.x, b.x), S = interpolateNumber$1(A.y, b.y), C = interpolateNumber$1(A.width, b.width), D = interpolateNumber$1(A.height, b.height);
            return _objectSpread$9(_objectSpread$9({}, b), {}, {
              x: $(R),
              y: S(R),
              width: C(R),
              height: D(R)
            });
          }
          if (f === "horizontal") {
            var O = interpolateNumber$1(0, b.height), N = O(R);
            return _objectSpread$9(_objectSpread$9({}, b), {}, {
              y: b.y + b.height - N,
              height: N
            });
          }
          var j = interpolateNumber$1(0, b.width), L = j(R);
          return _objectSpread$9(_objectSpread$9({}, b), {}, {
            width: L
          });
        });
        return /* @__PURE__ */ React__default.createElement(Layer, null, o.renderRectanglesStatically(_));
      });
    }
  }, {
    key: "renderRectangles",
    value: function() {
      var o = this.props, l = o.data, u = o.isAnimationActive, f = this.state.prevData;
      return u && l && l.length && (!f || !isEqual$2(f, l)) ? this.renderRectanglesWithAnimation() : this.renderRectanglesStatically(l);
    }
  }, {
    key: "renderBackground",
    value: function() {
      var o = this, l = this.props, u = l.data, f = l.dataKey, h = l.activeIndex, p = filterProps(this.props.background, !1);
      return u.map(function(v, g) {
        v.value;
        var w = v.background, E = _objectWithoutProperties$3(v, _excluded$3);
        if (!w)
          return null;
        var T = _objectSpread$9(_objectSpread$9(_objectSpread$9(_objectSpread$9(_objectSpread$9({}, E), {}, {
          fill: "#eee"
        }, w), p), adaptEventsOfChild(o.props, v, g)), {}, {
          onAnimationStart: o.handleAnimationStart,
          onAnimationEnd: o.handleAnimationEnd,
          dataKey: f,
          index: g,
          key: "background-bar-".concat(g),
          className: "recharts-bar-background-rectangle"
        });
        return /* @__PURE__ */ React__default.createElement(BarRectangle, _extends$a({
          option: o.props.background,
          isActive: g === h
        }, T));
      });
    }
  }, {
    key: "renderErrorBar",
    value: function(o, l) {
      if (this.props.isAnimationActive && !this.state.isAnimationFinished)
        return null;
      var u = this.props, f = u.data, h = u.xAxis, p = u.yAxis, v = u.layout, g = u.children, w = findAllByType(g, ErrorBar);
      if (!w)
        return null;
      var E = v === "vertical" ? f[0].height / 2 : f[0].width / 2, T = function(b, M) {
        var A = Array.isArray(b.value) ? b.value[1] : b.value;
        return {
          x: b.x,
          y: b.y,
          value: A,
          errorVal: getValueByDataKey(b, M)
        };
      }, R = {
        clipPath: o ? "url(#clipPath-".concat(l, ")") : null
      };
      return /* @__PURE__ */ React__default.createElement(Layer, R, w.map(function(_) {
        return /* @__PURE__ */ React__default.cloneElement(_, {
          key: "error-bar-".concat(l, "-").concat(_.props.dataKey),
          data: f,
          xAxis: h,
          yAxis: p,
          layout: v,
          offset: E,
          dataPointFormatter: T
        });
      }));
    }
  }, {
    key: "render",
    value: function() {
      var o = this.props, l = o.hide, u = o.data, f = o.className, h = o.xAxis, p = o.yAxis, v = o.left, g = o.top, w = o.width, E = o.height, T = o.isAnimationActive, R = o.background, _ = o.id;
      if (l || !u || !u.length)
        return null;
      var b = this.state.isAnimationFinished, M = clsx$1("recharts-bar", f), A = h && h.allowDataOverflow, $ = p && p.allowDataOverflow, S = A || $, C = isNil$1(_) ? this.id : _;
      return /* @__PURE__ */ React__default.createElement(Layer, {
        className: M
      }, A || $ ? /* @__PURE__ */ React__default.createElement("defs", null, /* @__PURE__ */ React__default.createElement("clipPath", {
        id: "clipPath-".concat(C)
      }, /* @__PURE__ */ React__default.createElement("rect", {
        x: A ? v : v - w / 2,
        y: $ ? g : g - E / 2,
        width: A ? w : w * 2,
        height: $ ? E : E * 2
      }))) : null, /* @__PURE__ */ React__default.createElement(Layer, {
        className: "recharts-bar-rectangles",
        clipPath: S ? "url(#clipPath-".concat(C, ")") : null
      }, R ? this.renderBackground() : null, this.renderRectangles()), this.renderErrorBar(S, C), (!T || b) && LabelList.renderCallByParent(this.props, u));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function(o, l) {
      return o.animationId !== l.prevAnimationId ? {
        prevAnimationId: o.animationId,
        curData: o.data,
        prevData: l.curData
      } : o.data !== l.curData ? {
        curData: o.data
      } : null;
    }
  }]), e;
}(PureComponent);
_Bar = Bar;
_defineProperty$b(Bar, "displayName", "Bar");
_defineProperty$b(Bar, "defaultProps", {
  xAxisId: 0,
  yAxisId: 0,
  legendType: "rect",
  minPointSize: 0,
  hide: !1,
  data: [],
  layout: "vertical",
  activeBar: !1,
  isAnimationActive: !Global.isSsr,
  animationBegin: 0,
  animationDuration: 400,
  animationEasing: "ease"
});
_defineProperty$b(Bar, "getComposedData", function(t) {
  var e = t.props, n = t.item, o = t.barPosition, l = t.bandSize, u = t.xAxis, f = t.yAxis, h = t.xAxisTicks, p = t.yAxisTicks, v = t.stackedData, g = t.dataStartIndex, w = t.displayedData, E = t.offset, T = findPositionOfBar(o, n);
  if (!T)
    return null;
  var R = e.layout, _ = n.props, b = _.dataKey, M = _.children, A = _.minPointSize, $ = R === "horizontal" ? f : u, S = v ? $.scale.domain() : null, C = getBaseValueOfBar({
    numericAxis: $
  }), D = findAllByType(M, Cell), O = w.map(function(N, j) {
    var L, z, G, B, F, H;
    v ? L = truncateByDomain(v[g + j], S) : (L = getValueByDataKey(N, b), Array.isArray(L) || (L = [C, L]));
    var W = minPointSizeCallback(A, _Bar.defaultProps.minPointSize)(L[1], j);
    if (R === "horizontal") {
      var V, X = [f.scale(L[0]), f.scale(L[1])], Z = X[0], Q = X[1];
      z = getCateCoordinateOfBar({
        axis: u,
        ticks: h,
        bandSize: l,
        offset: T.offset,
        entry: N,
        index: j
      }), G = (V = Q ?? Z) !== null && V !== void 0 ? V : void 0, B = T.size;
      var q = Z - Q;
      if (F = Number.isNaN(q) ? 0 : q, H = {
        x: z,
        y: f.y,
        width: B,
        height: f.height
      }, Math.abs(W) > 0 && Math.abs(F) < Math.abs(W)) {
        var J = mathSign(F || W) * (Math.abs(W) - Math.abs(F));
        G -= J, F += J;
      }
    } else {
      var ie = [u.scale(L[0]), u.scale(L[1])], ne = ie[0], ge = ie[1];
      if (z = ne, G = getCateCoordinateOfBar({
        axis: f,
        ticks: p,
        bandSize: l,
        offset: T.offset,
        entry: N,
        index: j
      }), B = ge - ne, F = T.size, H = {
        x: u.x,
        y: G,
        width: u.width,
        height: F
      }, Math.abs(W) > 0 && Math.abs(B) < Math.abs(W)) {
        var ye = mathSign(B || W) * (Math.abs(W) - Math.abs(B));
        B += ye;
      }
    }
    return _objectSpread$9(_objectSpread$9(_objectSpread$9({}, N), {}, {
      x: z,
      y: G,
      width: B,
      height: F,
      value: v ? L : L[1],
      payload: N,
      background: H
    }, D && D[j] && D[j].props), {}, {
      tooltipPayload: [getTooltipItem(n, N)],
      tooltipPosition: {
        x: z + B / 2,
        y: G + F / 2
      }
    });
  });
  return _objectSpread$9({
    data: O,
    layout: R
  }, E);
});
function _typeof$b(t) {
  "@babel/helpers - typeof";
  return _typeof$b = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof$b(t);
}
function _classCallCheck$4(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$4(t, e) {
  for (var n = 0; n < e.length; n++) {
    var o = e[n];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, _toPropertyKey$a(o.key), o);
  }
}
function _createClass$4(t, e, n) {
  return e && _defineProperties$4(t.prototype, e), n && _defineProperties$4(t, n), Object.defineProperty(t, "prototype", { writable: !1 }), t;
}
function ownKeys$9(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(l) {
      return Object.getOwnPropertyDescriptor(t, l).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function _objectSpread$8(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ownKeys$9(Object(n), !0).forEach(function(o) {
      _defineProperty$a(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : ownKeys$9(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
function _defineProperty$a(t, e, n) {
  return e = _toPropertyKey$a(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function _toPropertyKey$a(t) {
  var e = _toPrimitive$a(t, "string");
  return _typeof$b(e) == "symbol" ? e : String(e);
}
function _toPrimitive$a(t, e) {
  if (_typeof$b(t) != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(t, e || "default");
    if (_typeof$b(o) != "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
var formatAxisMap = function t(e, n, o, l, u) {
  var f = e.width, h = e.height, p = e.layout, v = e.children, g = Object.keys(n), w = {
    left: o.left,
    leftMirror: o.left,
    right: f - o.right,
    rightMirror: f - o.right,
    top: o.top,
    topMirror: o.top,
    bottom: h - o.bottom,
    bottomMirror: h - o.bottom
  }, E = !!findChildByType(v, Bar);
  return g.reduce(function(T, R) {
    var _ = n[R], b = _.orientation, M = _.domain, A = _.padding, $ = A === void 0 ? {} : A, S = _.mirror, C = _.reversed, D = "".concat(b).concat(S ? "Mirror" : ""), O, N, j, L, z;
    if (_.type === "number" && (_.padding === "gap" || _.padding === "no-gap")) {
      var G = M[1] - M[0], B = 1 / 0, F = _.categoricalDomain.sort();
      if (F.forEach(function(ne, ge) {
        ge > 0 && (B = Math.min((ne || 0) - (F[ge - 1] || 0), B));
      }), Number.isFinite(B)) {
        var H = B / G, W = _.layout === "vertical" ? o.height : o.width;
        if (_.padding === "gap" && (O = H * W / 2), _.padding === "no-gap") {
          var V = getPercentValue(e.barCategoryGap, H * W), X = H * W / 2;
          O = X - V - (X - V) / W * V;
        }
      }
    }
    l === "xAxis" ? N = [o.left + ($.left || 0) + (O || 0), o.left + o.width - ($.right || 0) - (O || 0)] : l === "yAxis" ? N = p === "horizontal" ? [o.top + o.height - ($.bottom || 0), o.top + ($.top || 0)] : [o.top + ($.top || 0) + (O || 0), o.top + o.height - ($.bottom || 0) - (O || 0)] : N = _.range, C && (N = [N[1], N[0]]);
    var Z = parseScale(_, u, E), Q = Z.scale, q = Z.realScaleType;
    Q.domain(M).range(N), checkDomainOfScale(Q);
    var J = getTicksOfScale(Q, _objectSpread$8(_objectSpread$8({}, _), {}, {
      realScaleType: q
    }));
    l === "xAxis" ? (z = b === "top" && !S || b === "bottom" && S, j = o.left, L = w[D] - z * _.height) : l === "yAxis" && (z = b === "left" && !S || b === "right" && S, j = w[D] - z * _.width, L = o.top);
    var ie = _objectSpread$8(_objectSpread$8(_objectSpread$8({}, _), J), {}, {
      realScaleType: q,
      x: j,
      y: L,
      scale: Q,
      width: l === "xAxis" ? o.width : _.width,
      height: l === "yAxis" ? o.height : _.height
    });
    return ie.bandSize = getBandSizeOfAxis(ie, J), !_.hide && l === "xAxis" ? w[D] += (z ? -1 : 1) * ie.height : _.hide || (w[D] += (z ? -1 : 1) * ie.width), _objectSpread$8(_objectSpread$8({}, T), {}, _defineProperty$a({}, R, ie));
  }, {});
}, rectWithPoints = function t(e, n) {
  var o = e.x, l = e.y, u = n.x, f = n.y;
  return {
    x: Math.min(o, u),
    y: Math.min(l, f),
    width: Math.abs(u - o),
    height: Math.abs(f - l)
  };
}, rectWithCoords = function t(e) {
  var n = e.x1, o = e.y1, l = e.x2, u = e.y2;
  return rectWithPoints({
    x: n,
    y: o
  }, {
    x: l,
    y: u
  });
}, ScaleHelper = /* @__PURE__ */ function() {
  function t(e) {
    _classCallCheck$4(this, t), this.scale = e;
  }
  return _createClass$4(t, [{
    key: "domain",
    get: function() {
      return this.scale.domain;
    }
  }, {
    key: "range",
    get: function() {
      return this.scale.range;
    }
  }, {
    key: "rangeMin",
    get: function() {
      return this.range()[0];
    }
  }, {
    key: "rangeMax",
    get: function() {
      return this.range()[1];
    }
  }, {
    key: "bandwidth",
    get: function() {
      return this.scale.bandwidth;
    }
  }, {
    key: "apply",
    value: function(n) {
      var o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, l = o.bandAware, u = o.position;
      if (n !== void 0) {
        if (u)
          switch (u) {
            case "start":
              return this.scale(n);
            case "middle": {
              var f = this.bandwidth ? this.bandwidth() / 2 : 0;
              return this.scale(n) + f;
            }
            case "end": {
              var h = this.bandwidth ? this.bandwidth() : 0;
              return this.scale(n) + h;
            }
            default:
              return this.scale(n);
          }
        if (l) {
          var p = this.bandwidth ? this.bandwidth() / 2 : 0;
          return this.scale(n) + p;
        }
        return this.scale(n);
      }
    }
  }, {
    key: "isInRange",
    value: function(n) {
      var o = this.range(), l = o[0], u = o[o.length - 1];
      return l <= u ? n >= l && n <= u : n >= u && n <= l;
    }
  }], [{
    key: "create",
    value: function(n) {
      return new t(n);
    }
  }]), t;
}();
_defineProperty$a(ScaleHelper, "EPS", 1e-4);
var createLabeledScales = function t(e) {
  var n = Object.keys(e).reduce(function(o, l) {
    return _objectSpread$8(_objectSpread$8({}, o), {}, _defineProperty$a({}, l, ScaleHelper.create(e[l])));
  }, {});
  return _objectSpread$8(_objectSpread$8({}, n), {}, {
    apply: function(l) {
      var u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, f = u.bandAware, h = u.position;
      return mapValues$1(l, function(p, v) {
        return n[v].apply(p, {
          bandAware: f,
          position: h
        });
      });
    },
    isInRange: function(l) {
      return every$1(l, function(u, f) {
        return n[f].isInRange(u);
      });
    }
  });
};
function normalizeAngle(t) {
  return (t % 180 + 180) % 180;
}
var getAngledRectangleWidth = function t(e) {
  var n = e.width, o = e.height, l = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, u = normalizeAngle(l), f = u * Math.PI / 180, h = Math.atan(o / n), p = f > h && f < Math.PI - h ? o / Math.sin(f) : n / Math.cos(f);
  return Math.abs(p);
}, baseIteratee$1 = _baseIteratee, isArrayLike = isArrayLike_1, keys = keys_1;
function createFind$1(t) {
  return function(e, n, o) {
    var l = Object(e);
    if (!isArrayLike(e)) {
      var u = baseIteratee$1(n);
      e = keys(e), n = function(h) {
        return u(l[h], h, l);
      };
    }
    var f = t(e, n, o);
    return f > -1 ? l[u ? e[f] : f] : void 0;
  };
}
var _createFind = createFind$1, toFinite = toFinite_1;
function toInteger$1(t) {
  var e = toFinite(t), n = e % 1;
  return e === e ? n ? e - n : e : 0;
}
var toInteger_1 = toInteger$1, baseFindIndex = _baseFindIndex, baseIteratee = _baseIteratee, toInteger = toInteger_1, nativeMax = Math.max;
function findIndex$1(t, e, n) {
  var o = t == null ? 0 : t.length;
  if (!o)
    return -1;
  var l = n == null ? 0 : toInteger(n);
  return l < 0 && (l = nativeMax(o + l, 0)), baseFindIndex(t, baseIteratee(e), l);
}
var findIndex_1 = findIndex$1, createFind = _createFind, findIndex = findIndex_1, find = createFind(findIndex), find_1 = find;
const find$1 = /* @__PURE__ */ getDefaultExportFromCjs(find_1);
var calculateViewBox = memoize$3(function(t) {
  return {
    x: t.left,
    y: t.top,
    width: t.width,
    height: t.height
  };
}, function(t) {
  return ["l", t.left, "t", t.top, "w", t.width, "h", t.height].join("");
});
function _typeof$a(t) {
  "@babel/helpers - typeof";
  return _typeof$a = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof$a(t);
}
var XAxisContext = /* @__PURE__ */ createContext(void 0), YAxisContext = /* @__PURE__ */ createContext(void 0), ViewBoxContext = /* @__PURE__ */ createContext(void 0), OffsetContext = /* @__PURE__ */ createContext({}), ClipPathIdContext = /* @__PURE__ */ createContext(void 0), ChartHeightContext = /* @__PURE__ */ createContext(0), ChartWidthContext = /* @__PURE__ */ createContext(0), ChartLayoutContextProvider = function t(e) {
  var n = e.state, o = n.xAxisMap, l = n.yAxisMap, u = n.offset, f = e.clipPathId, h = e.children, p = e.width, v = e.height, g = calculateViewBox(u);
  return /* @__PURE__ */ React__default.createElement(XAxisContext.Provider, {
    value: o
  }, /* @__PURE__ */ React__default.createElement(YAxisContext.Provider, {
    value: l
  }, /* @__PURE__ */ React__default.createElement(OffsetContext.Provider, {
    value: u
  }, /* @__PURE__ */ React__default.createElement(ViewBoxContext.Provider, {
    value: g
  }, /* @__PURE__ */ React__default.createElement(ClipPathIdContext.Provider, {
    value: f
  }, /* @__PURE__ */ React__default.createElement(ChartHeightContext.Provider, {
    value: v
  }, /* @__PURE__ */ React__default.createElement(ChartWidthContext.Provider, {
    value: p
  }, h)))))));
}, useClipPathId = function t() {
  return useContext(ClipPathIdContext);
};
function getKeysForDebug(t) {
  var e = Object.keys(t);
  return e.length === 0 ? "There are no available ids." : "Available ids are: ".concat(e, ".");
}
var useXAxisOrThrow = function t(e) {
  var n = useContext(XAxisContext);
  n == null && (process.env.NODE_ENV !== "production" ? invariant(!1, "Could not find Recharts context; are you sure this is rendered inside a Recharts wrapper component?") : invariant());
  var o = n[e];
  return o == null && (process.env.NODE_ENV !== "production" ? invariant(!1, 'Could not find xAxis by id "'.concat(e, '" [').concat(_typeof$a(e), "]. ").concat(getKeysForDebug(n))) : invariant()), o;
}, useArbitraryXAxis = function t() {
  var e = useContext(XAxisContext);
  return getAnyElementOfObject(e);
}, useYAxisWithFiniteDomainOrRandom = function t() {
  var e = useContext(YAxisContext), n = find$1(e, function(o) {
    return every$1(o.domain, Number.isFinite);
  });
  return n || getAnyElementOfObject(e);
}, useYAxisOrThrow = function t(e) {
  var n = useContext(YAxisContext);
  n == null && (process.env.NODE_ENV !== "production" ? invariant(!1, "Could not find Recharts context; are you sure this is rendered inside a Recharts wrapper component?") : invariant());
  var o = n[e];
  return o == null && (process.env.NODE_ENV !== "production" ? invariant(!1, 'Could not find yAxis by id "'.concat(e, '" [').concat(_typeof$a(e), "]. ").concat(getKeysForDebug(n))) : invariant()), o;
}, useViewBox = function t() {
  var e = useContext(ViewBoxContext);
  return e;
}, useOffset = function t() {
  return useContext(OffsetContext);
}, useChartWidth = function t() {
  return useContext(ChartWidthContext);
}, useChartHeight = function t() {
  return useContext(ChartHeightContext);
};
function _typeof$9(t) {
  "@babel/helpers - typeof";
  return _typeof$9 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof$9(t);
}
function ownKeys$8(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(l) {
      return Object.getOwnPropertyDescriptor(t, l).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function _objectSpread$7(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ownKeys$8(Object(n), !0).forEach(function(o) {
      _defineProperty$9(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : ownKeys$8(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
function _defineProperty$9(t, e, n) {
  return e = _toPropertyKey$9(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function _toPropertyKey$9(t) {
  var e = _toPrimitive$9(t, "string");
  return _typeof$9(e) == "symbol" ? e : String(e);
}
function _toPrimitive$9(t, e) {
  if (_typeof$9(t) != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(t, e || "default");
    if (_typeof$9(o) != "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function _slicedToArray$1(t, e) {
  return _arrayWithHoles$1(t) || _iterableToArrayLimit$1(t, e) || _unsupportedIterableToArray$3(t, e) || _nonIterableRest$1();
}
function _nonIterableRest$1() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function _unsupportedIterableToArray$3(t, e) {
  if (t) {
    if (typeof t == "string") return _arrayLikeToArray$3(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(t, e);
  }
}
function _arrayLikeToArray$3(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, o = new Array(e); n < e; n++) o[n] = t[n];
  return o;
}
function _iterableToArrayLimit$1(t, e) {
  var n = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
  if (n != null) {
    var o, l, u, f, h = [], p = !0, v = !1;
    try {
      if (u = (n = n.call(t)).next, e !== 0) for (; !(p = (o = u.call(n)).done) && (h.push(o.value), h.length !== e); p = !0) ;
    } catch (g) {
      v = !0, l = g;
    } finally {
      try {
        if (!p && n.return != null && (f = n.return(), Object(f) !== f)) return;
      } finally {
        if (v) throw l;
      }
    }
    return h;
  }
}
function _arrayWithHoles$1(t) {
  if (Array.isArray(t)) return t;
}
function _extends$9() {
  return _extends$9 = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }
    return t;
  }, _extends$9.apply(this, arguments);
}
var renderLine = function t(e, n) {
  var o;
  return /* @__PURE__ */ React__default.isValidElement(e) ? o = /* @__PURE__ */ React__default.cloneElement(e, n) : isFunction$3(e) ? o = e(n) : o = /* @__PURE__ */ React__default.createElement("line", _extends$9({}, n, {
    className: "recharts-reference-line-line"
  })), o;
}, getEndPoints = function t(e, n, o, l, u, f, h, p, v) {
  var g = u.x, w = u.y, E = u.width, T = u.height;
  if (o) {
    var R = v.y, _ = e.y.apply(R, {
      position: f
    });
    if (ifOverflowMatches(v, "discard") && !e.y.isInRange(_))
      return null;
    var b = [{
      x: g + E,
      y: _
    }, {
      x: g,
      y: _
    }];
    return p === "left" ? b.reverse() : b;
  }
  if (n) {
    var M = v.x, A = e.x.apply(M, {
      position: f
    });
    if (ifOverflowMatches(v, "discard") && !e.x.isInRange(A))
      return null;
    var $ = [{
      x: A,
      y: w + T
    }, {
      x: A,
      y: w
    }];
    return h === "top" ? $.reverse() : $;
  }
  if (l) {
    var S = v.segment, C = S.map(function(D) {
      return e.apply(D, {
        position: f
      });
    });
    return ifOverflowMatches(v, "discard") && some$1(C, function(D) {
      return !e.isInRange(D);
    }) ? null : C;
  }
  return null;
};
function ReferenceLine(t) {
  var e = t.x, n = t.y, o = t.segment, l = t.xAxisId, u = t.yAxisId, f = t.shape, h = t.className, p = t.alwaysShow, v = useClipPathId(), g = useXAxisOrThrow(l), w = useYAxisOrThrow(u), E = useViewBox();
  if (!v || !E)
    return null;
  warn$2(p === void 0, 'The alwaysShow prop is deprecated. Please use ifOverflow="extendDomain" instead.');
  var T = createLabeledScales({
    x: g.scale,
    y: w.scale
  }), R = isNumOrStr(e), _ = isNumOrStr(n), b = o && o.length === 2, M = getEndPoints(T, R, _, b, E, t.position, g.orientation, w.orientation, t);
  if (!M)
    return null;
  var A = _slicedToArray$1(M, 2), $ = A[0], S = $.x, C = $.y, D = A[1], O = D.x, N = D.y, j = ifOverflowMatches(t, "hidden") ? "url(#".concat(v, ")") : void 0, L = _objectSpread$7(_objectSpread$7({
    clipPath: j
  }, filterProps(t, !0)), {}, {
    x1: S,
    y1: C,
    x2: O,
    y2: N
  });
  return /* @__PURE__ */ React__default.createElement(Layer, {
    className: clsx$1("recharts-reference-line", h)
  }, renderLine(f, L), Label.renderCallByParent(t, rectWithCoords({
    x1: S,
    y1: C,
    x2: O,
    y2: N
  })));
}
ReferenceLine.displayName = "ReferenceLine";
ReferenceLine.defaultProps = {
  isFront: !1,
  ifOverflow: "discard",
  xAxisId: 0,
  yAxisId: 0,
  fill: "none",
  stroke: "#ccc",
  fillOpacity: 1,
  strokeWidth: 1,
  position: "middle"
};
function _typeof$8(t) {
  "@babel/helpers - typeof";
  return _typeof$8 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof$8(t);
}
function _extends$8() {
  return _extends$8 = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }
    return t;
  }, _extends$8.apply(this, arguments);
}
function ownKeys$7(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(l) {
      return Object.getOwnPropertyDescriptor(t, l).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function _objectSpread$6(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ownKeys$7(Object(n), !0).forEach(function(o) {
      _defineProperty$8(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : ownKeys$7(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
function _defineProperty$8(t, e, n) {
  return e = _toPropertyKey$8(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function _toPropertyKey$8(t) {
  var e = _toPrimitive$8(t, "string");
  return _typeof$8(e) == "symbol" ? e : String(e);
}
function _toPrimitive$8(t, e) {
  if (_typeof$8(t) != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(t, e || "default");
    if (_typeof$8(o) != "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
var getCoordinate = function t(e) {
  var n = e.x, o = e.y, l = e.xAxis, u = e.yAxis, f = createLabeledScales({
    x: l.scale,
    y: u.scale
  }), h = f.apply({
    x: n,
    y: o
  }, {
    bandAware: !0
  });
  return ifOverflowMatches(e, "discard") && !f.isInRange(h) ? null : h;
};
function ReferenceDot(t) {
  var e = t.x, n = t.y, o = t.r, l = t.alwaysShow, u = t.clipPathId, f = isNumOrStr(e), h = isNumOrStr(n);
  if (warn$2(l === void 0, 'The alwaysShow prop is deprecated. Please use ifOverflow="extendDomain" instead.'), !f || !h)
    return null;
  var p = getCoordinate(t);
  if (!p)
    return null;
  var v = p.x, g = p.y, w = t.shape, E = t.className, T = ifOverflowMatches(t, "hidden") ? "url(#".concat(u, ")") : void 0, R = _objectSpread$6(_objectSpread$6({
    clipPath: T
  }, filterProps(t, !0)), {}, {
    cx: v,
    cy: g
  });
  return /* @__PURE__ */ React__default.createElement(Layer, {
    className: clsx$1("recharts-reference-dot", E)
  }, ReferenceDot.renderDot(w, R), Label.renderCallByParent(t, {
    x: v - o,
    y: g - o,
    width: 2 * o,
    height: 2 * o
  }));
}
ReferenceDot.displayName = "ReferenceDot";
ReferenceDot.defaultProps = {
  isFront: !1,
  ifOverflow: "discard",
  xAxisId: 0,
  yAxisId: 0,
  r: 10,
  fill: "#fff",
  stroke: "#ccc",
  fillOpacity: 1,
  strokeWidth: 1
};
ReferenceDot.renderDot = function(t, e) {
  var n;
  return /* @__PURE__ */ React__default.isValidElement(t) ? n = /* @__PURE__ */ React__default.cloneElement(t, e) : isFunction$3(t) ? n = t(e) : n = /* @__PURE__ */ React__default.createElement(Dot, _extends$8({}, e, {
    cx: e.cx,
    cy: e.cy,
    className: "recharts-reference-dot-dot"
  })), n;
};
function _typeof$7(t) {
  "@babel/helpers - typeof";
  return _typeof$7 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof$7(t);
}
function _extends$7() {
  return _extends$7 = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }
    return t;
  }, _extends$7.apply(this, arguments);
}
function ownKeys$6(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(l) {
      return Object.getOwnPropertyDescriptor(t, l).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function _objectSpread$5(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ownKeys$6(Object(n), !0).forEach(function(o) {
      _defineProperty$7(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : ownKeys$6(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
function _defineProperty$7(t, e, n) {
  return e = _toPropertyKey$7(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function _toPropertyKey$7(t) {
  var e = _toPrimitive$7(t, "string");
  return _typeof$7(e) == "symbol" ? e : String(e);
}
function _toPrimitive$7(t, e) {
  if (_typeof$7(t) != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(t, e || "default");
    if (_typeof$7(o) != "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
var getRect = function t(e, n, o, l, u) {
  var f = u.x1, h = u.x2, p = u.y1, v = u.y2, g = u.xAxis, w = u.yAxis;
  if (!g || !w) return null;
  var E = createLabeledScales({
    x: g.scale,
    y: w.scale
  }), T = {
    x: e ? E.x.apply(f, {
      position: "start"
    }) : E.x.rangeMin,
    y: o ? E.y.apply(p, {
      position: "start"
    }) : E.y.rangeMin
  }, R = {
    x: n ? E.x.apply(h, {
      position: "end"
    }) : E.x.rangeMax,
    y: l ? E.y.apply(v, {
      position: "end"
    }) : E.y.rangeMax
  };
  return ifOverflowMatches(u, "discard") && (!E.isInRange(T) || !E.isInRange(R)) ? null : rectWithPoints(T, R);
};
function ReferenceArea(t) {
  var e = t.x1, n = t.x2, o = t.y1, l = t.y2, u = t.className, f = t.alwaysShow, h = t.clipPathId;
  warn$2(f === void 0, 'The alwaysShow prop is deprecated. Please use ifOverflow="extendDomain" instead.');
  var p = isNumOrStr(e), v = isNumOrStr(n), g = isNumOrStr(o), w = isNumOrStr(l), E = t.shape;
  if (!p && !v && !g && !w && !E)
    return null;
  var T = getRect(p, v, g, w, t);
  if (!T && !E)
    return null;
  var R = ifOverflowMatches(t, "hidden") ? "url(#".concat(h, ")") : void 0;
  return /* @__PURE__ */ React__default.createElement(Layer, {
    className: clsx$1("recharts-reference-area", u)
  }, ReferenceArea.renderRect(E, _objectSpread$5(_objectSpread$5({
    clipPath: R
  }, filterProps(t, !0)), T)), Label.renderCallByParent(t, T));
}
ReferenceArea.displayName = "ReferenceArea";
ReferenceArea.defaultProps = {
  isFront: !1,
  ifOverflow: "discard",
  xAxisId: 0,
  yAxisId: 0,
  r: 10,
  fill: "#ccc",
  fillOpacity: 0.5,
  stroke: "none",
  strokeWidth: 1
};
ReferenceArea.renderRect = function(t, e) {
  var n;
  return /* @__PURE__ */ React__default.isValidElement(t) ? n = /* @__PURE__ */ React__default.cloneElement(t, e) : isFunction$3(t) ? n = t(e) : n = /* @__PURE__ */ React__default.createElement(Rectangle, _extends$7({}, e, {
    className: "recharts-reference-area-rect"
  })), n;
};
function getEveryNthWithCondition(t, e, n) {
  if (e < 1)
    return [];
  if (e === 1 && n === void 0)
    return t;
  for (var o = [], l = 0; l < t.length; l += e)
    o.push(t[l]);
  return o;
}
function getAngledTickWidth(t, e, n) {
  var o = {
    width: t.width + e.width,
    height: t.height + e.height
  };
  return getAngledRectangleWidth(o, n);
}
function getTickBoundaries(t, e, n) {
  var o = n === "width", l = t.x, u = t.y, f = t.width, h = t.height;
  return e === 1 ? {
    start: o ? l : u,
    end: o ? l + f : u + h
  } : {
    start: o ? l + f : u + h,
    end: o ? l : u
  };
}
function isVisible(t, e, n, o, l) {
  if (t * e < t * o || t * e > t * l)
    return !1;
  var u = n();
  return t * (e - t * u / 2 - o) >= 0 && t * (e + t * u / 2 - l) <= 0;
}
function getNumberIntervalTicks(t, e) {
  return getEveryNthWithCondition(t, e + 1);
}
function getEquidistantTicks(t, e, n, o, l) {
  for (var u = (o || []).slice(), f = e.start, h = e.end, p = 0, v = 1, g = f, w = function() {
    var R = o == null ? void 0 : o[p];
    if (R === void 0)
      return {
        v: getEveryNthWithCondition(o, v)
      };
    var _ = p, b, M = function() {
      return b === void 0 && (b = n(R, _)), b;
    }, A = R.coordinate, $ = p === 0 || isVisible(t, A, M, g, h);
    $ || (p = 0, g = f, v += 1), $ && (g = A + t * (M() / 2 + l), p += v);
  }, E; v <= u.length; )
    if (E = w(), E) return E.v;
  return [];
}
function _typeof$6(t) {
  "@babel/helpers - typeof";
  return _typeof$6 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof$6(t);
}
function ownKeys$5(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(l) {
      return Object.getOwnPropertyDescriptor(t, l).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function _objectSpread$4(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ownKeys$5(Object(n), !0).forEach(function(o) {
      _defineProperty$6(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : ownKeys$5(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
function _defineProperty$6(t, e, n) {
  return e = _toPropertyKey$6(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function _toPropertyKey$6(t) {
  var e = _toPrimitive$6(t, "string");
  return _typeof$6(e) == "symbol" ? e : String(e);
}
function _toPrimitive$6(t, e) {
  if (_typeof$6(t) != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(t, e || "default");
    if (_typeof$6(o) != "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function getTicksEnd(t, e, n, o, l) {
  for (var u = (o || []).slice(), f = u.length, h = e.start, p = e.end, v = function(E) {
    var T = u[E], R, _ = function() {
      return R === void 0 && (R = n(T, E)), R;
    };
    if (E === f - 1) {
      var b = t * (T.coordinate + t * _() / 2 - p);
      u[E] = T = _objectSpread$4(_objectSpread$4({}, T), {}, {
        tickCoord: b > 0 ? T.coordinate - b * t : T.coordinate
      });
    } else
      u[E] = T = _objectSpread$4(_objectSpread$4({}, T), {}, {
        tickCoord: T.coordinate
      });
    var M = isVisible(t, T.tickCoord, _, h, p);
    M && (p = T.tickCoord - t * (_() / 2 + l), u[E] = _objectSpread$4(_objectSpread$4({}, T), {}, {
      isShow: !0
    }));
  }, g = f - 1; g >= 0; g--)
    v(g);
  return u;
}
function getTicksStart(t, e, n, o, l, u) {
  var f = (o || []).slice(), h = f.length, p = e.start, v = e.end;
  if (u) {
    var g = o[h - 1], w = n(g, h - 1), E = t * (g.coordinate + t * w / 2 - v);
    f[h - 1] = g = _objectSpread$4(_objectSpread$4({}, g), {}, {
      tickCoord: E > 0 ? g.coordinate - E * t : g.coordinate
    });
    var T = isVisible(t, g.tickCoord, function() {
      return w;
    }, p, v);
    T && (v = g.tickCoord - t * (w / 2 + l), f[h - 1] = _objectSpread$4(_objectSpread$4({}, g), {}, {
      isShow: !0
    }));
  }
  for (var R = u ? h - 1 : h, _ = function(A) {
    var $ = f[A], S, C = function() {
      return S === void 0 && (S = n($, A)), S;
    };
    if (A === 0) {
      var D = t * ($.coordinate - t * C() / 2 - p);
      f[A] = $ = _objectSpread$4(_objectSpread$4({}, $), {}, {
        tickCoord: D < 0 ? $.coordinate - D * t : $.coordinate
      });
    } else
      f[A] = $ = _objectSpread$4(_objectSpread$4({}, $), {}, {
        tickCoord: $.coordinate
      });
    var O = isVisible(t, $.tickCoord, C, p, v);
    O && (p = $.tickCoord + t * (C() / 2 + l), f[A] = _objectSpread$4(_objectSpread$4({}, $), {}, {
      isShow: !0
    }));
  }, b = 0; b < R; b++)
    _(b);
  return f;
}
function getTicks(t, e, n) {
  var o = t.tick, l = t.ticks, u = t.viewBox, f = t.minTickGap, h = t.orientation, p = t.interval, v = t.tickFormatter, g = t.unit, w = t.angle;
  if (!l || !l.length || !o)
    return [];
  if (isNumber(p) || Global.isSsr)
    return getNumberIntervalTicks(l, typeof p == "number" && isNumber(p) ? p : 0);
  var E = [], T = h === "top" || h === "bottom" ? "width" : "height", R = g && T === "width" ? getStringSize(g, {
    fontSize: e,
    letterSpacing: n
  }) : {
    width: 0,
    height: 0
  }, _ = function($, S) {
    var C = isFunction$3(v) ? v($.value, S) : $.value;
    return T === "width" ? getAngledTickWidth(getStringSize(C, {
      fontSize: e,
      letterSpacing: n
    }), R, w) : getStringSize(C, {
      fontSize: e,
      letterSpacing: n
    })[T];
  }, b = l.length >= 2 ? mathSign(l[1].coordinate - l[0].coordinate) : 1, M = getTickBoundaries(u, b, T);
  return p === "equidistantPreserveStart" ? getEquidistantTicks(b, M, _, l, f) : (p === "preserveStart" || p === "preserveStartEnd" ? E = getTicksStart(b, M, _, l, f, p === "preserveStartEnd") : E = getTicksEnd(b, M, _, l, f), E.filter(function(A) {
    return A.isShow;
  }));
}
var _excluded$2 = ["viewBox"], _excluded2$2 = ["viewBox"], _excluded3 = ["ticks"];
function _typeof$5(t) {
  "@babel/helpers - typeof";
  return _typeof$5 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof$5(t);
}
function _extends$6() {
  return _extends$6 = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }
    return t;
  }, _extends$6.apply(this, arguments);
}
function ownKeys$4(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(l) {
      return Object.getOwnPropertyDescriptor(t, l).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function _objectSpread$3(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ownKeys$4(Object(n), !0).forEach(function(o) {
      _defineProperty$5(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : ownKeys$4(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
function _objectWithoutProperties$2(t, e) {
  if (t == null) return {};
  var n = _objectWithoutPropertiesLoose$3(t, e), o, l;
  if (Object.getOwnPropertySymbols) {
    var u = Object.getOwnPropertySymbols(t);
    for (l = 0; l < u.length; l++)
      o = u[l], !(e.indexOf(o) >= 0) && Object.prototype.propertyIsEnumerable.call(t, o) && (n[o] = t[o]);
  }
  return n;
}
function _objectWithoutPropertiesLoose$3(t, e) {
  if (t == null) return {};
  var n = {}, o = Object.keys(t), l, u;
  for (u = 0; u < o.length; u++)
    l = o[u], !(e.indexOf(l) >= 0) && (n[l] = t[l]);
  return n;
}
function _classCallCheck$3(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$3(t, e) {
  for (var n = 0; n < e.length; n++) {
    var o = e[n];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, _toPropertyKey$5(o.key), o);
  }
}
function _createClass$3(t, e, n) {
  return e && _defineProperties$3(t.prototype, e), n && _defineProperties$3(t, n), Object.defineProperty(t, "prototype", { writable: !1 }), t;
}
function _callSuper$2(t, e, n) {
  return e = _getPrototypeOf$2(e), _possibleConstructorReturn$2(t, _isNativeReflectConstruct$2() ? Reflect.construct(e, n || [], _getPrototypeOf$2(t).constructor) : e.apply(t, n));
}
function _possibleConstructorReturn$2(t, e) {
  if (e && (_typeof$5(e) === "object" || typeof e == "function"))
    return e;
  if (e !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized$3(t);
}
function _assertThisInitialized$3(t) {
  if (t === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t;
}
function _isNativeReflectConstruct$2() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (_isNativeReflectConstruct$2 = function() {
    return !!t;
  })();
}
function _getPrototypeOf$2(t) {
  return _getPrototypeOf$2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
    return n.__proto__ || Object.getPrototypeOf(n);
  }, _getPrototypeOf$2(t);
}
function _inherits$2(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf$3(t, e);
}
function _setPrototypeOf$3(t, e) {
  return _setPrototypeOf$3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(o, l) {
    return o.__proto__ = l, o;
  }, _setPrototypeOf$3(t, e);
}
function _defineProperty$5(t, e, n) {
  return e = _toPropertyKey$5(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function _toPropertyKey$5(t) {
  var e = _toPrimitive$5(t, "string");
  return _typeof$5(e) == "symbol" ? e : String(e);
}
function _toPrimitive$5(t, e) {
  if (_typeof$5(t) != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(t, e || "default");
    if (_typeof$5(o) != "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
var CartesianAxis = /* @__PURE__ */ function(t) {
  _inherits$2(e, t);
  function e(n) {
    var o;
    return _classCallCheck$3(this, e), o = _callSuper$2(this, e, [n]), o.state = {
      fontSize: "",
      letterSpacing: ""
    }, o;
  }
  return _createClass$3(e, [{
    key: "shouldComponentUpdate",
    value: function(o, l) {
      var u = o.viewBox, f = _objectWithoutProperties$2(o, _excluded$2), h = this.props, p = h.viewBox, v = _objectWithoutProperties$2(h, _excluded2$2);
      return !shallowEqual(u, p) || !shallowEqual(f, v) || !shallowEqual(l, this.state);
    }
  }, {
    key: "componentDidMount",
    value: function() {
      var o = this.layerReference;
      if (o) {
        var l = o.getElementsByClassName("recharts-cartesian-axis-tick-value")[0];
        l && this.setState({
          fontSize: window.getComputedStyle(l).fontSize,
          letterSpacing: window.getComputedStyle(l).letterSpacing
        });
      }
    }
    /**
     * Calculate the coordinates of endpoints in ticks
     * @param  {Object} data The data of a simple tick
     * @return {Object} (x1, y1): The coordinate of endpoint close to tick text
     *  (x2, y2): The coordinate of endpoint close to axis
     */
  }, {
    key: "getTickLineCoord",
    value: function(o) {
      var l = this.props, u = l.x, f = l.y, h = l.width, p = l.height, v = l.orientation, g = l.tickSize, w = l.mirror, E = l.tickMargin, T, R, _, b, M, A, $ = w ? -1 : 1, S = o.tickSize || g, C = isNumber(o.tickCoord) ? o.tickCoord : o.coordinate;
      switch (v) {
        case "top":
          T = R = o.coordinate, b = f + +!w * p, _ = b - $ * S, A = _ - $ * E, M = C;
          break;
        case "left":
          _ = b = o.coordinate, R = u + +!w * h, T = R - $ * S, M = T - $ * E, A = C;
          break;
        case "right":
          _ = b = o.coordinate, R = u + +w * h, T = R + $ * S, M = T + $ * E, A = C;
          break;
        default:
          T = R = o.coordinate, b = f + +w * p, _ = b + $ * S, A = _ + $ * E, M = C;
          break;
      }
      return {
        line: {
          x1: T,
          y1: _,
          x2: R,
          y2: b
        },
        tick: {
          x: M,
          y: A
        }
      };
    }
  }, {
    key: "getTickTextAnchor",
    value: function() {
      var o = this.props, l = o.orientation, u = o.mirror, f;
      switch (l) {
        case "left":
          f = u ? "start" : "end";
          break;
        case "right":
          f = u ? "end" : "start";
          break;
        default:
          f = "middle";
          break;
      }
      return f;
    }
  }, {
    key: "getTickVerticalAnchor",
    value: function() {
      var o = this.props, l = o.orientation, u = o.mirror, f = "end";
      switch (l) {
        case "left":
        case "right":
          f = "middle";
          break;
        case "top":
          f = u ? "start" : "end";
          break;
        default:
          f = u ? "end" : "start";
          break;
      }
      return f;
    }
  }, {
    key: "renderAxisLine",
    value: function() {
      var o = this.props, l = o.x, u = o.y, f = o.width, h = o.height, p = o.orientation, v = o.mirror, g = o.axisLine, w = _objectSpread$3(_objectSpread$3(_objectSpread$3({}, filterProps(this.props, !1)), filterProps(g, !1)), {}, {
        fill: "none"
      });
      if (p === "top" || p === "bottom") {
        var E = +(p === "top" && !v || p === "bottom" && v);
        w = _objectSpread$3(_objectSpread$3({}, w), {}, {
          x1: l,
          y1: u + E * h,
          x2: l + f,
          y2: u + E * h
        });
      } else {
        var T = +(p === "left" && !v || p === "right" && v);
        w = _objectSpread$3(_objectSpread$3({}, w), {}, {
          x1: l + T * f,
          y1: u,
          x2: l + T * f,
          y2: u + h
        });
      }
      return /* @__PURE__ */ React__default.createElement("line", _extends$6({}, w, {
        className: clsx$1("recharts-cartesian-axis-line", get$2(g, "className"))
      }));
    }
  }, {
    key: "renderTicks",
    value: (
      /**
       * render the ticks
       * @param {Array} ticks The ticks to actually render (overrides what was passed in props)
       * @param {string} fontSize Fontsize to consider for tick spacing
       * @param {string} letterSpacing Letterspacing to consider for tick spacing
       * @return {ReactComponent} renderedTicks
       */
      function(o, l, u) {
        var f = this, h = this.props, p = h.tickLine, v = h.stroke, g = h.tick, w = h.tickFormatter, E = h.unit, T = getTicks(_objectSpread$3(_objectSpread$3({}, this.props), {}, {
          ticks: o
        }), l, u), R = this.getTickTextAnchor(), _ = this.getTickVerticalAnchor(), b = filterProps(this.props, !1), M = filterProps(g, !1), A = _objectSpread$3(_objectSpread$3({}, b), {}, {
          fill: "none"
        }, filterProps(p, !1)), $ = T.map(function(S, C) {
          var D = f.getTickLineCoord(S), O = D.line, N = D.tick, j = _objectSpread$3(_objectSpread$3(_objectSpread$3(_objectSpread$3({
            textAnchor: R,
            verticalAnchor: _
          }, b), {}, {
            stroke: "none",
            fill: v
          }, M), N), {}, {
            index: C,
            payload: S,
            visibleTicksCount: T.length,
            tickFormatter: w
          });
          return /* @__PURE__ */ React__default.createElement(Layer, _extends$6({
            className: "recharts-cartesian-axis-tick",
            key: "tick-".concat(S.value, "-").concat(S.coordinate, "-").concat(S.tickCoord)
          }, adaptEventsOfChild(f.props, S, C)), p && /* @__PURE__ */ React__default.createElement("line", _extends$6({}, A, O, {
            className: clsx$1("recharts-cartesian-axis-tick-line", get$2(p, "className"))
          })), g && e.renderTickItem(g, j, "".concat(isFunction$3(w) ? w(S.value, C) : S.value).concat(E || "")));
        });
        return /* @__PURE__ */ React__default.createElement("g", {
          className: "recharts-cartesian-axis-ticks"
        }, $);
      }
    )
  }, {
    key: "render",
    value: function() {
      var o = this, l = this.props, u = l.axisLine, f = l.width, h = l.height, p = l.ticksGenerator, v = l.className, g = l.hide;
      if (g)
        return null;
      var w = this.props, E = w.ticks, T = _objectWithoutProperties$2(w, _excluded3), R = E;
      return isFunction$3(p) && (R = E && E.length > 0 ? p(this.props) : p(T)), f <= 0 || h <= 0 || !R || !R.length ? null : /* @__PURE__ */ React__default.createElement(Layer, {
        className: clsx$1("recharts-cartesian-axis", v),
        ref: function(b) {
          o.layerReference = b;
        }
      }, u && this.renderAxisLine(), this.renderTicks(R, this.state.fontSize, this.state.letterSpacing), Label.renderCallByParent(this.props));
    }
  }], [{
    key: "renderTickItem",
    value: function(o, l, u) {
      var f;
      return /* @__PURE__ */ React__default.isValidElement(o) ? f = /* @__PURE__ */ React__default.cloneElement(o, l) : isFunction$3(o) ? f = o(l) : f = /* @__PURE__ */ React__default.createElement(Text, _extends$6({}, l, {
        className: "recharts-cartesian-axis-tick-value"
      }), u), f;
    }
  }]), e;
}(Component$1);
_defineProperty$5(CartesianAxis, "displayName", "CartesianAxis");
_defineProperty$5(CartesianAxis, "defaultProps", {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  viewBox: {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  // The orientation of axis
  orientation: "bottom",
  // The ticks
  ticks: [],
  stroke: "#666",
  tickLine: !0,
  axisLine: !0,
  tick: !0,
  mirror: !1,
  minTickGap: 5,
  // The width or height of tick
  tickSize: 6,
  tickMargin: 2,
  interval: "preserveEnd"
});
var _excluded$1 = ["x1", "y1", "x2", "y2", "key"], _excluded2$1 = ["offset"];
function _typeof$4(t) {
  "@babel/helpers - typeof";
  return _typeof$4 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof$4(t);
}
function ownKeys$3(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(l) {
      return Object.getOwnPropertyDescriptor(t, l).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function _objectSpread$2(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ownKeys$3(Object(n), !0).forEach(function(o) {
      _defineProperty$4(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : ownKeys$3(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
function _defineProperty$4(t, e, n) {
  return e = _toPropertyKey$4(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function _toPropertyKey$4(t) {
  var e = _toPrimitive$4(t, "string");
  return _typeof$4(e) == "symbol" ? e : String(e);
}
function _toPrimitive$4(t, e) {
  if (_typeof$4(t) != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(t, e || "default");
    if (_typeof$4(o) != "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function _extends$5() {
  return _extends$5 = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }
    return t;
  }, _extends$5.apply(this, arguments);
}
function _objectWithoutProperties$1(t, e) {
  if (t == null) return {};
  var n = _objectWithoutPropertiesLoose$2(t, e), o, l;
  if (Object.getOwnPropertySymbols) {
    var u = Object.getOwnPropertySymbols(t);
    for (l = 0; l < u.length; l++)
      o = u[l], !(e.indexOf(o) >= 0) && Object.prototype.propertyIsEnumerable.call(t, o) && (n[o] = t[o]);
  }
  return n;
}
function _objectWithoutPropertiesLoose$2(t, e) {
  if (t == null) return {};
  var n = {}, o = Object.keys(t), l, u;
  for (u = 0; u < o.length; u++)
    l = o[u], !(e.indexOf(l) >= 0) && (n[l] = t[l]);
  return n;
}
var Background = function t(e) {
  var n = e.fill;
  if (!n || n === "none")
    return null;
  var o = e.fillOpacity, l = e.x, u = e.y, f = e.width, h = e.height;
  return /* @__PURE__ */ React__default.createElement("rect", {
    x: l,
    y: u,
    width: f,
    height: h,
    stroke: "none",
    fill: n,
    fillOpacity: o,
    className: "recharts-cartesian-grid-bg"
  });
};
function renderLineItem(t, e) {
  var n;
  if (/* @__PURE__ */ React__default.isValidElement(t))
    n = /* @__PURE__ */ React__default.cloneElement(t, e);
  else if (isFunction$3(t))
    n = t(e);
  else {
    var o = e.x1, l = e.y1, u = e.x2, f = e.y2, h = e.key, p = _objectWithoutProperties$1(e, _excluded$1), v = filterProps(p, !1);
    v.offset;
    var g = _objectWithoutProperties$1(v, _excluded2$1);
    n = /* @__PURE__ */ React__default.createElement("line", _extends$5({}, g, {
      x1: o,
      y1: l,
      x2: u,
      y2: f,
      fill: "none",
      key: h
    }));
  }
  return n;
}
function HorizontalGridLines(t) {
  var e = t.x, n = t.width, o = t.horizontal, l = o === void 0 ? !0 : o, u = t.horizontalPoints;
  if (!l || !u || !u.length)
    return null;
  var f = u.map(function(h, p) {
    var v = _objectSpread$2(_objectSpread$2({}, t), {}, {
      x1: e,
      y1: h,
      x2: e + n,
      y2: h,
      key: "line-".concat(p),
      index: p
    });
    return renderLineItem(l, v);
  });
  return /* @__PURE__ */ React__default.createElement("g", {
    className: "recharts-cartesian-grid-horizontal"
  }, f);
}
function VerticalGridLines(t) {
  var e = t.y, n = t.height, o = t.vertical, l = o === void 0 ? !0 : o, u = t.verticalPoints;
  if (!l || !u || !u.length)
    return null;
  var f = u.map(function(h, p) {
    var v = _objectSpread$2(_objectSpread$2({}, t), {}, {
      x1: h,
      y1: e,
      x2: h,
      y2: e + n,
      key: "line-".concat(p),
      index: p
    });
    return renderLineItem(l, v);
  });
  return /* @__PURE__ */ React__default.createElement("g", {
    className: "recharts-cartesian-grid-vertical"
  }, f);
}
function HorizontalStripes(t) {
  var e = t.horizontalFill, n = t.fillOpacity, o = t.x, l = t.y, u = t.width, f = t.height, h = t.horizontalPoints, p = t.horizontal, v = p === void 0 ? !0 : p;
  if (!v || !e || !e.length)
    return null;
  var g = h.map(function(E) {
    return Math.round(E + l - l);
  }).sort(function(E, T) {
    return E - T;
  });
  l !== g[0] && g.unshift(0);
  var w = g.map(function(E, T) {
    var R = !g[T + 1], _ = R ? l + f - E : g[T + 1] - E;
    if (_ <= 0)
      return null;
    var b = T % e.length;
    return /* @__PURE__ */ React__default.createElement("rect", {
      key: "react-".concat(T),
      y: E,
      x: o,
      height: _,
      width: u,
      stroke: "none",
      fill: e[b],
      fillOpacity: n,
      className: "recharts-cartesian-grid-bg"
    });
  });
  return /* @__PURE__ */ React__default.createElement("g", {
    className: "recharts-cartesian-gridstripes-horizontal"
  }, w);
}
function VerticalStripes(t) {
  var e = t.vertical, n = e === void 0 ? !0 : e, o = t.verticalFill, l = t.fillOpacity, u = t.x, f = t.y, h = t.width, p = t.height, v = t.verticalPoints;
  if (!n || !o || !o.length)
    return null;
  var g = v.map(function(E) {
    return Math.round(E + u - u);
  }).sort(function(E, T) {
    return E - T;
  });
  u !== g[0] && g.unshift(0);
  var w = g.map(function(E, T) {
    var R = !g[T + 1], _ = R ? u + h - E : g[T + 1] - E;
    if (_ <= 0)
      return null;
    var b = T % o.length;
    return /* @__PURE__ */ React__default.createElement("rect", {
      key: "react-".concat(T),
      x: E,
      y: f,
      width: _,
      height: p,
      stroke: "none",
      fill: o[b],
      fillOpacity: l,
      className: "recharts-cartesian-grid-bg"
    });
  });
  return /* @__PURE__ */ React__default.createElement("g", {
    className: "recharts-cartesian-gridstripes-vertical"
  }, w);
}
var defaultVerticalCoordinatesGenerator = function t(e, n) {
  var o = e.xAxis, l = e.width, u = e.height, f = e.offset;
  return getCoordinatesOfGrid(getTicks(_objectSpread$2(_objectSpread$2(_objectSpread$2({}, CartesianAxis.defaultProps), o), {}, {
    ticks: getTicksOfAxis(o, !0),
    viewBox: {
      x: 0,
      y: 0,
      width: l,
      height: u
    }
  })), f.left, f.left + f.width, n);
}, defaultHorizontalCoordinatesGenerator = function t(e, n) {
  var o = e.yAxis, l = e.width, u = e.height, f = e.offset;
  return getCoordinatesOfGrid(getTicks(_objectSpread$2(_objectSpread$2(_objectSpread$2({}, CartesianAxis.defaultProps), o), {}, {
    ticks: getTicksOfAxis(o, !0),
    viewBox: {
      x: 0,
      y: 0,
      width: l,
      height: u
    }
  })), f.top, f.top + f.height, n);
}, defaultProps = {
  horizontal: !0,
  vertical: !0,
  // The ordinates of horizontal grid lines
  horizontalPoints: [],
  // The abscissas of vertical grid lines
  verticalPoints: [],
  stroke: "#ccc",
  fill: "none",
  // The fill of colors of grid lines
  verticalFill: [],
  horizontalFill: []
};
function CartesianGrid(t) {
  var e, n, o, l, u, f, h = useChartWidth(), p = useChartHeight(), v = useOffset(), g = _objectSpread$2(_objectSpread$2({}, t), {}, {
    stroke: (e = t.stroke) !== null && e !== void 0 ? e : defaultProps.stroke,
    fill: (n = t.fill) !== null && n !== void 0 ? n : defaultProps.fill,
    horizontal: (o = t.horizontal) !== null && o !== void 0 ? o : defaultProps.horizontal,
    horizontalFill: (l = t.horizontalFill) !== null && l !== void 0 ? l : defaultProps.horizontalFill,
    vertical: (u = t.vertical) !== null && u !== void 0 ? u : defaultProps.vertical,
    verticalFill: (f = t.verticalFill) !== null && f !== void 0 ? f : defaultProps.verticalFill,
    x: isNumber(t.x) ? t.x : v.left,
    y: isNumber(t.y) ? t.y : v.top,
    width: isNumber(t.width) ? t.width : v.width,
    height: isNumber(t.height) ? t.height : v.height
  }), w = g.x, E = g.y, T = g.width, R = g.height, _ = g.syncWithTicks, b = g.horizontalValues, M = g.verticalValues, A = useArbitraryXAxis(), $ = useYAxisWithFiniteDomainOrRandom();
  if (!isNumber(T) || T <= 0 || !isNumber(R) || R <= 0 || !isNumber(w) || w !== +w || !isNumber(E) || E !== +E)
    return null;
  var S = g.verticalCoordinatesGenerator || defaultVerticalCoordinatesGenerator, C = g.horizontalCoordinatesGenerator || defaultHorizontalCoordinatesGenerator, D = g.horizontalPoints, O = g.verticalPoints;
  if ((!D || !D.length) && isFunction$3(C)) {
    var N = b && b.length, j = C({
      yAxis: $ ? _objectSpread$2(_objectSpread$2({}, $), {}, {
        ticks: N ? b : $.ticks
      }) : void 0,
      width: h,
      height: p,
      offset: v
    }, N ? !0 : _);
    warn$2(Array.isArray(j), "horizontalCoordinatesGenerator should return Array but instead it returned [".concat(_typeof$4(j), "]")), Array.isArray(j) && (D = j);
  }
  if ((!O || !O.length) && isFunction$3(S)) {
    var L = M && M.length, z = S({
      xAxis: A ? _objectSpread$2(_objectSpread$2({}, A), {}, {
        ticks: L ? M : A.ticks
      }) : void 0,
      width: h,
      height: p,
      offset: v
    }, L ? !0 : _);
    warn$2(Array.isArray(z), "verticalCoordinatesGenerator should return Array but instead it returned [".concat(_typeof$4(z), "]")), Array.isArray(z) && (O = z);
  }
  return /* @__PURE__ */ React__default.createElement("g", {
    className: "recharts-cartesian-grid"
  }, /* @__PURE__ */ React__default.createElement(Background, {
    fill: g.fill,
    fillOpacity: g.fillOpacity,
    x: g.x,
    y: g.y,
    width: g.width,
    height: g.height
  }), /* @__PURE__ */ React__default.createElement(HorizontalGridLines, _extends$5({}, g, {
    offset: v,
    horizontalPoints: D,
    xAxis: A,
    yAxis: $
  })), /* @__PURE__ */ React__default.createElement(VerticalGridLines, _extends$5({}, g, {
    offset: v,
    verticalPoints: O,
    xAxis: A,
    yAxis: $
  })), /* @__PURE__ */ React__default.createElement(HorizontalStripes, _extends$5({}, g, {
    horizontalPoints: D
  })), /* @__PURE__ */ React__default.createElement(VerticalStripes, _extends$5({}, g, {
    verticalPoints: O
  })));
}
CartesianGrid.displayName = "CartesianGrid";
function _extends$4() {
  return _extends$4 = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }
    return t;
  }, _extends$4.apply(this, arguments);
}
var XAxis = function t(e) {
  var n = e.xAxisId, o = useChartWidth(), l = useChartHeight(), u = useXAxisOrThrow(n);
  return u == null ? null : (
    // @ts-expect-error the axisOptions type is not exactly what CartesianAxis is expecting.
    /* @__PURE__ */ React__default.createElement(CartesianAxis, _extends$4({}, u, {
      className: clsx$1("recharts-".concat(u.axisType, " ").concat(u.axisType), u.className),
      viewBox: {
        x: 0,
        y: 0,
        width: o,
        height: l
      },
      ticksGenerator: function(h) {
        return getTicksOfAxis(h, !0);
      }
    }))
  );
};
XAxis.displayName = "XAxis";
XAxis.defaultProps = {
  allowDecimals: !0,
  hide: !1,
  orientation: "bottom",
  width: 0,
  height: 30,
  mirror: !1,
  xAxisId: 0,
  tickCount: 5,
  type: "category",
  padding: {
    left: 0,
    right: 0
  },
  allowDataOverflow: !1,
  scale: "auto",
  reversed: !1,
  allowDuplicatedCategory: !0
};
function _extends$3() {
  return _extends$3 = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }
    return t;
  }, _extends$3.apply(this, arguments);
}
var YAxis = function t(e) {
  var n = e.yAxisId, o = useChartWidth(), l = useChartHeight(), u = useYAxisOrThrow(n);
  return u == null ? null : (
    // @ts-expect-error the axisOptions type is not exactly what CartesianAxis is expecting.
    /* @__PURE__ */ React__default.createElement(CartesianAxis, _extends$3({}, u, {
      className: clsx$1("recharts-".concat(u.axisType, " ").concat(u.axisType), u.className),
      viewBox: {
        x: 0,
        y: 0,
        width: o,
        height: l
      },
      ticksGenerator: function(h) {
        return getTicksOfAxis(h, !0);
      }
    }))
  );
};
YAxis.displayName = "YAxis";
YAxis.defaultProps = {
  allowDuplicatedCategory: !0,
  allowDecimals: !0,
  hide: !1,
  orientation: "left",
  width: 60,
  height: 0,
  mirror: !1,
  yAxisId: 0,
  tickCount: 5,
  type: "number",
  padding: {
    top: 0,
    bottom: 0
  },
  allowDataOverflow: !1,
  scale: "auto",
  reversed: !1
};
function _toConsumableArray$2(t) {
  return _arrayWithoutHoles$2(t) || _iterableToArray$2(t) || _unsupportedIterableToArray$2(t) || _nonIterableSpread$2();
}
function _nonIterableSpread$2() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function _unsupportedIterableToArray$2(t, e) {
  if (t) {
    if (typeof t == "string") return _arrayLikeToArray$2(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(t, e);
  }
}
function _iterableToArray$2(t) {
  if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
}
function _arrayWithoutHoles$2(t) {
  if (Array.isArray(t)) return _arrayLikeToArray$2(t);
}
function _arrayLikeToArray$2(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, o = new Array(e); n < e; n++) o[n] = t[n];
  return o;
}
var detectReferenceElementsDomain = function t(e, n, o, l, u) {
  var f = findAllByType(e, ReferenceLine), h = findAllByType(e, ReferenceDot), p = [].concat(_toConsumableArray$2(f), _toConsumableArray$2(h)), v = findAllByType(e, ReferenceArea), g = "".concat(l, "Id"), w = l[0], E = n;
  if (p.length && (E = p.reduce(function(_, b) {
    if (b.props[g] === o && ifOverflowMatches(b.props, "extendDomain") && isNumber(b.props[w])) {
      var M = b.props[w];
      return [Math.min(_[0], M), Math.max(_[1], M)];
    }
    return _;
  }, E)), v.length) {
    var T = "".concat(w, "1"), R = "".concat(w, "2");
    E = v.reduce(function(_, b) {
      if (b.props[g] === o && ifOverflowMatches(b.props, "extendDomain") && isNumber(b.props[T]) && isNumber(b.props[R])) {
        var M = b.props[T], A = b.props[R];
        return [Math.min(_[0], M, A), Math.max(_[1], M, A)];
      }
      return _;
    }, E);
  }
  return u && u.length && (E = u.reduce(function(_, b) {
    return isNumber(b) ? [Math.min(_[0], b), Math.max(_[1], b)] : _;
  }, E)), E;
}, eventemitter3 = { exports: {} };
(function(t) {
  var e = Object.prototype.hasOwnProperty, n = "~";
  function o() {
  }
  Object.create && (o.prototype = /* @__PURE__ */ Object.create(null), new o().__proto__ || (n = !1));
  function l(p, v, g) {
    this.fn = p, this.context = v, this.once = g || !1;
  }
  function u(p, v, g, w, E) {
    if (typeof g != "function")
      throw new TypeError("The listener must be a function");
    var T = new l(g, w || p, E), R = n ? n + v : v;
    return p._events[R] ? p._events[R].fn ? p._events[R] = [p._events[R], T] : p._events[R].push(T) : (p._events[R] = T, p._eventsCount++), p;
  }
  function f(p, v) {
    --p._eventsCount === 0 ? p._events = new o() : delete p._events[v];
  }
  function h() {
    this._events = new o(), this._eventsCount = 0;
  }
  h.prototype.eventNames = function() {
    var v = [], g, w;
    if (this._eventsCount === 0) return v;
    for (w in g = this._events)
      e.call(g, w) && v.push(n ? w.slice(1) : w);
    return Object.getOwnPropertySymbols ? v.concat(Object.getOwnPropertySymbols(g)) : v;
  }, h.prototype.listeners = function(v) {
    var g = n ? n + v : v, w = this._events[g];
    if (!w) return [];
    if (w.fn) return [w.fn];
    for (var E = 0, T = w.length, R = new Array(T); E < T; E++)
      R[E] = w[E].fn;
    return R;
  }, h.prototype.listenerCount = function(v) {
    var g = n ? n + v : v, w = this._events[g];
    return w ? w.fn ? 1 : w.length : 0;
  }, h.prototype.emit = function(v, g, w, E, T, R) {
    var _ = n ? n + v : v;
    if (!this._events[_]) return !1;
    var b = this._events[_], M = arguments.length, A, $;
    if (b.fn) {
      switch (b.once && this.removeListener(v, b.fn, void 0, !0), M) {
        case 1:
          return b.fn.call(b.context), !0;
        case 2:
          return b.fn.call(b.context, g), !0;
        case 3:
          return b.fn.call(b.context, g, w), !0;
        case 4:
          return b.fn.call(b.context, g, w, E), !0;
        case 5:
          return b.fn.call(b.context, g, w, E, T), !0;
        case 6:
          return b.fn.call(b.context, g, w, E, T, R), !0;
      }
      for ($ = 1, A = new Array(M - 1); $ < M; $++)
        A[$ - 1] = arguments[$];
      b.fn.apply(b.context, A);
    } else {
      var S = b.length, C;
      for ($ = 0; $ < S; $++)
        switch (b[$].once && this.removeListener(v, b[$].fn, void 0, !0), M) {
          case 1:
            b[$].fn.call(b[$].context);
            break;
          case 2:
            b[$].fn.call(b[$].context, g);
            break;
          case 3:
            b[$].fn.call(b[$].context, g, w);
            break;
          case 4:
            b[$].fn.call(b[$].context, g, w, E);
            break;
          default:
            if (!A) for (C = 1, A = new Array(M - 1); C < M; C++)
              A[C - 1] = arguments[C];
            b[$].fn.apply(b[$].context, A);
        }
    }
    return !0;
  }, h.prototype.on = function(v, g, w) {
    return u(this, v, g, w, !1);
  }, h.prototype.once = function(v, g, w) {
    return u(this, v, g, w, !0);
  }, h.prototype.removeListener = function(v, g, w, E) {
    var T = n ? n + v : v;
    if (!this._events[T]) return this;
    if (!g)
      return f(this, T), this;
    var R = this._events[T];
    if (R.fn)
      R.fn === g && (!E || R.once) && (!w || R.context === w) && f(this, T);
    else {
      for (var _ = 0, b = [], M = R.length; _ < M; _++)
        (R[_].fn !== g || E && !R[_].once || w && R[_].context !== w) && b.push(R[_]);
      b.length ? this._events[T] = b.length === 1 ? b[0] : b : f(this, T);
    }
    return this;
  }, h.prototype.removeAllListeners = function(v) {
    var g;
    return v ? (g = n ? n + v : v, this._events[g] && f(this, g)) : (this._events = new o(), this._eventsCount = 0), this;
  }, h.prototype.off = h.prototype.removeListener, h.prototype.addListener = h.prototype.on, h.prefixed = n, h.EventEmitter = h, t.exports = h;
})(eventemitter3);
var eventemitter3Exports = eventemitter3.exports;
const EventEmitter = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter3Exports);
var eventCenter = new EventEmitter(), SYNC_EVENT = "recharts.syncMouseEvents";
function _typeof$3(t) {
  "@babel/helpers - typeof";
  return _typeof$3 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof$3(t);
}
function _classCallCheck$2(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$2(t, e) {
  for (var n = 0; n < e.length; n++) {
    var o = e[n];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, _toPropertyKey$3(o.key), o);
  }
}
function _createClass$2(t, e, n) {
  return e && _defineProperties$2(t.prototype, e), Object.defineProperty(t, "prototype", { writable: !1 }), t;
}
function _defineProperty$3(t, e, n) {
  return e = _toPropertyKey$3(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function _toPropertyKey$3(t) {
  var e = _toPrimitive$3(t, "string");
  return _typeof$3(e) == "symbol" ? e : String(e);
}
function _toPrimitive$3(t, e) {
  if (_typeof$3(t) != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(t, e || "default");
    if (_typeof$3(o) != "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
var AccessibilityManager = /* @__PURE__ */ function() {
  function t() {
    _classCallCheck$2(this, t), _defineProperty$3(this, "activeIndex", 0), _defineProperty$3(this, "coordinateList", []), _defineProperty$3(this, "layout", "horizontal");
  }
  return _createClass$2(t, [{
    key: "setDetails",
    value: function(n) {
      var o, l = n.coordinateList, u = l === void 0 ? null : l, f = n.container, h = f === void 0 ? null : f, p = n.layout, v = p === void 0 ? null : p, g = n.offset, w = g === void 0 ? null : g, E = n.mouseHandlerCallback, T = E === void 0 ? null : E;
      this.coordinateList = (o = u ?? this.coordinateList) !== null && o !== void 0 ? o : [], this.container = h ?? this.container, this.layout = v ?? this.layout, this.offset = w ?? this.offset, this.mouseHandlerCallback = T ?? this.mouseHandlerCallback, this.activeIndex = Math.min(Math.max(this.activeIndex, 0), this.coordinateList.length - 1);
    }
  }, {
    key: "focus",
    value: function() {
      this.spoofMouse();
    }
  }, {
    key: "keyboardEvent",
    value: function(n) {
      if (this.coordinateList.length !== 0)
        switch (n.key) {
          case "ArrowRight": {
            if (this.layout !== "horizontal")
              return;
            this.activeIndex = Math.min(this.activeIndex + 1, this.coordinateList.length - 1), this.spoofMouse();
            break;
          }
          case "ArrowLeft": {
            if (this.layout !== "horizontal")
              return;
            this.activeIndex = Math.max(this.activeIndex - 1, 0), this.spoofMouse();
            break;
          }
        }
    }
  }, {
    key: "setIndex",
    value: function(n) {
      this.activeIndex = n;
    }
  }, {
    key: "spoofMouse",
    value: function() {
      var n, o;
      if (this.layout === "horizontal" && this.coordinateList.length !== 0) {
        var l = this.container.getBoundingClientRect(), u = l.x, f = l.y, h = l.height, p = this.coordinateList[this.activeIndex].coordinate, v = ((n = window) === null || n === void 0 ? void 0 : n.scrollX) || 0, g = ((o = window) === null || o === void 0 ? void 0 : o.scrollY) || 0, w = u + p + v, E = f + this.offset.top + h / 2 + g;
        this.mouseHandlerCallback({
          pageX: w,
          pageY: E
        });
      }
    }
  }]), t;
}();
function isDomainSpecifiedByUser(t, e, n) {
  if (n === "number" && e === !0 && Array.isArray(t)) {
    var o = t == null ? void 0 : t[0], l = t == null ? void 0 : t[1];
    if (o && l && isNumber(o) && isNumber(l))
      return !0;
  }
  return !1;
}
function getCursorRectangle(t, e, n, o) {
  var l = o / 2;
  return {
    stroke: "none",
    fill: "#ccc",
    x: t === "horizontal" ? e.x - l : n.left + 0.5,
    y: t === "horizontal" ? n.top + 0.5 : e.y - l,
    width: t === "horizontal" ? o : n.width - 1,
    height: t === "horizontal" ? n.height - 1 : o
  };
}
function getRadialCursorPoints(t) {
  var e = t.cx, n = t.cy, o = t.radius, l = t.startAngle, u = t.endAngle, f = polarToCartesian(e, n, o, l), h = polarToCartesian(e, n, o, u);
  return {
    points: [f, h],
    cx: e,
    cy: n,
    radius: o,
    startAngle: l,
    endAngle: u
  };
}
function getCursorPoints(t, e, n) {
  var o, l, u, f;
  if (t === "horizontal")
    o = e.x, u = o, l = n.top, f = n.top + n.height;
  else if (t === "vertical")
    l = e.y, f = l, o = n.left, u = n.left + n.width;
  else if (e.cx != null && e.cy != null)
    if (t === "centric") {
      var h = e.cx, p = e.cy, v = e.innerRadius, g = e.outerRadius, w = e.angle, E = polarToCartesian(h, p, v, w), T = polarToCartesian(h, p, g, w);
      o = E.x, l = E.y, u = T.x, f = T.y;
    } else
      return getRadialCursorPoints(e);
  return [{
    x: o,
    y: l
  }, {
    x: u,
    y: f
  }];
}
function _typeof$2(t) {
  "@babel/helpers - typeof";
  return _typeof$2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof$2(t);
}
function ownKeys$2(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(l) {
      return Object.getOwnPropertyDescriptor(t, l).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function _objectSpread$1(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ownKeys$2(Object(n), !0).forEach(function(o) {
      _defineProperty$2(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : ownKeys$2(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
function _defineProperty$2(t, e, n) {
  return e = _toPropertyKey$2(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function _toPropertyKey$2(t) {
  var e = _toPrimitive$2(t, "string");
  return _typeof$2(e) == "symbol" ? e : String(e);
}
function _toPrimitive$2(t, e) {
  if (_typeof$2(t) != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(t, e || "default");
    if (_typeof$2(o) != "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function Cursor(t) {
  var e = t.element, n = t.tooltipEventType, o = t.isActive, l = t.activeCoordinate, u = t.activePayload, f = t.offset, h = t.activeTooltipIndex, p = t.tooltipAxisBandSize, v = t.layout, g = t.chartName;
  if (!e || !e.props.cursor || !o || !l || g !== "ScatterChart" && n !== "axis")
    return null;
  var w, E = Curve;
  if (g === "ScatterChart")
    w = l, E = Cross;
  else if (g === "BarChart")
    w = getCursorRectangle(v, l, f, p), E = Rectangle;
  else if (v === "radial") {
    var T = getRadialCursorPoints(l), R = T.cx, _ = T.cy, b = T.radius, M = T.startAngle, A = T.endAngle;
    w = {
      cx: R,
      cy: _,
      startAngle: M,
      endAngle: A,
      innerRadius: b,
      outerRadius: b
    }, E = Sector;
  } else
    w = {
      points: getCursorPoints(v, l, f)
    }, E = Curve;
  var $ = _objectSpread$1(_objectSpread$1(_objectSpread$1(_objectSpread$1({
    stroke: "#ccc",
    pointerEvents: "none"
  }, f), w), filterProps(e.props.cursor, !1)), {}, {
    payload: u,
    payloadIndex: h,
    className: clsx$1("recharts-tooltip-cursor", e.props.cursor.className)
  });
  return /* @__PURE__ */ isValidElement(e.props.cursor) ? /* @__PURE__ */ cloneElement(e.props.cursor, $) : /* @__PURE__ */ createElement(E, $);
}
var _excluded = ["item"], _excluded2 = ["children", "className", "width", "height", "style", "compact", "title", "desc"];
function _typeof$1(t) {
  "@babel/helpers - typeof";
  return _typeof$1 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof$1(t);
}
function _extends$2() {
  return _extends$2 = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }
    return t;
  }, _extends$2.apply(this, arguments);
}
function _slicedToArray(t, e) {
  return _arrayWithHoles(t) || _iterableToArrayLimit(t, e) || _unsupportedIterableToArray$1(t, e) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function _iterableToArrayLimit(t, e) {
  var n = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
  if (n != null) {
    var o, l, u, f, h = [], p = !0, v = !1;
    try {
      if (u = (n = n.call(t)).next, e !== 0) for (; !(p = (o = u.call(n)).done) && (h.push(o.value), h.length !== e); p = !0) ;
    } catch (g) {
      v = !0, l = g;
    } finally {
      try {
        if (!p && n.return != null && (f = n.return(), Object(f) !== f)) return;
      } finally {
        if (v) throw l;
      }
    }
    return h;
  }
}
function _arrayWithHoles(t) {
  if (Array.isArray(t)) return t;
}
function _objectWithoutProperties(t, e) {
  if (t == null) return {};
  var n = _objectWithoutPropertiesLoose$1(t, e), o, l;
  if (Object.getOwnPropertySymbols) {
    var u = Object.getOwnPropertySymbols(t);
    for (l = 0; l < u.length; l++)
      o = u[l], !(e.indexOf(o) >= 0) && Object.prototype.propertyIsEnumerable.call(t, o) && (n[o] = t[o]);
  }
  return n;
}
function _objectWithoutPropertiesLoose$1(t, e) {
  if (t == null) return {};
  var n = {}, o = Object.keys(t), l, u;
  for (u = 0; u < o.length; u++)
    l = o[u], !(e.indexOf(l) >= 0) && (n[l] = t[l]);
  return n;
}
function _classCallCheck$1(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties$1(t, e) {
  for (var n = 0; n < e.length; n++) {
    var o = e[n];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, _toPropertyKey$1(o.key), o);
  }
}
function _createClass$1(t, e, n) {
  return e && _defineProperties$1(t.prototype, e), Object.defineProperty(t, "prototype", { writable: !1 }), t;
}
function _callSuper$1(t, e, n) {
  return e = _getPrototypeOf$1(e), _possibleConstructorReturn$1(t, _isNativeReflectConstruct$1() ? Reflect.construct(e, n || [], _getPrototypeOf$1(t).constructor) : e.apply(t, n));
}
function _possibleConstructorReturn$1(t, e) {
  if (e && (_typeof$1(e) === "object" || typeof e == "function"))
    return e;
  if (e !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized$2(t);
}
function _isNativeReflectConstruct$1() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (_isNativeReflectConstruct$1 = function() {
    return !!t;
  })();
}
function _getPrototypeOf$1(t) {
  return _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
    return n.__proto__ || Object.getPrototypeOf(n);
  }, _getPrototypeOf$1(t);
}
function _assertThisInitialized$2(t) {
  if (t === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t;
}
function _inherits$1(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf$2(t, e);
}
function _setPrototypeOf$2(t, e) {
  return _setPrototypeOf$2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(o, l) {
    return o.__proto__ = l, o;
  }, _setPrototypeOf$2(t, e);
}
function _toConsumableArray$1(t) {
  return _arrayWithoutHoles$1(t) || _iterableToArray$1(t) || _unsupportedIterableToArray$1(t) || _nonIterableSpread$1();
}
function _nonIterableSpread$1() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function _unsupportedIterableToArray$1(t, e) {
  if (t) {
    if (typeof t == "string") return _arrayLikeToArray$1(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(t, e);
  }
}
function _iterableToArray$1(t) {
  if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
}
function _arrayWithoutHoles$1(t) {
  if (Array.isArray(t)) return _arrayLikeToArray$1(t);
}
function _arrayLikeToArray$1(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, o = new Array(e); n < e; n++) o[n] = t[n];
  return o;
}
function ownKeys$1(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(l) {
      return Object.getOwnPropertyDescriptor(t, l).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function _objectSpread(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ownKeys$1(Object(n), !0).forEach(function(o) {
      _defineProperty$1(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : ownKeys$1(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
function _defineProperty$1(t, e, n) {
  return e = _toPropertyKey$1(e), e in t ? Object.defineProperty(t, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = n, t;
}
function _toPropertyKey$1(t) {
  var e = _toPrimitive$1(t, "string");
  return _typeof$1(e) == "symbol" ? e : String(e);
}
function _toPrimitive$1(t, e) {
  if (_typeof$1(t) != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(t, e || "default");
    if (_typeof$1(o) != "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
var ORIENT_MAP = {
  xAxis: ["bottom", "top"],
  yAxis: ["left", "right"]
}, FULL_WIDTH_AND_HEIGHT = {
  width: "100%",
  height: "100%"
}, originCoordinate = {
  x: 0,
  y: 0
};
function renderAsIs(t) {
  return t;
}
var calculateTooltipPos = function t(e, n) {
  return n === "horizontal" ? e.x : n === "vertical" ? e.y : n === "centric" ? e.angle : e.radius;
}, getActiveCoordinate = function t(e, n, o, l) {
  var u = n.find(function(g) {
    return g && g.index === o;
  });
  if (u) {
    if (e === "horizontal")
      return {
        x: u.coordinate,
        y: l.y
      };
    if (e === "vertical")
      return {
        x: l.x,
        y: u.coordinate
      };
    if (e === "centric") {
      var f = u.coordinate, h = l.radius;
      return _objectSpread(_objectSpread(_objectSpread({}, l), polarToCartesian(l.cx, l.cy, h, f)), {}, {
        angle: f,
        radius: h
      });
    }
    var p = u.coordinate, v = l.angle;
    return _objectSpread(_objectSpread(_objectSpread({}, l), polarToCartesian(l.cx, l.cy, p, v)), {}, {
      angle: v,
      radius: p
    });
  }
  return originCoordinate;
}, getDisplayedData = function t(e, n) {
  var o = n.graphicalItems, l = n.dataStartIndex, u = n.dataEndIndex, f = (o ?? []).reduce(function(h, p) {
    var v = p.props.data;
    return v && v.length ? [].concat(_toConsumableArray$1(h), _toConsumableArray$1(v)) : h;
  }, []);
  return f.length > 0 ? f : e && e.length && isNumber(l) && isNumber(u) ? e.slice(l, u + 1) : [];
};
function getDefaultDomainByAxisType(t) {
  return t === "number" ? [0, "auto"] : void 0;
}
var getTooltipContent = function t(e, n, o, l) {
  var u = e.graphicalItems, f = e.tooltipAxis, h = getDisplayedData(n, e);
  return o < 0 || !u || !u.length || o >= h.length ? null : u.reduce(function(p, v) {
    var g, w = (g = v.props.data) !== null && g !== void 0 ? g : n;
    w && e.dataStartIndex + e.dataEndIndex !== 0 && (w = w.slice(e.dataStartIndex, e.dataEndIndex + 1));
    var E;
    if (f.dataKey && !f.allowDuplicatedCategory) {
      var T = w === void 0 ? h : w;
      E = findEntryInArray(T, f.dataKey, l);
    } else
      E = w && w[o] || h[o];
    return E ? [].concat(_toConsumableArray$1(p), [getTooltipItem(v, E)]) : p;
  }, []);
}, getTooltipData = function t(e, n, o, l) {
  var u = l || {
    x: e.chartX,
    y: e.chartY
  }, f = calculateTooltipPos(u, o), h = e.orderedTooltipTicks, p = e.tooltipAxis, v = e.tooltipTicks, g = calculateActiveTickIndex(f, h, v, p);
  if (g >= 0 && v) {
    var w = v[g] && v[g].value, E = getTooltipContent(e, n, g, w), T = getActiveCoordinate(o, h, g, u);
    return {
      activeTooltipIndex: g,
      activeLabel: w,
      activePayload: E,
      activeCoordinate: T
    };
  }
  return null;
}, getAxisMapByAxes = function t(e, n) {
  var o = n.axes, l = n.graphicalItems, u = n.axisType, f = n.axisIdKey, h = n.stackGroups, p = n.dataStartIndex, v = n.dataEndIndex, g = e.layout, w = e.children, E = e.stackOffset, T = isCategoricalAxis(g, u);
  return o.reduce(function(R, _) {
    var b, M = _.props, A = M.type, $ = M.dataKey, S = M.allowDataOverflow, C = M.allowDuplicatedCategory, D = M.scale, O = M.ticks, N = M.includeHidden, j = _.props[f];
    if (R[j])
      return R;
    var L = getDisplayedData(e.data, {
      graphicalItems: l.filter(function(J) {
        return J.props[f] === j;
      }),
      dataStartIndex: p,
      dataEndIndex: v
    }), z = L.length, G, B, F;
    isDomainSpecifiedByUser(_.props.domain, S, A) && (G = parseSpecifiedDomain(_.props.domain, null, S), T && (A === "number" || D !== "auto") && (F = getDomainOfDataByKey(L, $, "category")));
    var H = getDefaultDomainByAxisType(A);
    if (!G || G.length === 0) {
      var W, V = (W = _.props.domain) !== null && W !== void 0 ? W : H;
      if ($) {
        if (G = getDomainOfDataByKey(L, $, A), A === "category" && T) {
          var X = hasDuplicate(G);
          C && X ? (B = G, G = range$1(0, z)) : C || (G = parseDomainOfCategoryAxis(V, G, _).reduce(function(J, ie) {
            return J.indexOf(ie) >= 0 ? J : [].concat(_toConsumableArray$1(J), [ie]);
          }, []));
        } else if (A === "category")
          C ? G = G.filter(function(J) {
            return J !== "" && !isNil$1(J);
          }) : G = parseDomainOfCategoryAxis(V, G, _).reduce(function(J, ie) {
            return J.indexOf(ie) >= 0 || ie === "" || isNil$1(ie) ? J : [].concat(_toConsumableArray$1(J), [ie]);
          }, []);
        else if (A === "number") {
          var Z = parseErrorBarsOfAxis(L, l.filter(function(J) {
            return J.props[f] === j && (N || !J.props.hide);
          }), $, u, g);
          Z && (G = Z);
        }
        T && (A === "number" || D !== "auto") && (F = getDomainOfDataByKey(L, $, "category"));
      } else T ? G = range$1(0, z) : h && h[j] && h[j].hasStack && A === "number" ? G = E === "expand" ? [0, 1] : getDomainOfStackGroups(h[j].stackGroups, p, v) : G = getDomainOfItemsWithSameAxis(L, l.filter(function(J) {
        return J.props[f] === j && (N || !J.props.hide);
      }), A, g, !0);
      if (A === "number")
        G = detectReferenceElementsDomain(w, G, j, u, O), V && (G = parseSpecifiedDomain(V, G, S));
      else if (A === "category" && V) {
        var Q = V, q = G.every(function(J) {
          return Q.indexOf(J) >= 0;
        });
        q && (G = Q);
      }
    }
    return _objectSpread(_objectSpread({}, R), {}, _defineProperty$1({}, j, _objectSpread(_objectSpread({}, _.props), {}, {
      axisType: u,
      domain: G,
      categoricalDomain: F,
      duplicateDomain: B,
      originalDomain: (b = _.props.domain) !== null && b !== void 0 ? b : H,
      isCategorical: T,
      layout: g
    })));
  }, {});
}, getAxisMapByItems = function t(e, n) {
  var o = n.graphicalItems, l = n.Axis, u = n.axisType, f = n.axisIdKey, h = n.stackGroups, p = n.dataStartIndex, v = n.dataEndIndex, g = e.layout, w = e.children, E = getDisplayedData(e.data, {
    graphicalItems: o,
    dataStartIndex: p,
    dataEndIndex: v
  }), T = E.length, R = isCategoricalAxis(g, u), _ = -1;
  return o.reduce(function(b, M) {
    var A = M.props[f], $ = getDefaultDomainByAxisType("number");
    if (!b[A]) {
      _++;
      var S;
      return R ? S = range$1(0, T) : h && h[A] && h[A].hasStack ? (S = getDomainOfStackGroups(h[A].stackGroups, p, v), S = detectReferenceElementsDomain(w, S, A, u)) : (S = parseSpecifiedDomain($, getDomainOfItemsWithSameAxis(E, o.filter(function(C) {
        return C.props[f] === A && !C.props.hide;
      }), "number", g), l.defaultProps.allowDataOverflow), S = detectReferenceElementsDomain(w, S, A, u)), _objectSpread(_objectSpread({}, b), {}, _defineProperty$1({}, A, _objectSpread(_objectSpread({
        axisType: u
      }, l.defaultProps), {}, {
        hide: !0,
        orientation: get$2(ORIENT_MAP, "".concat(u, ".").concat(_ % 2), null),
        domain: S,
        originalDomain: $,
        isCategorical: R,
        layout: g
        // specify scale when no Axis
        // scale: isCategorical ? 'band' : 'linear',
      })));
    }
    return b;
  }, {});
}, getAxisMap = function t(e, n) {
  var o = n.axisType, l = o === void 0 ? "xAxis" : o, u = n.AxisComp, f = n.graphicalItems, h = n.stackGroups, p = n.dataStartIndex, v = n.dataEndIndex, g = e.children, w = "".concat(l, "Id"), E = findAllByType(g, u), T = {};
  return E && E.length ? T = getAxisMapByAxes(e, {
    axes: E,
    graphicalItems: f,
    axisType: l,
    axisIdKey: w,
    stackGroups: h,
    dataStartIndex: p,
    dataEndIndex: v
  }) : f && f.length && (T = getAxisMapByItems(e, {
    Axis: u,
    graphicalItems: f,
    axisType: l,
    axisIdKey: w,
    stackGroups: h,
    dataStartIndex: p,
    dataEndIndex: v
  })), T;
}, tooltipTicksGenerator = function t(e) {
  var n = getAnyElementOfObject(e), o = getTicksOfAxis(n, !1, !0);
  return {
    tooltipTicks: o,
    orderedTooltipTicks: sortBy$1(o, function(l) {
      return l.coordinate;
    }),
    tooltipAxis: n,
    tooltipAxisBandSize: getBandSizeOfAxis(n, o)
  };
}, createDefaultState = function t(e) {
  var n = e.children, o = e.defaultShowTooltip, l = findChildByType(n, Brush), u = 0, f = 0;
  return e.data && e.data.length !== 0 && (f = e.data.length - 1), l && l.props && (l.props.startIndex >= 0 && (u = l.props.startIndex), l.props.endIndex >= 0 && (f = l.props.endIndex)), {
    chartX: 0,
    chartY: 0,
    dataStartIndex: u,
    dataEndIndex: f,
    activeTooltipIndex: -1,
    isTooltipActive: !!o
  };
}, hasGraphicalBarItem = function t(e) {
  return !e || !e.length ? !1 : e.some(function(n) {
    var o = getDisplayName(n && n.type);
    return o && o.indexOf("Bar") >= 0;
  });
}, getAxisNameByLayout = function t(e) {
  return e === "horizontal" ? {
    numericAxisName: "yAxis",
    cateAxisName: "xAxis"
  } : e === "vertical" ? {
    numericAxisName: "xAxis",
    cateAxisName: "yAxis"
  } : e === "centric" ? {
    numericAxisName: "radiusAxis",
    cateAxisName: "angleAxis"
  } : {
    numericAxisName: "angleAxis",
    cateAxisName: "radiusAxis"
  };
}, calculateOffset = function t(e, n) {
  var o = e.props, l = e.graphicalItems, u = e.xAxisMap, f = u === void 0 ? {} : u, h = e.yAxisMap, p = h === void 0 ? {} : h, v = o.width, g = o.height, w = o.children, E = o.margin || {}, T = findChildByType(w, Brush), R = findChildByType(w, Legend), _ = Object.keys(p).reduce(function(C, D) {
    var O = p[D], N = O.orientation;
    return !O.mirror && !O.hide ? _objectSpread(_objectSpread({}, C), {}, _defineProperty$1({}, N, C[N] + O.width)) : C;
  }, {
    left: E.left || 0,
    right: E.right || 0
  }), b = Object.keys(f).reduce(function(C, D) {
    var O = f[D], N = O.orientation;
    return !O.mirror && !O.hide ? _objectSpread(_objectSpread({}, C), {}, _defineProperty$1({}, N, get$2(C, "".concat(N)) + O.height)) : C;
  }, {
    top: E.top || 0,
    bottom: E.bottom || 0
  }), M = _objectSpread(_objectSpread({}, b), _), A = M.bottom;
  T && (M.bottom += T.props.height || Brush.defaultProps.height), R && n && (M = appendOffsetOfLegend(M, l, o, n));
  var $ = v - M.left - M.right, S = g - M.top - M.bottom;
  return _objectSpread(_objectSpread({
    brushBottom: A
  }, M), {}, {
    // never return negative values for height and width
    width: Math.max($, 0),
    height: Math.max(S, 0)
  });
}, getCartesianAxisSize = function t(e, n) {
  if (n === "xAxis")
    return e[n].width;
  if (n === "yAxis")
    return e[n].height;
}, generateCategoricalChart = function t(e) {
  var n, o = e.chartName, l = e.GraphicalChild, u = e.defaultTooltipEventType, f = u === void 0 ? "axis" : u, h = e.validateTooltipEventTypes, p = h === void 0 ? ["axis"] : h, v = e.axisComponents, g = e.legendContent, w = e.formatAxisMap, E = e.defaultProps, T = function(b, M) {
    var A = M.graphicalItems, $ = M.stackGroups, S = M.offset, C = M.updateId, D = M.dataStartIndex, O = M.dataEndIndex, N = b.barSize, j = b.layout, L = b.barGap, z = b.barCategoryGap, G = b.maxBarSize, B = getAxisNameByLayout(j), F = B.numericAxisName, H = B.cateAxisName, W = hasGraphicalBarItem(A), V = [];
    return A.forEach(function(X, Z) {
      var Q = getDisplayedData(b.data, {
        graphicalItems: [X],
        dataStartIndex: D,
        dataEndIndex: O
      }), q = X.props, J = q.dataKey, ie = q.maxBarSize, ne = X.props["".concat(F, "Id")], ge = X.props["".concat(H, "Id")], ye = {}, xe = v.reduce(function(Qe, ue) {
        var te, Be, Je = M["".concat(ue.axisType, "Map")], ft = X.props["".concat(ue.axisType, "Id")];
        Je && Je[ft] || ue.axisType === "zAxis" || (process.env.NODE_ENV !== "production" ? invariant(!1, "Specifying a(n) ".concat(ue.axisType, "Id requires a corresponding ").concat(
          ue.axisType,
          "Id on the targeted graphical component "
        ).concat((te = X == null || (Be = X.type) === null || Be === void 0 ? void 0 : Be.displayName) !== null && te !== void 0 ? te : "")) : invariant());
        var lt = Je[ft];
        return _objectSpread(_objectSpread({}, Qe), {}, _defineProperty$1(_defineProperty$1({}, ue.axisType, lt), "".concat(ue.axisType, "Ticks"), getTicksOfAxis(lt)));
      }, ye), we = xe[H], de = xe["".concat(H, "Ticks")], Te = $ && $[ne] && $[ne].hasStack && getStackedDataOfItem(X, $[ne].stackGroups), Ce = getDisplayName(X.type).indexOf("Bar") >= 0, ee = getBandSizeOfAxis(we, de), Ae = [], be = W && getBarSizeList({
        barSize: N,
        stackGroups: $,
        totalSize: getCartesianAxisSize(xe, H)
      });
      if (Ce) {
        var Fe, et, Ye = isNil$1(ie) ? G : ie, De = (Fe = (et = getBandSizeOfAxis(we, de, !0)) !== null && et !== void 0 ? et : Ye) !== null && Fe !== void 0 ? Fe : 0;
        Ae = getBarPosition({
          barGap: L,
          barCategoryGap: z,
          bandSize: De !== ee ? De : ee,
          sizeList: be[ge],
          maxBarSize: Ye
        }), De !== ee && (Ae = Ae.map(function(Qe) {
          return _objectSpread(_objectSpread({}, Qe), {}, {
            position: _objectSpread(_objectSpread({}, Qe.position), {}, {
              offset: Qe.position.offset - De / 2
            })
          });
        }));
      }
      var Ue = X && X.type && X.type.getComposedData;
      Ue && V.push({
        props: _objectSpread(_objectSpread({}, Ue(_objectSpread(_objectSpread({}, xe), {}, {
          displayedData: Q,
          props: b,
          dataKey: J,
          item: X,
          bandSize: ee,
          barPosition: Ae,
          offset: S,
          stackedData: Te,
          layout: j,
          dataStartIndex: D,
          dataEndIndex: O
        }))), {}, _defineProperty$1(_defineProperty$1(_defineProperty$1({
          key: X.key || "item-".concat(Z)
        }, F, xe[F]), H, xe[H]), "animationId", C)),
        childIndex: parseChildIndex(X, b.children),
        item: X
      });
    }), V;
  }, R = function(b, M) {
    var A = b.props, $ = b.dataStartIndex, S = b.dataEndIndex, C = b.updateId;
    if (!validateWidthHeight({
      props: A
    }))
      return null;
    var D = A.children, O = A.layout, N = A.stackOffset, j = A.data, L = A.reverseStackOrder, z = getAxisNameByLayout(O), G = z.numericAxisName, B = z.cateAxisName, F = findAllByType(D, l), H = getStackGroupsByAxisId(j, F, "".concat(G, "Id"), "".concat(B, "Id"), N, L), W = v.reduce(function(q, J) {
      var ie = "".concat(J.axisType, "Map");
      return _objectSpread(_objectSpread({}, q), {}, _defineProperty$1({}, ie, getAxisMap(A, _objectSpread(_objectSpread({}, J), {}, {
        graphicalItems: F,
        stackGroups: J.axisType === G && H,
        dataStartIndex: $,
        dataEndIndex: S
      }))));
    }, {}), V = calculateOffset(_objectSpread(_objectSpread({}, W), {}, {
      props: A,
      graphicalItems: F
    }), M == null ? void 0 : M.legendBBox);
    Object.keys(W).forEach(function(q) {
      W[q] = w(A, W[q], V, q.replace("Map", ""), o);
    });
    var X = W["".concat(B, "Map")], Z = tooltipTicksGenerator(X), Q = T(A, _objectSpread(_objectSpread({}, W), {}, {
      dataStartIndex: $,
      dataEndIndex: S,
      updateId: C,
      graphicalItems: F,
      stackGroups: H,
      offset: V
    }));
    return _objectSpread(_objectSpread({
      formattedGraphicalItems: Q,
      graphicalItems: F,
      offset: V,
      stackGroups: H
    }, Z), W);
  };
  return n = /* @__PURE__ */ function(_) {
    _inherits$1(b, _);
    function b(M) {
      var A, $, S;
      return _classCallCheck$1(this, b), S = _callSuper$1(this, b, [M]), _defineProperty$1(_assertThisInitialized$2(S), "eventEmitterSymbol", Symbol("rechartsEventEmitter")), _defineProperty$1(_assertThisInitialized$2(S), "accessibilityManager", new AccessibilityManager()), _defineProperty$1(_assertThisInitialized$2(S), "handleLegendBBoxUpdate", function(C) {
        if (C) {
          var D = S.state, O = D.dataStartIndex, N = D.dataEndIndex, j = D.updateId;
          S.setState(_objectSpread({
            legendBBox: C
          }, R({
            props: S.props,
            dataStartIndex: O,
            dataEndIndex: N,
            updateId: j
          }, _objectSpread(_objectSpread({}, S.state), {}, {
            legendBBox: C
          }))));
        }
      }), _defineProperty$1(_assertThisInitialized$2(S), "handleReceiveSyncEvent", function(C, D, O) {
        if (S.props.syncId === C) {
          if (O === S.eventEmitterSymbol && typeof S.props.syncMethod != "function")
            return;
          S.applySyncEvent(D);
        }
      }), _defineProperty$1(_assertThisInitialized$2(S), "handleBrushChange", function(C) {
        var D = C.startIndex, O = C.endIndex;
        if (D !== S.state.dataStartIndex || O !== S.state.dataEndIndex) {
          var N = S.state.updateId;
          S.setState(function() {
            return _objectSpread({
              dataStartIndex: D,
              dataEndIndex: O
            }, R({
              props: S.props,
              dataStartIndex: D,
              dataEndIndex: O,
              updateId: N
            }, S.state));
          }), S.triggerSyncEvent({
            dataStartIndex: D,
            dataEndIndex: O
          });
        }
      }), _defineProperty$1(_assertThisInitialized$2(S), "handleMouseEnter", function(C) {
        var D = S.getMouseInfo(C);
        if (D) {
          var O = _objectSpread(_objectSpread({}, D), {}, {
            isTooltipActive: !0
          });
          S.setState(O), S.triggerSyncEvent(O);
          var N = S.props.onMouseEnter;
          isFunction$3(N) && N(O, C);
        }
      }), _defineProperty$1(_assertThisInitialized$2(S), "triggeredAfterMouseMove", function(C) {
        var D = S.getMouseInfo(C), O = D ? _objectSpread(_objectSpread({}, D), {}, {
          isTooltipActive: !0
        }) : {
          isTooltipActive: !1
        };
        S.setState(O), S.triggerSyncEvent(O);
        var N = S.props.onMouseMove;
        isFunction$3(N) && N(O, C);
      }), _defineProperty$1(_assertThisInitialized$2(S), "handleItemMouseEnter", function(C) {
        S.setState(function() {
          return {
            isTooltipActive: !0,
            activeItem: C,
            activePayload: C.tooltipPayload,
            activeCoordinate: C.tooltipPosition || {
              x: C.cx,
              y: C.cy
            }
          };
        });
      }), _defineProperty$1(_assertThisInitialized$2(S), "handleItemMouseLeave", function() {
        S.setState(function() {
          return {
            isTooltipActive: !1
          };
        });
      }), _defineProperty$1(_assertThisInitialized$2(S), "handleMouseMove", function(C) {
        C.persist(), S.throttleTriggeredAfterMouseMove(C);
      }), _defineProperty$1(_assertThisInitialized$2(S), "handleMouseLeave", function(C) {
        S.throttleTriggeredAfterMouseMove.cancel();
        var D = {
          isTooltipActive: !1
        };
        S.setState(D), S.triggerSyncEvent(D);
        var O = S.props.onMouseLeave;
        isFunction$3(O) && O(D, C);
      }), _defineProperty$1(_assertThisInitialized$2(S), "handleOuterEvent", function(C) {
        var D = getReactEventByType(C), O = get$2(S.props, "".concat(D));
        if (D && isFunction$3(O)) {
          var N, j;
          /.*touch.*/i.test(D) ? j = S.getMouseInfo(C.changedTouches[0]) : j = S.getMouseInfo(C), O((N = j) !== null && N !== void 0 ? N : {}, C);
        }
      }), _defineProperty$1(_assertThisInitialized$2(S), "handleClick", function(C) {
        var D = S.getMouseInfo(C);
        if (D) {
          var O = _objectSpread(_objectSpread({}, D), {}, {
            isTooltipActive: !0
          });
          S.setState(O), S.triggerSyncEvent(O);
          var N = S.props.onClick;
          isFunction$3(N) && N(O, C);
        }
      }), _defineProperty$1(_assertThisInitialized$2(S), "handleMouseDown", function(C) {
        var D = S.props.onMouseDown;
        if (isFunction$3(D)) {
          var O = S.getMouseInfo(C);
          D(O, C);
        }
      }), _defineProperty$1(_assertThisInitialized$2(S), "handleMouseUp", function(C) {
        var D = S.props.onMouseUp;
        if (isFunction$3(D)) {
          var O = S.getMouseInfo(C);
          D(O, C);
        }
      }), _defineProperty$1(_assertThisInitialized$2(S), "handleTouchMove", function(C) {
        C.changedTouches != null && C.changedTouches.length > 0 && S.throttleTriggeredAfterMouseMove(C.changedTouches[0]);
      }), _defineProperty$1(_assertThisInitialized$2(S), "handleTouchStart", function(C) {
        C.changedTouches != null && C.changedTouches.length > 0 && S.handleMouseDown(C.changedTouches[0]);
      }), _defineProperty$1(_assertThisInitialized$2(S), "handleTouchEnd", function(C) {
        C.changedTouches != null && C.changedTouches.length > 0 && S.handleMouseUp(C.changedTouches[0]);
      }), _defineProperty$1(_assertThisInitialized$2(S), "triggerSyncEvent", function(C) {
        S.props.syncId !== void 0 && eventCenter.emit(SYNC_EVENT, S.props.syncId, C, S.eventEmitterSymbol);
      }), _defineProperty$1(_assertThisInitialized$2(S), "applySyncEvent", function(C) {
        var D = S.props, O = D.layout, N = D.syncMethod, j = S.state.updateId, L = C.dataStartIndex, z = C.dataEndIndex;
        if (C.dataStartIndex !== void 0 || C.dataEndIndex !== void 0)
          S.setState(_objectSpread({
            dataStartIndex: L,
            dataEndIndex: z
          }, R({
            props: S.props,
            dataStartIndex: L,
            dataEndIndex: z,
            updateId: j
          }, S.state)));
        else if (C.activeTooltipIndex !== void 0) {
          var G = C.chartX, B = C.chartY, F = C.activeTooltipIndex, H = S.state, W = H.offset, V = H.tooltipTicks;
          if (!W)
            return;
          if (typeof N == "function")
            F = N(V, C);
          else if (N === "value") {
            F = -1;
            for (var X = 0; X < V.length; X++)
              if (V[X].value === C.activeLabel) {
                F = X;
                break;
              }
          }
          var Z = _objectSpread(_objectSpread({}, W), {}, {
            x: W.left,
            y: W.top
          }), Q = Math.min(G, Z.x + Z.width), q = Math.min(B, Z.y + Z.height), J = V[F] && V[F].value, ie = getTooltipContent(S.state, S.props.data, F), ne = V[F] ? {
            x: O === "horizontal" ? V[F].coordinate : Q,
            y: O === "horizontal" ? q : V[F].coordinate
          } : originCoordinate;
          S.setState(_objectSpread(_objectSpread({}, C), {}, {
            activeLabel: J,
            activeCoordinate: ne,
            activePayload: ie,
            activeTooltipIndex: F
          }));
        } else
          S.setState(C);
      }), _defineProperty$1(_assertThisInitialized$2(S), "renderCursor", function(C) {
        var D, O = S.state, N = O.isTooltipActive, j = O.activeCoordinate, L = O.activePayload, z = O.offset, G = O.activeTooltipIndex, B = O.tooltipAxisBandSize, F = S.getTooltipEventType(), H = (D = C.props.active) !== null && D !== void 0 ? D : N, W = S.props.layout, V = C.key || "_recharts-cursor";
        return /* @__PURE__ */ React__default.createElement(Cursor, {
          key: V,
          activeCoordinate: j,
          activePayload: L,
          activeTooltipIndex: G,
          chartName: o,
          element: C,
          isActive: H,
          layout: W,
          offset: z,
          tooltipAxisBandSize: B,
          tooltipEventType: F
        });
      }), _defineProperty$1(_assertThisInitialized$2(S), "renderPolarAxis", function(C, D, O) {
        var N = get$2(C, "type.axisType"), j = get$2(S.state, "".concat(N, "Map")), L = j && j[C.props["".concat(N, "Id")]];
        return /* @__PURE__ */ cloneElement(C, _objectSpread(_objectSpread({}, L), {}, {
          className: clsx$1(N, L.className),
          key: C.key || "".concat(D, "-").concat(O),
          ticks: getTicksOfAxis(L, !0)
        }));
      }), _defineProperty$1(_assertThisInitialized$2(S), "renderPolarGrid", function(C) {
        var D = C.props, O = D.radialLines, N = D.polarAngles, j = D.polarRadius, L = S.state, z = L.radiusAxisMap, G = L.angleAxisMap, B = getAnyElementOfObject(z), F = getAnyElementOfObject(G), H = F.cx, W = F.cy, V = F.innerRadius, X = F.outerRadius;
        return /* @__PURE__ */ cloneElement(C, {
          polarAngles: Array.isArray(N) ? N : getTicksOfAxis(F, !0).map(function(Z) {
            return Z.coordinate;
          }),
          polarRadius: Array.isArray(j) ? j : getTicksOfAxis(B, !0).map(function(Z) {
            return Z.coordinate;
          }),
          cx: H,
          cy: W,
          innerRadius: V,
          outerRadius: X,
          key: C.key || "polar-grid",
          radialLines: O
        });
      }), _defineProperty$1(_assertThisInitialized$2(S), "renderLegend", function() {
        var C = S.state.formattedGraphicalItems, D = S.props, O = D.children, N = D.width, j = D.height, L = S.props.margin || {}, z = N - (L.left || 0) - (L.right || 0), G = getLegendProps({
          children: O,
          formattedGraphicalItems: C,
          legendWidth: z,
          legendContent: g
        });
        if (!G)
          return null;
        var B = G.item, F = _objectWithoutProperties(G, _excluded);
        return /* @__PURE__ */ cloneElement(B, _objectSpread(_objectSpread({}, F), {}, {
          chartWidth: N,
          chartHeight: j,
          margin: L,
          onBBoxUpdate: S.handleLegendBBoxUpdate
        }));
      }), _defineProperty$1(_assertThisInitialized$2(S), "renderTooltip", function() {
        var C, D = S.props, O = D.children, N = D.accessibilityLayer, j = findChildByType(O, Tooltip);
        if (!j)
          return null;
        var L = S.state, z = L.isTooltipActive, G = L.activeCoordinate, B = L.activePayload, F = L.activeLabel, H = L.offset, W = (C = j.props.active) !== null && C !== void 0 ? C : z;
        return /* @__PURE__ */ cloneElement(j, {
          viewBox: _objectSpread(_objectSpread({}, H), {}, {
            x: H.left,
            y: H.top
          }),
          active: W,
          label: F,
          payload: W ? B : [],
          coordinate: G,
          accessibilityLayer: N
        });
      }), _defineProperty$1(_assertThisInitialized$2(S), "renderBrush", function(C) {
        var D = S.props, O = D.margin, N = D.data, j = S.state, L = j.offset, z = j.dataStartIndex, G = j.dataEndIndex, B = j.updateId;
        return /* @__PURE__ */ cloneElement(C, {
          key: C.key || "_recharts-brush",
          onChange: combineEventHandlers(S.handleBrushChange, C.props.onChange),
          data: N,
          x: isNumber(C.props.x) ? C.props.x : L.left,
          y: isNumber(C.props.y) ? C.props.y : L.top + L.height + L.brushBottom - (O.bottom || 0),
          width: isNumber(C.props.width) ? C.props.width : L.width,
          startIndex: z,
          endIndex: G,
          updateId: "brush-".concat(B)
        });
      }), _defineProperty$1(_assertThisInitialized$2(S), "renderReferenceElement", function(C, D, O) {
        if (!C)
          return null;
        var N = _assertThisInitialized$2(S), j = N.clipPathId, L = S.state, z = L.xAxisMap, G = L.yAxisMap, B = L.offset, F = C.props, H = F.xAxisId, W = F.yAxisId;
        return /* @__PURE__ */ cloneElement(C, {
          key: C.key || "".concat(D, "-").concat(O),
          xAxis: z[H],
          yAxis: G[W],
          viewBox: {
            x: B.left,
            y: B.top,
            width: B.width,
            height: B.height
          },
          clipPathId: j
        });
      }), _defineProperty$1(_assertThisInitialized$2(S), "renderActivePoints", function(C) {
        var D = C.item, O = C.activePoint, N = C.basePoint, j = C.childIndex, L = C.isRange, z = [], G = D.props.key, B = D.item.props, F = B.activeDot, H = B.dataKey, W = _objectSpread(_objectSpread({
          index: j,
          dataKey: H,
          cx: O.x,
          cy: O.y,
          r: 4,
          fill: getMainColorOfGraphicItem(D.item),
          strokeWidth: 2,
          stroke: "#fff",
          payload: O.payload,
          value: O.value,
          key: "".concat(G, "-activePoint-").concat(j)
        }, filterProps(F, !1)), adaptEventHandlers(F));
        return z.push(b.renderActiveDot(F, W)), N ? z.push(b.renderActiveDot(F, _objectSpread(_objectSpread({}, W), {}, {
          cx: N.x,
          cy: N.y,
          key: "".concat(G, "-basePoint-").concat(j)
        }))) : L && z.push(null), z;
      }), _defineProperty$1(_assertThisInitialized$2(S), "renderGraphicChild", function(C, D, O) {
        var N = S.filterFormatItem(C, D, O);
        if (!N)
          return null;
        var j = S.getTooltipEventType(), L = S.state, z = L.isTooltipActive, G = L.tooltipAxis, B = L.activeTooltipIndex, F = L.activeLabel, H = S.props.children, W = findChildByType(H, Tooltip), V = N.props, X = V.points, Z = V.isRange, Q = V.baseLine, q = N.item.props, J = q.activeDot, ie = q.hide, ne = q.activeBar, ge = q.activeShape, ye = !!(!ie && z && W && (J || ne || ge)), xe = {};
        j !== "axis" && W && W.props.trigger === "click" ? xe = {
          onClick: combineEventHandlers(S.handleItemMouseEnter, C.props.onClick)
        } : j !== "axis" && (xe = {
          onMouseLeave: combineEventHandlers(S.handleItemMouseLeave, C.props.onMouseLeave),
          onMouseEnter: combineEventHandlers(S.handleItemMouseEnter, C.props.onMouseEnter)
        });
        var we = /* @__PURE__ */ cloneElement(C, _objectSpread(_objectSpread({}, N.props), xe));
        function de(ue) {
          return typeof G.dataKey == "function" ? G.dataKey(ue.payload) : null;
        }
        if (ye)
          if (B >= 0) {
            var Te, Ce;
            if (G.dataKey && !G.allowDuplicatedCategory) {
              var ee = typeof G.dataKey == "function" ? de : "payload.".concat(G.dataKey.toString());
              Te = findEntryInArray(X, ee, F), Ce = Z && Q && findEntryInArray(Q, ee, F);
            } else
              Te = X == null ? void 0 : X[B], Ce = Z && Q && Q[B];
            if (ge || ne) {
              var Ae = C.props.activeIndex !== void 0 ? C.props.activeIndex : B;
              return [/* @__PURE__ */ cloneElement(C, _objectSpread(_objectSpread(_objectSpread({}, N.props), xe), {}, {
                activeIndex: Ae
              })), null, null];
            }
            if (!isNil$1(Te))
              return [we].concat(_toConsumableArray$1(S.renderActivePoints({
                item: N,
                activePoint: Te,
                basePoint: Ce,
                childIndex: B,
                isRange: Z
              })));
          } else {
            var be, Fe = (be = S.getItemByXY(S.state.activeCoordinate)) !== null && be !== void 0 ? be : {
              graphicalItem: we
            }, et = Fe.graphicalItem, Ye = et.item, De = Ye === void 0 ? C : Ye, Ue = et.childIndex, Qe = _objectSpread(_objectSpread(_objectSpread({}, N.props), xe), {}, {
              activeIndex: Ue
            });
            return [/* @__PURE__ */ cloneElement(De, Qe), null, null];
          }
        return Z ? [we, null, null] : [we, null];
      }), _defineProperty$1(_assertThisInitialized$2(S), "renderCustomized", function(C, D, O) {
        return /* @__PURE__ */ cloneElement(C, _objectSpread(_objectSpread({
          key: "recharts-customized-".concat(O)
        }, S.props), S.state));
      }), _defineProperty$1(_assertThisInitialized$2(S), "renderMap", {
        CartesianGrid: {
          handler: renderAsIs,
          once: !0
        },
        ReferenceArea: {
          handler: S.renderReferenceElement
        },
        ReferenceLine: {
          handler: renderAsIs
        },
        ReferenceDot: {
          handler: S.renderReferenceElement
        },
        XAxis: {
          handler: renderAsIs
        },
        YAxis: {
          handler: renderAsIs
        },
        Brush: {
          handler: S.renderBrush,
          once: !0
        },
        Bar: {
          handler: S.renderGraphicChild
        },
        Line: {
          handler: S.renderGraphicChild
        },
        Area: {
          handler: S.renderGraphicChild
        },
        Radar: {
          handler: S.renderGraphicChild
        },
        RadialBar: {
          handler: S.renderGraphicChild
        },
        Scatter: {
          handler: S.renderGraphicChild
        },
        Pie: {
          handler: S.renderGraphicChild
        },
        Funnel: {
          handler: S.renderGraphicChild
        },
        Tooltip: {
          handler: S.renderCursor,
          once: !0
        },
        PolarGrid: {
          handler: S.renderPolarGrid,
          once: !0
        },
        PolarAngleAxis: {
          handler: S.renderPolarAxis
        },
        PolarRadiusAxis: {
          handler: S.renderPolarAxis
        },
        Customized: {
          handler: S.renderCustomized
        }
      }), S.clipPathId = "".concat((A = M.id) !== null && A !== void 0 ? A : uniqueId("recharts"), "-clip"), S.throttleTriggeredAfterMouseMove = throttle$1(S.triggeredAfterMouseMove, ($ = M.throttleDelay) !== null && $ !== void 0 ? $ : 1e3 / 60), S.state = {}, S;
    }
    return _createClass$1(b, [{
      key: "componentDidMount",
      value: function() {
        var A, $;
        this.addListener(), this.accessibilityManager.setDetails({
          container: this.container,
          offset: {
            left: (A = this.props.margin.left) !== null && A !== void 0 ? A : 0,
            top: ($ = this.props.margin.top) !== null && $ !== void 0 ? $ : 0
          },
          coordinateList: this.state.tooltipTicks,
          mouseHandlerCallback: this.triggeredAfterMouseMove,
          layout: this.props.layout
        }), this.displayDefaultTooltip();
      }
    }, {
      key: "displayDefaultTooltip",
      value: function() {
        var A = this.props, $ = A.children, S = A.data, C = A.height, D = A.layout, O = findChildByType($, Tooltip);
        if (O) {
          var N = O.props.defaultIndex;
          if (!(typeof N != "number" || N < 0 || N > this.state.tooltipTicks.length)) {
            var j = this.state.tooltipTicks[N] && this.state.tooltipTicks[N].value, L = getTooltipContent(this.state, S, N, j), z = this.state.tooltipTicks[N].coordinate, G = (this.state.offset.top + C) / 2, B = D === "horizontal", F = B ? {
              x: z,
              y: G
            } : {
              y: z,
              x: G
            }, H = this.state.formattedGraphicalItems.find(function(V) {
              var X = V.item;
              return X.type.name === "Scatter";
            });
            H && (F = _objectSpread(_objectSpread({}, F), H.props.points[N].tooltipPosition), L = H.props.points[N].tooltipPayload);
            var W = {
              activeTooltipIndex: N,
              isTooltipActive: !0,
              activeLabel: j,
              activePayload: L,
              activeCoordinate: F
            };
            this.setState(W), this.renderCursor(O), this.accessibilityManager.setIndex(N);
          }
        }
      }
    }, {
      key: "getSnapshotBeforeUpdate",
      value: function(A, $) {
        if (!this.props.accessibilityLayer)
          return null;
        if (this.state.tooltipTicks !== $.tooltipTicks && this.accessibilityManager.setDetails({
          coordinateList: this.state.tooltipTicks
        }), this.props.layout !== A.layout && this.accessibilityManager.setDetails({
          layout: this.props.layout
        }), this.props.margin !== A.margin) {
          var S, C;
          this.accessibilityManager.setDetails({
            offset: {
              left: (S = this.props.margin.left) !== null && S !== void 0 ? S : 0,
              top: (C = this.props.margin.top) !== null && C !== void 0 ? C : 0
            }
          });
        }
        return null;
      }
    }, {
      key: "componentDidUpdate",
      value: function(A) {
        isChildrenEqual([findChildByType(A.children, Tooltip)], [findChildByType(this.props.children, Tooltip)]) || this.displayDefaultTooltip();
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        this.removeListener(), this.throttleTriggeredAfterMouseMove.cancel();
      }
    }, {
      key: "getTooltipEventType",
      value: function() {
        var A = findChildByType(this.props.children, Tooltip);
        if (A && typeof A.props.shared == "boolean") {
          var $ = A.props.shared ? "axis" : "item";
          return p.indexOf($) >= 0 ? $ : f;
        }
        return f;
      }
      /**
       * Get the information of mouse in chart, return null when the mouse is not in the chart
       * @param  {MousePointer} event    The event object
       * @return {Object}          Mouse data
       */
    }, {
      key: "getMouseInfo",
      value: function(A) {
        if (!this.container)
          return null;
        var $ = this.container, S = $.getBoundingClientRect(), C = getOffset(S), D = {
          chartX: Math.round(A.pageX - C.left),
          chartY: Math.round(A.pageY - C.top)
        }, O = S.width / $.offsetWidth || 1, N = this.inRange(D.chartX, D.chartY, O);
        if (!N)
          return null;
        var j = this.state, L = j.xAxisMap, z = j.yAxisMap, G = this.getTooltipEventType();
        if (G !== "axis" && L && z) {
          var B = getAnyElementOfObject(L).scale, F = getAnyElementOfObject(z).scale, H = B && B.invert ? B.invert(D.chartX) : null, W = F && F.invert ? F.invert(D.chartY) : null;
          return _objectSpread(_objectSpread({}, D), {}, {
            xValue: H,
            yValue: W
          });
        }
        var V = getTooltipData(this.state, this.props.data, this.props.layout, N);
        return V ? _objectSpread(_objectSpread({}, D), V) : null;
      }
    }, {
      key: "inRange",
      value: function(A, $) {
        var S = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, C = this.props.layout, D = A / S, O = $ / S;
        if (C === "horizontal" || C === "vertical") {
          var N = this.state.offset, j = D >= N.left && D <= N.left + N.width && O >= N.top && O <= N.top + N.height;
          return j ? {
            x: D,
            y: O
          } : null;
        }
        var L = this.state, z = L.angleAxisMap, G = L.radiusAxisMap;
        if (z && G) {
          var B = getAnyElementOfObject(z);
          return inRangeOfSector({
            x: D,
            y: O
          }, B);
        }
        return null;
      }
    }, {
      key: "parseEventsOfWrapper",
      value: function() {
        var A = this.props.children, $ = this.getTooltipEventType(), S = findChildByType(A, Tooltip), C = {};
        S && $ === "axis" && (S.props.trigger === "click" ? C = {
          onClick: this.handleClick
        } : C = {
          onMouseEnter: this.handleMouseEnter,
          onMouseMove: this.handleMouseMove,
          onMouseLeave: this.handleMouseLeave,
          onTouchMove: this.handleTouchMove,
          onTouchStart: this.handleTouchStart,
          onTouchEnd: this.handleTouchEnd
        });
        var D = adaptEventHandlers(this.props, this.handleOuterEvent);
        return _objectSpread(_objectSpread({}, D), C);
      }
    }, {
      key: "addListener",
      value: function() {
        eventCenter.on(SYNC_EVENT, this.handleReceiveSyncEvent);
      }
    }, {
      key: "removeListener",
      value: function() {
        eventCenter.removeListener(SYNC_EVENT, this.handleReceiveSyncEvent);
      }
    }, {
      key: "filterFormatItem",
      value: function(A, $, S) {
        for (var C = this.state.formattedGraphicalItems, D = 0, O = C.length; D < O; D++) {
          var N = C[D];
          if (N.item === A || N.props.key === A.key || $ === getDisplayName(N.item.type) && S === N.childIndex)
            return N;
        }
        return null;
      }
    }, {
      key: "renderClipPath",
      value: function() {
        var A = this.clipPathId, $ = this.state.offset, S = $.left, C = $.top, D = $.height, O = $.width;
        return /* @__PURE__ */ React__default.createElement("defs", null, /* @__PURE__ */ React__default.createElement("clipPath", {
          id: A
        }, /* @__PURE__ */ React__default.createElement("rect", {
          x: S,
          y: C,
          height: D,
          width: O
        })));
      }
    }, {
      key: "getXScales",
      value: function() {
        var A = this.state.xAxisMap;
        return A ? Object.entries(A).reduce(function($, S) {
          var C = _slicedToArray(S, 2), D = C[0], O = C[1];
          return _objectSpread(_objectSpread({}, $), {}, _defineProperty$1({}, D, O.scale));
        }, {}) : null;
      }
    }, {
      key: "getYScales",
      value: function() {
        var A = this.state.yAxisMap;
        return A ? Object.entries(A).reduce(function($, S) {
          var C = _slicedToArray(S, 2), D = C[0], O = C[1];
          return _objectSpread(_objectSpread({}, $), {}, _defineProperty$1({}, D, O.scale));
        }, {}) : null;
      }
    }, {
      key: "getXScaleByAxisId",
      value: function(A) {
        var $;
        return ($ = this.state.xAxisMap) === null || $ === void 0 || ($ = $[A]) === null || $ === void 0 ? void 0 : $.scale;
      }
    }, {
      key: "getYScaleByAxisId",
      value: function(A) {
        var $;
        return ($ = this.state.yAxisMap) === null || $ === void 0 || ($ = $[A]) === null || $ === void 0 ? void 0 : $.scale;
      }
    }, {
      key: "getItemByXY",
      value: function(A) {
        var $ = this.state, S = $.formattedGraphicalItems, C = $.activeItem;
        if (S && S.length)
          for (var D = 0, O = S.length; D < O; D++) {
            var N = S[D], j = N.props, L = N.item, z = getDisplayName(L.type);
            if (z === "Bar") {
              var G = (j.data || []).find(function(W) {
                return isInRectangle(A, W);
              });
              if (G)
                return {
                  graphicalItem: N,
                  payload: G
                };
            } else if (z === "RadialBar") {
              var B = (j.data || []).find(function(W) {
                return inRangeOfSector(A, W);
              });
              if (B)
                return {
                  graphicalItem: N,
                  payload: B
                };
            } else if (isFunnel(N, C) || isPie(N, C) || isScatter(N, C)) {
              var F = getActiveShapeIndexForTooltip({
                graphicalItem: N,
                activeTooltipItem: C,
                itemData: L.props.data
              }), H = L.props.activeIndex === void 0 ? F : L.props.activeIndex;
              return {
                graphicalItem: _objectSpread(_objectSpread({}, N), {}, {
                  childIndex: H
                }),
                payload: isScatter(N, C) ? L.props.data[F] : N.props.data[F]
              };
            }
          }
        return null;
      }
    }, {
      key: "render",
      value: function() {
        var A = this;
        if (!validateWidthHeight(this))
          return null;
        var $ = this.props, S = $.children, C = $.className, D = $.width, O = $.height, N = $.style, j = $.compact, L = $.title, z = $.desc, G = _objectWithoutProperties($, _excluded2), B = filterProps(G, !1);
        if (j)
          return /* @__PURE__ */ React__default.createElement(ChartLayoutContextProvider, {
            state: this.state,
            width: this.props.width,
            height: this.props.height,
            clipPathId: this.clipPathId
          }, /* @__PURE__ */ React__default.createElement(Surface, _extends$2({}, B, {
            width: D,
            height: O,
            title: L,
            desc: z
          }), this.renderClipPath(), renderByOrder(S, this.renderMap)));
        if (this.props.accessibilityLayer) {
          var F, H;
          B.tabIndex = (F = this.props.tabIndex) !== null && F !== void 0 ? F : 0, B.role = (H = this.props.role) !== null && H !== void 0 ? H : "application", B.onKeyDown = function(V) {
            A.accessibilityManager.keyboardEvent(V);
          }, B.onFocus = function() {
            A.accessibilityManager.focus();
          };
        }
        var W = this.parseEventsOfWrapper();
        return /* @__PURE__ */ React__default.createElement(ChartLayoutContextProvider, {
          state: this.state,
          width: this.props.width,
          height: this.props.height,
          clipPathId: this.clipPathId
        }, /* @__PURE__ */ React__default.createElement("div", _extends$2({
          className: clsx$1("recharts-wrapper", C),
          style: _objectSpread({
            position: "relative",
            cursor: "default",
            width: D,
            height: O
          }, N)
        }, W, {
          ref: function(X) {
            A.container = X;
          }
        }), /* @__PURE__ */ React__default.createElement(Surface, _extends$2({}, B, {
          width: D,
          height: O,
          title: L,
          desc: z,
          style: FULL_WIDTH_AND_HEIGHT
        }), this.renderClipPath(), renderByOrder(S, this.renderMap)), this.renderLegend(), this.renderTooltip()));
      }
    }]), b;
  }(Component$1), _defineProperty$1(n, "displayName", o), _defineProperty$1(n, "defaultProps", _objectSpread({
    layout: "horizontal",
    stackOffset: "none",
    barCategoryGap: "10%",
    barGap: 4,
    margin: {
      top: 5,
      right: 5,
      bottom: 5,
      left: 5
    },
    reverseStackOrder: !1,
    syncMethod: "index"
  }, E)), _defineProperty$1(n, "getDerivedStateFromProps", function(_, b) {
    var M = _.dataKey, A = _.data, $ = _.children, S = _.width, C = _.height, D = _.layout, O = _.stackOffset, N = _.margin, j = b.dataStartIndex, L = b.dataEndIndex;
    if (b.updateId === void 0) {
      var z = createDefaultState(_);
      return _objectSpread(_objectSpread(_objectSpread({}, z), {}, {
        updateId: 0
      }, R(_objectSpread(_objectSpread({
        props: _
      }, z), {}, {
        updateId: 0
      }), b)), {}, {
        prevDataKey: M,
        prevData: A,
        prevWidth: S,
        prevHeight: C,
        prevLayout: D,
        prevStackOffset: O,
        prevMargin: N,
        prevChildren: $
      });
    }
    if (M !== b.prevDataKey || A !== b.prevData || S !== b.prevWidth || C !== b.prevHeight || D !== b.prevLayout || O !== b.prevStackOffset || !shallowEqual(N, b.prevMargin)) {
      var G = createDefaultState(_), B = {
        // (chartX, chartY) are (0,0) in default state, but we want to keep the last mouse position to avoid
        // any flickering
        chartX: b.chartX,
        chartY: b.chartY,
        // The tooltip should stay active when it was active in the previous render. If this is not
        // the case, the tooltip disappears and immediately re-appears, causing a flickering effect
        isTooltipActive: b.isTooltipActive
      }, F = _objectSpread(_objectSpread({}, getTooltipData(b, A, D)), {}, {
        updateId: b.updateId + 1
      }), H = _objectSpread(_objectSpread(_objectSpread({}, G), B), F);
      return _objectSpread(_objectSpread(_objectSpread({}, H), R(_objectSpread({
        props: _
      }, H), b)), {}, {
        prevDataKey: M,
        prevData: A,
        prevWidth: S,
        prevHeight: C,
        prevLayout: D,
        prevStackOffset: O,
        prevMargin: N,
        prevChildren: $
      });
    }
    if (!isChildrenEqual($, b.prevChildren)) {
      var W, V, X, Z, Q = findChildByType($, Brush), q = Q && (W = (V = Q.props) === null || V === void 0 ? void 0 : V.startIndex) !== null && W !== void 0 ? W : j, J = Q && (X = (Z = Q.props) === null || Z === void 0 ? void 0 : Z.endIndex) !== null && X !== void 0 ? X : L, ie = q !== j || J !== L, ne = !isNil$1(A), ge = ne && !ie ? b.updateId : b.updateId + 1;
      return _objectSpread(_objectSpread({
        updateId: ge
      }, R(_objectSpread(_objectSpread({
        props: _
      }, b), {}, {
        updateId: ge,
        dataStartIndex: q,
        dataEndIndex: J
      }), b)), {}, {
        prevChildren: $,
        dataStartIndex: q,
        dataEndIndex: J
      });
    }
    return null;
  }), _defineProperty$1(n, "renderActiveDot", function(_, b) {
    var M;
    return /* @__PURE__ */ isValidElement(_) ? M = /* @__PURE__ */ cloneElement(_, b) : isFunction$3(_) ? M = _(b) : M = /* @__PURE__ */ React__default.createElement(Dot, b), /* @__PURE__ */ React__default.createElement(Layer, {
      className: "recharts-active-dot",
      key: b.key
    }, M);
  }), n;
}, BarChart = generateCategoricalChart({
  chartName: "BarChart",
  GraphicalChild: Bar,
  defaultTooltipEventType: "axis",
  validateTooltipEventTypes: ["axis", "item"],
  axisComponents: [{
    axisType: "xAxis",
    AxisComp: XAxis
  }, {
    axisType: "yAxis",
    AxisComp: YAxis
  }],
  formatAxisMap
}), PieChart = generateCategoricalChart({
  chartName: "PieChart",
  GraphicalChild: Pie,
  validateTooltipEventTypes: ["item"],
  defaultTooltipEventType: "item",
  legendContent: "children",
  axisComponents: [{
    axisType: "angleAxis",
    AxisComp: PolarAngleAxis
  }, {
    axisType: "radiusAxis",
    AxisComp: PolarRadiusAxis
  }],
  formatAxisMap: formatAxisMap$1,
  defaultProps: {
    layout: "centric",
    startAngle: 0,
    endAngle: 360,
    cx: "50%",
    cy: "50%",
    innerRadius: 0,
    outerRadius: "80%"
  }
});
function _inheritsLoose(t, e) {
  t.prototype = Object.create(e.prototype), t.prototype.constructor = t, _setPrototypeOf$1(t, e);
}
function _setPrototypeOf$1(t, e) {
  return _setPrototypeOf$1 = Object.setPrototypeOf || function(o, l) {
    return o.__proto__ = l, o;
  }, _setPrototypeOf$1(t, e);
}
function _objectWithoutPropertiesLoose(t, e) {
  if (t == null) return {};
  var n = {}, o = Object.keys(t), l, u;
  for (u = 0; u < o.length; u++)
    l = o[u], !(e.indexOf(l) >= 0) && (n[l] = t[l]);
  return n;
}
function _assertThisInitialized$1(t) {
  if (t === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t;
}
function isNodeFound(t, e, n) {
  return t === e ? !0 : t.correspondingElement ? t.correspondingElement.classList.contains(n) : t.classList.contains(n);
}
function findHighest(t, e, n) {
  if (t === e)
    return !0;
  for (; t.parentNode || t.host; ) {
    if (t.parentNode && isNodeFound(t, e, n))
      return !0;
    t = t.parentNode || t.host;
  }
  return t;
}
function clickedScrollbar(t) {
  return document.documentElement.clientWidth <= t.clientX || document.documentElement.clientHeight <= t.clientY;
}
var testPassiveEventSupport = function t() {
  if (!(typeof window > "u" || typeof window.addEventListener != "function")) {
    var e = !1, n = Object.defineProperty({}, "passive", {
      get: function() {
        e = !0;
      }
    }), o = function() {
    };
    return window.addEventListener("testPassiveEventSupport", o, n), window.removeEventListener("testPassiveEventSupport", o, n), e;
  }
};
function autoInc(t) {
  return t === void 0 && (t = 0), function() {
    return ++t;
  };
}
var uid = autoInc(), passiveEventSupport, handlersMap = {}, enabledInstances = {}, touchEvents = ["touchstart", "touchmove"], IGNORE_CLASS_NAME = "ignore-react-onclickoutside";
function getEventHandlerOptions(t, e) {
  var n = {}, o = touchEvents.indexOf(e) !== -1;
  return o && passiveEventSupport && (n.passive = !t.props.preventDefault), n;
}
function onClickOutsideHOC(t, e) {
  var n, o, l = t.displayName || t.name || "Component";
  return o = n = /* @__PURE__ */ function(u) {
    _inheritsLoose(f, u);
    function f(p) {
      var v;
      return v = u.call(this, p) || this, v.__outsideClickHandler = function(g) {
        if (typeof v.__clickOutsideHandlerProp == "function") {
          v.__clickOutsideHandlerProp(g);
          return;
        }
        var w = v.getInstance();
        if (typeof w.props.handleClickOutside == "function") {
          w.props.handleClickOutside(g);
          return;
        }
        if (typeof w.handleClickOutside == "function") {
          w.handleClickOutside(g);
          return;
        }
        throw new Error("WrappedComponent: " + l + " lacks a handleClickOutside(event) function for processing outside click events.");
      }, v.__getComponentNode = function() {
        var g = v.getInstance();
        return typeof g.setClickOutsideRef == "function" ? g.setClickOutsideRef() : findDOMNode(g);
      }, v.enableOnClickOutside = function() {
        if (!(typeof document > "u" || enabledInstances[v._uid])) {
          typeof passiveEventSupport > "u" && (passiveEventSupport = testPassiveEventSupport()), enabledInstances[v._uid] = !0;
          var g = v.props.eventTypes;
          g.forEach || (g = [g]), handlersMap[v._uid] = function(w) {
            if (v.componentNode !== null && !(v.initTimeStamp > w.timeStamp) && (v.props.preventDefault && w.preventDefault(), v.props.stopPropagation && w.stopPropagation(), !(v.props.excludeScrollbar && clickedScrollbar(w)))) {
              var E = w.composed && w.composedPath && w.composedPath().shift() || w.target;
              findHighest(E, v.componentNode, v.props.outsideClickIgnoreClass) === document && v.__outsideClickHandler(w);
            }
          }, g.forEach(function(w) {
            document.addEventListener(w, handlersMap[v._uid], getEventHandlerOptions(_assertThisInitialized$1(v), w));
          });
        }
      }, v.disableOnClickOutside = function() {
        delete enabledInstances[v._uid];
        var g = handlersMap[v._uid];
        if (g && typeof document < "u") {
          var w = v.props.eventTypes;
          w.forEach || (w = [w]), w.forEach(function(E) {
            return document.removeEventListener(E, g, getEventHandlerOptions(_assertThisInitialized$1(v), E));
          }), delete handlersMap[v._uid];
        }
      }, v.getRef = function(g) {
        return v.instanceRef = g;
      }, v._uid = uid(), v.initTimeStamp = performance.now(), v;
    }
    var h = f.prototype;
    return h.getInstance = function() {
      if (t.prototype && !t.prototype.isReactComponent)
        return this;
      var v = this.instanceRef;
      return v.getInstance ? v.getInstance() : v;
    }, h.componentDidMount = function() {
      typeof document > "u" || !document.createElement || (this.getInstance(), this.componentNode = this.__getComponentNode(), !this.props.disableOnClickOutside && this.enableOnClickOutside());
    }, h.componentDidUpdate = function() {
      this.componentNode = this.__getComponentNode();
    }, h.componentWillUnmount = function() {
      this.disableOnClickOutside();
    }, h.render = function() {
      var v = this.props;
      v.excludeScrollbar;
      var g = _objectWithoutPropertiesLoose(v, ["excludeScrollbar"]);
      return t.prototype && t.prototype.isReactComponent ? g.ref = this.getRef : g.wrappedRef = this.getRef, g.disableOnClickOutside = this.disableOnClickOutside, g.enableOnClickOutside = this.enableOnClickOutside, createElement(t, g);
    }, f;
  }(Component$1), n.displayName = "OnClickOutside(" + l + ")", n.defaultProps = {
    eventTypes: ["mousedown", "touchstart"],
    excludeScrollbar: !1,
    outsideClickIgnoreClass: IGNORE_CLASS_NAME,
    preventDefault: !1,
    stopPropagation: !1
  }, n.getClass = function() {
    return t.getClass ? t.getClass() : t;
  }, o;
}
function getNodeName(t) {
  return isNode(t) ? (t.nodeName || "").toLowerCase() : "#document";
}
function getWindow(t) {
  var e;
  return (t == null || (e = t.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
function getDocumentElement(t) {
  var e;
  return (e = (isNode(t) ? t.ownerDocument : t.document) || window.document) == null ? void 0 : e.documentElement;
}
function isNode(t) {
  return t instanceof Node || t instanceof getWindow(t).Node;
}
function isElement(t) {
  return t instanceof Element || t instanceof getWindow(t).Element;
}
function isHTMLElement(t) {
  return t instanceof HTMLElement || t instanceof getWindow(t).HTMLElement;
}
function isShadowRoot(t) {
  return typeof ShadowRoot > "u" ? !1 : t instanceof ShadowRoot || t instanceof getWindow(t).ShadowRoot;
}
function isOverflowElement(t) {
  const {
    overflow: e,
    overflowX: n,
    overflowY: o,
    display: l
  } = getComputedStyle(t);
  return /auto|scroll|overlay|hidden|clip/.test(e + o + n) && !["inline", "contents"].includes(l);
}
function isTableElement(t) {
  return ["table", "td", "th"].includes(getNodeName(t));
}
function isTopLayer(t) {
  return [":popover-open", ":modal"].some((e) => {
    try {
      return t.matches(e);
    } catch {
      return !1;
    }
  });
}
function isContainingBlock(t) {
  const e = isWebKit(), n = isElement(t) ? getComputedStyle(t) : t;
  return n.transform !== "none" || n.perspective !== "none" || (n.containerType ? n.containerType !== "normal" : !1) || !e && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !e && (n.filter ? n.filter !== "none" : !1) || ["transform", "perspective", "filter"].some((o) => (n.willChange || "").includes(o)) || ["paint", "layout", "strict", "content"].some((o) => (n.contain || "").includes(o));
}
function getContainingBlock(t) {
  let e = getParentNode(t);
  for (; isHTMLElement(e) && !isLastTraversableNode(e); ) {
    if (isContainingBlock(e))
      return e;
    if (isTopLayer(e))
      return null;
    e = getParentNode(e);
  }
  return null;
}
function isWebKit() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(t) {
  return ["html", "body", "#document"].includes(getNodeName(t));
}
function getComputedStyle(t) {
  return getWindow(t).getComputedStyle(t);
}
function getNodeScroll(t) {
  return isElement(t) ? {
    scrollLeft: t.scrollLeft,
    scrollTop: t.scrollTop
  } : {
    scrollLeft: t.scrollX,
    scrollTop: t.scrollY
  };
}
function getParentNode(t) {
  if (getNodeName(t) === "html")
    return t;
  const e = (
    // Step into the shadow DOM of the parent of a slotted node.
    t.assignedSlot || // DOM Element detected.
    t.parentNode || // ShadowRoot detected.
    isShadowRoot(t) && t.host || // Fallback.
    getDocumentElement(t)
  );
  return isShadowRoot(e) ? e.host : e;
}
function getNearestOverflowAncestor(t) {
  const e = getParentNode(t);
  return isLastTraversableNode(e) ? t.ownerDocument ? t.ownerDocument.body : t.body : isHTMLElement(e) && isOverflowElement(e) ? e : getNearestOverflowAncestor(e);
}
function getOverflowAncestors(t, e, n) {
  var o;
  e === void 0 && (e = []), n === void 0 && (n = !0);
  const l = getNearestOverflowAncestor(t), u = l === ((o = t.ownerDocument) == null ? void 0 : o.body), f = getWindow(l);
  if (u) {
    const h = getFrameElement(f);
    return e.concat(f, f.visualViewport || [], isOverflowElement(l) ? l : [], h && n ? getOverflowAncestors(h) : []);
  }
  return e.concat(l, getOverflowAncestors(l, [], n));
}
function getFrameElement(t) {
  return t.parent && Object.getPrototypeOf(t.parent) ? t.frameElement : null;
}
const min = Math.min, max = Math.max, round = Math.round, floor = Math.floor, createCoords = (t) => ({
  x: t,
  y: t
}), oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(t, e, n) {
  return max(t, min(e, n));
}
function evaluate(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function getSide(t) {
  return t.split("-")[0];
}
function getAlignment(t) {
  return t.split("-")[1];
}
function getOppositeAxis(t) {
  return t === "x" ? "y" : "x";
}
function getAxisLength(t) {
  return t === "y" ? "height" : "width";
}
function getSideAxis(t) {
  return ["top", "bottom"].includes(getSide(t)) ? "y" : "x";
}
function getAlignmentAxis(t) {
  return getOppositeAxis(getSideAxis(t));
}
function getAlignmentSides(t, e, n) {
  n === void 0 && (n = !1);
  const o = getAlignment(t), l = getAlignmentAxis(t), u = getAxisLength(l);
  let f = l === "x" ? o === (n ? "end" : "start") ? "right" : "left" : o === "start" ? "bottom" : "top";
  return e.reference[u] > e.floating[u] && (f = getOppositePlacement(f)), [f, getOppositePlacement(f)];
}
function getExpandedPlacements(t) {
  const e = getOppositePlacement(t);
  return [getOppositeAlignmentPlacement(t), e, getOppositeAlignmentPlacement(e)];
}
function getOppositeAlignmentPlacement(t) {
  return t.replace(/start|end/g, (e) => oppositeAlignmentMap[e]);
}
function getSideList(t, e, n) {
  const o = ["left", "right"], l = ["right", "left"], u = ["top", "bottom"], f = ["bottom", "top"];
  switch (t) {
    case "top":
    case "bottom":
      return n ? e ? l : o : e ? o : l;
    case "left":
    case "right":
      return e ? u : f;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(t, e, n, o) {
  const l = getAlignment(t);
  let u = getSideList(getSide(t), n === "start", o);
  return l && (u = u.map((f) => f + "-" + l), e && (u = u.concat(u.map(getOppositeAlignmentPlacement)))), u;
}
function getOppositePlacement(t) {
  return t.replace(/left|right|bottom|top/g, (e) => oppositeSideMap[e]);
}
function expandPaddingObject(t) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...t
  };
}
function getPaddingObject(t) {
  return typeof t != "number" ? expandPaddingObject(t) : {
    top: t,
    right: t,
    bottom: t,
    left: t
  };
}
function rectToClientRect(t) {
  const {
    x: e,
    y: n,
    width: o,
    height: l
  } = t;
  return {
    width: o,
    height: l,
    top: n,
    left: e,
    right: e + o,
    bottom: n + l,
    x: e,
    y: n
  };
}
function computeCoordsFromPlacement(t, e, n) {
  let {
    reference: o,
    floating: l
  } = t;
  const u = getSideAxis(e), f = getAlignmentAxis(e), h = getAxisLength(f), p = getSide(e), v = u === "y", g = o.x + o.width / 2 - l.width / 2, w = o.y + o.height / 2 - l.height / 2, E = o[h] / 2 - l[h] / 2;
  let T;
  switch (p) {
    case "top":
      T = {
        x: g,
        y: o.y - l.height
      };
      break;
    case "bottom":
      T = {
        x: g,
        y: o.y + o.height
      };
      break;
    case "right":
      T = {
        x: o.x + o.width,
        y: w
      };
      break;
    case "left":
      T = {
        x: o.x - l.width,
        y: w
      };
      break;
    default:
      T = {
        x: o.x,
        y: o.y
      };
  }
  switch (getAlignment(e)) {
    case "start":
      T[f] -= E * (n && v ? -1 : 1);
      break;
    case "end":
      T[f] += E * (n && v ? -1 : 1);
      break;
  }
  return T;
}
const computePosition$1 = async (t, e, n) => {
  const {
    placement: o = "bottom",
    strategy: l = "absolute",
    middleware: u = [],
    platform: f
  } = n, h = u.filter(Boolean), p = await (f.isRTL == null ? void 0 : f.isRTL(e));
  let v = await f.getElementRects({
    reference: t,
    floating: e,
    strategy: l
  }), {
    x: g,
    y: w
  } = computeCoordsFromPlacement(v, o, p), E = o, T = {}, R = 0;
  for (let _ = 0; _ < h.length; _++) {
    const {
      name: b,
      fn: M
    } = h[_], {
      x: A,
      y: $,
      data: S,
      reset: C
    } = await M({
      x: g,
      y: w,
      initialPlacement: o,
      placement: E,
      strategy: l,
      middlewareData: T,
      rects: v,
      platform: f,
      elements: {
        reference: t,
        floating: e
      }
    });
    g = A ?? g, w = $ ?? w, T = {
      ...T,
      [b]: {
        ...T[b],
        ...S
      }
    }, C && R <= 50 && (R++, typeof C == "object" && (C.placement && (E = C.placement), C.rects && (v = C.rects === !0 ? await f.getElementRects({
      reference: t,
      floating: e,
      strategy: l
    }) : C.rects), {
      x: g,
      y: w
    } = computeCoordsFromPlacement(v, E, p)), _ = -1);
  }
  return {
    x: g,
    y: w,
    placement: E,
    strategy: l,
    middlewareData: T
  };
};
async function detectOverflow(t, e) {
  var n;
  e === void 0 && (e = {});
  const {
    x: o,
    y: l,
    platform: u,
    rects: f,
    elements: h,
    strategy: p
  } = t, {
    boundary: v = "clippingAncestors",
    rootBoundary: g = "viewport",
    elementContext: w = "floating",
    altBoundary: E = !1,
    padding: T = 0
  } = evaluate(e, t), R = getPaddingObject(T), b = h[E ? w === "floating" ? "reference" : "floating" : w], M = rectToClientRect(await u.getClippingRect({
    element: (n = await (u.isElement == null ? void 0 : u.isElement(b))) == null || n ? b : b.contextElement || await (u.getDocumentElement == null ? void 0 : u.getDocumentElement(h.floating)),
    boundary: v,
    rootBoundary: g,
    strategy: p
  })), A = w === "floating" ? {
    x: o,
    y: l,
    width: f.floating.width,
    height: f.floating.height
  } : f.reference, $ = await (u.getOffsetParent == null ? void 0 : u.getOffsetParent(h.floating)), S = await (u.isElement == null ? void 0 : u.isElement($)) ? await (u.getScale == null ? void 0 : u.getScale($)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, C = rectToClientRect(u.convertOffsetParentRelativeRectToViewportRelativeRect ? await u.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: h,
    rect: A,
    offsetParent: $,
    strategy: p
  }) : A);
  return {
    top: (M.top - C.top + R.top) / S.y,
    bottom: (C.bottom - M.bottom + R.bottom) / S.y,
    left: (M.left - C.left + R.left) / S.x,
    right: (C.right - M.right + R.right) / S.x
  };
}
const arrow$3 = (t) => ({
  name: "arrow",
  options: t,
  async fn(e) {
    const {
      x: n,
      y: o,
      placement: l,
      rects: u,
      platform: f,
      elements: h,
      middlewareData: p
    } = e, {
      element: v,
      padding: g = 0
    } = evaluate(t, e) || {};
    if (v == null)
      return {};
    const w = getPaddingObject(g), E = {
      x: n,
      y: o
    }, T = getAlignmentAxis(l), R = getAxisLength(T), _ = await f.getDimensions(v), b = T === "y", M = b ? "top" : "left", A = b ? "bottom" : "right", $ = b ? "clientHeight" : "clientWidth", S = u.reference[R] + u.reference[T] - E[T] - u.floating[R], C = E[T] - u.reference[T], D = await (f.getOffsetParent == null ? void 0 : f.getOffsetParent(v));
    let O = D ? D[$] : 0;
    (!O || !await (f.isElement == null ? void 0 : f.isElement(D))) && (O = h.floating[$] || u.floating[R]);
    const N = S / 2 - C / 2, j = O / 2 - _[R] / 2 - 1, L = min(w[M], j), z = min(w[A], j), G = L, B = O - _[R] - z, F = O / 2 - _[R] / 2 + N, H = clamp(G, F, B), W = !p.arrow && getAlignment(l) != null && F !== H && u.reference[R] / 2 - (F < G ? L : z) - _[R] / 2 < 0, V = W ? F < G ? F - G : F - B : 0;
    return {
      [T]: E[T] + V,
      data: {
        [T]: H,
        centerOffset: F - H - V,
        ...W && {
          alignmentOffset: V
        }
      },
      reset: W
    };
  }
}), flip$2 = function(t) {
  return t === void 0 && (t = {}), {
    name: "flip",
    options: t,
    async fn(e) {
      var n, o;
      const {
        placement: l,
        middlewareData: u,
        rects: f,
        initialPlacement: h,
        platform: p,
        elements: v
      } = e, {
        mainAxis: g = !0,
        crossAxis: w = !0,
        fallbackPlacements: E,
        fallbackStrategy: T = "bestFit",
        fallbackAxisSideDirection: R = "none",
        flipAlignment: _ = !0,
        ...b
      } = evaluate(t, e);
      if ((n = u.arrow) != null && n.alignmentOffset)
        return {};
      const M = getSide(l), A = getSideAxis(h), $ = getSide(h) === h, S = await (p.isRTL == null ? void 0 : p.isRTL(v.floating)), C = E || ($ || !_ ? [getOppositePlacement(h)] : getExpandedPlacements(h)), D = R !== "none";
      !E && D && C.push(...getOppositeAxisPlacements(h, _, R, S));
      const O = [h, ...C], N = await detectOverflow(e, b), j = [];
      let L = ((o = u.flip) == null ? void 0 : o.overflows) || [];
      if (g && j.push(N[M]), w) {
        const F = getAlignmentSides(l, f, S);
        j.push(N[F[0]], N[F[1]]);
      }
      if (L = [...L, {
        placement: l,
        overflows: j
      }], !j.every((F) => F <= 0)) {
        var z, G;
        const F = (((z = u.flip) == null ? void 0 : z.index) || 0) + 1, H = O[F];
        if (H)
          return {
            data: {
              index: F,
              overflows: L
            },
            reset: {
              placement: H
            }
          };
        let W = (G = L.filter((V) => V.overflows[0] <= 0).sort((V, X) => V.overflows[1] - X.overflows[1])[0]) == null ? void 0 : G.placement;
        if (!W)
          switch (T) {
            case "bestFit": {
              var B;
              const V = (B = L.filter((X) => {
                if (D) {
                  const Z = getSideAxis(X.placement);
                  return Z === A || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  Z === "y";
                }
                return !0;
              }).map((X) => [X.placement, X.overflows.filter((Z) => Z > 0).reduce((Z, Q) => Z + Q, 0)]).sort((X, Z) => X[1] - Z[1])[0]) == null ? void 0 : B[0];
              V && (W = V);
              break;
            }
            case "initialPlacement":
              W = h;
              break;
          }
        if (l !== W)
          return {
            reset: {
              placement: W
            }
          };
      }
      return {};
    }
  };
};
async function convertValueToCoords(t, e) {
  const {
    placement: n,
    platform: o,
    elements: l
  } = t, u = await (o.isRTL == null ? void 0 : o.isRTL(l.floating)), f = getSide(n), h = getAlignment(n), p = getSideAxis(n) === "y", v = ["left", "top"].includes(f) ? -1 : 1, g = u && p ? -1 : 1, w = evaluate(e, t);
  let {
    mainAxis: E,
    crossAxis: T,
    alignmentAxis: R
  } = typeof w == "number" ? {
    mainAxis: w,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...w
  };
  return h && typeof R == "number" && (T = h === "end" ? R * -1 : R), p ? {
    x: T * g,
    y: E * v
  } : {
    x: E * v,
    y: T * g
  };
}
const offset$2 = function(t) {
  return t === void 0 && (t = 0), {
    name: "offset",
    options: t,
    async fn(e) {
      var n, o;
      const {
        x: l,
        y: u,
        placement: f,
        middlewareData: h
      } = e, p = await convertValueToCoords(e, t);
      return f === ((n = h.offset) == null ? void 0 : n.placement) && (o = h.arrow) != null && o.alignmentOffset ? {} : {
        x: l + p.x,
        y: u + p.y,
        data: {
          ...p,
          placement: f
        }
      };
    }
  };
};
function getCssDimensions(t) {
  const e = getComputedStyle(t);
  let n = parseFloat(e.width) || 0, o = parseFloat(e.height) || 0;
  const l = isHTMLElement(t), u = l ? t.offsetWidth : n, f = l ? t.offsetHeight : o, h = round(n) !== u || round(o) !== f;
  return h && (n = u, o = f), {
    width: n,
    height: o,
    $: h
  };
}
function unwrapElement(t) {
  return isElement(t) ? t : t.contextElement;
}
function getScale(t) {
  const e = unwrapElement(t);
  if (!isHTMLElement(e))
    return createCoords(1);
  const n = e.getBoundingClientRect(), {
    width: o,
    height: l,
    $: u
  } = getCssDimensions(e);
  let f = (u ? round(n.width) : n.width) / o, h = (u ? round(n.height) : n.height) / l;
  return (!f || !Number.isFinite(f)) && (f = 1), (!h || !Number.isFinite(h)) && (h = 1), {
    x: f,
    y: h
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(t) {
  const e = getWindow(t);
  return !isWebKit() || !e.visualViewport ? noOffsets : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(t, e, n) {
  return e === void 0 && (e = !1), !n || e && n !== getWindow(t) ? !1 : e;
}
function getBoundingClientRect(t, e, n, o) {
  e === void 0 && (e = !1), n === void 0 && (n = !1);
  const l = t.getBoundingClientRect(), u = unwrapElement(t);
  let f = createCoords(1);
  e && (o ? isElement(o) && (f = getScale(o)) : f = getScale(t));
  const h = shouldAddVisualOffsets(u, n, o) ? getVisualOffsets(u) : createCoords(0);
  let p = (l.left + h.x) / f.x, v = (l.top + h.y) / f.y, g = l.width / f.x, w = l.height / f.y;
  if (u) {
    const E = getWindow(u), T = o && isElement(o) ? getWindow(o) : o;
    let R = E, _ = getFrameElement(R);
    for (; _ && o && T !== R; ) {
      const b = getScale(_), M = _.getBoundingClientRect(), A = getComputedStyle(_), $ = M.left + (_.clientLeft + parseFloat(A.paddingLeft)) * b.x, S = M.top + (_.clientTop + parseFloat(A.paddingTop)) * b.y;
      p *= b.x, v *= b.y, g *= b.x, w *= b.y, p += $, v += S, R = getWindow(_), _ = getFrameElement(R);
    }
  }
  return rectToClientRect({
    width: g,
    height: w,
    x: p,
    y: v
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(t) {
  let {
    elements: e,
    rect: n,
    offsetParent: o,
    strategy: l
  } = t;
  const u = l === "fixed", f = getDocumentElement(o), h = e ? isTopLayer(e.floating) : !1;
  if (o === f || h && u)
    return n;
  let p = {
    scrollLeft: 0,
    scrollTop: 0
  }, v = createCoords(1);
  const g = createCoords(0), w = isHTMLElement(o);
  if ((w || !w && !u) && ((getNodeName(o) !== "body" || isOverflowElement(f)) && (p = getNodeScroll(o)), isHTMLElement(o))) {
    const E = getBoundingClientRect(o);
    v = getScale(o), g.x = E.x + o.clientLeft, g.y = E.y + o.clientTop;
  }
  return {
    width: n.width * v.x,
    height: n.height * v.y,
    x: n.x * v.x - p.scrollLeft * v.x + g.x,
    y: n.y * v.y - p.scrollTop * v.y + g.y
  };
}
function getClientRects(t) {
  return Array.from(t.getClientRects());
}
function getWindowScrollBarX(t) {
  return getBoundingClientRect(getDocumentElement(t)).left + getNodeScroll(t).scrollLeft;
}
function getDocumentRect(t) {
  const e = getDocumentElement(t), n = getNodeScroll(t), o = t.ownerDocument.body, l = max(e.scrollWidth, e.clientWidth, o.scrollWidth, o.clientWidth), u = max(e.scrollHeight, e.clientHeight, o.scrollHeight, o.clientHeight);
  let f = -n.scrollLeft + getWindowScrollBarX(t);
  const h = -n.scrollTop;
  return getComputedStyle(o).direction === "rtl" && (f += max(e.clientWidth, o.clientWidth) - l), {
    width: l,
    height: u,
    x: f,
    y: h
  };
}
function getViewportRect(t, e) {
  const n = getWindow(t), o = getDocumentElement(t), l = n.visualViewport;
  let u = o.clientWidth, f = o.clientHeight, h = 0, p = 0;
  if (l) {
    u = l.width, f = l.height;
    const v = isWebKit();
    (!v || v && e === "fixed") && (h = l.offsetLeft, p = l.offsetTop);
  }
  return {
    width: u,
    height: f,
    x: h,
    y: p
  };
}
function getInnerBoundingClientRect(t, e) {
  const n = getBoundingClientRect(t, !0, e === "fixed"), o = n.top + t.clientTop, l = n.left + t.clientLeft, u = isHTMLElement(t) ? getScale(t) : createCoords(1), f = t.clientWidth * u.x, h = t.clientHeight * u.y, p = l * u.x, v = o * u.y;
  return {
    width: f,
    height: h,
    x: p,
    y: v
  };
}
function getClientRectFromClippingAncestor(t, e, n) {
  let o;
  if (e === "viewport")
    o = getViewportRect(t, n);
  else if (e === "document")
    o = getDocumentRect(getDocumentElement(t));
  else if (isElement(e))
    o = getInnerBoundingClientRect(e, n);
  else {
    const l = getVisualOffsets(t);
    o = {
      ...e,
      x: e.x - l.x,
      y: e.y - l.y
    };
  }
  return rectToClientRect(o);
}
function hasFixedPositionAncestor(t, e) {
  const n = getParentNode(t);
  return n === e || !isElement(n) || isLastTraversableNode(n) ? !1 : getComputedStyle(n).position === "fixed" || hasFixedPositionAncestor(n, e);
}
function getClippingElementAncestors(t, e) {
  const n = e.get(t);
  if (n)
    return n;
  let o = getOverflowAncestors(t, [], !1).filter((h) => isElement(h) && getNodeName(h) !== "body"), l = null;
  const u = getComputedStyle(t).position === "fixed";
  let f = u ? getParentNode(t) : t;
  for (; isElement(f) && !isLastTraversableNode(f); ) {
    const h = getComputedStyle(f), p = isContainingBlock(f);
    !p && h.position === "fixed" && (l = null), (u ? !p && !l : !p && h.position === "static" && !!l && ["absolute", "fixed"].includes(l.position) || isOverflowElement(f) && !p && hasFixedPositionAncestor(t, f)) ? o = o.filter((g) => g !== f) : l = h, f = getParentNode(f);
  }
  return e.set(t, o), o;
}
function getClippingRect(t) {
  let {
    element: e,
    boundary: n,
    rootBoundary: o,
    strategy: l
  } = t;
  const f = [...n === "clippingAncestors" ? isTopLayer(e) ? [] : getClippingElementAncestors(e, this._c) : [].concat(n), o], h = f[0], p = f.reduce((v, g) => {
    const w = getClientRectFromClippingAncestor(e, g, l);
    return v.top = max(w.top, v.top), v.right = min(w.right, v.right), v.bottom = min(w.bottom, v.bottom), v.left = max(w.left, v.left), v;
  }, getClientRectFromClippingAncestor(e, h, l));
  return {
    width: p.right - p.left,
    height: p.bottom - p.top,
    x: p.left,
    y: p.top
  };
}
function getDimensions(t) {
  const {
    width: e,
    height: n
  } = getCssDimensions(t);
  return {
    width: e,
    height: n
  };
}
function getRectRelativeToOffsetParent(t, e, n) {
  const o = isHTMLElement(e), l = getDocumentElement(e), u = n === "fixed", f = getBoundingClientRect(t, !0, u, e);
  let h = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const p = createCoords(0);
  if (o || !o && !u)
    if ((getNodeName(e) !== "body" || isOverflowElement(l)) && (h = getNodeScroll(e)), o) {
      const w = getBoundingClientRect(e, !0, u, e);
      p.x = w.x + e.clientLeft, p.y = w.y + e.clientTop;
    } else l && (p.x = getWindowScrollBarX(l));
  const v = f.left + h.scrollLeft - p.x, g = f.top + h.scrollTop - p.y;
  return {
    x: v,
    y: g,
    width: f.width,
    height: f.height
  };
}
function isStaticPositioned(t) {
  return getComputedStyle(t).position === "static";
}
function getTrueOffsetParent(t, e) {
  return !isHTMLElement(t) || getComputedStyle(t).position === "fixed" ? null : e ? e(t) : t.offsetParent;
}
function getOffsetParent(t, e) {
  const n = getWindow(t);
  if (isTopLayer(t))
    return n;
  if (!isHTMLElement(t)) {
    let l = getParentNode(t);
    for (; l && !isLastTraversableNode(l); ) {
      if (isElement(l) && !isStaticPositioned(l))
        return l;
      l = getParentNode(l);
    }
    return n;
  }
  let o = getTrueOffsetParent(t, e);
  for (; o && isTableElement(o) && isStaticPositioned(o); )
    o = getTrueOffsetParent(o, e);
  return o && isLastTraversableNode(o) && isStaticPositioned(o) && !isContainingBlock(o) ? n : o || getContainingBlock(t) || n;
}
const getElementRects = async function(t) {
  const e = this.getOffsetParent || getOffsetParent, n = this.getDimensions, o = await n(t.floating);
  return {
    reference: getRectRelativeToOffsetParent(t.reference, await e(t.floating), t.strategy),
    floating: {
      x: 0,
      y: 0,
      width: o.width,
      height: o.height
    }
  };
};
function isRTL(t) {
  return getComputedStyle(t).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function observeMove(t, e) {
  let n = null, o;
  const l = getDocumentElement(t);
  function u() {
    var h;
    clearTimeout(o), (h = n) == null || h.disconnect(), n = null;
  }
  function f(h, p) {
    h === void 0 && (h = !1), p === void 0 && (p = 1), u();
    const {
      left: v,
      top: g,
      width: w,
      height: E
    } = t.getBoundingClientRect();
    if (h || e(), !w || !E)
      return;
    const T = floor(g), R = floor(l.clientWidth - (v + w)), _ = floor(l.clientHeight - (g + E)), b = floor(v), A = {
      rootMargin: -T + "px " + -R + "px " + -_ + "px " + -b + "px",
      threshold: max(0, min(1, p)) || 1
    };
    let $ = !0;
    function S(C) {
      const D = C[0].intersectionRatio;
      if (D !== p) {
        if (!$)
          return f();
        D ? f(!1, D) : o = setTimeout(() => {
          f(!1, 1e-7);
        }, 1e3);
      }
      $ = !1;
    }
    try {
      n = new IntersectionObserver(S, {
        ...A,
        // Handle <iframe>s
        root: l.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(S, A);
    }
    n.observe(t);
  }
  return f(!0), u;
}
function autoUpdate(t, e, n, o) {
  o === void 0 && (o = {});
  const {
    ancestorScroll: l = !0,
    ancestorResize: u = !0,
    elementResize: f = typeof ResizeObserver == "function",
    layoutShift: h = typeof IntersectionObserver == "function",
    animationFrame: p = !1
  } = o, v = unwrapElement(t), g = l || u ? [...v ? getOverflowAncestors(v) : [], ...getOverflowAncestors(e)] : [];
  g.forEach((M) => {
    l && M.addEventListener("scroll", n, {
      passive: !0
    }), u && M.addEventListener("resize", n);
  });
  const w = v && h ? observeMove(v, n) : null;
  let E = -1, T = null;
  f && (T = new ResizeObserver((M) => {
    let [A] = M;
    A && A.target === v && T && (T.unobserve(e), cancelAnimationFrame(E), E = requestAnimationFrame(() => {
      var $;
      ($ = T) == null || $.observe(e);
    })), n();
  }), v && !p && T.observe(v), T.observe(e));
  let R, _ = p ? getBoundingClientRect(t) : null;
  p && b();
  function b() {
    const M = getBoundingClientRect(t);
    _ && (M.x !== _.x || M.y !== _.y || M.width !== _.width || M.height !== _.height) && n(), _ = M, R = requestAnimationFrame(b);
  }
  return n(), () => {
    var M;
    g.forEach((A) => {
      l && A.removeEventListener("scroll", n), u && A.removeEventListener("resize", n);
    }), w == null || w(), (M = T) == null || M.disconnect(), T = null, p && cancelAnimationFrame(R);
  };
}
const offset$1 = offset$2, flip$1 = flip$2, arrow$2 = arrow$3, computePosition = (t, e, n) => {
  const o = /* @__PURE__ */ new Map(), l = {
    platform,
    ...n
  }, u = {
    ...l.platform,
    _c: o
  };
  return computePosition$1(t, e, {
    ...l,
    platform: u
  });
};
var index$1 = typeof document < "u" ? useLayoutEffect : useEffect;
function deepEqual(t, e) {
  if (t === e)
    return !0;
  if (typeof t != typeof e)
    return !1;
  if (typeof t == "function" && t.toString() === e.toString())
    return !0;
  let n, o, l;
  if (t && e && typeof t == "object") {
    if (Array.isArray(t)) {
      if (n = t.length, n !== e.length) return !1;
      for (o = n; o-- !== 0; )
        if (!deepEqual(t[o], e[o]))
          return !1;
      return !0;
    }
    if (l = Object.keys(t), n = l.length, n !== Object.keys(e).length)
      return !1;
    for (o = n; o-- !== 0; )
      if (!{}.hasOwnProperty.call(e, l[o]))
        return !1;
    for (o = n; o-- !== 0; ) {
      const u = l[o];
      if (!(u === "_owner" && t.$$typeof) && !deepEqual(t[u], e[u]))
        return !1;
    }
    return !0;
  }
  return t !== t && e !== e;
}
function getDPR(t) {
  return typeof window > "u" ? 1 : (t.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function roundByDPR(t, e) {
  const n = getDPR(t);
  return Math.round(e * n) / n;
}
function useLatestRef(t) {
  const e = React.useRef(t);
  return index$1(() => {
    e.current = t;
  }), e;
}
function useFloating$1(t) {
  t === void 0 && (t = {});
  const {
    placement: e = "bottom",
    strategy: n = "absolute",
    middleware: o = [],
    platform: l,
    elements: {
      reference: u,
      floating: f
    } = {},
    transform: h = !0,
    whileElementsMounted: p,
    open: v
  } = t, [g, w] = React.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: e,
    middlewareData: {},
    isPositioned: !1
  }), [E, T] = React.useState(o);
  deepEqual(E, o) || T(o);
  const [R, _] = React.useState(null), [b, M] = React.useState(null), A = React.useCallback((V) => {
    V !== D.current && (D.current = V, _(V));
  }, []), $ = React.useCallback((V) => {
    V !== O.current && (O.current = V, M(V));
  }, []), S = u || R, C = f || b, D = React.useRef(null), O = React.useRef(null), N = React.useRef(g), j = p != null, L = useLatestRef(p), z = useLatestRef(l), G = React.useCallback(() => {
    if (!D.current || !O.current)
      return;
    const V = {
      placement: e,
      strategy: n,
      middleware: E
    };
    z.current && (V.platform = z.current), computePosition(D.current, O.current, V).then((X) => {
      const Z = {
        ...X,
        isPositioned: !0
      };
      B.current && !deepEqual(N.current, Z) && (N.current = Z, ReactDOM.flushSync(() => {
        w(Z);
      }));
    });
  }, [E, e, n, z]);
  index$1(() => {
    v === !1 && N.current.isPositioned && (N.current.isPositioned = !1, w((V) => ({
      ...V,
      isPositioned: !1
    })));
  }, [v]);
  const B = React.useRef(!1);
  index$1(() => (B.current = !0, () => {
    B.current = !1;
  }), []), index$1(() => {
    if (S && (D.current = S), C && (O.current = C), S && C) {
      if (L.current)
        return L.current(S, C, G);
      G();
    }
  }, [S, C, G, L, j]);
  const F = React.useMemo(() => ({
    reference: D,
    floating: O,
    setReference: A,
    setFloating: $
  }), [A, $]), H = React.useMemo(() => ({
    reference: S,
    floating: C
  }), [S, C]), W = React.useMemo(() => {
    const V = {
      position: n,
      left: 0,
      top: 0
    };
    if (!H.floating)
      return V;
    const X = roundByDPR(H.floating, g.x), Z = roundByDPR(H.floating, g.y);
    return h ? {
      ...V,
      transform: "translate(" + X + "px, " + Z + "px)",
      ...getDPR(H.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: X,
      top: Z
    };
  }, [n, h, H.floating, g.x, g.y]);
  return React.useMemo(() => ({
    ...g,
    update: G,
    refs: F,
    elements: H,
    floatingStyles: W
  }), [g, G, F, H, W]);
}
const arrow$1 = (t) => {
  function e(n) {
    return {}.hasOwnProperty.call(n, "current");
  }
  return {
    name: "arrow",
    options: t,
    fn(n) {
      const {
        element: o,
        padding: l
      } = typeof t == "function" ? t(n) : t;
      return o && e(o) ? o.current != null ? arrow$2({
        element: o.current,
        padding: l
      }).fn(n) : {} : o ? arrow$2({
        element: o,
        padding: l
      }).fn(n) : {};
    }
  };
}, offset = (t, e) => ({
  ...offset$1(t),
  options: [t, e]
}), flip = (t, e) => ({
  ...flip$1(t),
  options: [t, e]
}), arrow = (t, e) => ({
  ...arrow$1(t),
  options: [t, e]
}), SafeReact = {
  ...React
}, useInsertionEffect = SafeReact.useInsertionEffect, useSafeInsertionEffect = useInsertionEffect || ((t) => t());
function useEffectEvent(t) {
  const e = React.useRef(() => {
    if (process.env.NODE_ENV !== "production")
      throw new Error("Cannot call an event handler while rendering.");
  });
  return useSafeInsertionEffect(() => {
    e.current = t;
  }), React.useCallback(function() {
    for (var n = arguments.length, o = new Array(n), l = 0; l < n; l++)
      o[l] = arguments[l];
    return e.current == null ? void 0 : e.current(...o);
  }, []);
}
var index = typeof document < "u" ? useLayoutEffect : useEffect;
function _extends$1() {
  return _extends$1 = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }
    return t;
  }, _extends$1.apply(this, arguments);
}
let serverHandoffComplete = !1, count = 0;
const genId = () => (
  // Ensure the id is unique with multiple independent versions of Floating UI
  // on <React 18
  "floating-ui-" + Math.random().toString(36).slice(2, 6) + count++
);
function useFloatingId() {
  const [t, e] = React.useState(() => serverHandoffComplete ? genId() : void 0);
  return index(() => {
    t == null && e(genId());
  }, []), React.useEffect(() => {
    serverHandoffComplete = !0;
  }, []), t;
}
const useReactId = SafeReact.useId, useId = useReactId || useFloatingId;
let devMessageSet;
process.env.NODE_ENV !== "production" && (devMessageSet = /* @__PURE__ */ new Set());
function warn() {
  for (var t, e = arguments.length, n = new Array(e), o = 0; o < e; o++)
    n[o] = arguments[o];
  const l = "Floating UI: " + n.join(" ");
  if (!((t = devMessageSet) != null && t.has(l))) {
    var u;
    (u = devMessageSet) == null || u.add(l), console.warn(l);
  }
}
function error() {
  for (var t, e = arguments.length, n = new Array(e), o = 0; o < e; o++)
    n[o] = arguments[o];
  const l = "Floating UI: " + n.join(" ");
  if (!((t = devMessageSet) != null && t.has(l))) {
    var u;
    (u = devMessageSet) == null || u.add(l), console.error(l);
  }
}
const FloatingArrow = /* @__PURE__ */ React.forwardRef(function t(e, n) {
  const {
    context: {
      placement: o,
      elements: {
        floating: l
      },
      middlewareData: {
        arrow: u
      }
    },
    width: f = 14,
    height: h = 7,
    tipRadius: p = 0,
    strokeWidth: v = 0,
    staticOffset: g,
    stroke: w,
    d: E,
    style: {
      transform: T,
      ...R
    } = {},
    ..._
  } = e;
  process.env.NODE_ENV !== "production" && (n || warn("The `ref` prop is required for `FloatingArrow`."));
  const b = useId(), [M, A] = React.useState(!1);
  if (index(() => {
    if (!l) return;
    getComputedStyle(l).direction === "rtl" && A(!0);
  }, [l]), !l)
    return null;
  const $ = v * 2, S = $ / 2, C = f / 2 * (p / -8 + 1), D = h / 2 * p / 4, [O, N] = o.split("-"), j = !!E, L = O === "top" || O === "bottom", z = g && N === "end" ? "bottom" : "top";
  let G = g && N === "end" ? "right" : "left";
  g && M && (G = N === "end" ? "left" : "right");
  const B = (u == null ? void 0 : u.x) != null ? g || u.x : "", F = (u == null ? void 0 : u.y) != null ? g || u.y : "", H = E || "M0,0" + (" H" + f) + (" L" + (f - C) + "," + (h - D)) + (" Q" + f / 2 + "," + h + " " + C + "," + (h - D)) + " Z", W = {
    top: j ? "rotate(180deg)" : "",
    left: j ? "rotate(90deg)" : "rotate(-90deg)",
    bottom: j ? "" : "rotate(180deg)",
    right: j ? "rotate(-90deg)" : "rotate(90deg)"
  }[O];
  return /* @__PURE__ */ React.createElement("svg", _extends$1({}, _, {
    "aria-hidden": !0,
    ref: n,
    width: j ? f : f + $,
    height: f,
    viewBox: "0 0 " + f + " " + (h > f ? h : f),
    style: {
      position: "absolute",
      pointerEvents: "none",
      [G]: B,
      [z]: F,
      [O]: L || j ? "100%" : "calc(100% - " + $ / 2 + "px)",
      transform: "" + W + (T ?? ""),
      ...R
    }
  }), $ > 0 && /* @__PURE__ */ React.createElement("path", {
    clipPath: "url(#" + b + ")",
    fill: "none",
    stroke: w,
    strokeWidth: $ + (E ? 0 : 1),
    d: H
  }), /* @__PURE__ */ React.createElement("path", {
    stroke: $ && !E ? _.fill : "none",
    d: H
  }), /* @__PURE__ */ React.createElement("clipPath", {
    id: b
  }, /* @__PURE__ */ React.createElement("rect", {
    x: -S,
    y: S * (j ? -1 : 1),
    width: f + $,
    height: f
  })));
});
function createPubSub() {
  const t = /* @__PURE__ */ new Map();
  return {
    emit(e, n) {
      var o;
      (o = t.get(e)) == null || o.forEach((l) => l(n));
    },
    on(e, n) {
      t.set(e, [...t.get(e) || [], n]);
    },
    off(e, n) {
      var o;
      t.set(e, ((o = t.get(e)) == null ? void 0 : o.filter((l) => l !== n)) || []);
    }
  };
}
const FloatingNodeContext = /* @__PURE__ */ React.createContext(null), FloatingTreeContext = /* @__PURE__ */ React.createContext(null), useFloatingParentNodeId = () => {
  var t;
  return ((t = React.useContext(FloatingNodeContext)) == null ? void 0 : t.id) || null;
}, useFloatingTree = () => React.useContext(FloatingTreeContext);
function useFloatingRootContext(t) {
  const {
    open: e = !1,
    onOpenChange: n,
    elements: o
  } = t, l = useId(), u = React.useRef({}), [f] = React.useState(() => createPubSub()), h = useFloatingParentNodeId() != null;
  if (process.env.NODE_ENV !== "production") {
    const T = o.reference;
    T && !isElement(T) && error("Cannot pass a virtual element to the `elements.reference` option,", "as it must be a real DOM element. Use `refs.setPositionReference()`", "instead.");
  }
  const [p, v] = React.useState(o.reference), g = useEffectEvent((T, R, _) => {
    u.current.openEvent = T ? R : void 0, f.emit("openchange", {
      open: T,
      event: R,
      reason: _,
      nested: h
    }), n == null || n(T, R, _);
  }), w = React.useMemo(() => ({
    setPositionReference: v
  }), []), E = React.useMemo(() => ({
    reference: p || o.reference || null,
    floating: o.floating || null,
    domReference: o.reference
  }), [p, o.reference, o.floating]);
  return React.useMemo(() => ({
    dataRef: u,
    open: e,
    onOpenChange: g,
    elements: E,
    events: f,
    floatingId: l,
    refs: w
  }), [e, g, E, f, l, w]);
}
function useFloating(t) {
  t === void 0 && (t = {});
  const {
    nodeId: e
  } = t, n = useFloatingRootContext({
    ...t,
    elements: {
      reference: null,
      floating: null,
      ...t.elements
    }
  }), o = t.rootContext || n, l = o.elements, [u, f] = React.useState(null), [h, p] = React.useState(null), g = (l == null ? void 0 : l.reference) || u, w = React.useRef(null), E = useFloatingTree();
  index(() => {
    g && (w.current = g);
  }, [g]);
  const T = useFloating$1({
    ...t,
    elements: {
      ...l,
      ...h && {
        reference: h
      }
    }
  }), R = React.useCallback(($) => {
    const S = isElement($) ? {
      getBoundingClientRect: () => $.getBoundingClientRect(),
      contextElement: $
    } : $;
    p(S), T.refs.setReference(S);
  }, [T.refs]), _ = React.useCallback(($) => {
    (isElement($) || $ === null) && (w.current = $, f($)), (isElement(T.refs.reference.current) || T.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    $ !== null && !isElement($)) && T.refs.setReference($);
  }, [T.refs]), b = React.useMemo(() => ({
    ...T.refs,
    setReference: _,
    setPositionReference: R,
    domReference: w
  }), [T.refs, _, R]), M = React.useMemo(() => ({
    ...T.elements,
    domReference: g
  }), [T.elements, g]), A = React.useMemo(() => ({
    ...T,
    ...o,
    refs: b,
    elements: M,
    nodeId: e
  }), [T, b, M, e, o]);
  return index(() => {
    o.dataRef.current.floatingContext = A;
    const $ = E == null ? void 0 : E.nodesRef.current.find((S) => S.id === e);
    $ && ($.context = A);
  }), React.useMemo(() => ({
    ...T,
    context: A,
    refs: b,
    elements: M
  }), [T, b, M, A]);
}
/*!
  react-datepicker v6.9.0
  https://github.com/Hacker0x01/react-datepicker
  Released under the MIT License.
*/
function _callSuper(t, e, n) {
  return e = _getPrototypeOf(e), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(e, n || [], _getPrototypeOf(t).constructor) : e.apply(t, n));
}
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (_isNativeReflectConstruct = function() {
    return !!t;
  })();
}
function ownKeys(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t);
    e && (o = o.filter(function(l) {
      return Object.getOwnPropertyDescriptor(t, l).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function _objectSpread2(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ownKeys(Object(n), !0).forEach(function(o) {
      _defineProperty(t, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : ownKeys(Object(n)).forEach(function(o) {
      Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return t;
}
function _toPrimitive(t, e) {
  if (typeof t != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(t, e || "default");
    if (typeof o != "object") return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function _toPropertyKey(t) {
  var e = _toPrimitive(t, "string");
  return typeof e == "symbol" ? e : e + "";
}
function _typeof(t) {
  "@babel/helpers - typeof";
  return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof(t);
}
function _classCallCheck(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(t, e) {
  for (var n = 0; n < e.length; n++) {
    var o = e[n];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, _toPropertyKey(o.key), o);
  }
}
function _createClass(t, e, n) {
  return e && _defineProperties(t.prototype, e), n && _defineProperties(t, n), Object.defineProperty(t, "prototype", {
    writable: !1
  }), t;
}
function _defineProperty(t, e, n) {
  return e = _toPropertyKey(e), e in t ? Object.defineProperty(t, e, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = n, t;
}
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
    }
    return t;
  }, _extends.apply(this, arguments);
}
function _inherits(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(t, "prototype", {
    writable: !1
  }), e && _setPrototypeOf(t, e);
}
function _getPrototypeOf(t) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
    return n.__proto__ || Object.getPrototypeOf(n);
  }, _getPrototypeOf(t);
}
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(o, l) {
    return o.__proto__ = l, o;
  }, _setPrototypeOf(t, e);
}
function _assertThisInitialized(t) {
  if (t === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t;
}
function _possibleConstructorReturn(t, e) {
  if (e && (typeof e == "object" || typeof e == "function"))
    return e;
  if (e !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t);
}
function _toConsumableArray(t) {
  return _arrayWithoutHoles(t) || _iterableToArray(t) || _unsupportedIterableToArray(t) || _nonIterableSpread();
}
function _arrayWithoutHoles(t) {
  if (Array.isArray(t)) return _arrayLikeToArray(t);
}
function _iterableToArray(t) {
  if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
}
function _unsupportedIterableToArray(t, e) {
  if (t) {
    if (typeof t == "string") return _arrayLikeToArray(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(t, e);
  }
}
function _arrayLikeToArray(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, o = new Array(e); n < e; n++) o[n] = t[n];
  return o;
}
function _nonIterableSpread() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
var DEFAULT_YEAR_ITEM_NUMBER = 12, longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
function newDate(t) {
  var e = t ? typeof t == "string" || t instanceof String ? parseISO(t) : toDate(t) : /* @__PURE__ */ new Date();
  return isValid(e) ? e : null;
}
function parseDate(t, e, n, o, l) {
  var u = null, f = getLocaleObject(n) || getLocaleObject(getDefaultLocale()), h = !0;
  return Array.isArray(e) ? (e.forEach(function(p) {
    var v = parse(t, p, /* @__PURE__ */ new Date(), {
      locale: f,
      useAdditionalWeekYearTokens: !0,
      useAdditionalDayOfYearTokens: !0
    });
    o && (h = isValid(v, l) && t === formatDate(v, p, n)), isValid(v, l) && h && (u = v);
  }), u) : (u = parse(t, e, /* @__PURE__ */ new Date(), {
    locale: f,
    useAdditionalWeekYearTokens: !0,
    useAdditionalDayOfYearTokens: !0
  }), o ? h = isValid(u) && t === formatDate(u, e, n) : isValid(u) || (e = e.match(longFormattingTokensRegExp).map(function(p) {
    var v = p[0];
    if (v === "p" || v === "P") {
      var g = longFormatters[v];
      return f ? g(p, f.formatLong) : v;
    }
    return p;
  }).join(""), t.length > 0 && (u = parse(t, e.slice(0, t.length), /* @__PURE__ */ new Date(), {
    useAdditionalWeekYearTokens: !0,
    useAdditionalDayOfYearTokens: !0
  })), isValid(u) || (u = new Date(t))), isValid(u) && h ? u : null);
}
function isValid(t, e) {
  return e = e || /* @__PURE__ */ new Date("1/1/1000"), isValid$1(t) && !isBefore(t, e);
}
function formatDate(t, e, n) {
  if (n === "en")
    return format$1(t, e, {
      useAdditionalWeekYearTokens: !0,
      useAdditionalDayOfYearTokens: !0
    });
  var o = getLocaleObject(n);
  return n && !o && console.warn('A locale object was not found for the provided string ["'.concat(n, '"].')), !o && getDefaultLocale() && getLocaleObject(getDefaultLocale()) && (o = getLocaleObject(getDefaultLocale())), format$1(t, e, {
    locale: o || null,
    useAdditionalWeekYearTokens: !0,
    useAdditionalDayOfYearTokens: !0
  });
}
function safeDateFormat(t, e) {
  var n = e.dateFormat, o = e.locale;
  return t && formatDate(t, Array.isArray(n) ? n[0] : n, o) || "";
}
function safeDateRangeFormat(t, e, n) {
  if (!t)
    return "";
  var o = safeDateFormat(t, n), l = e ? safeDateFormat(e, n) : "";
  return "".concat(o, " - ").concat(l);
}
function safeMultipleDatesFormat(t, e) {
  if (!(t != null && t.length))
    return "";
  var n = safeDateFormat(t[0], e);
  if (t.length === 1)
    return n;
  if (t.length === 2) {
    var o = safeDateFormat(t[1], e);
    return "".concat(n, ", ").concat(o);
  }
  var l = t.length - 1;
  return "".concat(n, " (+").concat(l, ")");
}
function setTime(t, e) {
  var n = e.hour, o = n === void 0 ? 0 : n, l = e.minute, u = l === void 0 ? 0 : l, f = e.second, h = f === void 0 ? 0 : f;
  return setHours(setMinutes(setSeconds(t, h), u), o);
}
function getWeek(t, e) {
  return getDefaultLocale() && getLocaleObject(getDefaultLocale()), getISOWeek(t);
}
function getDayOfWeekCode(t, e) {
  return formatDate(t, "ddd", e);
}
function getStartOfDay(t) {
  return startOfDay(t);
}
function getStartOfWeek(t, e, n) {
  var o = getLocaleObject(e || getDefaultLocale());
  return startOfWeek(t, {
    locale: o,
    weekStartsOn: n
  });
}
function getStartOfMonth(t) {
  return startOfMonth(t);
}
function getStartOfYear(t) {
  return startOfYear(t);
}
function getStartOfQuarter(t) {
  return startOfQuarter(t);
}
function getStartOfToday() {
  return startOfDay(newDate());
}
function getEndOfWeek(t) {
  return endOfWeek(t);
}
function isSameYear(t, e) {
  return t && e ? isSameYear$1(t, e) : !t && !e;
}
function isSameMonth(t, e) {
  return t && e ? isSameMonth$1(t, e) : !t && !e;
}
function isSameQuarter(t, e) {
  return t && e ? isSameQuarter$1(t, e) : !t && !e;
}
function isSameDay(t, e) {
  return t && e ? isSameDay$1(t, e) : !t && !e;
}
function isEqual(t, e) {
  return t && e ? isEqual$3(t, e) : !t && !e;
}
function isDayInRange(t, e, n) {
  var o, l = startOfDay(e), u = endOfDay(n);
  try {
    o = isWithinInterval(t, {
      start: l,
      end: u
    });
  } catch {
    o = !1;
  }
  return o;
}
function getDefaultLocale() {
  var t = typeof window < "u" ? window : globalThis;
  return t.__localeId__;
}
function getLocaleObject(t) {
  if (typeof t == "string") {
    var e = typeof window < "u" ? window : globalThis;
    return e.__localeData__ ? e.__localeData__[t] : null;
  } else
    return t;
}
function getFormattedWeekdayInLocale(t, e, n) {
  return e(formatDate(t, "EEEE", n));
}
function getWeekdayMinInLocale(t, e) {
  return formatDate(t, "EEEEEE", e);
}
function getWeekdayShortInLocale(t, e) {
  return formatDate(t, "EEE", e);
}
function getMonthInLocale(t, e) {
  return formatDate(setMonth(newDate(), t), "LLLL", e);
}
function getMonthShortInLocale(t, e) {
  return formatDate(setMonth(newDate(), t), "LLL", e);
}
function getQuarterShortInLocale(t, e) {
  return formatDate(setQuarter(newDate(), t), "QQQ", e);
}
function isDayDisabled(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = e.minDate, o = e.maxDate, l = e.excludeDates, u = e.excludeDateIntervals, f = e.includeDates, h = e.includeDateIntervals, p = e.filterDate;
  return isOutOfBounds(t, {
    minDate: n,
    maxDate: o
  }) || l && l.some(function(v) {
    return isSameDay(t, v.date ? v.date : v);
  }) || u && u.some(function(v) {
    var g = v.start, w = v.end;
    return isWithinInterval(t, {
      start: g,
      end: w
    });
  }) || f && !f.some(function(v) {
    return isSameDay(t, v);
  }) || h && !h.some(function(v) {
    var g = v.start, w = v.end;
    return isWithinInterval(t, {
      start: g,
      end: w
    });
  }) || p && !p(newDate(t)) || !1;
}
function isDayExcluded(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = e.excludeDates, o = e.excludeDateIntervals;
  return o && o.length > 0 ? o.some(function(l) {
    var u = l.start, f = l.end;
    return isWithinInterval(t, {
      start: u,
      end: f
    });
  }) : n && n.some(function(l) {
    return isSameDay(t, l.date ? l.date : l);
  }) || !1;
}
function isMonthDisabled(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = e.minDate, o = e.maxDate, l = e.excludeDates, u = e.includeDates, f = e.filterDate;
  return isOutOfBounds(t, {
    minDate: startOfMonth(n),
    maxDate: endOfMonth(o)
  }) || l && l.some(function(h) {
    return isSameMonth(t, h);
  }) || u && !u.some(function(h) {
    return isSameMonth(t, h);
  }) || f && !f(newDate(t)) || !1;
}
function isMonthInRange(t, e, n, o) {
  var l = getYear(t), u = getMonth(t), f = getYear(e), h = getMonth(e), p = getYear(o);
  if (l === f && l === p)
    return u <= n && n <= h;
  if (l < f)
    return p === l && u <= n || p === f && h >= n || p < f && p > l;
}
function isQuarterDisabled(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = e.minDate, o = e.maxDate, l = e.excludeDates, u = e.includeDates, f = e.filterDate;
  return isOutOfBounds(t, {
    minDate: n,
    maxDate: o
  }) || l && l.some(function(h) {
    return isSameQuarter(t, h);
  }) || u && !u.some(function(h) {
    return isSameQuarter(t, h);
  }) || f && !f(newDate(t)) || !1;
}
function isYearInRange(t, e, n) {
  if (!isValid$1(e) || !isValid$1(n)) return !1;
  var o = getYear(e), l = getYear(n);
  return o <= t && l >= t;
}
function isYearDisabled(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = e.minDate, o = e.maxDate, l = e.excludeDates, u = e.includeDates, f = e.filterDate, h = new Date(t, 0, 1);
  return isOutOfBounds(h, {
    minDate: startOfYear(n),
    maxDate: endOfYear(o)
  }) || l && l.some(function(p) {
    return isSameYear(h, p);
  }) || u && !u.some(function(p) {
    return isSameYear(h, p);
  }) || f && !f(newDate(h)) || !1;
}
function isQuarterInRange(t, e, n, o) {
  var l = getYear(t), u = getQuarter(t), f = getYear(e), h = getQuarter(e), p = getYear(o);
  if (l === f && l === p)
    return u <= n && n <= h;
  if (l < f)
    return p === l && u <= n || p === f && h >= n || p < f && p > l;
}
function isOutOfBounds(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = e.minDate, o = e.maxDate;
  return n && differenceInCalendarDays(t, n) < 0 || o && differenceInCalendarDays(t, o) > 0;
}
function isTimeInList(t, e) {
  return e.some(function(n) {
    return getHours(n) === getHours(t) && getMinutes(n) === getMinutes(t) && getSeconds(n) === getSeconds(t);
  });
}
function isTimeDisabled(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = e.excludeTimes, o = e.includeTimes, l = e.filterTime;
  return n && isTimeInList(t, n) || o && !isTimeInList(t, o) || l && !l(t) || !1;
}
function isTimeInDisabledRange(t, e) {
  var n = e.minTime, o = e.maxTime;
  if (!n || !o)
    throw new Error("Both minTime and maxTime props required");
  var l = newDate();
  l = setHours(l, getHours(t)), l = setMinutes(l, getMinutes(t)), l = setSeconds(l, getSeconds(t));
  var u = newDate();
  u = setHours(u, getHours(n)), u = setMinutes(u, getMinutes(n)), u = setSeconds(u, getSeconds(n));
  var f = newDate();
  f = setHours(f, getHours(o)), f = setMinutes(f, getMinutes(o)), f = setSeconds(f, getSeconds(o));
  var h;
  try {
    h = !isWithinInterval(l, {
      start: u,
      end: f
    });
  } catch {
    h = !1;
  }
  return h;
}
function monthDisabledBefore(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = e.minDate, o = e.includeDates, l = subMonths(t, 1);
  return n && differenceInCalendarMonths(n, l) > 0 || o && o.every(function(u) {
    return differenceInCalendarMonths(u, l) > 0;
  }) || !1;
}
function monthDisabledAfter(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = e.maxDate, o = e.includeDates, l = addMonths(t, 1);
  return n && differenceInCalendarMonths(l, n) > 0 || o && o.every(function(u) {
    return differenceInCalendarMonths(l, u) > 0;
  }) || !1;
}
function quarterDisabledBefore(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = e.minDate, o = e.includeDates, l = startOfYear(t), u = subQuarters(l, 1);
  return n && differenceInCalendarQuarters(n, u) > 0 || o && o.every(function(f) {
    return differenceInCalendarQuarters(f, u) > 0;
  }) || !1;
}
function quarterDisabledAfter(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = e.maxDate, o = e.includeDates, l = endOfYear(t), u = addQuarters(l, 1);
  return n && differenceInCalendarQuarters(u, n) > 0 || o && o.every(function(f) {
    return differenceInCalendarQuarters(u, f) > 0;
  }) || !1;
}
function yearDisabledBefore(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = e.minDate, o = e.includeDates, l = subYears(t, 1);
  return n && differenceInCalendarYears(n, l) > 0 || o && o.every(function(u) {
    return differenceInCalendarYears(u, l) > 0;
  }) || !1;
}
function yearsDisabledBefore(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = e.minDate, o = e.yearItemNumber, l = o === void 0 ? DEFAULT_YEAR_ITEM_NUMBER : o, u = getStartOfYear(subYears(t, l)), f = getYearsPeriod(u, l), h = f.endPeriod, p = n && getYear(n);
  return p && p > h || !1;
}
function yearDisabledAfter(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = e.maxDate, o = e.includeDates, l = addYears(t, 1);
  return n && differenceInCalendarYears(l, n) > 0 || o && o.every(function(u) {
    return differenceInCalendarYears(l, u) > 0;
  }) || !1;
}
function yearsDisabledAfter(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = e.maxDate, o = e.yearItemNumber, l = o === void 0 ? DEFAULT_YEAR_ITEM_NUMBER : o, u = addYears(t, l), f = getYearsPeriod(u, l), h = f.startPeriod, p = n && getYear(n);
  return p && p < h || !1;
}
function getEffectiveMinDate(t) {
  var e = t.minDate, n = t.includeDates;
  if (n && e) {
    var o = n.filter(function(l) {
      return differenceInCalendarDays(l, e) >= 0;
    });
    return min$4(o);
  } else return n ? min$4(n) : e;
}
function getEffectiveMaxDate(t) {
  var e = t.maxDate, n = t.includeDates;
  if (n && e) {
    var o = n.filter(function(l) {
      return differenceInCalendarDays(l, e) <= 0;
    });
    return max$4(o);
  } else return n ? max$4(n) : e;
}
function getHightLightDaysMap() {
  for (var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "react-datepicker__day--highlighted", n = /* @__PURE__ */ new Map(), o = 0, l = t.length; o < l; o++) {
    var u = t[o];
    if (isDate(u)) {
      var f = formatDate(u, "MM.dd.yyyy"), h = n.get(f) || [];
      h.includes(e) || (h.push(e), n.set(f, h));
    } else if (_typeof(u) === "object") {
      var p = Object.keys(u), v = p[0], g = u[p[0]];
      if (typeof v == "string" && g.constructor === Array)
        for (var w = 0, E = g.length; w < E; w++) {
          var T = formatDate(g[w], "MM.dd.yyyy"), R = n.get(T) || [];
          R.includes(v) || (R.push(v), n.set(T, R));
        }
    }
  }
  return n;
}
function arraysAreEqual(t, e) {
  return t.length !== e.length ? !1 : t.every(function(n, o) {
    return n === e[o];
  });
}
function getHolidaysMap() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "react-datepicker__day--holidays", n = /* @__PURE__ */ new Map();
  return t.forEach(function(o) {
    var l = o.date, u = o.holidayName;
    if (isDate(l)) {
      var f = formatDate(l, "MM.dd.yyyy"), h = n.get(f) || {};
      if (!("className" in h && h.className === e && arraysAreEqual(h.holidayNames, [u]))) {
        h.className = e;
        var p = h.holidayNames;
        h.holidayNames = p ? [].concat(_toConsumableArray(p), [u]) : [u], n.set(f, h);
      }
    }
  }), n;
}
function timesToInjectAfter(t, e, n, o, l) {
  for (var u = l.length, f = [], h = 0; h < u; h++) {
    var p = t;
    p = addHours(p, getHours(l[h])), p = addMinutes(p, getMinutes(l[h])), p = addSeconds(p, getSeconds(l[h]));
    var v = addMinutes(t, (n + 1) * o);
    isAfter(p, e) && isBefore(p, v) && f.push(l[h]);
  }
  return f;
}
function addZero(t) {
  return t < 10 ? "0".concat(t) : "".concat(t);
}
function getYearsPeriod(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_YEAR_ITEM_NUMBER, n = Math.ceil(getYear(t) / e) * e, o = n - (e - 1);
  return {
    startPeriod: o,
    endPeriod: n
  };
}
function getHoursInDay(t) {
  var e = new Date(t.getFullYear(), t.getMonth(), t.getDate()), n = new Date(t.getFullYear(), t.getMonth(), t.getDate(), 24);
  return Math.round((+n - +e) / 36e5);
}
function startOfMinute(t) {
  var e = t.getSeconds(), n = t.getMilliseconds();
  return toDate(t.getTime() - e * 1e3 - n);
}
function isSameMinute(t, e) {
  return startOfMinute(t).getTime() === startOfMinute(e).getTime();
}
function getMidnightDate(t) {
  if (!isDate(t))
    throw new Error("Invalid date");
  var e = new Date(t);
  return e.setHours(0, 0, 0, 0), e;
}
function isDateBefore(t, e) {
  if (!isDate(t) || !isDate(e))
    throw new Error("Invalid date received");
  var n = getMidnightDate(t), o = getMidnightDate(e);
  return isBefore(n, o);
}
function isSpaceKeyDown(t) {
  var e = " ";
  return t.key === e;
}
function generateYears(t, e, n, o) {
  for (var l = [], u = 0; u < 2 * e + 1; u++) {
    var f = t + e - u, h = !0;
    n && (h = getYear(n) <= f), o && h && (h = getYear(o) >= f), h && l.push(f);
  }
  return l;
}
var YearDropdownOptions = /* @__PURE__ */ function(t) {
  function e(n) {
    var o;
    _classCallCheck(this, e), o = _callSuper(this, e, [n]), _defineProperty(o, "renderOptions", function() {
      var h = o.props.year, p = o.state.yearsList.map(function(w) {
        return /* @__PURE__ */ React__default.createElement("div", {
          className: h === w ? "react-datepicker__year-option react-datepicker__year-option--selected_year" : "react-datepicker__year-option",
          key: w,
          onClick: o.onChange.bind(o, w),
          "aria-selected": h === w ? "true" : void 0
        }, h === w ? /* @__PURE__ */ React__default.createElement("span", {
          className: "react-datepicker__year-option--selected"
        }, "✓") : "", w);
      }), v = o.props.minDate ? getYear(o.props.minDate) : null, g = o.props.maxDate ? getYear(o.props.maxDate) : null;
      return (!g || !o.state.yearsList.find(function(w) {
        return w === g;
      })) && p.unshift(/* @__PURE__ */ React__default.createElement("div", {
        className: "react-datepicker__year-option",
        key: "upcoming",
        onClick: o.incrementYears
      }, /* @__PURE__ */ React__default.createElement("a", {
        className: "react-datepicker__navigation react-datepicker__navigation--years react-datepicker__navigation--years-upcoming"
      }))), (!v || !o.state.yearsList.find(function(w) {
        return w === v;
      })) && p.push(/* @__PURE__ */ React__default.createElement("div", {
        className: "react-datepicker__year-option",
        key: "previous",
        onClick: o.decrementYears
      }, /* @__PURE__ */ React__default.createElement("a", {
        className: "react-datepicker__navigation react-datepicker__navigation--years react-datepicker__navigation--years-previous"
      }))), p;
    }), _defineProperty(o, "onChange", function(h) {
      o.props.onChange(h);
    }), _defineProperty(o, "handleClickOutside", function() {
      o.props.onCancel();
    }), _defineProperty(o, "shiftYears", function(h) {
      var p = o.state.yearsList.map(function(v) {
        return v + h;
      });
      o.setState({
        yearsList: p
      });
    }), _defineProperty(o, "incrementYears", function() {
      return o.shiftYears(1);
    }), _defineProperty(o, "decrementYears", function() {
      return o.shiftYears(-1);
    });
    var l = n.yearDropdownItemNumber, u = n.scrollableYearDropdown, f = l || (u ? 10 : 5);
    return o.state = {
      yearsList: generateYears(o.props.year, f, o.props.minDate, o.props.maxDate)
    }, o.dropdownRef = /* @__PURE__ */ createRef(), o;
  }
  return _inherits(e, t), _createClass(e, [{
    key: "componentDidMount",
    value: function() {
      var o = this.dropdownRef.current;
      if (o) {
        var l = o.children ? Array.from(o.children) : null, u = l ? l.find(function(f) {
          return f.ariaSelected;
        }) : null;
        o.scrollTop = u ? u.offsetTop + (u.clientHeight - o.clientHeight) / 2 : (o.scrollHeight - o.clientHeight) / 2;
      }
    }
  }, {
    key: "render",
    value: function() {
      var o = clsx$1({
        "react-datepicker__year-dropdown": !0,
        "react-datepicker__year-dropdown--scrollable": this.props.scrollableYearDropdown
      });
      return /* @__PURE__ */ React__default.createElement("div", {
        className: o,
        ref: this.dropdownRef
      }, this.renderOptions());
    }
  }]);
}(React__default.Component), WrappedYearDropdownOptions = onClickOutsideHOC(YearDropdownOptions), YearDropdown = /* @__PURE__ */ function(t) {
  function e() {
    var n;
    _classCallCheck(this, e);
    for (var o = arguments.length, l = new Array(o), u = 0; u < o; u++)
      l[u] = arguments[u];
    return n = _callSuper(this, e, [].concat(l)), _defineProperty(n, "state", {
      dropdownVisible: !1
    }), _defineProperty(n, "renderSelectOptions", function() {
      for (var f = n.props.minDate ? getYear(n.props.minDate) : 1900, h = n.props.maxDate ? getYear(n.props.maxDate) : 2100, p = [], v = f; v <= h; v++)
        p.push(/* @__PURE__ */ React__default.createElement("option", {
          key: v,
          value: v
        }, v));
      return p;
    }), _defineProperty(n, "onSelectChange", function(f) {
      n.onChange(f.target.value);
    }), _defineProperty(n, "renderSelectMode", function() {
      return /* @__PURE__ */ React__default.createElement("select", {
        value: n.props.year,
        className: "react-datepicker__year-select",
        onChange: n.onSelectChange
      }, n.renderSelectOptions());
    }), _defineProperty(n, "renderReadView", function(f) {
      return /* @__PURE__ */ React__default.createElement("div", {
        key: "read",
        style: {
          visibility: f ? "visible" : "hidden"
        },
        className: "react-datepicker__year-read-view",
        onClick: function(p) {
          return n.toggleDropdown(p);
        }
      }, /* @__PURE__ */ React__default.createElement("span", {
        className: "react-datepicker__year-read-view--down-arrow"
      }), /* @__PURE__ */ React__default.createElement("span", {
        className: "react-datepicker__year-read-view--selected-year"
      }, n.props.year));
    }), _defineProperty(n, "renderDropdown", function() {
      return /* @__PURE__ */ React__default.createElement(WrappedYearDropdownOptions, {
        key: "dropdown",
        year: n.props.year,
        onChange: n.onChange,
        onCancel: n.toggleDropdown,
        minDate: n.props.minDate,
        maxDate: n.props.maxDate,
        scrollableYearDropdown: n.props.scrollableYearDropdown,
        yearDropdownItemNumber: n.props.yearDropdownItemNumber
      });
    }), _defineProperty(n, "renderScrollMode", function() {
      var f = n.state.dropdownVisible, h = [n.renderReadView(!f)];
      return f && h.unshift(n.renderDropdown()), h;
    }), _defineProperty(n, "onChange", function(f) {
      n.toggleDropdown(), f !== n.props.year && n.props.onChange(f);
    }), _defineProperty(n, "toggleDropdown", function(f) {
      n.setState({
        dropdownVisible: !n.state.dropdownVisible
      }, function() {
        n.props.adjustDateOnChange && n.handleYearChange(n.props.date, f);
      });
    }), _defineProperty(n, "handleYearChange", function(f, h) {
      n.onSelect(f, h), n.setOpen();
    }), _defineProperty(n, "onSelect", function(f, h) {
      n.props.onSelect && n.props.onSelect(f, h);
    }), _defineProperty(n, "setOpen", function() {
      n.props.setOpen && n.props.setOpen(!0);
    }), n;
  }
  return _inherits(e, t), _createClass(e, [{
    key: "render",
    value: function() {
      var o;
      switch (this.props.dropdownMode) {
        case "scroll":
          o = this.renderScrollMode();
          break;
        case "select":
          o = this.renderSelectMode();
          break;
      }
      return /* @__PURE__ */ React__default.createElement("div", {
        className: "react-datepicker__year-dropdown-container react-datepicker__year-dropdown-container--".concat(this.props.dropdownMode)
      }, o);
    }
  }]);
}(React__default.Component), MonthDropdownOptions = /* @__PURE__ */ function(t) {
  function e() {
    var n;
    _classCallCheck(this, e);
    for (var o = arguments.length, l = new Array(o), u = 0; u < o; u++)
      l[u] = arguments[u];
    return n = _callSuper(this, e, [].concat(l)), _defineProperty(n, "isSelectedMonth", function(f) {
      return n.props.month === f;
    }), _defineProperty(n, "renderOptions", function() {
      return n.props.monthNames.map(function(f, h) {
        return /* @__PURE__ */ React__default.createElement("div", {
          className: n.isSelectedMonth(h) ? "react-datepicker__month-option react-datepicker__month-option--selected_month" : "react-datepicker__month-option",
          key: f,
          onClick: n.onChange.bind(n, h),
          "aria-selected": n.isSelectedMonth(h) ? "true" : void 0
        }, n.isSelectedMonth(h) ? /* @__PURE__ */ React__default.createElement("span", {
          className: "react-datepicker__month-option--selected"
        }, "✓") : "", f);
      });
    }), _defineProperty(n, "onChange", function(f) {
      return n.props.onChange(f);
    }), _defineProperty(n, "handleClickOutside", function() {
      return n.props.onCancel();
    }), n;
  }
  return _inherits(e, t), _createClass(e, [{
    key: "render",
    value: function() {
      return /* @__PURE__ */ React__default.createElement("div", {
        className: "react-datepicker__month-dropdown"
      }, this.renderOptions());
    }
  }]);
}(React__default.Component), WrappedMonthDropdownOptions = onClickOutsideHOC(MonthDropdownOptions), MonthDropdown = /* @__PURE__ */ function(t) {
  function e() {
    var n;
    _classCallCheck(this, e);
    for (var o = arguments.length, l = new Array(o), u = 0; u < o; u++)
      l[u] = arguments[u];
    return n = _callSuper(this, e, [].concat(l)), _defineProperty(n, "state", {
      dropdownVisible: !1
    }), _defineProperty(n, "renderSelectOptions", function(f) {
      return f.map(function(h, p) {
        return /* @__PURE__ */ React__default.createElement("option", {
          key: p,
          value: p
        }, h);
      });
    }), _defineProperty(n, "renderSelectMode", function(f) {
      return /* @__PURE__ */ React__default.createElement("select", {
        value: n.props.month,
        className: "react-datepicker__month-select",
        onChange: function(p) {
          return n.onChange(p.target.value);
        }
      }, n.renderSelectOptions(f));
    }), _defineProperty(n, "renderReadView", function(f, h) {
      return /* @__PURE__ */ React__default.createElement("div", {
        key: "read",
        style: {
          visibility: f ? "visible" : "hidden"
        },
        className: "react-datepicker__month-read-view",
        onClick: n.toggleDropdown
      }, /* @__PURE__ */ React__default.createElement("span", {
        className: "react-datepicker__month-read-view--down-arrow"
      }), /* @__PURE__ */ React__default.createElement("span", {
        className: "react-datepicker__month-read-view--selected-month"
      }, h[n.props.month]));
    }), _defineProperty(n, "renderDropdown", function(f) {
      return /* @__PURE__ */ React__default.createElement(WrappedMonthDropdownOptions, {
        key: "dropdown",
        month: n.props.month,
        monthNames: f,
        onChange: n.onChange,
        onCancel: n.toggleDropdown
      });
    }), _defineProperty(n, "renderScrollMode", function(f) {
      var h = n.state.dropdownVisible, p = [n.renderReadView(!h, f)];
      return h && p.unshift(n.renderDropdown(f)), p;
    }), _defineProperty(n, "onChange", function(f) {
      n.toggleDropdown(), f !== n.props.month && n.props.onChange(f);
    }), _defineProperty(n, "toggleDropdown", function() {
      return n.setState({
        dropdownVisible: !n.state.dropdownVisible
      });
    }), n;
  }
  return _inherits(e, t), _createClass(e, [{
    key: "render",
    value: function() {
      var o = this, l = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].map(this.props.useShortMonthInDropdown ? function(f) {
        return getMonthShortInLocale(f, o.props.locale);
      } : function(f) {
        return getMonthInLocale(f, o.props.locale);
      }), u;
      switch (this.props.dropdownMode) {
        case "scroll":
          u = this.renderScrollMode(l);
          break;
        case "select":
          u = this.renderSelectMode(l);
          break;
      }
      return /* @__PURE__ */ React__default.createElement("div", {
        className: "react-datepicker__month-dropdown-container react-datepicker__month-dropdown-container--".concat(this.props.dropdownMode)
      }, u);
    }
  }]);
}(React__default.Component);
function generateMonthYears(t, e) {
  for (var n = [], o = getStartOfMonth(t), l = getStartOfMonth(e); !isAfter(o, l); )
    n.push(newDate(o)), o = addMonths(o, 1);
  return n;
}
var MonthYearDropdownOptions = /* @__PURE__ */ function(t) {
  function e(n) {
    var o;
    return _classCallCheck(this, e), o = _callSuper(this, e, [n]), _defineProperty(o, "renderOptions", function() {
      return o.state.monthYearsList.map(function(l) {
        var u = getTime(l), f = isSameYear(o.props.date, l) && isSameMonth(o.props.date, l);
        return /* @__PURE__ */ React__default.createElement("div", {
          className: f ? "react-datepicker__month-year-option--selected_month-year" : "react-datepicker__month-year-option",
          key: u,
          onClick: o.onChange.bind(o, u),
          "aria-selected": f ? "true" : void 0
        }, f ? /* @__PURE__ */ React__default.createElement("span", {
          className: "react-datepicker__month-year-option--selected"
        }, "✓") : "", formatDate(l, o.props.dateFormat, o.props.locale));
      });
    }), _defineProperty(o, "onChange", function(l) {
      return o.props.onChange(l);
    }), _defineProperty(o, "handleClickOutside", function() {
      o.props.onCancel();
    }), o.state = {
      monthYearsList: generateMonthYears(o.props.minDate, o.props.maxDate)
    }, o;
  }
  return _inherits(e, t), _createClass(e, [{
    key: "render",
    value: function() {
      var o = clsx$1({
        "react-datepicker__month-year-dropdown": !0,
        "react-datepicker__month-year-dropdown--scrollable": this.props.scrollableMonthYearDropdown
      });
      return /* @__PURE__ */ React__default.createElement("div", {
        className: o
      }, this.renderOptions());
    }
  }]);
}(React__default.Component), WrappedMonthYearDropdownOptions = onClickOutsideHOC(MonthYearDropdownOptions), MonthYearDropdown = /* @__PURE__ */ function(t) {
  function e() {
    var n;
    _classCallCheck(this, e);
    for (var o = arguments.length, l = new Array(o), u = 0; u < o; u++)
      l[u] = arguments[u];
    return n = _callSuper(this, e, [].concat(l)), _defineProperty(n, "state", {
      dropdownVisible: !1
    }), _defineProperty(n, "renderSelectOptions", function() {
      for (var f = getStartOfMonth(n.props.minDate), h = getStartOfMonth(n.props.maxDate), p = []; !isAfter(f, h); ) {
        var v = getTime(f);
        p.push(/* @__PURE__ */ React__default.createElement("option", {
          key: v,
          value: v
        }, formatDate(f, n.props.dateFormat, n.props.locale))), f = addMonths(f, 1);
      }
      return p;
    }), _defineProperty(n, "onSelectChange", function(f) {
      n.onChange(f.target.value);
    }), _defineProperty(n, "renderSelectMode", function() {
      return /* @__PURE__ */ React__default.createElement("select", {
        value: getTime(getStartOfMonth(n.props.date)),
        className: "react-datepicker__month-year-select",
        onChange: n.onSelectChange
      }, n.renderSelectOptions());
    }), _defineProperty(n, "renderReadView", function(f) {
      var h = formatDate(n.props.date, n.props.dateFormat, n.props.locale);
      return /* @__PURE__ */ React__default.createElement("div", {
        key: "read",
        style: {
          visibility: f ? "visible" : "hidden"
        },
        className: "react-datepicker__month-year-read-view",
        onClick: function(v) {
          return n.toggleDropdown(v);
        }
      }, /* @__PURE__ */ React__default.createElement("span", {
        className: "react-datepicker__month-year-read-view--down-arrow"
      }), /* @__PURE__ */ React__default.createElement("span", {
        className: "react-datepicker__month-year-read-view--selected-month-year"
      }, h));
    }), _defineProperty(n, "renderDropdown", function() {
      return /* @__PURE__ */ React__default.createElement(WrappedMonthYearDropdownOptions, {
        key: "dropdown",
        date: n.props.date,
        dateFormat: n.props.dateFormat,
        onChange: n.onChange,
        onCancel: n.toggleDropdown,
        minDate: n.props.minDate,
        maxDate: n.props.maxDate,
        scrollableMonthYearDropdown: n.props.scrollableMonthYearDropdown,
        locale: n.props.locale
      });
    }), _defineProperty(n, "renderScrollMode", function() {
      var f = n.state.dropdownVisible, h = [n.renderReadView(!f)];
      return f && h.unshift(n.renderDropdown()), h;
    }), _defineProperty(n, "onChange", function(f) {
      n.toggleDropdown();
      var h = newDate(parseInt(f));
      isSameYear(n.props.date, h) && isSameMonth(n.props.date, h) || n.props.onChange(h);
    }), _defineProperty(n, "toggleDropdown", function() {
      return n.setState({
        dropdownVisible: !n.state.dropdownVisible
      });
    }), n;
  }
  return _inherits(e, t), _createClass(e, [{
    key: "render",
    value: function() {
      var o;
      switch (this.props.dropdownMode) {
        case "scroll":
          o = this.renderScrollMode();
          break;
        case "select":
          o = this.renderSelectMode();
          break;
      }
      return /* @__PURE__ */ React__default.createElement("div", {
        className: "react-datepicker__month-year-dropdown-container react-datepicker__month-year-dropdown-container--".concat(this.props.dropdownMode)
      }, o);
    }
  }]);
}(React__default.Component), Day = /* @__PURE__ */ function(t) {
  function e() {
    var n;
    _classCallCheck(this, e);
    for (var o = arguments.length, l = new Array(o), u = 0; u < o; u++)
      l[u] = arguments[u];
    return n = _callSuper(this, e, [].concat(l)), _defineProperty(n, "dayEl", /* @__PURE__ */ React__default.createRef()), _defineProperty(n, "handleClick", function(f) {
      !n.isDisabled() && n.props.onClick && n.props.onClick(f);
    }), _defineProperty(n, "handleMouseEnter", function(f) {
      !n.isDisabled() && n.props.onMouseEnter && n.props.onMouseEnter(f);
    }), _defineProperty(n, "handleOnKeyDown", function(f) {
      var h = f.key;
      h === " " && (f.preventDefault(), f.key = "Enter"), n.props.handleOnKeyDown(f);
    }), _defineProperty(n, "isSameDay", function(f) {
      return isSameDay(n.props.day, f);
    }), _defineProperty(n, "isKeyboardSelected", function() {
      var f;
      if (n.props.disabledKeyboardNavigation)
        return !1;
      var h = n.props.selectsMultiple ? (f = n.props.selectedDates) === null || f === void 0 ? void 0 : f.some(function(p) {
        return n.isSameDayOrWeek(p);
      }) : n.isSameDayOrWeek(n.props.selected);
      return !h && n.isSameDayOrWeek(n.props.preSelection);
    }), _defineProperty(n, "isDisabled", function() {
      return isDayDisabled(n.props.day, n.props);
    }), _defineProperty(n, "isExcluded", function() {
      return isDayExcluded(n.props.day, n.props);
    }), _defineProperty(n, "isStartOfWeek", function() {
      return isSameDay(n.props.day, getStartOfWeek(n.props.day, n.props.locale, n.props.calendarStartDay));
    }), _defineProperty(n, "isSameWeek", function(f) {
      return n.props.showWeekPicker && isSameDay(f, getStartOfWeek(n.props.day, n.props.locale, n.props.calendarStartDay));
    }), _defineProperty(n, "isSameDayOrWeek", function(f) {
      return n.isSameDay(f) || n.isSameWeek(f);
    }), _defineProperty(n, "getHighLightedClass", function() {
      var f = n.props, h = f.day, p = f.highlightDates;
      if (!p)
        return !1;
      var v = formatDate(h, "MM.dd.yyyy");
      return p.get(v);
    }), _defineProperty(n, "getHolidaysClass", function() {
      var f = n.props, h = f.day, p = f.holidays;
      if (!p)
        return !1;
      var v = formatDate(h, "MM.dd.yyyy");
      if (p.has(v))
        return [p.get(v).className];
    }), _defineProperty(n, "isInRange", function() {
      var f = n.props, h = f.day, p = f.startDate, v = f.endDate;
      return !p || !v ? !1 : isDayInRange(h, p, v);
    }), _defineProperty(n, "isInSelectingRange", function() {
      var f, h = n.props, p = h.day, v = h.selectsStart, g = h.selectsEnd, w = h.selectsRange, E = h.selectsDisabledDaysInRange, T = h.startDate, R = h.endDate, _ = (f = n.props.selectingDate) !== null && f !== void 0 ? f : n.props.preSelection;
      return !(v || g || w) || !_ || !E && n.isDisabled() ? !1 : v && R && (isBefore(_, R) || isEqual(_, R)) ? isDayInRange(p, _, R) : g && T && (isAfter(_, T) || isEqual(_, T)) || w && T && !R && (isAfter(_, T) || isEqual(_, T)) ? isDayInRange(p, T, _) : !1;
    }), _defineProperty(n, "isSelectingRangeStart", function() {
      var f;
      if (!n.isInSelectingRange())
        return !1;
      var h = n.props, p = h.day, v = h.startDate, g = h.selectsStart, w = (f = n.props.selectingDate) !== null && f !== void 0 ? f : n.props.preSelection;
      return g ? isSameDay(p, w) : isSameDay(p, v);
    }), _defineProperty(n, "isSelectingRangeEnd", function() {
      var f;
      if (!n.isInSelectingRange())
        return !1;
      var h = n.props, p = h.day, v = h.endDate, g = h.selectsEnd, w = h.selectsRange, E = (f = n.props.selectingDate) !== null && f !== void 0 ? f : n.props.preSelection;
      return g || w ? isSameDay(p, E) : isSameDay(p, v);
    }), _defineProperty(n, "isRangeStart", function() {
      var f = n.props, h = f.day, p = f.startDate, v = f.endDate;
      return !p || !v ? !1 : isSameDay(p, h);
    }), _defineProperty(n, "isRangeEnd", function() {
      var f = n.props, h = f.day, p = f.startDate, v = f.endDate;
      return !p || !v ? !1 : isSameDay(v, h);
    }), _defineProperty(n, "isWeekend", function() {
      var f = getDay(n.props.day);
      return f === 0 || f === 6;
    }), _defineProperty(n, "isAfterMonth", function() {
      return n.props.month !== void 0 && (n.props.month + 1) % 12 === getMonth(n.props.day);
    }), _defineProperty(n, "isBeforeMonth", function() {
      return n.props.month !== void 0 && (getMonth(n.props.day) + 1) % 12 === n.props.month;
    }), _defineProperty(n, "isCurrentDay", function() {
      return n.isSameDay(newDate());
    }), _defineProperty(n, "isSelected", function() {
      if (n.props.selectsMultiple) {
        var f;
        return (f = n.props.selectedDates) === null || f === void 0 ? void 0 : f.some(function(h) {
          return n.isSameDayOrWeek(h);
        });
      }
      return n.isSameDayOrWeek(n.props.selected);
    }), _defineProperty(n, "getClassNames", function(f) {
      var h = n.props.dayClassName ? n.props.dayClassName(f) : void 0;
      return clsx$1("react-datepicker__day", h, "react-datepicker__day--" + getDayOfWeekCode(n.props.day), {
        "react-datepicker__day--disabled": n.isDisabled(),
        "react-datepicker__day--excluded": n.isExcluded(),
        "react-datepicker__day--selected": n.isSelected(),
        "react-datepicker__day--keyboard-selected": n.isKeyboardSelected(),
        "react-datepicker__day--range-start": n.isRangeStart(),
        "react-datepicker__day--range-end": n.isRangeEnd(),
        "react-datepicker__day--in-range": n.isInRange(),
        "react-datepicker__day--in-selecting-range": n.isInSelectingRange(),
        "react-datepicker__day--selecting-range-start": n.isSelectingRangeStart(),
        "react-datepicker__day--selecting-range-end": n.isSelectingRangeEnd(),
        "react-datepicker__day--today": n.isCurrentDay(),
        "react-datepicker__day--weekend": n.isWeekend(),
        "react-datepicker__day--outside-month": n.isAfterMonth() || n.isBeforeMonth()
      }, n.getHighLightedClass("react-datepicker__day--highlighted"), n.getHolidaysClass());
    }), _defineProperty(n, "getAriaLabel", function() {
      var f = n.props, h = f.day, p = f.ariaLabelPrefixWhenEnabled, v = p === void 0 ? "Choose" : p, g = f.ariaLabelPrefixWhenDisabled, w = g === void 0 ? "Not available" : g, E = n.isDisabled() || n.isExcluded() ? w : v;
      return "".concat(E, " ").concat(formatDate(h, "PPPP", n.props.locale));
    }), _defineProperty(n, "getTitle", function() {
      var f = n.props, h = f.day, p = f.holidays, v = p === void 0 ? /* @__PURE__ */ new Map() : p, g = f.excludeDates, w = formatDate(h, "MM.dd.yyyy"), E = [];
      return v.has(w) && E.push.apply(E, _toConsumableArray(v.get(w).holidayNames)), n.isExcluded() && E.push(g == null ? void 0 : g.filter(function(T) {
        return isSameDay(T.date ? T.date : T, h);
      }).map(function(T) {
        return T.message;
      })), E.join(", ");
    }), _defineProperty(n, "getTabIndex", function(f, h) {
      var p = f || n.props.selected, v = h || n.props.preSelection, g = !(n.props.showWeekPicker && (n.props.showWeekNumber || !n.isStartOfWeek())) && (n.isKeyboardSelected() || n.isSameDay(p) && isSameDay(v, p)) ? 0 : -1;
      return g;
    }), _defineProperty(n, "handleFocusDay", function() {
      var f, h = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, p = !1;
      n.getTabIndex() === 0 && !h.isInputFocused && n.isSameDay(n.props.preSelection) && ((!document.activeElement || document.activeElement === document.body) && (p = !0), n.props.inline && !n.props.shouldFocusDayInline && (p = !1), n.props.containerRef && n.props.containerRef.current && n.props.containerRef.current.contains(document.activeElement) && document.activeElement.classList.contains("react-datepicker__day") && (p = !0), n.props.monthShowsDuplicateDaysEnd && n.isAfterMonth() && (p = !1), n.props.monthShowsDuplicateDaysStart && n.isBeforeMonth() && (p = !1)), p && ((f = n.dayEl.current) === null || f === void 0 || f.focus({
        preventScroll: !0
      }));
    }), _defineProperty(n, "renderDayContents", function() {
      return n.props.monthShowsDuplicateDaysEnd && n.isAfterMonth() || n.props.monthShowsDuplicateDaysStart && n.isBeforeMonth() ? null : n.props.renderDayContents ? n.props.renderDayContents(getDate(n.props.day), n.props.day) : getDate(n.props.day);
    }), _defineProperty(n, "render", function() {
      return /* @__PURE__ */ React__default.createElement("div", {
        ref: n.dayEl,
        className: n.getClassNames(n.props.day),
        onKeyDown: n.handleOnKeyDown,
        onClick: n.handleClick,
        onMouseEnter: n.props.usePointerEvent ? void 0 : n.handleMouseEnter,
        onPointerEnter: n.props.usePointerEvent ? n.handleMouseEnter : void 0,
        tabIndex: n.getTabIndex(),
        "aria-label": n.getAriaLabel(),
        role: "option",
        title: n.getTitle(),
        "aria-disabled": n.isDisabled(),
        "aria-current": n.isCurrentDay() ? "date" : void 0,
        "aria-selected": n.isSelected() || n.isInRange()
      }, n.renderDayContents(), n.getTitle() !== "" && /* @__PURE__ */ React__default.createElement("span", {
        className: "overlay"
      }, n.getTitle()));
    }), n;
  }
  return _inherits(e, t), _createClass(e, [{
    key: "componentDidMount",
    value: function() {
      this.handleFocusDay();
    }
  }, {
    key: "componentDidUpdate",
    value: function(o) {
      this.handleFocusDay(o);
    }
  }]);
}(React__default.Component), WeekNumber = /* @__PURE__ */ function(t) {
  function e() {
    var n;
    _classCallCheck(this, e);
    for (var o = arguments.length, l = new Array(o), u = 0; u < o; u++)
      l[u] = arguments[u];
    return n = _callSuper(this, e, [].concat(l)), _defineProperty(n, "weekNumberEl", /* @__PURE__ */ React__default.createRef()), _defineProperty(n, "handleClick", function(f) {
      n.props.onClick && n.props.onClick(f);
    }), _defineProperty(n, "handleOnKeyDown", function(f) {
      var h = f.key;
      h === " " && (f.preventDefault(), f.key = "Enter"), n.props.handleOnKeyDown(f);
    }), _defineProperty(n, "isKeyboardSelected", function() {
      return !n.props.disabledKeyboardNavigation && !isSameDay(n.props.date, n.props.selected) && isSameDay(n.props.date, n.props.preSelection);
    }), _defineProperty(n, "getTabIndex", function() {
      return n.props.showWeekPicker && n.props.showWeekNumber && (n.isKeyboardSelected() || isSameDay(n.props.date, n.props.selected) && isSameDay(n.props.preSelection, n.props.selected)) ? 0 : -1;
    }), _defineProperty(n, "handleFocusWeekNumber", function() {
      var f = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, h = !1;
      n.getTabIndex() === 0 && !f.isInputFocused && isSameDay(n.props.date, n.props.preSelection) && ((!document.activeElement || document.activeElement === document.body) && (h = !0), n.props.inline && !n.props.shouldFocusDayInline && (h = !1), n.props.containerRef && n.props.containerRef.current && n.props.containerRef.current.contains(document.activeElement) && document.activeElement && document.activeElement.classList.contains("react-datepicker__week-number") && (h = !0)), h && n.weekNumberEl.current && n.weekNumberEl.current.focus({
        preventScroll: !0
      });
    }), n;
  }
  return _inherits(e, t), _createClass(e, [{
    key: "componentDidMount",
    value: function() {
      this.handleFocusWeekNumber();
    }
  }, {
    key: "componentDidUpdate",
    value: function(o) {
      this.handleFocusWeekNumber(o);
    }
  }, {
    key: "render",
    value: function() {
      var o = this.props, l = o.weekNumber, u = o.ariaLabelPrefix, f = u === void 0 ? "week " : u, h = o.onClick, p = {
        "react-datepicker__week-number": !0,
        "react-datepicker__week-number--clickable": !!h,
        "react-datepicker__week-number--selected": !!h && isSameDay(this.props.date, this.props.selected),
        "react-datepicker__week-number--keyboard-selected": this.isKeyboardSelected()
      };
      return /* @__PURE__ */ React__default.createElement("div", {
        ref: this.weekNumberEl,
        className: clsx$1(p),
        "aria-label": "".concat(f, " ").concat(this.props.weekNumber),
        onClick: this.handleClick,
        onKeyDown: this.handleOnKeyDown,
        tabIndex: this.getTabIndex()
      }, l);
    }
  }], [{
    key: "defaultProps",
    get: function() {
      return {
        ariaLabelPrefix: "week "
      };
    }
  }]);
}(React__default.Component), Week = /* @__PURE__ */ function(t) {
  function e() {
    var n;
    _classCallCheck(this, e);
    for (var o = arguments.length, l = new Array(o), u = 0; u < o; u++)
      l[u] = arguments[u];
    return n = _callSuper(this, e, [].concat(l)), _defineProperty(n, "handleDayClick", function(f, h) {
      n.props.onDayClick && n.props.onDayClick(f, h);
    }), _defineProperty(n, "handleDayMouseEnter", function(f) {
      n.props.onDayMouseEnter && n.props.onDayMouseEnter(f);
    }), _defineProperty(n, "handleWeekClick", function(f, h, p) {
      typeof n.props.onWeekSelect == "function" && n.props.onWeekSelect(f, h, p), n.props.showWeekPicker && n.handleDayClick(f, p), n.props.shouldCloseOnSelect && n.props.setOpen(!1);
    }), _defineProperty(n, "formatWeekNumber", function(f) {
      return n.props.formatWeekNumber ? n.props.formatWeekNumber(f) : getWeek(f);
    }), _defineProperty(n, "renderDays", function() {
      var f = n.startOfWeek(), h = [], p = n.formatWeekNumber(f);
      if (n.props.showWeekNumber) {
        var v = n.props.onWeekSelect || n.props.showWeekPicker ? n.handleWeekClick.bind(n, f, p) : void 0;
        h.push(/* @__PURE__ */ React__default.createElement(WeekNumber, {
          key: "W",
          weekNumber: p,
          date: f,
          onClick: v,
          selected: n.props.selected,
          preSelection: n.props.preSelection,
          ariaLabelPrefix: n.props.ariaLabelPrefix,
          showWeekPicker: n.props.showWeekPicker,
          showWeekNumber: n.props.showWeekNumber,
          disabledKeyboardNavigation: n.props.disabledKeyboardNavigation,
          handleOnKeyDown: n.props.handleOnKeyDown,
          isInputFocused: n.props.isInputFocused,
          containerRef: n.props.containerRef
        }));
      }
      return h.concat([0, 1, 2, 3, 4, 5, 6].map(function(g) {
        var w = addDays(f, g);
        return /* @__PURE__ */ React__default.createElement(Day, {
          ariaLabelPrefixWhenEnabled: n.props.chooseDayAriaLabelPrefix,
          ariaLabelPrefixWhenDisabled: n.props.disabledDayAriaLabelPrefix,
          key: w.valueOf(),
          day: w,
          month: n.props.month,
          onClick: n.handleDayClick.bind(n, w),
          usePointerEvent: n.props.usePointerEvent,
          onMouseEnter: n.handleDayMouseEnter.bind(n, w),
          minDate: n.props.minDate,
          maxDate: n.props.maxDate,
          calendarStartDay: n.props.calendarStartDay,
          excludeDates: n.props.excludeDates,
          excludeDateIntervals: n.props.excludeDateIntervals,
          includeDates: n.props.includeDates,
          includeDateIntervals: n.props.includeDateIntervals,
          highlightDates: n.props.highlightDates,
          holidays: n.props.holidays,
          selectingDate: n.props.selectingDate,
          filterDate: n.props.filterDate,
          preSelection: n.props.preSelection,
          selected: n.props.selected,
          selectsStart: n.props.selectsStart,
          selectsEnd: n.props.selectsEnd,
          selectsRange: n.props.selectsRange,
          showWeekPicker: n.props.showWeekPicker,
          showWeekNumber: n.props.showWeekNumber,
          selectsDisabledDaysInRange: n.props.selectsDisabledDaysInRange,
          selectsMultiple: n.props.selectsMultiple,
          selectedDates: n.props.selectedDates,
          startDate: n.props.startDate,
          endDate: n.props.endDate,
          dayClassName: n.props.dayClassName,
          renderDayContents: n.props.renderDayContents,
          disabledKeyboardNavigation: n.props.disabledKeyboardNavigation,
          handleOnKeyDown: n.props.handleOnKeyDown,
          isInputFocused: n.props.isInputFocused,
          containerRef: n.props.containerRef,
          inline: n.props.inline,
          shouldFocusDayInline: n.props.shouldFocusDayInline,
          monthShowsDuplicateDaysEnd: n.props.monthShowsDuplicateDaysEnd,
          monthShowsDuplicateDaysStart: n.props.monthShowsDuplicateDaysStart,
          locale: n.props.locale
        });
      }));
    }), _defineProperty(n, "startOfWeek", function() {
      return getStartOfWeek(n.props.day, n.props.locale, n.props.calendarStartDay);
    }), _defineProperty(n, "isKeyboardSelected", function() {
      return !n.props.disabledKeyboardNavigation && !isSameDay(n.startOfWeek(), n.props.selected) && isSameDay(n.startOfWeek(), n.props.preSelection);
    }), n;
  }
  return _inherits(e, t), _createClass(e, [{
    key: "render",
    value: function() {
      var o = {
        "react-datepicker__week": !0,
        "react-datepicker__week--selected": isSameDay(this.startOfWeek(), this.props.selected),
        "react-datepicker__week--keyboard-selected": this.isKeyboardSelected()
      };
      return /* @__PURE__ */ React__default.createElement("div", {
        className: clsx$1(o)
      }, this.renderDays());
    }
  }], [{
    key: "defaultProps",
    get: function() {
      return {
        shouldCloseOnSelect: !0
      };
    }
  }]);
}(React__default.Component), FIXED_HEIGHT_STANDARD_WEEK_COUNT = 6, MONTH_COLUMNS_LAYOUT = {
  TWO_COLUMNS: "two_columns",
  THREE_COLUMNS: "three_columns",
  FOUR_COLUMNS: "four_columns"
}, MONTH_COLUMNS = _defineProperty(_defineProperty(_defineProperty({}, MONTH_COLUMNS_LAYOUT.TWO_COLUMNS, {
  grid: [[0, 1], [2, 3], [4, 5], [6, 7], [8, 9], [10, 11]],
  verticalNavigationOffset: 2
}), MONTH_COLUMNS_LAYOUT.THREE_COLUMNS, {
  grid: [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10, 11]],
  verticalNavigationOffset: 3
}), MONTH_COLUMNS_LAYOUT.FOUR_COLUMNS, {
  grid: [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]],
  verticalNavigationOffset: 4
}), MONTH_NAVIGATION_HORIZONTAL_OFFSET = 1;
function getMonthColumnsLayout(t, e) {
  return t ? MONTH_COLUMNS_LAYOUT.FOUR_COLUMNS : e ? MONTH_COLUMNS_LAYOUT.TWO_COLUMNS : MONTH_COLUMNS_LAYOUT.THREE_COLUMNS;
}
var Month = /* @__PURE__ */ function(t) {
  function e() {
    var n;
    _classCallCheck(this, e);
    for (var o = arguments.length, l = new Array(o), u = 0; u < o; u++)
      l[u] = arguments[u];
    return n = _callSuper(this, e, [].concat(l)), _defineProperty(n, "MONTH_REFS", _toConsumableArray(Array(12)).map(function() {
      return /* @__PURE__ */ React__default.createRef();
    })), _defineProperty(n, "QUARTER_REFS", _toConsumableArray(Array(4)).map(function() {
      return /* @__PURE__ */ React__default.createRef();
    })), _defineProperty(n, "isDisabled", function(f) {
      return isDayDisabled(f, n.props);
    }), _defineProperty(n, "isExcluded", function(f) {
      return isDayExcluded(f, n.props);
    }), _defineProperty(n, "handleDayClick", function(f, h) {
      n.props.onDayClick && n.props.onDayClick(f, h, n.props.orderInDisplay);
    }), _defineProperty(n, "handleDayMouseEnter", function(f) {
      n.props.onDayMouseEnter && n.props.onDayMouseEnter(f);
    }), _defineProperty(n, "handleMouseLeave", function() {
      n.props.onMouseLeave && n.props.onMouseLeave();
    }), _defineProperty(n, "isRangeStartMonth", function(f) {
      var h = n.props, p = h.day, v = h.startDate, g = h.endDate;
      return !v || !g ? !1 : isSameMonth(setMonth(p, f), v);
    }), _defineProperty(n, "isRangeStartQuarter", function(f) {
      var h = n.props, p = h.day, v = h.startDate, g = h.endDate;
      return !v || !g ? !1 : isSameQuarter(setQuarter(p, f), v);
    }), _defineProperty(n, "isRangeEndMonth", function(f) {
      var h = n.props, p = h.day, v = h.startDate, g = h.endDate;
      return !v || !g ? !1 : isSameMonth(setMonth(p, f), g);
    }), _defineProperty(n, "isRangeEndQuarter", function(f) {
      var h = n.props, p = h.day, v = h.startDate, g = h.endDate;
      return !v || !g ? !1 : isSameQuarter(setQuarter(p, f), g);
    }), _defineProperty(n, "isInSelectingRangeMonth", function(f) {
      var h, p = n.props, v = p.day, g = p.selectsStart, w = p.selectsEnd, E = p.selectsRange, T = p.startDate, R = p.endDate, _ = (h = n.props.selectingDate) !== null && h !== void 0 ? h : n.props.preSelection;
      return !(g || w || E) || !_ ? !1 : g && R ? isMonthInRange(_, R, f, v) : w && T || E && T && !R ? isMonthInRange(T, _, f, v) : !1;
    }), _defineProperty(n, "isSelectingMonthRangeStart", function(f) {
      var h;
      if (!n.isInSelectingRangeMonth(f))
        return !1;
      var p = n.props, v = p.day, g = p.startDate, w = p.selectsStart, E = setMonth(v, f), T = (h = n.props.selectingDate) !== null && h !== void 0 ? h : n.props.preSelection;
      return w ? isSameMonth(E, T) : isSameMonth(E, g);
    }), _defineProperty(n, "isSelectingMonthRangeEnd", function(f) {
      var h;
      if (!n.isInSelectingRangeMonth(f))
        return !1;
      var p = n.props, v = p.day, g = p.endDate, w = p.selectsEnd, E = p.selectsRange, T = setMonth(v, f), R = (h = n.props.selectingDate) !== null && h !== void 0 ? h : n.props.preSelection;
      return w || E ? isSameMonth(T, R) : isSameMonth(T, g);
    }), _defineProperty(n, "isInSelectingRangeQuarter", function(f) {
      var h, p = n.props, v = p.day, g = p.selectsStart, w = p.selectsEnd, E = p.selectsRange, T = p.startDate, R = p.endDate, _ = (h = n.props.selectingDate) !== null && h !== void 0 ? h : n.props.preSelection;
      return !(g || w || E) || !_ ? !1 : g && R ? isQuarterInRange(_, R, f, v) : w && T || E && T && !R ? isQuarterInRange(T, _, f, v) : !1;
    }), _defineProperty(n, "isWeekInMonth", function(f) {
      var h = n.props.day, p = addDays(f, 6);
      return isSameMonth(f, h) || isSameMonth(p, h);
    }), _defineProperty(n, "isCurrentMonth", function(f, h) {
      return getYear(f) === getYear(newDate()) && h === getMonth(newDate());
    }), _defineProperty(n, "isCurrentQuarter", function(f, h) {
      return getYear(f) === getYear(newDate()) && h === getQuarter(newDate());
    }), _defineProperty(n, "isSelectedMonth", function(f, h, p) {
      return getMonth(p) === h && getYear(f) === getYear(p);
    }), _defineProperty(n, "isSelectedQuarter", function(f, h, p) {
      return getQuarter(f) === h && getYear(f) === getYear(p);
    }), _defineProperty(n, "renderWeeks", function() {
      for (var f = [], h = n.props.fixedHeight, p = 0, v = !1, g = getStartOfWeek(getStartOfMonth(n.props.day), n.props.locale, n.props.calendarStartDay), w = n.props.showWeekPicker ? getStartOfWeek(n.props.selected, n.props.locale, n.props.calendarStartDay) : n.props.selected, E = n.props.showWeekPicker ? getStartOfWeek(n.props.preSelection, n.props.locale, n.props.calendarStartDay) : n.props.preSelection; f.push(/* @__PURE__ */ React__default.createElement(Week, {
        ariaLabelPrefix: n.props.weekAriaLabelPrefix,
        chooseDayAriaLabelPrefix: n.props.chooseDayAriaLabelPrefix,
        disabledDayAriaLabelPrefix: n.props.disabledDayAriaLabelPrefix,
        key: p,
        day: g,
        month: getMonth(n.props.day),
        onDayClick: n.handleDayClick,
        usePointerEvent: n.props.usePointerEvent,
        onDayMouseEnter: n.handleDayMouseEnter,
        onWeekSelect: n.props.onWeekSelect,
        formatWeekNumber: n.props.formatWeekNumber,
        locale: n.props.locale,
        minDate: n.props.minDate,
        maxDate: n.props.maxDate,
        excludeDates: n.props.excludeDates,
        excludeDateIntervals: n.props.excludeDateIntervals,
        includeDates: n.props.includeDates,
        includeDateIntervals: n.props.includeDateIntervals,
        inline: n.props.inline,
        shouldFocusDayInline: n.props.shouldFocusDayInline,
        highlightDates: n.props.highlightDates,
        holidays: n.props.holidays,
        selectingDate: n.props.selectingDate,
        filterDate: n.props.filterDate,
        preSelection: E,
        selected: w,
        selectsStart: n.props.selectsStart,
        selectsEnd: n.props.selectsEnd,
        selectsRange: n.props.selectsRange,
        selectsDisabledDaysInRange: n.props.selectsDisabledDaysInRange,
        selectsMultiple: n.props.selectsMultiple,
        selectedDates: n.props.selectedDates,
        showWeekNumber: n.props.showWeekNumbers,
        showWeekPicker: n.props.showWeekPicker,
        startDate: n.props.startDate,
        endDate: n.props.endDate,
        dayClassName: n.props.dayClassName,
        setOpen: n.props.setOpen,
        shouldCloseOnSelect: n.props.shouldCloseOnSelect,
        disabledKeyboardNavigation: n.props.disabledKeyboardNavigation,
        renderDayContents: n.props.renderDayContents,
        handleOnKeyDown: n.props.handleOnKeyDown,
        isInputFocused: n.props.isInputFocused,
        containerRef: n.props.containerRef,
        calendarStartDay: n.props.calendarStartDay,
        monthShowsDuplicateDaysEnd: n.props.monthShowsDuplicateDaysEnd,
        monthShowsDuplicateDaysStart: n.props.monthShowsDuplicateDaysStart
      })), !v; ) {
        p++, g = addWeeks(g, 1);
        var T = h && p >= FIXED_HEIGHT_STANDARD_WEEK_COUNT, R = !h && !n.isWeekInMonth(g);
        if (T || R)
          if (n.props.peekNextMonth)
            v = !0;
          else
            break;
      }
      return f;
    }), _defineProperty(n, "onMonthClick", function(f, h) {
      var p = setMonth(n.props.day, h);
      isMonthDisabled(p, n.props) || n.handleDayClick(getStartOfMonth(p), f);
    }), _defineProperty(n, "onMonthMouseEnter", function(f) {
      var h = setMonth(n.props.day, f);
      isMonthDisabled(h, n.props) || n.handleDayMouseEnter(getStartOfMonth(h));
    }), _defineProperty(n, "handleMonthNavigation", function(f, h) {
      n.isDisabled(h) || n.isExcluded(h) || (n.props.setPreSelection(h), n.MONTH_REFS[f].current && n.MONTH_REFS[f].current.focus());
    }), _defineProperty(n, "onMonthKeyDown", function(f, h) {
      var p = n.props, v = p.selected, g = p.preSelection, w = p.disabledKeyboardNavigation, E = p.showTwoColumnMonthYearPicker, T = p.showFourColumnMonthYearPicker, R = p.setPreSelection, _ = p.handleOnMonthKeyDown, b = f.key;
      if (b !== "Tab" && f.preventDefault(), !w) {
        var M = getMonthColumnsLayout(T, E), A = MONTH_COLUMNS[M].verticalNavigationOffset, $ = MONTH_COLUMNS[M].grid;
        switch (b) {
          case "Enter":
            n.onMonthClick(f, h), R(v);
            break;
          case "ArrowRight":
            n.handleMonthNavigation(h === 11 ? 0 : h + MONTH_NAVIGATION_HORIZONTAL_OFFSET, addMonths(g, MONTH_NAVIGATION_HORIZONTAL_OFFSET));
            break;
          case "ArrowLeft":
            n.handleMonthNavigation(h === 0 ? 11 : h - MONTH_NAVIGATION_HORIZONTAL_OFFSET, subMonths(g, MONTH_NAVIGATION_HORIZONTAL_OFFSET));
            break;
          case "ArrowUp":
            n.handleMonthNavigation(
              // Check if month on the first row
              $[0].includes(h) ? h + 12 - A : h - A,
              subMonths(g, A)
            );
            break;
          case "ArrowDown":
            n.handleMonthNavigation(
              // Check if month on the last row
              $[$.length - 1].includes(h) ? h - 12 + A : h + A,
              addMonths(g, A)
            );
            break;
        }
      }
      _ && _(f);
    }), _defineProperty(n, "onQuarterClick", function(f, h) {
      var p = setQuarter(n.props.day, h);
      isQuarterDisabled(p, n.props) || n.handleDayClick(getStartOfQuarter(p), f);
    }), _defineProperty(n, "onQuarterMouseEnter", function(f) {
      var h = setQuarter(n.props.day, f);
      isQuarterDisabled(h, n.props) || n.handleDayMouseEnter(getStartOfQuarter(h));
    }), _defineProperty(n, "handleQuarterNavigation", function(f, h) {
      n.isDisabled(h) || n.isExcluded(h) || (n.props.setPreSelection(h), n.QUARTER_REFS[f - 1].current && n.QUARTER_REFS[f - 1].current.focus());
    }), _defineProperty(n, "onQuarterKeyDown", function(f, h) {
      var p = f.key;
      if (!n.props.disabledKeyboardNavigation)
        switch (p) {
          case "Enter":
            n.onQuarterClick(f, h), n.props.setPreSelection(n.props.selected);
            break;
          case "ArrowRight":
            n.handleQuarterNavigation(h === 4 ? 1 : h + 1, addQuarters(n.props.preSelection, 1));
            break;
          case "ArrowLeft":
            n.handleQuarterNavigation(h === 1 ? 4 : h - 1, subQuarters(n.props.preSelection, 1));
            break;
        }
    }), _defineProperty(n, "isMonthDisabled", function(f) {
      var h = n.props, p = h.day, v = h.minDate, g = h.maxDate, w = h.excludeDates, E = h.includeDates, T = setMonth(p, f);
      return (v || g || w || E) && isMonthDisabled(T, n.props);
    }), _defineProperty(n, "getMonthClassNames", function(f) {
      var h = n.props, p = h.day, v = h.startDate, g = h.endDate, w = h.selected, E = h.preSelection, T = h.monthClassName, R = T ? T(setMonth(p, f)) : void 0;
      return clsx$1("react-datepicker__month-text", "react-datepicker__month-".concat(f), R, {
        "react-datepicker__month-text--disabled": n.isMonthDisabled(f),
        "react-datepicker__month-text--selected": n.isSelectedMonth(p, f, w),
        "react-datepicker__month-text--keyboard-selected": !n.props.disabledKeyboardNavigation && n.isSelectedMonth(p, f, E),
        "react-datepicker__month-text--in-selecting-range": n.isInSelectingRangeMonth(f),
        "react-datepicker__month-text--in-range": isMonthInRange(v, g, f, p),
        "react-datepicker__month-text--range-start": n.isRangeStartMonth(f),
        "react-datepicker__month-text--range-end": n.isRangeEndMonth(f),
        "react-datepicker__month-text--selecting-range-start": n.isSelectingMonthRangeStart(f),
        "react-datepicker__month-text--selecting-range-end": n.isSelectingMonthRangeEnd(f),
        "react-datepicker__month-text--today": n.isCurrentMonth(p, f)
      });
    }), _defineProperty(n, "getTabIndex", function(f) {
      var h = getMonth(n.props.preSelection), p = !n.props.disabledKeyboardNavigation && f === h ? "0" : "-1";
      return p;
    }), _defineProperty(n, "getQuarterTabIndex", function(f) {
      var h = getQuarter(n.props.preSelection), p = !n.props.disabledKeyboardNavigation && f === h ? "0" : "-1";
      return p;
    }), _defineProperty(n, "getAriaLabel", function(f) {
      var h = n.props, p = h.chooseDayAriaLabelPrefix, v = p === void 0 ? "Choose" : p, g = h.disabledDayAriaLabelPrefix, w = g === void 0 ? "Not available" : g, E = h.day, T = h.locale, R = setMonth(E, f), _ = n.isDisabled(R) || n.isExcluded(R) ? w : v;
      return "".concat(_, " ").concat(formatDate(R, "MMMM yyyy", T));
    }), _defineProperty(n, "getQuarterClassNames", function(f) {
      var h = n.props, p = h.day, v = h.startDate, g = h.endDate, w = h.selected, E = h.minDate, T = h.maxDate, R = h.preSelection, _ = h.disabledKeyboardNavigation;
      return clsx$1("react-datepicker__quarter-text", "react-datepicker__quarter-".concat(f), {
        "react-datepicker__quarter-text--disabled": (E || T) && isQuarterDisabled(setQuarter(p, f), n.props),
        "react-datepicker__quarter-text--selected": n.isSelectedQuarter(p, f, w),
        "react-datepicker__quarter-text--keyboard-selected": !_ && n.isSelectedQuarter(p, f, R),
        "react-datepicker__quarter-text--in-selecting-range": n.isInSelectingRangeQuarter(f),
        "react-datepicker__quarter-text--in-range": isQuarterInRange(v, g, f, p),
        "react-datepicker__quarter-text--range-start": n.isRangeStartQuarter(f),
        "react-datepicker__quarter-text--range-end": n.isRangeEndQuarter(f)
      });
    }), _defineProperty(n, "getMonthContent", function(f) {
      var h = n.props, p = h.showFullMonthYearPicker, v = h.renderMonthContent, g = h.locale, w = h.day, E = getMonthShortInLocale(f, g), T = getMonthInLocale(f, g);
      return v ? v(f, E, T, w) : p ? T : E;
    }), _defineProperty(n, "getQuarterContent", function(f) {
      var h = n.props, p = h.renderQuarterContent, v = h.locale, g = getQuarterShortInLocale(f, v);
      return p ? p(f, g) : g;
    }), _defineProperty(n, "renderMonths", function() {
      var f = n.props, h = f.showTwoColumnMonthYearPicker, p = f.showFourColumnMonthYearPicker, v = f.day, g = f.selected, w = MONTH_COLUMNS[getMonthColumnsLayout(p, h)].grid;
      return w.map(function(E, T) {
        return /* @__PURE__ */ React__default.createElement("div", {
          className: "react-datepicker__month-wrapper",
          key: T
        }, E.map(function(R, _) {
          return /* @__PURE__ */ React__default.createElement("div", {
            ref: n.MONTH_REFS[R],
            key: _,
            onClick: function(M) {
              n.onMonthClick(M, R);
            },
            onKeyDown: function(M) {
              isSpaceKeyDown(M) && (M.preventDefault(), M.key = "Enter"), n.onMonthKeyDown(M, R);
            },
            onMouseEnter: n.props.usePointerEvent ? void 0 : function() {
              return n.onMonthMouseEnter(R);
            },
            onPointerEnter: n.props.usePointerEvent ? function() {
              return n.onMonthMouseEnter(R);
            } : void 0,
            tabIndex: n.getTabIndex(R),
            className: n.getMonthClassNames(R),
            "aria-disabled": n.isMonthDisabled(R),
            role: "option",
            "aria-label": n.getAriaLabel(R),
            "aria-current": n.isCurrentMonth(v, R) ? "date" : void 0,
            "aria-selected": n.isSelectedMonth(v, R, g)
          }, n.getMonthContent(R));
        }));
      });
    }), _defineProperty(n, "renderQuarters", function() {
      var f = n.props, h = f.day, p = f.selected, v = [1, 2, 3, 4];
      return /* @__PURE__ */ React__default.createElement("div", {
        className: "react-datepicker__quarter-wrapper"
      }, v.map(function(g, w) {
        return /* @__PURE__ */ React__default.createElement("div", {
          key: w,
          ref: n.QUARTER_REFS[w],
          role: "option",
          onClick: function(T) {
            n.onQuarterClick(T, g);
          },
          onKeyDown: function(T) {
            n.onQuarterKeyDown(T, g);
          },
          onMouseEnter: n.props.usePointerEvent ? void 0 : function() {
            return n.onQuarterMouseEnter(g);
          },
          onPointerEnter: n.props.usePointerEvent ? function() {
            return n.onQuarterMouseEnter(g);
          } : void 0,
          className: n.getQuarterClassNames(g),
          "aria-selected": n.isSelectedQuarter(h, g, p),
          tabIndex: n.getQuarterTabIndex(g),
          "aria-current": n.isCurrentQuarter(h, g) ? "date" : void 0
        }, n.getQuarterContent(g));
      }));
    }), _defineProperty(n, "getClassNames", function() {
      var f = n.props, h = f.selectingDate, p = f.selectsStart, v = f.selectsEnd, g = f.showMonthYearPicker, w = f.showQuarterYearPicker, E = f.showWeekPicker;
      return clsx$1("react-datepicker__month", {
        "react-datepicker__month--selecting-range": h && (p || v)
      }, {
        "react-datepicker__monthPicker": g
      }, {
        "react-datepicker__quarterPicker": w
      }, {
        "react-datepicker__weekPicker": E
      });
    }), n;
  }
  return _inherits(e, t), _createClass(e, [{
    key: "render",
    value: function() {
      var o = this.props, l = o.showMonthYearPicker, u = o.showQuarterYearPicker, f = o.day, h = o.ariaLabelPrefix, p = h === void 0 ? "Month " : h, v = p ? p.trim() + " " : "";
      return /* @__PURE__ */ React__default.createElement("div", {
        className: this.getClassNames(),
        onMouseLeave: this.props.usePointerEvent ? void 0 : this.handleMouseLeave,
        onPointerLeave: this.props.usePointerEvent ? this.handleMouseLeave : void 0,
        "aria-label": "".concat(v).concat(formatDate(f, "MMMM, yyyy", this.props.locale)),
        role: "listbox"
      }, l ? this.renderMonths() : u ? this.renderQuarters() : this.renderWeeks());
    }
  }]);
}(React__default.Component), Time = /* @__PURE__ */ function(t) {
  function e() {
    var n;
    _classCallCheck(this, e);
    for (var o = arguments.length, l = new Array(o), u = 0; u < o; u++)
      l[u] = arguments[u];
    return n = _callSuper(this, e, [].concat(l)), _defineProperty(n, "state", {
      height: null
    }), _defineProperty(n, "scrollToTheSelectedTime", function() {
      requestAnimationFrame(function() {
        n.list && (n.list.scrollTop = n.centerLi && e.calcCenterPosition(n.props.monthRef ? n.props.monthRef.clientHeight - n.header.clientHeight : n.list.clientHeight, n.centerLi));
      });
    }), _defineProperty(n, "handleClick", function(f) {
      (n.props.minTime || n.props.maxTime) && isTimeInDisabledRange(f, n.props) || (n.props.excludeTimes || n.props.includeTimes || n.props.filterTime) && isTimeDisabled(f, n.props) || n.props.onChange(f);
    }), _defineProperty(n, "isSelectedTime", function(f) {
      return n.props.selected && isSameMinute(n.props.selected, f);
    }), _defineProperty(n, "isDisabledTime", function(f) {
      return (n.props.minTime || n.props.maxTime) && isTimeInDisabledRange(f, n.props) || (n.props.excludeTimes || n.props.includeTimes || n.props.filterTime) && isTimeDisabled(f, n.props);
    }), _defineProperty(n, "liClasses", function(f) {
      var h = ["react-datepicker__time-list-item", n.props.timeClassName ? n.props.timeClassName(f) : void 0];
      return n.isSelectedTime(f) && h.push("react-datepicker__time-list-item--selected"), n.isDisabledTime(f) && h.push("react-datepicker__time-list-item--disabled"), n.props.injectTimes && (getHours(f) * 3600 + getMinutes(f) * 60 + getSeconds(f)) % (n.props.intervals * 60) !== 0 && h.push("react-datepicker__time-list-item--injected"), h.join(" ");
    }), _defineProperty(n, "handleOnKeyDown", function(f, h) {
      f.key === " " && (f.preventDefault(), f.key = "Enter"), (f.key === "ArrowUp" || f.key === "ArrowLeft") && f.target.previousSibling && (f.preventDefault(), f.target.previousSibling.focus()), (f.key === "ArrowDown" || f.key === "ArrowRight") && f.target.nextSibling && (f.preventDefault(), f.target.nextSibling.focus()), f.key === "Enter" && n.handleClick(h), n.props.handleOnKeyDown(f);
    }), _defineProperty(n, "renderTimes", function() {
      for (var f = [], h = n.props.format ? n.props.format : "p", p = n.props.intervals, v = n.props.selected || n.props.openToDate || newDate(), g = getStartOfDay(v), w = n.props.injectTimes && n.props.injectTimes.sort(function(A, $) {
        return A - $;
      }), E = 60 * getHoursInDay(v), T = E / p, R = 0; R < T; R++) {
        var _ = addMinutes(g, R * p);
        if (f.push(_), w) {
          var b = timesToInjectAfter(g, _, R, p, w);
          f = f.concat(b);
        }
      }
      var M = f.reduce(function(A, $) {
        return $.getTime() <= v.getTime() ? $ : A;
      }, f[0]);
      return f.map(function(A, $) {
        return /* @__PURE__ */ React__default.createElement("li", {
          key: $,
          onClick: n.handleClick.bind(n, A),
          className: n.liClasses(A),
          ref: function(C) {
            A === M && (n.centerLi = C);
          },
          onKeyDown: function(C) {
            n.handleOnKeyDown(C, A);
          },
          tabIndex: A === M ? 0 : -1,
          role: "option",
          "aria-selected": n.isSelectedTime(A) ? "true" : void 0,
          "aria-disabled": n.isDisabledTime(A) ? "true" : void 0
        }, formatDate(A, h, n.props.locale));
      });
    }), n;
  }
  return _inherits(e, t), _createClass(e, [{
    key: "componentDidMount",
    value: function() {
      this.scrollToTheSelectedTime(), this.props.monthRef && this.header && this.setState({
        height: this.props.monthRef.clientHeight - this.header.clientHeight
      });
    }
  }, {
    key: "render",
    value: function() {
      var o = this, l = this.state.height;
      return /* @__PURE__ */ React__default.createElement("div", {
        className: "react-datepicker__time-container ".concat(this.props.todayButton ? "react-datepicker__time-container--with-today-button" : "")
      }, /* @__PURE__ */ React__default.createElement("div", {
        className: "react-datepicker__header react-datepicker__header--time ".concat(this.props.showTimeSelectOnly ? "react-datepicker__header--time--only" : ""),
        ref: function(f) {
          o.header = f;
        }
      }, /* @__PURE__ */ React__default.createElement("div", {
        className: "react-datepicker-time__header"
      }, this.props.timeCaption)), /* @__PURE__ */ React__default.createElement("div", {
        className: "react-datepicker__time"
      }, /* @__PURE__ */ React__default.createElement("div", {
        className: "react-datepicker__time-box"
      }, /* @__PURE__ */ React__default.createElement("ul", {
        className: "react-datepicker__time-list",
        ref: function(f) {
          o.list = f;
        },
        style: l ? {
          height: l
        } : {},
        role: "listbox",
        "aria-label": this.props.timeCaption
      }, this.renderTimes()))));
    }
  }], [{
    key: "defaultProps",
    get: function() {
      return {
        intervals: 30,
        onTimeChange: function() {
        },
        todayButton: null,
        timeCaption: "Time"
      };
    }
  }]);
}(React__default.Component);
_defineProperty(Time, "calcCenterPosition", function(t, e) {
  return e.offsetTop - (t / 2 - e.clientHeight / 2);
});
var VERTICAL_NAVIGATION_OFFSET = 3, Year = /* @__PURE__ */ function(t) {
  function e(n) {
    var o;
    return _classCallCheck(this, e), o = _callSuper(this, e, [n]), _defineProperty(o, "YEAR_REFS", _toConsumableArray(Array(o.props.yearItemNumber)).map(function() {
      return /* @__PURE__ */ React__default.createRef();
    })), _defineProperty(o, "isDisabled", function(l) {
      return isDayDisabled(l, o.props);
    }), _defineProperty(o, "isExcluded", function(l) {
      return isDayExcluded(l, o.props);
    }), _defineProperty(o, "selectingDate", function() {
      var l;
      return (l = o.props.selectingDate) !== null && l !== void 0 ? l : o.props.preSelection;
    }), _defineProperty(o, "updateFocusOnPaginate", function(l) {
      var u = (function() {
        this.YEAR_REFS[l].current.focus();
      }).bind(o);
      window.requestAnimationFrame(u);
    }), _defineProperty(o, "handleYearClick", function(l, u) {
      o.props.onDayClick && o.props.onDayClick(l, u);
    }), _defineProperty(o, "handleYearNavigation", function(l, u) {
      var f = o.props, h = f.date, p = f.yearItemNumber, v = getYearsPeriod(h, p), g = v.startPeriod;
      o.isDisabled(u) || o.isExcluded(u) || (o.props.setPreSelection(u), l - g < 0 ? o.updateFocusOnPaginate(p - (g - l)) : l - g >= p ? o.updateFocusOnPaginate(Math.abs(p - (l - g))) : o.YEAR_REFS[l - g].current.focus());
    }), _defineProperty(o, "isSameDay", function(l, u) {
      return isSameDay(l, u);
    }), _defineProperty(o, "isCurrentYear", function(l) {
      return l === getYear(newDate());
    }), _defineProperty(o, "isRangeStart", function(l) {
      return o.props.startDate && o.props.endDate && isSameYear(setYear(newDate(), l), o.props.startDate);
    }), _defineProperty(o, "isRangeEnd", function(l) {
      return o.props.startDate && o.props.endDate && isSameYear(setYear(newDate(), l), o.props.endDate);
    }), _defineProperty(o, "isInRange", function(l) {
      return isYearInRange(l, o.props.startDate, o.props.endDate);
    }), _defineProperty(o, "isInSelectingRange", function(l) {
      var u = o.props, f = u.selectsStart, h = u.selectsEnd, p = u.selectsRange, v = u.startDate, g = u.endDate;
      return !(f || h || p) || !o.selectingDate() ? !1 : f && g ? isYearInRange(l, o.selectingDate(), g) : h && v || p && v && !g ? isYearInRange(l, v, o.selectingDate()) : !1;
    }), _defineProperty(o, "isSelectingRangeStart", function(l) {
      if (!o.isInSelectingRange(l))
        return !1;
      var u = o.props, f = u.startDate, h = u.selectsStart, p = setYear(newDate(), l);
      return h ? isSameYear(p, o.selectingDate()) : isSameYear(p, f);
    }), _defineProperty(o, "isSelectingRangeEnd", function(l) {
      if (!o.isInSelectingRange(l))
        return !1;
      var u = o.props, f = u.endDate, h = u.selectsEnd, p = u.selectsRange, v = setYear(newDate(), l);
      return h || p ? isSameYear(v, o.selectingDate()) : isSameYear(v, f);
    }), _defineProperty(o, "isKeyboardSelected", function(l) {
      var u = getStartOfYear(setYear(o.props.date, l));
      return !o.props.disabledKeyboardNavigation && !o.props.inline && !isSameDay(u, getStartOfYear(o.props.selected)) && isSameDay(u, getStartOfYear(o.props.preSelection));
    }), _defineProperty(o, "onYearClick", function(l, u) {
      var f = o.props.date;
      o.handleYearClick(getStartOfYear(setYear(f, u)), l);
    }), _defineProperty(o, "onYearKeyDown", function(l, u) {
      var f = l.key, h = o.props, p = h.date, v = h.yearItemNumber, g = h.handleOnKeyDown;
      if (f !== "Tab" && l.preventDefault(), !o.props.disabledKeyboardNavigation)
        switch (f) {
          case "Enter":
            o.onYearClick(l, u), o.props.setPreSelection(o.props.selected);
            break;
          case "ArrowRight":
            o.handleYearNavigation(u + 1, addYears(o.props.preSelection, 1));
            break;
          case "ArrowLeft":
            o.handleYearNavigation(u - 1, subYears(o.props.preSelection, 1));
            break;
          case "ArrowUp": {
            var w = getYearsPeriod(p, v), E = w.startPeriod, T = VERTICAL_NAVIGATION_OFFSET, R = u - T;
            if (R < E) {
              var _ = v % T;
              u >= E && u < E + _ ? T = _ : T += _, R = u - T;
            }
            o.handleYearNavigation(R, subYears(o.props.preSelection, T));
            break;
          }
          case "ArrowDown": {
            var b = getYearsPeriod(p, v), M = b.endPeriod, A = VERTICAL_NAVIGATION_OFFSET, $ = u + A;
            if ($ > M) {
              var S = v % A;
              u <= M && u > M - S ? A = S : A += S, $ = u + A;
            }
            o.handleYearNavigation($, addYears(o.props.preSelection, A));
            break;
          }
        }
      g && g(l);
    }), _defineProperty(o, "getYearClassNames", function(l) {
      var u = o.props, f = u.date, h = u.minDate, p = u.maxDate, v = u.selected, g = u.excludeDates, w = u.includeDates, E = u.filterDate, T = u.yearClassName;
      return clsx$1("react-datepicker__year-text", "react-datepicker__year-".concat(l), T ? T(setYear(f, l)) : void 0, {
        "react-datepicker__year-text--selected": l === getYear(v),
        "react-datepicker__year-text--disabled": (h || p || g || w || E) && isYearDisabled(l, o.props),
        "react-datepicker__year-text--keyboard-selected": o.isKeyboardSelected(l),
        "react-datepicker__year-text--range-start": o.isRangeStart(l),
        "react-datepicker__year-text--range-end": o.isRangeEnd(l),
        "react-datepicker__year-text--in-range": o.isInRange(l),
        "react-datepicker__year-text--in-selecting-range": o.isInSelectingRange(l),
        "react-datepicker__year-text--selecting-range-start": o.isSelectingRangeStart(l),
        "react-datepicker__year-text--selecting-range-end": o.isSelectingRangeEnd(l),
        "react-datepicker__year-text--today": o.isCurrentYear(l)
      });
    }), _defineProperty(o, "getYearTabIndex", function(l) {
      if (o.props.disabledKeyboardNavigation) return "-1";
      var u = getYear(o.props.preSelection);
      return l === u ? "0" : "-1";
    }), _defineProperty(o, "getYearContainerClassNames", function() {
      var l = o.props, u = l.selectingDate, f = l.selectsStart, h = l.selectsEnd, p = l.selectsRange;
      return clsx$1("react-datepicker__year", {
        "react-datepicker__year--selecting-range": u && (f || h || p)
      });
    }), _defineProperty(o, "getYearContent", function(l) {
      return o.props.renderYearContent ? o.props.renderYearContent(l) : l;
    }), o;
  }
  return _inherits(e, t), _createClass(e, [{
    key: "render",
    value: function() {
      for (var o = this, l = [], u = this.props, f = u.date, h = u.yearItemNumber, p = u.onYearMouseEnter, v = u.onYearMouseLeave, g = getYearsPeriod(f, h), w = g.startPeriod, E = g.endPeriod, T = function(b) {
        l.push(/* @__PURE__ */ React__default.createElement("div", {
          ref: o.YEAR_REFS[b - w],
          onClick: function(A) {
            o.onYearClick(A, b);
          },
          onKeyDown: function(A) {
            isSpaceKeyDown(A) && (A.preventDefault(), A.key = "Enter"), o.onYearKeyDown(A, b);
          },
          tabIndex: o.getYearTabIndex(b),
          className: o.getYearClassNames(b),
          onMouseEnter: o.props.usePointerEvent ? void 0 : function(M) {
            return p(M, b);
          },
          onPointerEnter: o.props.usePointerEvent ? function(M) {
            return p(M, b);
          } : void 0,
          onMouseLeave: o.props.usePointerEvent ? void 0 : function(M) {
            return v(M, b);
          },
          onPointerLeave: o.props.usePointerEvent ? function(M) {
            return v(M, b);
          } : void 0,
          key: b,
          "aria-current": o.isCurrentYear(b) ? "date" : void 0
        }, o.getYearContent(b)));
      }, R = w; R <= E; R++)
        T(R);
      return /* @__PURE__ */ React__default.createElement("div", {
        className: this.getYearContainerClassNames()
      }, /* @__PURE__ */ React__default.createElement("div", {
        className: "react-datepicker__year-wrapper",
        onMouseLeave: this.props.usePointerEvent ? void 0 : this.props.clearSelectingDate,
        onPointerLeave: this.props.usePointerEvent ? this.props.clearSelectingDate : void 0
      }, l));
    }
  }]);
}(React__default.Component), inputTime = /* @__PURE__ */ function(t) {
  function e(n) {
    var o;
    return _classCallCheck(this, e), o = _callSuper(this, e, [n]), _defineProperty(o, "onTimeChange", function(l) {
      o.setState({
        time: l
      });
      var u = o.props.date, f = u instanceof Date && !isNaN(u), h = f ? u : /* @__PURE__ */ new Date();
      h.setHours(l.split(":")[0]), h.setMinutes(l.split(":")[1]), o.props.onChange(h);
    }), _defineProperty(o, "renderTimeInput", function() {
      var l = o.state.time, u = o.props, f = u.date, h = u.timeString, p = u.customTimeInput;
      return p ? /* @__PURE__ */ React__default.cloneElement(p, {
        date: f,
        value: l,
        onChange: o.onTimeChange
      }) : /* @__PURE__ */ React__default.createElement("input", {
        type: "time",
        className: "react-datepicker-time__input",
        placeholder: "Time",
        name: "time-input",
        required: !0,
        value: l,
        onChange: function(g) {
          o.onTimeChange(g.target.value || h);
        }
      });
    }), o.state = {
      time: o.props.timeString
    }, o;
  }
  return _inherits(e, t), _createClass(e, [{
    key: "render",
    value: function() {
      return /* @__PURE__ */ React__default.createElement("div", {
        className: "react-datepicker__input-time-container"
      }, /* @__PURE__ */ React__default.createElement("div", {
        className: "react-datepicker-time__caption"
      }, this.props.timeInputLabel), /* @__PURE__ */ React__default.createElement("div", {
        className: "react-datepicker-time__input-container"
      }, /* @__PURE__ */ React__default.createElement("div", {
        className: "react-datepicker-time__input"
      }, this.renderTimeInput())));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function(o, l) {
      return o.timeString !== l.time ? {
        time: o.timeString
      } : null;
    }
  }]);
}(React__default.Component);
function CalendarContainer(t) {
  var e = t.showTimeSelectOnly, n = e === void 0 ? !1 : e, o = t.showTime, l = o === void 0 ? !1 : o, u = t.className, f = t.children, h = n ? "Choose Time" : "Choose Date".concat(l ? " and Time" : "");
  return /* @__PURE__ */ React__default.createElement("div", {
    className: u,
    role: "dialog",
    "aria-label": h,
    "aria-modal": "true"
  }, f);
}
var DROPDOWN_FOCUS_CLASSNAMES = ["react-datepicker__year-select", "react-datepicker__month-select", "react-datepicker__month-year-select"], isDropdownSelect = function t() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = (e.className || "").split(/\s+/);
  return DROPDOWN_FOCUS_CLASSNAMES.some(function(o) {
    return n.indexOf(o) >= 0;
  });
}, Calendar = /* @__PURE__ */ function(t) {
  function e(n) {
    var o;
    return _classCallCheck(this, e), o = _callSuper(this, e, [n]), _defineProperty(o, "handleClickOutside", function(l) {
      o.props.onClickOutside(l);
    }), _defineProperty(o, "setClickOutsideRef", function() {
      return o.containerRef.current;
    }), _defineProperty(o, "handleDropdownFocus", function(l) {
      isDropdownSelect(l.target) && o.props.onDropdownFocus();
    }), _defineProperty(o, "getDateInView", function() {
      var l = o.props, u = l.preSelection, f = l.selected, h = l.openToDate, p = getEffectiveMinDate(o.props), v = getEffectiveMaxDate(o.props), g = newDate(), w = h || f || u;
      return w || (p && isBefore(g, p) ? p : v && isAfter(g, v) ? v : g);
    }), _defineProperty(o, "increaseMonth", function() {
      o.setState(function(l) {
        var u = l.date;
        return {
          date: addMonths(u, 1)
        };
      }, function() {
        return o.handleMonthChange(o.state.date);
      });
    }), _defineProperty(o, "decreaseMonth", function() {
      o.setState(function(l) {
        var u = l.date;
        return {
          date: subMonths(u, 1)
        };
      }, function() {
        return o.handleMonthChange(o.state.date);
      });
    }), _defineProperty(o, "handleDayClick", function(l, u, f) {
      o.props.onSelect(l, u, f), o.props.setPreSelection && o.props.setPreSelection(l);
    }), _defineProperty(o, "handleDayMouseEnter", function(l) {
      o.setState({
        selectingDate: l
      }), o.props.onDayMouseEnter && o.props.onDayMouseEnter(l);
    }), _defineProperty(o, "handleMonthMouseLeave", function() {
      o.setState({
        selectingDate: null
      }), o.props.onMonthMouseLeave && o.props.onMonthMouseLeave();
    }), _defineProperty(o, "handleYearMouseEnter", function(l, u) {
      o.setState({
        selectingDate: setYear(newDate(), u)
      }), o.props.onYearMouseEnter && o.props.onYearMouseEnter(l, u);
    }), _defineProperty(o, "handleYearMouseLeave", function(l, u) {
      o.props.onYearMouseLeave && o.props.onYearMouseLeave(l, u);
    }), _defineProperty(o, "handleYearChange", function(l) {
      o.props.onYearChange && (o.props.onYearChange(l), o.setState({
        isRenderAriaLiveMessage: !0
      })), o.props.adjustDateOnChange && (o.props.onSelect && o.props.onSelect(l), o.props.setOpen && o.props.setOpen(!0)), o.props.setPreSelection && o.props.setPreSelection(l);
    }), _defineProperty(o, "handleMonthChange", function(l) {
      o.handleCustomMonthChange(l), o.props.adjustDateOnChange && (o.props.onSelect && o.props.onSelect(l), o.props.setOpen && o.props.setOpen(!0)), o.props.setPreSelection && o.props.setPreSelection(l);
    }), _defineProperty(o, "handleCustomMonthChange", function(l) {
      o.props.onMonthChange && (o.props.onMonthChange(l), o.setState({
        isRenderAriaLiveMessage: !0
      }));
    }), _defineProperty(o, "handleMonthYearChange", function(l) {
      o.handleYearChange(l), o.handleMonthChange(l);
    }), _defineProperty(o, "changeYear", function(l) {
      o.setState(function(u) {
        var f = u.date;
        return {
          date: setYear(f, l)
        };
      }, function() {
        return o.handleYearChange(o.state.date);
      });
    }), _defineProperty(o, "changeMonth", function(l) {
      o.setState(function(u) {
        var f = u.date;
        return {
          date: setMonth(f, l)
        };
      }, function() {
        return o.handleMonthChange(o.state.date);
      });
    }), _defineProperty(o, "changeMonthYear", function(l) {
      o.setState(function(u) {
        var f = u.date;
        return {
          date: setYear(setMonth(f, getMonth(l)), getYear(l))
        };
      }, function() {
        return o.handleMonthYearChange(o.state.date);
      });
    }), _defineProperty(o, "header", function() {
      var l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : o.state.date, u = getStartOfWeek(l, o.props.locale, o.props.calendarStartDay), f = [];
      return o.props.showWeekNumbers && f.push(/* @__PURE__ */ React__default.createElement("div", {
        key: "W",
        className: "react-datepicker__day-name"
      }, o.props.weekLabel || "#")), f.concat([0, 1, 2, 3, 4, 5, 6].map(function(h) {
        var p = addDays(u, h), v = o.formatWeekday(p, o.props.locale), g = o.props.weekDayClassName ? o.props.weekDayClassName(p) : void 0;
        return /* @__PURE__ */ React__default.createElement("div", {
          key: h,
          "aria-label": formatDate(p, "EEEE", o.props.locale),
          className: clsx$1("react-datepicker__day-name", g)
        }, v);
      }));
    }), _defineProperty(o, "formatWeekday", function(l, u) {
      return o.props.formatWeekDay ? getFormattedWeekdayInLocale(l, o.props.formatWeekDay, u) : o.props.useWeekdaysShort ? getWeekdayShortInLocale(l, u) : getWeekdayMinInLocale(l, u);
    }), _defineProperty(o, "decreaseYear", function() {
      o.setState(function(l) {
        var u = l.date;
        return {
          date: subYears(u, o.props.showYearPicker ? o.props.yearItemNumber : 1)
        };
      }, function() {
        return o.handleYearChange(o.state.date);
      });
    }), _defineProperty(o, "clearSelectingDate", function() {
      o.setState({
        selectingDate: null
      });
    }), _defineProperty(o, "renderPreviousButton", function() {
      if (!o.props.renderCustomHeader) {
        var l;
        switch (!0) {
          case o.props.showMonthYearPicker:
            l = yearDisabledBefore(o.state.date, o.props);
            break;
          case o.props.showYearPicker:
            l = yearsDisabledBefore(o.state.date, o.props);
            break;
          case o.props.showQuarterYearPicker:
            l = quarterDisabledBefore(o.state.date, o.props);
            break;
          default:
            l = monthDisabledBefore(o.state.date, o.props);
            break;
        }
        if (!(!o.props.forceShowMonthNavigation && !o.props.showDisabledMonthNavigation && l || o.props.showTimeSelectOnly)) {
          var u = ["react-datepicker__navigation-icon", "react-datepicker__navigation-icon--previous"], f = ["react-datepicker__navigation", "react-datepicker__navigation--previous"], h = o.decreaseMonth;
          (o.props.showMonthYearPicker || o.props.showQuarterYearPicker || o.props.showYearPicker) && (h = o.decreaseYear), l && o.props.showDisabledMonthNavigation && (f.push("react-datepicker__navigation--previous--disabled"), h = null);
          var p = o.props.showMonthYearPicker || o.props.showQuarterYearPicker || o.props.showYearPicker, v = o.props, g = v.previousMonthButtonLabel, w = v.previousYearButtonLabel, E = o.props, T = E.previousMonthAriaLabel, R = T === void 0 ? typeof g == "string" ? g : "Previous Month" : T, _ = E.previousYearAriaLabel, b = _ === void 0 ? typeof w == "string" ? w : "Previous Year" : _;
          return /* @__PURE__ */ React__default.createElement("button", {
            type: "button",
            className: f.join(" "),
            onClick: h,
            onKeyDown: o.props.handleOnKeyDown,
            "aria-label": p ? b : R
          }, /* @__PURE__ */ React__default.createElement("span", {
            className: u.join(" ")
          }, p ? o.props.previousYearButtonLabel : o.props.previousMonthButtonLabel));
        }
      }
    }), _defineProperty(o, "increaseYear", function() {
      o.setState(function(l) {
        var u = l.date;
        return {
          date: addYears(u, o.props.showYearPicker ? o.props.yearItemNumber : 1)
        };
      }, function() {
        return o.handleYearChange(o.state.date);
      });
    }), _defineProperty(o, "renderNextButton", function() {
      if (!o.props.renderCustomHeader) {
        var l;
        switch (!0) {
          case o.props.showMonthYearPicker:
            l = yearDisabledAfter(o.state.date, o.props);
            break;
          case o.props.showYearPicker:
            l = yearsDisabledAfter(o.state.date, o.props);
            break;
          case o.props.showQuarterYearPicker:
            l = quarterDisabledAfter(o.state.date, o.props);
            break;
          default:
            l = monthDisabledAfter(o.state.date, o.props);
            break;
        }
        if (!(!o.props.forceShowMonthNavigation && !o.props.showDisabledMonthNavigation && l || o.props.showTimeSelectOnly)) {
          var u = ["react-datepicker__navigation", "react-datepicker__navigation--next"], f = ["react-datepicker__navigation-icon", "react-datepicker__navigation-icon--next"];
          o.props.showTimeSelect && u.push("react-datepicker__navigation--next--with-time"), o.props.todayButton && u.push("react-datepicker__navigation--next--with-today-button");
          var h = o.increaseMonth;
          (o.props.showMonthYearPicker || o.props.showQuarterYearPicker || o.props.showYearPicker) && (h = o.increaseYear), l && o.props.showDisabledMonthNavigation && (u.push("react-datepicker__navigation--next--disabled"), h = null);
          var p = o.props.showMonthYearPicker || o.props.showQuarterYearPicker || o.props.showYearPicker, v = o.props, g = v.nextMonthButtonLabel, w = v.nextYearButtonLabel, E = o.props, T = E.nextMonthAriaLabel, R = T === void 0 ? typeof g == "string" ? g : "Next Month" : T, _ = E.nextYearAriaLabel, b = _ === void 0 ? typeof w == "string" ? w : "Next Year" : _;
          return /* @__PURE__ */ React__default.createElement("button", {
            type: "button",
            className: u.join(" "),
            onClick: h,
            onKeyDown: o.props.handleOnKeyDown,
            "aria-label": p ? b : R
          }, /* @__PURE__ */ React__default.createElement("span", {
            className: f.join(" ")
          }, p ? o.props.nextYearButtonLabel : o.props.nextMonthButtonLabel));
        }
      }
    }), _defineProperty(o, "renderCurrentMonth", function() {
      var l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : o.state.date, u = ["react-datepicker__current-month"];
      return o.props.showYearDropdown && u.push("react-datepicker__current-month--hasYearDropdown"), o.props.showMonthDropdown && u.push("react-datepicker__current-month--hasMonthDropdown"), o.props.showMonthYearDropdown && u.push("react-datepicker__current-month--hasMonthYearDropdown"), /* @__PURE__ */ React__default.createElement("div", {
        className: u.join(" ")
      }, formatDate(l, o.props.dateFormat, o.props.locale));
    }), _defineProperty(o, "renderYearDropdown", function() {
      var l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
      if (!(!o.props.showYearDropdown || l))
        return /* @__PURE__ */ React__default.createElement(YearDropdown, {
          adjustDateOnChange: o.props.adjustDateOnChange,
          date: o.state.date,
          onSelect: o.props.onSelect,
          setOpen: o.props.setOpen,
          dropdownMode: o.props.dropdownMode,
          onChange: o.changeYear,
          minDate: o.props.minDate,
          maxDate: o.props.maxDate,
          year: getYear(o.state.date),
          scrollableYearDropdown: o.props.scrollableYearDropdown,
          yearDropdownItemNumber: o.props.yearDropdownItemNumber
        });
    }), _defineProperty(o, "renderMonthDropdown", function() {
      var l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
      if (!(!o.props.showMonthDropdown || l))
        return /* @__PURE__ */ React__default.createElement(MonthDropdown, {
          dropdownMode: o.props.dropdownMode,
          locale: o.props.locale,
          onChange: o.changeMonth,
          month: getMonth(o.state.date),
          useShortMonthInDropdown: o.props.useShortMonthInDropdown
        });
    }), _defineProperty(o, "renderMonthYearDropdown", function() {
      var l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
      if (!(!o.props.showMonthYearDropdown || l))
        return /* @__PURE__ */ React__default.createElement(MonthYearDropdown, {
          dropdownMode: o.props.dropdownMode,
          locale: o.props.locale,
          dateFormat: o.props.dateFormat,
          onChange: o.changeMonthYear,
          minDate: o.props.minDate,
          maxDate: o.props.maxDate,
          date: o.state.date,
          scrollableMonthYearDropdown: o.props.scrollableMonthYearDropdown
        });
    }), _defineProperty(o, "handleTodayButtonClick", function(l) {
      o.props.onSelect(getStartOfToday(), l), o.props.setPreSelection && o.props.setPreSelection(getStartOfToday());
    }), _defineProperty(o, "renderTodayButton", function() {
      if (!(!o.props.todayButton || o.props.showTimeSelectOnly))
        return /* @__PURE__ */ React__default.createElement("div", {
          className: "react-datepicker__today-button",
          onClick: function(u) {
            return o.handleTodayButtonClick(u);
          }
        }, o.props.todayButton);
    }), _defineProperty(o, "renderDefaultHeader", function(l) {
      var u = l.monthDate, f = l.i;
      return /* @__PURE__ */ React__default.createElement("div", {
        className: "react-datepicker__header ".concat(o.props.showTimeSelect ? "react-datepicker__header--has-time-select" : "")
      }, o.renderCurrentMonth(u), /* @__PURE__ */ React__default.createElement("div", {
        className: "react-datepicker__header__dropdown react-datepicker__header__dropdown--".concat(o.props.dropdownMode),
        onFocus: o.handleDropdownFocus
      }, o.renderMonthDropdown(f !== 0), o.renderMonthYearDropdown(f !== 0), o.renderYearDropdown(f !== 0)), /* @__PURE__ */ React__default.createElement("div", {
        className: "react-datepicker__day-names"
      }, o.header(u)));
    }), _defineProperty(o, "renderCustomHeader", function() {
      var l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, u = l.monthDate, f = l.i;
      if (o.props.showTimeSelect && !o.state.monthContainer || o.props.showTimeSelectOnly)
        return null;
      var h = monthDisabledBefore(o.state.date, o.props), p = monthDisabledAfter(o.state.date, o.props), v = yearDisabledBefore(o.state.date, o.props), g = yearDisabledAfter(o.state.date, o.props), w = !o.props.showMonthYearPicker && !o.props.showQuarterYearPicker && !o.props.showYearPicker;
      return /* @__PURE__ */ React__default.createElement("div", {
        className: "react-datepicker__header react-datepicker__header--custom",
        onFocus: o.props.onDropdownFocus
      }, o.props.renderCustomHeader(_objectSpread2(_objectSpread2({}, o.state), {}, {
        customHeaderCount: f,
        monthDate: u,
        changeMonth: o.changeMonth,
        changeYear: o.changeYear,
        decreaseMonth: o.decreaseMonth,
        increaseMonth: o.increaseMonth,
        decreaseYear: o.decreaseYear,
        increaseYear: o.increaseYear,
        prevMonthButtonDisabled: h,
        nextMonthButtonDisabled: p,
        prevYearButtonDisabled: v,
        nextYearButtonDisabled: g
      })), w && /* @__PURE__ */ React__default.createElement("div", {
        className: "react-datepicker__day-names"
      }, o.header(u)));
    }), _defineProperty(o, "renderYearHeader", function(l) {
      var u = l.monthDate, f = o.props, h = f.showYearPicker, p = f.yearItemNumber, v = getYearsPeriod(u, p), g = v.startPeriod, w = v.endPeriod;
      return /* @__PURE__ */ React__default.createElement("div", {
        className: "react-datepicker__header react-datepicker-year-header"
      }, h ? "".concat(g, " - ").concat(w) : getYear(u));
    }), _defineProperty(o, "renderHeader", function(l) {
      switch (!0) {
        case o.props.renderCustomHeader !== void 0:
          return o.renderCustomHeader(l);
        case (o.props.showMonthYearPicker || o.props.showQuarterYearPicker || o.props.showYearPicker):
          return o.renderYearHeader(l);
        default:
          return o.renderDefaultHeader(l);
      }
    }), _defineProperty(o, "renderMonths", function() {
      var l;
      if (!(o.props.showTimeSelectOnly || o.props.showYearPicker)) {
        for (var u = [], f = o.props.showPreviousMonths ? o.props.monthsShown - 1 : 0, h = o.props.showMonthYearPicker || o.props.showQuarterYearPicker ? addYears(o.state.date, f) : subMonths(o.state.date, f), p = (l = o.props.monthSelectedIn) !== null && l !== void 0 ? l : f, v = 0; v < o.props.monthsShown; ++v) {
          var g = v - p + f, w = o.props.showMonthYearPicker || o.props.showQuarterYearPicker ? addYears(h, g) : addMonths(h, g), E = "month-".concat(v), T = v < o.props.monthsShown - 1, R = v > 0;
          u.push(/* @__PURE__ */ React__default.createElement("div", {
            key: E,
            ref: function(b) {
              o.monthContainer = b;
            },
            className: "react-datepicker__month-container"
          }, o.renderHeader({
            monthDate: w,
            i: v
          }), /* @__PURE__ */ React__default.createElement(Month, {
            chooseDayAriaLabelPrefix: o.props.chooseDayAriaLabelPrefix,
            disabledDayAriaLabelPrefix: o.props.disabledDayAriaLabelPrefix,
            weekAriaLabelPrefix: o.props.weekAriaLabelPrefix,
            ariaLabelPrefix: o.props.monthAriaLabelPrefix,
            onChange: o.changeMonthYear,
            day: w,
            dayClassName: o.props.dayClassName,
            calendarStartDay: o.props.calendarStartDay,
            monthClassName: o.props.monthClassName,
            onDayClick: o.handleDayClick,
            handleOnKeyDown: o.props.handleOnDayKeyDown,
            handleOnMonthKeyDown: o.props.handleOnKeyDown,
            usePointerEvent: o.props.usePointerEvent,
            onDayMouseEnter: o.handleDayMouseEnter,
            onMouseLeave: o.handleMonthMouseLeave,
            onWeekSelect: o.props.onWeekSelect,
            orderInDisplay: v,
            formatWeekNumber: o.props.formatWeekNumber,
            locale: o.props.locale,
            minDate: o.props.minDate,
            maxDate: o.props.maxDate,
            excludeDates: o.props.excludeDates,
            excludeDateIntervals: o.props.excludeDateIntervals,
            highlightDates: o.props.highlightDates,
            holidays: o.props.holidays,
            selectingDate: o.state.selectingDate,
            includeDates: o.props.includeDates,
            includeDateIntervals: o.props.includeDateIntervals,
            inline: o.props.inline,
            shouldFocusDayInline: o.props.shouldFocusDayInline,
            fixedHeight: o.props.fixedHeight,
            filterDate: o.props.filterDate,
            preSelection: o.props.preSelection,
            setPreSelection: o.props.setPreSelection,
            selected: o.props.selected,
            selectsStart: o.props.selectsStart,
            selectsEnd: o.props.selectsEnd,
            selectsRange: o.props.selectsRange,
            selectsDisabledDaysInRange: o.props.selectsDisabledDaysInRange,
            selectsMultiple: o.props.selectsMultiple,
            selectedDates: o.props.selectedDates,
            showWeekNumbers: o.props.showWeekNumbers,
            startDate: o.props.startDate,
            endDate: o.props.endDate,
            peekNextMonth: o.props.peekNextMonth,
            setOpen: o.props.setOpen,
            shouldCloseOnSelect: o.props.shouldCloseOnSelect,
            renderDayContents: o.props.renderDayContents,
            renderMonthContent: o.props.renderMonthContent,
            renderQuarterContent: o.props.renderQuarterContent,
            renderYearContent: o.props.renderYearContent,
            disabledKeyboardNavigation: o.props.disabledKeyboardNavigation,
            showMonthYearPicker: o.props.showMonthYearPicker,
            showFullMonthYearPicker: o.props.showFullMonthYearPicker,
            showTwoColumnMonthYearPicker: o.props.showTwoColumnMonthYearPicker,
            showFourColumnMonthYearPicker: o.props.showFourColumnMonthYearPicker,
            showYearPicker: o.props.showYearPicker,
            showQuarterYearPicker: o.props.showQuarterYearPicker,
            showWeekPicker: o.props.showWeekPicker,
            isInputFocused: o.props.isInputFocused,
            containerRef: o.containerRef,
            monthShowsDuplicateDaysEnd: T,
            monthShowsDuplicateDaysStart: R
          })));
        }
        return u;
      }
    }), _defineProperty(o, "renderYears", function() {
      if (!o.props.showTimeSelectOnly && o.props.showYearPicker)
        return /* @__PURE__ */ React__default.createElement("div", {
          className: "react-datepicker__year--container"
        }, o.renderHeader({
          monthDate: o.state.date
        }), /* @__PURE__ */ React__default.createElement(Year, _extends({
          onDayClick: o.handleDayClick,
          selectingDate: o.state.selectingDate,
          clearSelectingDate: o.clearSelectingDate,
          date: o.state.date
        }, o.props, {
          onYearMouseEnter: o.handleYearMouseEnter,
          onYearMouseLeave: o.handleYearMouseLeave
        })));
    }), _defineProperty(o, "renderTimeSection", function() {
      if (o.props.showTimeSelect && (o.state.monthContainer || o.props.showTimeSelectOnly))
        return /* @__PURE__ */ React__default.createElement(Time, {
          selected: o.props.selected,
          openToDate: o.props.openToDate,
          onChange: o.props.onTimeChange,
          timeClassName: o.props.timeClassName,
          format: o.props.timeFormat,
          includeTimes: o.props.includeTimes,
          intervals: o.props.timeIntervals,
          minTime: o.props.minTime,
          maxTime: o.props.maxTime,
          excludeTimes: o.props.excludeTimes,
          filterTime: o.props.filterTime,
          timeCaption: o.props.timeCaption,
          todayButton: o.props.todayButton,
          showMonthDropdown: o.props.showMonthDropdown,
          showMonthYearDropdown: o.props.showMonthYearDropdown,
          showYearDropdown: o.props.showYearDropdown,
          withPortal: o.props.withPortal,
          monthRef: o.state.monthContainer,
          injectTimes: o.props.injectTimes,
          locale: o.props.locale,
          handleOnKeyDown: o.props.handleOnKeyDown,
          showTimeSelectOnly: o.props.showTimeSelectOnly
        });
    }), _defineProperty(o, "renderInputTimeSection", function() {
      var l = new Date(o.props.selected), u = isValid(l) && !!o.props.selected, f = u ? "".concat(addZero(l.getHours()), ":").concat(addZero(l.getMinutes())) : "";
      if (o.props.showTimeInput)
        return /* @__PURE__ */ React__default.createElement(inputTime, {
          date: l,
          timeString: f,
          timeInputLabel: o.props.timeInputLabel,
          onChange: o.props.onTimeChange,
          customTimeInput: o.props.customTimeInput
        });
    }), _defineProperty(o, "renderAriaLiveRegion", function() {
      var l = getYearsPeriod(o.state.date, o.props.yearItemNumber), u = l.startPeriod, f = l.endPeriod, h;
      return o.props.showYearPicker ? h = "".concat(u, " - ").concat(f) : o.props.showMonthYearPicker || o.props.showQuarterYearPicker ? h = getYear(o.state.date) : h = "".concat(getMonthInLocale(getMonth(o.state.date), o.props.locale), " ").concat(getYear(o.state.date)), /* @__PURE__ */ React__default.createElement("span", {
        role: "alert",
        "aria-live": "polite",
        className: "react-datepicker__aria-live"
      }, o.state.isRenderAriaLiveMessage && h);
    }), _defineProperty(o, "renderChildren", function() {
      if (o.props.children)
        return /* @__PURE__ */ React__default.createElement("div", {
          className: "react-datepicker__children-container"
        }, o.props.children);
    }), o.containerRef = /* @__PURE__ */ React__default.createRef(), o.state = {
      date: o.getDateInView(),
      selectingDate: null,
      monthContainer: null,
      isRenderAriaLiveMessage: !1
    }, o;
  }
  return _inherits(e, t), _createClass(e, [{
    key: "componentDidMount",
    value: function() {
      var o = this;
      this.props.showTimeSelect && (this.assignMonthContainer = function() {
        o.setState({
          monthContainer: o.monthContainer
        });
      }());
    }
  }, {
    key: "componentDidUpdate",
    value: function(o) {
      var l = this;
      if (this.props.preSelection && (!isSameDay(this.props.preSelection, o.preSelection) || this.props.monthSelectedIn !== o.monthSelectedIn)) {
        var u = !isSameMonth(this.state.date, this.props.preSelection);
        this.setState({
          date: this.props.preSelection
        }, function() {
          return u && l.handleCustomMonthChange(l.state.date);
        });
      } else this.props.openToDate && !isSameDay(this.props.openToDate, o.openToDate) && this.setState({
        date: this.props.openToDate
      });
    }
  }, {
    key: "render",
    value: function() {
      var o = this.props.container || CalendarContainer;
      return /* @__PURE__ */ React__default.createElement("div", {
        style: {
          display: "contents"
        },
        ref: this.containerRef
      }, /* @__PURE__ */ React__default.createElement(o, {
        className: clsx$1("react-datepicker", this.props.className, {
          "react-datepicker--time-only": this.props.showTimeSelectOnly
        }),
        showTime: this.props.showTimeSelect || this.props.showTimeInput,
        showTimeSelectOnly: this.props.showTimeSelectOnly
      }, this.renderAriaLiveRegion(), this.renderPreviousButton(), this.renderNextButton(), this.renderMonths(), this.renderYears(), this.renderTodayButton(), this.renderTimeSection(), this.renderInputTimeSection(), this.renderChildren()));
    }
  }], [{
    key: "defaultProps",
    get: function() {
      return {
        onDropdownFocus: function() {
        },
        monthsShown: 1,
        forceShowMonthNavigation: !1,
        timeCaption: "Time",
        previousYearButtonLabel: "Previous Year",
        nextYearButtonLabel: "Next Year",
        previousMonthButtonLabel: "Previous Month",
        nextMonthButtonLabel: "Next Month",
        customTimeInput: null,
        yearItemNumber: DEFAULT_YEAR_ITEM_NUMBER
      };
    }
  }]);
}(React__default.Component), CalendarIcon = function t(e) {
  var n = e.icon, o = e.className, l = o === void 0 ? "" : o, u = e.onClick, f = "react-datepicker__calendar-icon";
  return /* @__PURE__ */ React__default.isValidElement(n) ? /* @__PURE__ */ React__default.cloneElement(n, {
    className: "".concat(n.props.className || "", " ").concat(f, " ").concat(l),
    onClick: function(p) {
      typeof n.props.onClick == "function" && n.props.onClick(p), typeof u == "function" && u(p);
    }
  }) : typeof n == "string" ? /* @__PURE__ */ React__default.createElement("i", {
    className: "".concat(f, " ").concat(n, " ").concat(l),
    "aria-hidden": "true",
    onClick: u
  }) : /* @__PURE__ */ React__default.createElement("svg", {
    className: "".concat(f, " ").concat(l),
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 448 512",
    onClick: u
  }, /* @__PURE__ */ React__default.createElement("path", {
    d: "M96 32V64H48C21.5 64 0 85.5 0 112v48H448V112c0-26.5-21.5-48-48-48H352V32c0-17.7-14.3-32-32-32s-32 14.3-32 32V64H160V32c0-17.7-14.3-32-32-32S96 14.3 96 32zM448 192H0V464c0 26.5 21.5 48 48 48H400c26.5 0 48-21.5 48-48V192z"
  }));
}, CalendarIcon$1 = CalendarIcon, Portal = /* @__PURE__ */ function(t) {
  function e(n) {
    var o;
    return _classCallCheck(this, e), o = _callSuper(this, e, [n]), o.el = document.createElement("div"), o;
  }
  return _inherits(e, t), _createClass(e, [{
    key: "componentDidMount",
    value: function() {
      this.portalRoot = (this.props.portalHost || document).getElementById(this.props.portalId), this.portalRoot || (this.portalRoot = document.createElement("div"), this.portalRoot.setAttribute("id", this.props.portalId), (this.props.portalHost || document.body).appendChild(this.portalRoot)), this.portalRoot.appendChild(this.el);
    }
  }, {
    key: "componentWillUnmount",
    value: function() {
      this.portalRoot.removeChild(this.el);
    }
  }, {
    key: "render",
    value: function() {
      return /* @__PURE__ */ ReactDOM__default.createPortal(this.props.children, this.el);
    }
  }]);
}(React__default.Component), focusableElementsSelector = "[tabindex], a, button, input, select, textarea", focusableFilter = function t(e) {
  return !e.disabled && e.tabIndex !== -1;
}, TabLoop = /* @__PURE__ */ function(t) {
  function e(n) {
    var o;
    return _classCallCheck(this, e), o = _callSuper(this, e, [n]), _defineProperty(o, "getTabChildren", function() {
      return Array.prototype.slice.call(o.tabLoopRef.current.querySelectorAll(focusableElementsSelector), 1, -1).filter(focusableFilter);
    }), _defineProperty(o, "handleFocusStart", function() {
      var l = o.getTabChildren();
      l && l.length > 1 && l[l.length - 1].focus();
    }), _defineProperty(o, "handleFocusEnd", function() {
      var l = o.getTabChildren();
      l && l.length > 1 && l[0].focus();
    }), o.tabLoopRef = /* @__PURE__ */ React__default.createRef(), o;
  }
  return _inherits(e, t), _createClass(e, [{
    key: "render",
    value: function() {
      return this.props.enableTabLoop ? /* @__PURE__ */ React__default.createElement("div", {
        className: "react-datepicker__tab-loop",
        ref: this.tabLoopRef
      }, /* @__PURE__ */ React__default.createElement("div", {
        className: "react-datepicker__tab-loop__start",
        tabIndex: "0",
        onFocus: this.handleFocusStart
      }), this.props.children, /* @__PURE__ */ React__default.createElement("div", {
        className: "react-datepicker__tab-loop__end",
        tabIndex: "0",
        onFocus: this.handleFocusEnd
      })) : this.props.children;
    }
  }], [{
    key: "defaultProps",
    get: function() {
      return {
        enableTabLoop: !0
      };
    }
  }]);
}(React__default.Component);
function withFloating(t) {
  var e = function(o) {
    var l = _objectSpread2(_objectSpread2({}, o), {}, {
      popperModifiers: o.popperModifiers || [],
      popperProps: o.popperProps || {},
      hidePopper: typeof o.hidePopper == "boolean" ? o.hidePopper : !0
    }), u = React__default.useRef(), f = useFloating(_objectSpread2({
      open: !l.hidePopper,
      whileElementsMounted: autoUpdate,
      placement: l.popperPlacement,
      middleware: [flip({
        padding: 15
      }), offset(10), arrow({
        element: u
      })].concat(_toConsumableArray(l.popperModifiers))
    }, l.popperProps));
    return /* @__PURE__ */ React__default.createElement(t, _extends({}, l, {
      popperProps: _objectSpread2(_objectSpread2({}, f), {}, {
        arrowRef: u
      })
    }));
  };
  return e;
}
var PopperComponent = /* @__PURE__ */ function(t) {
  function e() {
    return _classCallCheck(this, e), _callSuper(this, e, arguments);
  }
  return _inherits(e, t), _createClass(e, [{
    key: "render",
    value: function() {
      var o = this.props, l = o.className, u = o.wrapperClassName, f = o.hidePopper, h = o.popperComponent, p = o.targetComponent, v = o.enableTabLoop, g = o.popperOnKeyDown, w = o.portalId, E = o.portalHost, T = o.popperProps, R = o.showArrow, _;
      if (!f) {
        var b = clsx$1("react-datepicker-popper", l);
        _ = /* @__PURE__ */ React__default.createElement(TabLoop, {
          enableTabLoop: v
        }, /* @__PURE__ */ React__default.createElement("div", {
          ref: T.refs.setFloating,
          style: T.floatingStyles,
          className: b,
          "data-placement": T.placement,
          onKeyDown: g
        }, h, R && /* @__PURE__ */ React__default.createElement(FloatingArrow, {
          ref: T.arrowRef,
          context: T.context,
          fill: "currentColor",
          strokeWidth: 1,
          height: 8,
          width: 16,
          style: {
            transform: "translateY(-1px)"
          },
          className: "react-datepicker__triangle"
        })));
      }
      this.props.popperContainer && (_ = /* @__PURE__ */ React__default.createElement(this.props.popperContainer, {}, _)), w && !f && (_ = /* @__PURE__ */ React__default.createElement(Portal, {
        portalId: w,
        portalHost: E
      }, _));
      var M = clsx$1("react-datepicker-wrapper", u);
      return /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, /* @__PURE__ */ React__default.createElement("div", {
        ref: T.refs.setReference,
        className: M
      }, p), _);
    }
  }], [{
    key: "defaultProps",
    get: function() {
      return {
        hidePopper: !0
      };
    }
  }]);
}(React__default.Component), PopperComponent$1 = withFloating(PopperComponent), outsideClickIgnoreClass = "react-datepicker-ignore-onclickoutside", WrappedCalendar = onClickOutsideHOC(Calendar);
function hasPreSelectionChanged(t, e) {
  return t && e ? getMonth(t) !== getMonth(e) || getYear(t) !== getYear(e) : t !== e;
}
var INPUT_ERR_1 = "Date input not valid.", DatePicker = /* @__PURE__ */ function(t) {
  function e(n) {
    var o;
    return _classCallCheck(this, e), o = _callSuper(this, e, [n]), _defineProperty(o, "getPreSelection", function() {
      return o.props.openToDate ? o.props.openToDate : o.props.selectsEnd && o.props.startDate ? o.props.startDate : o.props.selectsStart && o.props.endDate ? o.props.endDate : newDate();
    }), _defineProperty(o, "modifyHolidays", function() {
      var l;
      return (l = o.props.holidays) === null || l === void 0 ? void 0 : l.reduce(function(u, f) {
        var h = new Date(f.date);
        return isValid$1(h) ? [].concat(_toConsumableArray(u), [_objectSpread2(_objectSpread2({}, f), {}, {
          date: h
        })]) : u;
      }, []);
    }), _defineProperty(o, "calcInitialState", function() {
      var l, u = o.getPreSelection(), f = getEffectiveMinDate(o.props), h = getEffectiveMaxDate(o.props), p = f && isBefore(u, startOfDay(f)) ? f : h && isAfter(u, endOfDay(h)) ? h : u;
      return {
        open: o.props.startOpen || !1,
        preventFocus: !1,
        preSelection: (l = o.props.selectsRange ? o.props.startDate : o.props.selected) !== null && l !== void 0 ? l : p,
        // transforming highlighted days (perhaps nested array)
        // to flat Map for faster access in day.jsx
        highlightDates: getHightLightDaysMap(o.props.highlightDates),
        focused: !1,
        // used to focus day in inline version after month has changed, but not on
        // initial render
        shouldFocusDayInline: !1,
        isRenderAriaLiveMessage: !1
      };
    }), _defineProperty(o, "clearPreventFocusTimeout", function() {
      o.preventFocusTimeout && clearTimeout(o.preventFocusTimeout);
    }), _defineProperty(o, "setFocus", function() {
      o.input && o.input.focus && o.input.focus({
        preventScroll: !0
      });
    }), _defineProperty(o, "setBlur", function() {
      o.input && o.input.blur && o.input.blur(), o.cancelFocusInput();
    }), _defineProperty(o, "setOpen", function(l) {
      var u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
      o.setState({
        open: l,
        preSelection: l && o.state.open ? o.state.preSelection : o.calcInitialState().preSelection,
        lastPreSelectChange: PRESELECT_CHANGE_VIA_NAVIGATE
      }, function() {
        l || o.setState(function(f) {
          return {
            focused: u ? f.focused : !1
          };
        }, function() {
          !u && o.setBlur(), o.setState({
            inputValue: null
          });
        });
      });
    }), _defineProperty(o, "inputOk", function() {
      return isDate(o.state.preSelection);
    }), _defineProperty(o, "isCalendarOpen", function() {
      return o.props.open === void 0 ? o.state.open && !o.props.disabled && !o.props.readOnly : o.props.open;
    }), _defineProperty(o, "handleFocus", function(l) {
      o.state.preventFocus || (o.props.onFocus(l), !o.props.preventOpenOnFocus && !o.props.readOnly && o.setOpen(!0)), o.setState({
        focused: !0
      });
    }), _defineProperty(o, "sendFocusBackToInput", function() {
      o.preventFocusTimeout && o.clearPreventFocusTimeout(), o.setState({
        preventFocus: !0
      }, function() {
        o.preventFocusTimeout = setTimeout(function() {
          o.setFocus(), o.setState({
            preventFocus: !1
          });
        });
      });
    }), _defineProperty(o, "cancelFocusInput", function() {
      clearTimeout(o.inputFocusTimeout), o.inputFocusTimeout = null;
    }), _defineProperty(o, "deferFocusInput", function() {
      o.cancelFocusInput(), o.inputFocusTimeout = setTimeout(function() {
        return o.setFocus();
      }, 1);
    }), _defineProperty(o, "handleDropdownFocus", function() {
      o.cancelFocusInput();
    }), _defineProperty(o, "handleBlur", function(l) {
      (!o.state.open || o.props.withPortal || o.props.showTimeInput) && o.props.onBlur(l), o.setState({
        focused: !1
      });
    }), _defineProperty(o, "handleCalendarClickOutside", function(l) {
      o.props.inline || o.setOpen(!1), o.props.onClickOutside(l), o.props.withPortal && l.preventDefault();
    }), _defineProperty(o, "handleChange", function() {
      for (var l = arguments.length, u = new Array(l), f = 0; f < l; f++)
        u[f] = arguments[f];
      var h = u[0];
      if (!(o.props.onChangeRaw && (o.props.onChangeRaw.apply(o, u), typeof h.isDefaultPrevented != "function" || h.isDefaultPrevented()))) {
        o.setState({
          inputValue: h.target.value,
          lastPreSelectChange: PRESELECT_CHANGE_VIA_INPUT
        });
        var p = parseDate(h.target.value, o.props.dateFormat, o.props.locale, o.props.strictParsing, o.props.minDate);
        o.props.showTimeSelectOnly && o.props.selected && p && !isSameDay(p, o.props.selected) && (p = set(o.props.selected, {
          hours: getHours(p),
          minutes: getMinutes(p),
          seconds: getSeconds(p)
        })), (p || !h.target.value) && o.setSelected(p, h, !0);
      }
    }), _defineProperty(o, "handleSelect", function(l, u, f) {
      if (o.props.shouldCloseOnSelect && !o.props.showTimeSelect && o.sendFocusBackToInput(), o.props.onChangeRaw && o.props.onChangeRaw(u), o.setSelected(l, u, !1, f), o.props.showDateSelect && o.setState({
        isRenderAriaLiveMessage: !0
      }), !o.props.shouldCloseOnSelect || o.props.showTimeSelect)
        o.setPreSelection(l);
      else if (!o.props.inline) {
        o.props.selectsRange || o.setOpen(!1);
        var h = o.props, p = h.startDate, v = h.endDate;
        p && !v && (o.props.swapRange || !isDateBefore(l, p)) && o.setOpen(!1);
      }
    }), _defineProperty(o, "setSelected", function(l, u, f, h) {
      var p = l;
      if (o.props.showYearPicker) {
        if (p !== null && isYearDisabled(getYear(p), o.props))
          return;
      } else if (o.props.showMonthYearPicker) {
        if (p !== null && isMonthDisabled(p, o.props))
          return;
      } else if (p !== null && isDayDisabled(p, o.props))
        return;
      var v = o.props, g = v.onChange, w = v.selectsRange, E = v.startDate, T = v.endDate, R = v.selectsMultiple, _ = v.selectedDates, b = v.minTime, M = v.swapRange;
      if (!isEqual(o.props.selected, p) || o.props.allowSameDay || w || R)
        if (p !== null && (o.props.selected && (!f || !o.props.showTimeSelect && !o.props.showTimeSelectOnly && !o.props.showTimeInput) && (p = setTime(p, {
          hour: getHours(o.props.selected),
          minute: getMinutes(o.props.selected),
          second: getSeconds(o.props.selected)
        })), !f && (o.props.showTimeSelect || o.props.showTimeSelectOnly) && b && (p = setTime(p, {
          hour: b.getHours(),
          minute: b.getMinutes(),
          second: b.getSeconds()
        })), o.props.inline || o.setState({
          preSelection: p
        }), o.props.focusSelectedMonth || o.setState({
          monthSelectedIn: h
        })), w) {
          var A = !E && !T, $ = E && !T, S = E && T;
          A ? g([p, null], u) : $ && (p === null ? g([null, null], u) : isDateBefore(p, E) ? g(M ? [p, E] : [p, null], u) : g([E, p], u)), S && g([p, null], u);
        } else if (R)
          if (!(_ != null && _.length))
            g([p], u);
          else {
            var C = _.some(function(O) {
              return isSameDay(O, p);
            });
            if (C) {
              var D = _.filter(function(O) {
                return !isSameDay(O, p);
              });
              g(D, u);
            } else
              g([].concat(_toConsumableArray(_), [p]), u);
          }
        else
          g(p, u);
      f || (o.props.onSelect(p, u), o.setState({
        inputValue: null
      }));
    }), _defineProperty(o, "setPreSelection", function(l) {
      var u = typeof o.props.minDate < "u", f = typeof o.props.maxDate < "u", h = !0;
      if (l) {
        var p = startOfDay(l);
        if (u && f)
          h = isDayInRange(l, o.props.minDate, o.props.maxDate);
        else if (u) {
          var v = startOfDay(o.props.minDate);
          h = isAfter(l, v) || isEqual(p, v);
        } else if (f) {
          var g = endOfDay(o.props.maxDate);
          h = isBefore(l, g) || isEqual(p, g);
        }
      }
      h && o.setState({
        preSelection: l
      });
    }), _defineProperty(o, "toggleCalendar", function() {
      o.setOpen(!o.state.open);
    }), _defineProperty(o, "handleTimeChange", function(l) {
      var u = o.props.selected ? o.props.selected : o.getPreSelection(), f = o.props.selected ? l : setTime(u, {
        hour: getHours(l),
        minute: getMinutes(l)
      });
      o.setState({
        preSelection: f
      }), o.props.onChange(f), o.props.shouldCloseOnSelect && (o.sendFocusBackToInput(), o.setOpen(!1)), o.props.showTimeInput && o.setOpen(!0), (o.props.showTimeSelectOnly || o.props.showTimeSelect) && o.setState({
        isRenderAriaLiveMessage: !0
      }), o.setState({
        inputValue: null
      });
    }), _defineProperty(o, "onInputClick", function() {
      !o.props.disabled && !o.props.readOnly && o.setOpen(!0), o.props.onInputClick();
    }), _defineProperty(o, "onInputKeyDown", function(l) {
      o.props.onKeyDown(l);
      var u = l.key;
      if (!o.state.open && !o.props.inline && !o.props.preventOpenOnFocus) {
        (u === "ArrowDown" || u === "ArrowUp" || u === "Enter") && o.onInputClick();
        return;
      }
      if (o.state.open) {
        if (u === "ArrowDown" || u === "ArrowUp") {
          l.preventDefault();
          var f = o.props.showWeekPicker && o.props.showWeekNumbers ? '.react-datepicker__week-number[tabindex="0"]' : o.props.showFullMonthYearPicker || o.props.showMonthYearPicker ? '.react-datepicker__month-text[tabindex="0"]' : '.react-datepicker__day[tabindex="0"]', h = o.calendar.componentNode && o.calendar.componentNode.querySelector(f);
          h && h.focus({
            preventScroll: !0
          });
          return;
        }
        var p = newDate(o.state.preSelection);
        u === "Enter" ? (l.preventDefault(), o.inputOk() && o.state.lastPreSelectChange === PRESELECT_CHANGE_VIA_NAVIGATE ? (o.handleSelect(p, l), !o.props.shouldCloseOnSelect && o.setPreSelection(p)) : o.setOpen(!1)) : u === "Escape" ? (l.preventDefault(), o.sendFocusBackToInput(), o.setOpen(!1)) : u === "Tab" && o.setOpen(!1), o.inputOk() || o.props.onInputError({
          code: 1,
          msg: INPUT_ERR_1
        });
      }
    }), _defineProperty(o, "onPortalKeyDown", function(l) {
      var u = l.key;
      u === "Escape" && (l.preventDefault(), o.setState({
        preventFocus: !0
      }, function() {
        o.setOpen(!1), setTimeout(function() {
          o.setFocus(), o.setState({
            preventFocus: !1
          });
        });
      }));
    }), _defineProperty(o, "onDayKeyDown", function(l) {
      o.props.onKeyDown(l);
      var u = l.key, f = l.shiftKey, h = newDate(o.state.preSelection);
      if (u === "Enter")
        l.preventDefault(), o.handleSelect(h, l), !o.props.shouldCloseOnSelect && o.setPreSelection(h);
      else if (u === "Escape")
        l.preventDefault(), o.setOpen(!1), o.inputOk() || o.props.onInputError({
          code: 1,
          msg: INPUT_ERR_1
        });
      else if (!o.props.disabledKeyboardNavigation) {
        var p;
        switch (u) {
          case "ArrowLeft":
            o.props.showWeekPicker ? p = subWeeks(h, 1) : p = subDays(h, 1);
            break;
          case "ArrowRight":
            o.props.showWeekPicker ? p = addWeeks(h, 1) : p = addDays(h, 1);
            break;
          case "ArrowUp":
            p = subWeeks(h, 1);
            break;
          case "ArrowDown":
            p = addWeeks(h, 1);
            break;
          case "PageUp":
            p = f ? subYears(h, 1) : subMonths(h, 1);
            break;
          case "PageDown":
            p = f ? addYears(h, 1) : addMonths(h, 1);
            break;
          case "Home":
            p = getStartOfWeek(h, o.props.locale, o.props.calendarStartDay);
            break;
          case "End":
            p = getEndOfWeek(h);
            break;
          default:
            p = null;
            break;
        }
        if (!p) {
          o.props.onInputError && o.props.onInputError({
            code: 1,
            msg: INPUT_ERR_1
          });
          return;
        }
        if (l.preventDefault(), o.setState({
          lastPreSelectChange: PRESELECT_CHANGE_VIA_NAVIGATE
        }), o.props.adjustDateOnChange && o.setSelected(p), o.setPreSelection(p), o.props.inline) {
          var v = getMonth(h), g = getMonth(p), w = getYear(h), E = getYear(p);
          v !== g || w !== E ? o.setState({
            shouldFocusDayInline: !0
          }) : o.setState({
            shouldFocusDayInline: !1
          });
        }
      }
    }), _defineProperty(o, "onPopperKeyDown", function(l) {
      var u = l.key;
      u === "Escape" && (l.preventDefault(), o.sendFocusBackToInput());
    }), _defineProperty(o, "onClearClick", function(l) {
      l && l.preventDefault && l.preventDefault(), o.sendFocusBackToInput(), o.props.selectsRange ? o.props.onChange([null, null], l) : o.props.onChange(null, l), o.setState({
        inputValue: null
      });
    }), _defineProperty(o, "clear", function() {
      o.onClearClick();
    }), _defineProperty(o, "onScroll", function(l) {
      typeof o.props.closeOnScroll == "boolean" && o.props.closeOnScroll ? (l.target === document || l.target === document.documentElement || l.target === document.body) && o.setOpen(!1) : typeof o.props.closeOnScroll == "function" && o.props.closeOnScroll(l) && o.setOpen(!1);
    }), _defineProperty(o, "renderCalendar", function() {
      return !o.props.inline && !o.isCalendarOpen() ? null : /* @__PURE__ */ React__default.createElement(WrappedCalendar, {
        ref: function(u) {
          o.calendar = u;
        },
        locale: o.props.locale,
        calendarStartDay: o.props.calendarStartDay,
        chooseDayAriaLabelPrefix: o.props.chooseDayAriaLabelPrefix,
        disabledDayAriaLabelPrefix: o.props.disabledDayAriaLabelPrefix,
        weekAriaLabelPrefix: o.props.weekAriaLabelPrefix,
        monthAriaLabelPrefix: o.props.monthAriaLabelPrefix,
        adjustDateOnChange: o.props.adjustDateOnChange,
        setOpen: o.setOpen,
        shouldCloseOnSelect: o.props.shouldCloseOnSelect,
        dateFormat: o.props.dateFormatCalendar,
        useWeekdaysShort: o.props.useWeekdaysShort,
        formatWeekDay: o.props.formatWeekDay,
        dropdownMode: o.props.dropdownMode,
        selected: o.props.selected,
        preSelection: o.state.preSelection,
        onSelect: o.handleSelect,
        onWeekSelect: o.props.onWeekSelect,
        openToDate: o.props.openToDate,
        minDate: o.props.minDate,
        maxDate: o.props.maxDate,
        selectsStart: o.props.selectsStart,
        selectsEnd: o.props.selectsEnd,
        selectsRange: o.props.selectsRange,
        selectsMultiple: o.props.selectsMultiple,
        selectedDates: o.props.selectedDates,
        startDate: o.props.startDate,
        endDate: o.props.endDate,
        excludeDates: o.props.excludeDates,
        excludeDateIntervals: o.props.excludeDateIntervals,
        filterDate: o.props.filterDate,
        onClickOutside: o.handleCalendarClickOutside,
        formatWeekNumber: o.props.formatWeekNumber,
        highlightDates: o.state.highlightDates,
        holidays: getHolidaysMap(o.modifyHolidays()),
        includeDates: o.props.includeDates,
        includeDateIntervals: o.props.includeDateIntervals,
        includeTimes: o.props.includeTimes,
        injectTimes: o.props.injectTimes,
        inline: o.props.inline,
        shouldFocusDayInline: o.state.shouldFocusDayInline,
        peekNextMonth: o.props.peekNextMonth,
        showMonthDropdown: o.props.showMonthDropdown,
        showPreviousMonths: o.props.showPreviousMonths,
        useShortMonthInDropdown: o.props.useShortMonthInDropdown,
        showMonthYearDropdown: o.props.showMonthYearDropdown,
        showWeekNumbers: o.props.showWeekNumbers,
        showYearDropdown: o.props.showYearDropdown,
        withPortal: o.props.withPortal,
        forceShowMonthNavigation: o.props.forceShowMonthNavigation,
        showDisabledMonthNavigation: o.props.showDisabledMonthNavigation,
        scrollableYearDropdown: o.props.scrollableYearDropdown,
        scrollableMonthYearDropdown: o.props.scrollableMonthYearDropdown,
        todayButton: o.props.todayButton,
        weekLabel: o.props.weekLabel,
        outsideClickIgnoreClass,
        fixedHeight: o.props.fixedHeight,
        monthsShown: o.props.monthsShown,
        monthSelectedIn: o.state.monthSelectedIn,
        onDropdownFocus: o.handleDropdownFocus,
        onMonthChange: o.props.onMonthChange,
        onYearChange: o.props.onYearChange,
        dayClassName: o.props.dayClassName,
        weekDayClassName: o.props.weekDayClassName,
        monthClassName: o.props.monthClassName,
        timeClassName: o.props.timeClassName,
        showDateSelect: o.props.showDateSelect,
        showTimeSelect: o.props.showTimeSelect,
        showTimeSelectOnly: o.props.showTimeSelectOnly,
        onTimeChange: o.handleTimeChange,
        timeFormat: o.props.timeFormat,
        timeIntervals: o.props.timeIntervals,
        minTime: o.props.minTime,
        maxTime: o.props.maxTime,
        excludeTimes: o.props.excludeTimes,
        filterTime: o.props.filterTime,
        timeCaption: o.props.timeCaption,
        className: o.props.calendarClassName,
        container: o.props.calendarContainer,
        yearItemNumber: o.props.yearItemNumber,
        yearDropdownItemNumber: o.props.yearDropdownItemNumber,
        previousMonthAriaLabel: o.props.previousMonthAriaLabel,
        previousMonthButtonLabel: o.props.previousMonthButtonLabel,
        nextMonthAriaLabel: o.props.nextMonthAriaLabel,
        nextMonthButtonLabel: o.props.nextMonthButtonLabel,
        previousYearAriaLabel: o.props.previousYearAriaLabel,
        previousYearButtonLabel: o.props.previousYearButtonLabel,
        nextYearAriaLabel: o.props.nextYearAriaLabel,
        nextYearButtonLabel: o.props.nextYearButtonLabel,
        timeInputLabel: o.props.timeInputLabel,
        disabledKeyboardNavigation: o.props.disabledKeyboardNavigation,
        renderCustomHeader: o.props.renderCustomHeader,
        popperProps: o.props.popperProps,
        renderDayContents: o.props.renderDayContents,
        renderMonthContent: o.props.renderMonthContent,
        renderQuarterContent: o.props.renderQuarterContent,
        renderYearContent: o.props.renderYearContent,
        onDayMouseEnter: o.props.onDayMouseEnter,
        onMonthMouseLeave: o.props.onMonthMouseLeave,
        onYearMouseEnter: o.props.onYearMouseEnter,
        onYearMouseLeave: o.props.onYearMouseLeave,
        selectsDisabledDaysInRange: o.props.selectsDisabledDaysInRange,
        showTimeInput: o.props.showTimeInput,
        showMonthYearPicker: o.props.showMonthYearPicker,
        showFullMonthYearPicker: o.props.showFullMonthYearPicker,
        showTwoColumnMonthYearPicker: o.props.showTwoColumnMonthYearPicker,
        showFourColumnMonthYearPicker: o.props.showFourColumnMonthYearPicker,
        showYearPicker: o.props.showYearPicker,
        showQuarterYearPicker: o.props.showQuarterYearPicker,
        showWeekPicker: o.props.showWeekPicker,
        excludeScrollbar: o.props.excludeScrollbar,
        handleOnKeyDown: o.props.onKeyDown,
        handleOnDayKeyDown: o.onDayKeyDown,
        isInputFocused: o.state.focused,
        customTimeInput: o.props.customTimeInput,
        setPreSelection: o.setPreSelection,
        usePointerEvent: o.props.usePointerEvent,
        yearClassName: o.props.yearClassName
      }, o.props.children);
    }), _defineProperty(o, "renderAriaLiveRegion", function() {
      var l = o.props, u = l.dateFormat, f = l.locale, h = o.props.showTimeInput || o.props.showTimeSelect, p = h ? "PPPPp" : "PPPP", v;
      return o.props.selectsRange ? v = "Selected start date: ".concat(safeDateFormat(o.props.startDate, {
        dateFormat: p,
        locale: f
      }), ". ").concat(o.props.endDate ? "End date: " + safeDateFormat(o.props.endDate, {
        dateFormat: p,
        locale: f
      }) : "") : o.props.showTimeSelectOnly ? v = "Selected time: ".concat(safeDateFormat(o.props.selected, {
        dateFormat: u,
        locale: f
      })) : o.props.showYearPicker ? v = "Selected year: ".concat(safeDateFormat(o.props.selected, {
        dateFormat: "yyyy",
        locale: f
      })) : o.props.showMonthYearPicker ? v = "Selected month: ".concat(safeDateFormat(o.props.selected, {
        dateFormat: "MMMM yyyy",
        locale: f
      })) : o.props.showQuarterYearPicker ? v = "Selected quarter: ".concat(safeDateFormat(o.props.selected, {
        dateFormat: "yyyy, QQQ",
        locale: f
      })) : v = "Selected date: ".concat(safeDateFormat(o.props.selected, {
        dateFormat: p,
        locale: f
      })), /* @__PURE__ */ React__default.createElement("span", {
        role: "alert",
        "aria-live": "polite",
        className: "react-datepicker__aria-live"
      }, v);
    }), _defineProperty(o, "renderDateInput", function() {
      var l, u = clsx$1(o.props.className, _defineProperty({}, outsideClickIgnoreClass, o.state.open)), f = o.props.customInput || /* @__PURE__ */ React__default.createElement("input", {
        type: "text"
      }), h = o.props.customInputRef || "ref", p = typeof o.props.value == "string" ? o.props.value : typeof o.state.inputValue == "string" ? o.state.inputValue : o.props.selectsRange ? safeDateRangeFormat(o.props.startDate, o.props.endDate, o.props) : o.props.selectsMultiple ? safeMultipleDatesFormat(o.props.selectedDates, o.props) : safeDateFormat(o.props.selected, o.props);
      return /* @__PURE__ */ React__default.cloneElement(f, (l = {}, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(l, h, function(v) {
        o.input = v;
      }), "value", p), "onBlur", o.handleBlur), "onChange", o.handleChange), "onClick", o.onInputClick), "onFocus", o.handleFocus), "onKeyDown", o.onInputKeyDown), "id", o.props.id), "name", o.props.name), "form", o.props.form), _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(l, "autoFocus", o.props.autoFocus), "placeholder", o.props.placeholderText), "disabled", o.props.disabled), "autoComplete", o.props.autoComplete), "className", clsx$1(f.props.className, u)), "title", o.props.title), "readOnly", o.props.readOnly), "required", o.props.required), "tabIndex", o.props.tabIndex), "aria-describedby", o.props.ariaDescribedBy), _defineProperty(_defineProperty(_defineProperty(l, "aria-invalid", o.props.ariaInvalid), "aria-labelledby", o.props.ariaLabelledBy), "aria-required", o.props.ariaRequired)));
    }), _defineProperty(o, "renderClearButton", function() {
      var l = o.props, u = l.isClearable, f = l.disabled, h = l.selected, p = l.startDate, v = l.endDate, g = l.clearButtonTitle, w = l.clearButtonClassName, E = w === void 0 ? "" : w, T = l.ariaLabelClose, R = T === void 0 ? "Close" : T, _ = l.selectedDates;
      return u && (h != null || p != null || v != null || _ != null && _.length) ? /* @__PURE__ */ React__default.createElement("button", {
        type: "button",
        className: clsx$1("react-datepicker__close-icon", E, {
          "react-datepicker__close-icon--disabled": f
        }),
        disabled: f,
        "aria-label": R,
        onClick: o.onClearClick,
        title: g,
        tabIndex: -1
      }) : null;
    }), o.state = o.calcInitialState(), o.preventFocusTimeout = null, o;
  }
  return _inherits(e, t), _createClass(e, [{
    key: "componentDidMount",
    value: function() {
      window.addEventListener("scroll", this.onScroll, !0);
    }
  }, {
    key: "componentDidUpdate",
    value: function(o, l) {
      o.inline && hasPreSelectionChanged(o.selected, this.props.selected) && this.setPreSelection(this.props.selected), this.state.monthSelectedIn !== void 0 && o.monthsShown !== this.props.monthsShown && this.setState({
        monthSelectedIn: 0
      }), o.highlightDates !== this.props.highlightDates && this.setState({
        highlightDates: getHightLightDaysMap(this.props.highlightDates)
      }), !l.focused && !isEqual(o.selected, this.props.selected) && this.setState({
        inputValue: null
      }), l.open !== this.state.open && (l.open === !1 && this.state.open === !0 && this.props.onCalendarOpen(), l.open === !0 && this.state.open === !1 && this.props.onCalendarClose());
    }
  }, {
    key: "componentWillUnmount",
    value: function() {
      this.clearPreventFocusTimeout(), window.removeEventListener("scroll", this.onScroll, !0);
    }
  }, {
    key: "renderInputContainer",
    value: function() {
      var o = this.props, l = o.showIcon, u = o.icon, f = o.calendarIconClassname, h = o.toggleCalendarOnIconClick, p = this.state.open;
      return /* @__PURE__ */ React__default.createElement("div", {
        className: "react-datepicker__input-container".concat(l ? " react-datepicker__view-calendar-icon" : "")
      }, l && /* @__PURE__ */ React__default.createElement(CalendarIcon$1, _extends({
        icon: u,
        className: "".concat(f, " ").concat(p && "react-datepicker-ignore-onclickoutside")
      }, h ? {
        onClick: this.toggleCalendar
      } : null)), this.state.isRenderAriaLiveMessage && this.renderAriaLiveRegion(), this.renderDateInput(), this.renderClearButton());
    }
  }, {
    key: "render",
    value: function() {
      var o = this.renderCalendar();
      if (this.props.inline) return o;
      if (this.props.withPortal) {
        var l = this.state.open ? /* @__PURE__ */ React__default.createElement(TabLoop, {
          enableTabLoop: this.props.enableTabLoop
        }, /* @__PURE__ */ React__default.createElement("div", {
          className: "react-datepicker__portal",
          tabIndex: -1,
          onKeyDown: this.onPortalKeyDown
        }, o)) : null;
        return this.state.open && this.props.portalId && (l = /* @__PURE__ */ React__default.createElement(Portal, {
          portalId: this.props.portalId,
          portalHost: this.props.portalHost
        }, l)), /* @__PURE__ */ React__default.createElement("div", null, this.renderInputContainer(), l);
      }
      return /* @__PURE__ */ React__default.createElement(PopperComponent$1, {
        className: this.props.popperClassName,
        wrapperClassName: this.props.wrapperClassName,
        hidePopper: !this.isCalendarOpen(),
        portalId: this.props.portalId,
        portalHost: this.props.portalHost,
        popperModifiers: this.props.popperModifiers,
        targetComponent: this.renderInputContainer(),
        popperContainer: this.props.popperContainer,
        popperComponent: o,
        popperPlacement: this.props.popperPlacement,
        popperProps: this.props.popperProps,
        popperOnKeyDown: this.onPopperKeyDown,
        enableTabLoop: this.props.enableTabLoop,
        showArrow: this.props.showPopperArrow
      });
    }
  }], [{
    key: "defaultProps",
    get: function() {
      return {
        allowSameDay: !1,
        dateFormat: "MM/dd/yyyy",
        dateFormatCalendar: "LLLL yyyy",
        onChange: function() {
        },
        disabled: !1,
        disabledKeyboardNavigation: !1,
        dropdownMode: "scroll",
        onFocus: function() {
        },
        onBlur: function() {
        },
        onKeyDown: function() {
        },
        onInputClick: function() {
        },
        onSelect: function() {
        },
        onClickOutside: function() {
        },
        onMonthChange: function() {
        },
        onCalendarOpen: function() {
        },
        onCalendarClose: function() {
        },
        preventOpenOnFocus: !1,
        onYearChange: function() {
        },
        onInputError: function() {
        },
        monthsShown: 1,
        readOnly: !1,
        withPortal: !1,
        selectsDisabledDaysInRange: !1,
        shouldCloseOnSelect: !0,
        showTimeSelect: !1,
        showTimeInput: !1,
        showPreviousMonths: !1,
        showMonthYearPicker: !1,
        showFullMonthYearPicker: !1,
        showTwoColumnMonthYearPicker: !1,
        showFourColumnMonthYearPicker: !1,
        showYearPicker: !1,
        showQuarterYearPicker: !1,
        showWeekPicker: !1,
        strictParsing: !1,
        swapRange: !1,
        timeIntervals: 30,
        timeCaption: "Time",
        previousMonthAriaLabel: "Previous Month",
        previousMonthButtonLabel: "Previous Month",
        nextMonthAriaLabel: "Next Month",
        nextMonthButtonLabel: "Next Month",
        previousYearAriaLabel: "Previous Year",
        previousYearButtonLabel: "Previous Year",
        nextYearAriaLabel: "Next Year",
        nextYearButtonLabel: "Next Year",
        timeInputLabel: "Time",
        enableTabLoop: !0,
        yearItemNumber: DEFAULT_YEAR_ITEM_NUMBER,
        focusSelectedMonth: !1,
        showPopperArrow: !0,
        excludeScrollbar: !0,
        customTimeInput: null,
        calendarStartDay: void 0,
        toggleCalendarOnIconClick: !1,
        usePointerEvent: !1
      };
    }
  }]);
}(React__default.Component), PRESELECT_CHANGE_VIA_INPUT = "input", PRESELECT_CHANGE_VIA_NAVIGATE = "navigate";
const COLORS = [
  "#8FBC8F",
  "#90EE90",
  "#3CB371",
  "#2E8B57",
  "#006400",
  "#87CEFA",
  "#1E90FF",
  "#0000CD",
  "#00008B",
  "#191970",
  "#FFA07A",
  "#FF7F50",
  "#FF6347",
  "#FF4500",
  "#FF8C00"
], extractLabel = (t) => {
  if (!t) return "";
  const e = t.split(".");
  return e[e.length - 2];
}, renderActiveShape = (t) => {
  const e = Math.PI / 180, {
    cx: n,
    cy: o,
    midAngle: l,
    innerRadius: u,
    outerRadius: f,
    startAngle: h,
    endAngle: p,
    fill: v,
    payload: g,
    percent: w,
    value: E
  } = t, T = Math.sin(-e * l), R = Math.cos(-e * l), _ = n + (f + 10) * R, b = o + (f + 10) * T, M = n + (f + 30) * R, A = o + (f + 30) * T, $ = M + (R >= 0 ? 1 : -1) * 22, S = A, C = R >= 0 ? "start" : "end";
  return /* @__PURE__ */ jsxRuntimeExports$1.jsxs("g", { children: [
    /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      Sector,
      {
        cx: n,
        cy: o,
        innerRadius: u,
        outerRadius: f,
        startAngle: h,
        endAngle: p,
        fill: v
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      Sector,
      {
        cx: n,
        cy: o,
        startAngle: h,
        endAngle: p,
        innerRadius: f + 6,
        outerRadius: f + 10,
        fill: v
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports$1.jsx("path", { d: `M${_},${b}L${M},${A}L${$},${S}`, stroke: v, fill: "none" }),
    /* @__PURE__ */ jsxRuntimeExports$1.jsx("circle", { cx: $, cy: S, r: 2, fill: v, stroke: "none" }),
    /* @__PURE__ */ jsxRuntimeExports$1.jsx("text", { x: $ + (R >= 0 ? 1 : -1) * 12, y: S, textAnchor: C, fill: "#333", fontSize: "12", fontWeight: "bold", children: `${extractLabel(g.type)} ${(w * 100).toFixed(1)}%` }),
    /* @__PURE__ */ jsxRuntimeExports$1.jsx("text", { x: $ + (R >= 0 ? 1 : -1) * 12, y: S, dy: 18, textAnchor: C, fill: "#999", fontSize: "10", children: `(${E} entries)` })
  ] });
}, UserProcessNodesPieChart = ({ selectedUser: t, apiUrl: e }) => {
  const [n, o] = useState([]), [l, u] = useState(0), [f, h] = useState(!0), p = (g, w) => {
    u(w);
  }, v = async (g) => {
    try {
      const w = g ? `${e}/nodes/full_types_count?user=${g}` : `${e}/nodes/full_types_count`, T = (await axios.get(w)).data, R = [], _ = (b) => {
        b.full_type.startsWith("process") && R.push({ full_type: b.full_type, counter: b.counter }), b.subspaces && b.subspaces.length > 0 && b.subspaces.forEach((M) => {
          _(M);
        });
      };
      return _(T.data), R;
    } catch (w) {
      return console.error("Error fetching the data", w), [];
    }
  };
  return useEffect(() => {
    (async () => {
      h(!0);
      const w = await v(t === "everybody" ? null : t);
      o(w), h(!1);
    })();
  }, [t, e]), f ? /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { children: "Loading..." }) : /* @__PURE__ */ jsxRuntimeExports$1.jsx(ResponsiveContainer, { width: "100%", height: 400, children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(PieChart, { children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(
    Pie,
    {
      activeIndex: l,
      activeShape: renderActiveShape,
      data: n,
      innerRadius: 80,
      outerRadius: 120,
      fill: "#8884d8",
      dataKey: "counter",
      onMouseEnter: p,
      children: n.map((g, w) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(Cell, { fill: COLORS[w % COLORS.length] }, `cell-${w}`))
    }
  ) }) });
}, Statistics = ({ apiUrl: t }) => {
  const [e, n] = useState([]), [o, l] = useState([]), [u, f] = useState(!0), [h, p] = useState(/* @__PURE__ */ new Date("2019-06-28")), [v, g] = useState(/* @__PURE__ */ new Date("2019-12-10")), [w, E] = useState(null), [T, R] = useState(0), [_, b] = useState("everybody"), [M, A] = useState([]);
  useEffect(() => {
    (async () => {
      try {
        const C = await fetch(`${t}/users`);
        if (!C.ok) throw new Error("Failed to fetch users");
        const D = await C.json();
        A([
          { id: "everybody", name: "Everybody" },
          ...D.data.users.map((O) => ({
            id: O.id,
            name: `${O.first_name} ${O.last_name}`.trim()
          }))
        ]);
      } catch (C) {
        console.error("Error fetching users:", C), E("Failed to load users. Please try again later.");
      }
    })();
  }, [t]), useEffect(() => {
    (async () => {
      f(!0), E(null);
      try {
        const C = _ === "everybody" ? `${t}/nodes/statistics` : `${t}/nodes/statistics?user=${_}`, D = await fetch(C);
        if (!D.ok) throw new Error("Network response was not ok");
        const O = await D.json();
        if (O && O.data) {
          const N = Object.entries(O.data.ctime_by_day || {}).map(([j, L]) => ({
            date: j,
            nodes: L
          }));
          if (n(N), O.data.types) {
            const j = Object.entries(O.data.types).map(([L, z]) => ({
              type: L,
              count: z
            }));
            l(j);
          } else
            l([]);
        } else
          n([]), l([]);
      } catch (C) {
        console.error("Error fetching statistics:", C), E(C.message), n([]), l([]);
      } finally {
        f(!1);
      }
    })();
  }, [t, _]);
  const $ = (S, C) => {
    R(C);
  };
  return /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "mt-2 p-4 border-2 border-gray-300 rounded-lg shadow-lg", children: [
    /* @__PURE__ */ jsxRuntimeExports$1.jsx("h2", { className: "text-2xl font-bold mb-6 text-center", children: "Statistics" }),
    /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "flex justify-center space-x-4 mb-6", children: [
      /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsx("label", { className: "block text-gray-700 text-sm font-bold mb-2", children: "Select User" }),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          "select",
          {
            value: _,
            onChange: (S) => b(S.target.value),
            className: "border rounded p-2 focus:outline-none focus:ring-2 focus:ring-blue-500",
            children: M.map((S) => /* @__PURE__ */ jsxRuntimeExports$1.jsx("option", { value: S.id, children: S.name }, S.id))
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsx("label", { className: "block text-gray-700 text-sm font-bold mb-2", children: "Start Date" }),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          DatePicker,
          {
            selected: h,
            onChange: (S) => p(S),
            className: "border rounded p-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsx("label", { className: "block text-gray-700 text-sm font-bold mb-2", children: "End Date" }),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          DatePicker,
          {
            selected: v,
            onChange: (S) => g(S),
            className: "border rounded p-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "mb-6", children: [
      w && /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "text-red-500", children: w }),
      u ? /* @__PURE__ */ jsxRuntimeExports$1.jsx(ClipLoader, {}) : /* @__PURE__ */ jsxRuntimeExports$1.jsx(ResponsiveContainer, { width: "100%", height: 400, children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs(BarChart, { data: e, children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(CartesianGrid, { strokeDasharray: "3 3" }),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(XAxis, { dataKey: "date" }),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(YAxis, {}),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(Tooltip, {}),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(Legend, {}),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(Brush, { dataKey: "date", height: 30, stroke: "#8884d8" }),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(Bar, { dataKey: "nodes", fill: "#8884d8" })
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "flex flex-row justify-between", children: [
      /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "mb-6 w-1/2 border-r-2 border-gray-300", children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsx("h3", { className: "text-xl font-semibold mb-4 text-center", children: "Number of Nodes by Type" }),
        u ? /* @__PURE__ */ jsxRuntimeExports$1.jsx(ClipLoader, {}) : /* @__PURE__ */ jsxRuntimeExports$1.jsx(ResponsiveContainer, { width: "100%", height: 400, children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(PieChart, { children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          Pie,
          {
            activeIndex: T,
            activeShape: renderActiveShape,
            data: o,
            innerRadius: 80,
            outerRadius: 120,
            fill: "#8884d8",
            dataKey: "count",
            onMouseEnter: $,
            children: o.map((S, C) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(Cell, { fill: COLORS[C % COLORS.length] }, `cell-${C}`))
          }
        ) }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "w-1/2", children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsx("h3", { className: "text-xl font-semibold mb-4 text-center", children: "User Process Nodes" }),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(UserProcessNodesPieChart, { selectedUser: _, apiUrl: t })
      ] })
    ] })
  ] });
}, Tabs = () => {
  const t = useNavigate(), e = useLocation(), [n, o] = useState("");
  useEffect(() => {
    e.pathname.includes("details") ? o("details") : e.pathname.includes("statistics") ? o("statistics") : o("grid");
  }, [e]);
  const l = (f) => {
    const p = `${e.pathname.split("/").slice(0, 2).join("/")}${f}`;
    t(p);
  }, u = (f, h, p) => {
    const v = n === p;
    return /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      "button",
      {
        onClick: () => l(f),
        className: `px-4 py-2 text-sm font-medium w-1/3 space-x-2 last:border-r-0 ${v ? "text-white bg-gray-400" : "text-gray-700 bg-white"}`,
        children: h
      }
    );
  };
  return /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "border-2 text-center w-full border-gray-300 flex justify-between p-1", children: [
    u("/", "Node Grid", "grid"),
    u("/details/", "Node Details", "details"),
    u("/statistics", "Node Statistics", "statistics")
  ] });
}, ComputersGrid = ({ apiUrl: t }) => {
  const [e, n] = useState([]), [o, l] = useState(1), [u, f] = useState(null), [h, p] = useState(!0), [v, g] = useState(null), w = useNavigate(), E = useLocation(), T = `${t}`, [R, _] = useState(null), b = async (O) => {
    p(!0), g(null);
    try {
      const N = await axios.get(
        `${T}/computers/page/${O}?perpage=10`
      );
      n(N.data.data.computers), console.log("Fetched computers:", N.data.data.computers);
    } catch (N) {
      console.error("Error fetching computers:", N), g("Failed to fetch computers data");
    } finally {
      p(!1);
    }
  }, M = async (O) => {
    try {
      const N = await axios.get(`${O}/nodes/full_types_count/`);
      return console.log("Full type counts fetched:", N.data.data), f(N.data.data), N.data.data;
    } catch (N) {
      return console.error("Error fetching full type counts:", N), g("Failed to fetch full type counts"), null;
    }
  };
  useEffect(() => {
    (async () => {
      await b(o);
      const N = await M(T);
      N && f(N);
    })();
  }, [o, T]);
  const A = (O) => {
    console.log("Computers data received in parent:", O), O && O.computers && n(O.computers);
  };
  useEffect(() => {
    console.log("fullTypeCounts updated:", u);
  }, [u]);
  const $ = (O) => {
    const j = E.pathname.replace(/computers$/, `details/${O}`);
    w(`${j}?source=computersGrid`);
  }, S = createColumnHelper(), C = [
    S.accessor("uuid", {
      header: "UUID",
      cell: (O) => O.getValue()
    }),
    S.accessor("label", {
      header: "Label",
      cell: (O) => O.getValue()
    }),
    S.accessor("hostname", {
      header: "Host",
      cell: (O) => O.getValue()
    }),
    S.accessor("scheduler_type", {
      header: "Scheduler",
      cell: (O) => O.getValue()
    }),
    S.accessor("uuid", {
      header: "Details",
      cell: (O) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(
        "button",
        {
          onClick: () => $(O.getValue()),
          className: "px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600",
          children: "Details"
        }
      )
    })
  ], D = useReactTable({
    data: e,
    columns: C,
    getCoreRowModel: getCoreRowModel(),
    getPaginationRowModel: getPaginationRowModel(),
    getSortedRowModel: getSortedRowModel(),
    getFilteredRowModel: getFilteredRowModel(),
    state: {
      pagination: {
        pageIndex: o - 1,
        pageSize: 10
      }
    },
    onPaginationChange: (O) => {
      if (typeof O == "function") {
        const N = O({ pageIndex: o - 1 }).pageIndex;
        l(N + 1);
      } else
        l(O.pageIndex + 1);
    }
  });
  return console.log(u), /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "flex w-full mx-auto py-2 px-0 text-sm", children: [
    /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "w-1/5", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      FilterSidebar,
      {
        fullTypeCounts: u,
        onSelectNode: A,
        currentPage: o,
        setCurrentPage: l,
        setSelectedNode: _,
        onDataFetched: A,
        selectedNode: R
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "w-4/5 ml-2", children: [
      h ? /* @__PURE__ */ jsxRuntimeExports$1.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "loading-animation m-auto flex justify-center text-center", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx(ClipLoader, { size: 30, color: "#007bff" }) }) }) : v ? /* @__PURE__ */ jsxRuntimeExports$1.jsxs("p", { children: [
        "Error: ",
        v
      ] }) : /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "overflow-x-auto", children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs("table", { className: "min-w-full bg-white border border-gray-200", children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsx("thead", { children: D.getHeaderGroups().map((O) => /* @__PURE__ */ jsxRuntimeExports$1.jsx("tr", { children: O.headers.map((N) => /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          "th",
          {
            className: "p-2 border-b text-left bg-blue-50",
            children: N.isPlaceholder ? null : /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { children: flexRender(
              N.column.columnDef.header,
              N.getContext()
            ) })
          },
          N.id
        )) }, O.id)) }),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx("tbody", { children: D.getRowModel().rows.map((O) => /* @__PURE__ */ jsxRuntimeExports$1.jsx("tr", { className: "hover:bg-gray-50", children: O.getVisibleCells().map((N) => /* @__PURE__ */ jsxRuntimeExports$1.jsx("td", { className: "p-2 border-b", children: flexRender(
          N.column.columnDef.cell,
          N.getContext()
        ) }, N.id)) }, O.id)) })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "mt-4 flex justify-between", children: [
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          "button",
          {
            onClick: () => D.previousPage(),
            disabled: !D.getCanPreviousPage(),
            className: "px-4 py-2 bg-blue-500 text-white rounded disabled:bg-gray-300",
            children: "Previous"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports$1.jsxs("span", { children: [
          "Page ",
          D.getState().pagination.pageIndex + 1,
          " of",
          " ",
          D.getPageCount()
        ] }),
        /* @__PURE__ */ jsxRuntimeExports$1.jsx(
          "button",
          {
            onClick: () => D.nextPage(),
            disabled: !D.getCanNextPage(),
            className: "px-4 py-2 bg-blue-500 text-white rounded disabled:bg-gray-300",
            children: "Next"
          }
        )
      ] })
    ] })
  ] });
};
class ErrorBoundary extends Component$1 {
  constructor(e) {
    super(e), this.state = { hasError: !1 };
  }
  static getDerivedStateFromError(e) {
    return { hasError: !0 };
  }
  componentDidCatch(e, n) {
    console.error("ErrorBoundary caught an error", e, n);
  }
  render() {
    return this.state.hasError ? /* @__PURE__ */ jsxRuntimeExports$1.jsx("div", { className: "flex items-center justify-center min-h-screen bg-gray-100", children: /* @__PURE__ */ jsxRuntimeExports$1.jsx("h1", { className: "text-2xl text-red-500", children: "Something went wrong." }) }) : this.props.children;
  }
}
const AiidaExplorer = ({ apiUrl: t }) => /* @__PURE__ */ jsxRuntimeExports$1.jsxs("div", { className: "p-1", children: [
  /* @__PURE__ */ jsxRuntimeExports$1.jsx(Tabs, { apiUrl: t }),
  /* @__PURE__ */ jsxRuntimeExports$1.jsx(ErrorBoundary, { children: /* @__PURE__ */ jsxRuntimeExports$1.jsxs(Routes, { children: [
    /* @__PURE__ */ jsxRuntimeExports$1.jsx(Route, { path: "/", element: /* @__PURE__ */ jsxRuntimeExports$1.jsx(NodeGrid, { apiUrl: t }) }),
    /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      Route,
      {
        path: "/details/:uuid",
        element: /* @__PURE__ */ jsxRuntimeExports$1.jsx(DetailsPage, { apiUrl: t })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports$1.jsx(Route, { path: "/details/", element: /* @__PURE__ */ jsxRuntimeExports$1.jsx(Search, { apiUrl: t }) }),
    /* @__PURE__ */ jsxRuntimeExports$1.jsx(Route, { path: "/statistics/", element: /* @__PURE__ */ jsxRuntimeExports$1.jsx(Statistics, { apiUrl: t }) }),
    /* @__PURE__ */ jsxRuntimeExports$1.jsx(
      Route,
      {
        path: "/computers/",
        element: /* @__PURE__ */ jsxRuntimeExports$1.jsx(ComputersGrid, { apiUrl: t })
      }
    )
  ] }) })
] });
export {
  AiidaExplorer as default
};
